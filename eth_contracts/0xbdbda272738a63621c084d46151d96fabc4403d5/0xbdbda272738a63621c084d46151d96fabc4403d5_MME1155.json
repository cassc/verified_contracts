{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/amm/AMMBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IAMMBase} from \\\"../interfaces/IAMMBase.sol\\\";\\r\\nimport {Errors} from \\\"../libraries/Errors.sol\\\";\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport {IAddressesRegistry} from \\\"../interfaces/IAddressesRegistry.sol\\\";\\r\\nimport {IAccessManager} from \\\"../interfaces/IAccessManager.sol\\\";\\r\\nimport {Pool1155Logic} from \\\"../libraries/Pool1155Logic.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title AMMBase\\r\\n * @author Souq.Finance\\r\\n * @notice The Base contract to be inherited by MMEs\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ncontract AMMBase is IAMMBase {\\r\\n    using Math for uint256;\\r\\n    uint256 public yieldReserve;\\r\\n    address public immutable addressesRegistry;\\r\\n    DataTypes.PoolData public poolData;\\r\\n\\r\\n    constructor(address _registry) {\\r\\n        addressesRegistry = _registry;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for when the the msg sender is pool admin in the access manager\\r\\n     */\\r\\n    modifier onlyPoolAdmin() {\\r\\n        require(\\r\\n            IAccessManager(IAddressesRegistry(addressesRegistry).getAccessManager()).isPoolAdmin(msg.sender),\\r\\n            Errors.CALLER_NOT_POOL_ADMIN\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for when the the msg sender is either pool admin or pool operations in the access manager\\r\\n     */\\r\\n    modifier onlyPoolAdminOrOperations() {\\r\\n        require(\\r\\n            IAccessManager(IAddressesRegistry(addressesRegistry).getAccessManager()).isPoolAdmin(msg.sender) ||\\r\\n                IAccessManager(IAddressesRegistry(addressesRegistry).getAccessManager()).isPoolOperations(msg.sender),\\r\\n            Errors.CALLER_NOT_POOL_ADMIN_OR_OPERATIONS\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IAMMBase\\r\\n    function setFee(DataTypes.PoolFee calldata newFee) external onlyPoolAdmin {\\r\\n        poolData.fee.lpBuyFee = newFee.lpBuyFee;\\r\\n        poolData.fee.lpSellFee = newFee.lpSellFee;\\r\\n        poolData.fee.royaltiesBuyFee = newFee.royaltiesBuyFee;\\r\\n        poolData.fee.royaltiesSellFee = newFee.royaltiesSellFee;\\r\\n        poolData.fee.protocolBuyRatio = newFee.protocolBuyRatio;\\r\\n        poolData.fee.protocolSellRatio = newFee.protocolSellRatio;\\r\\n        poolData.fee.royaltiesAddress = newFee.royaltiesAddress;\\r\\n        poolData.fee.protocolFeeAddress = newFee.protocolFeeAddress;\\r\\n        emit FeeChanged(poolData.fee);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IAMMBase\\r\\n    function setPoolIterativeLimits(DataTypes.IterativeLimit calldata newLimits) external onlyPoolAdmin {\\r\\n        poolData.iterativeLimit.minimumF = newLimits.minimumF;\\r\\n        poolData.iterativeLimit.maxBulkStepSize = newLimits.maxBulkStepSize;\\r\\n        poolData.iterativeLimit.iterations = newLimits.iterations;\\r\\n        emit PoolIterativeLimitsSet(poolData.iterativeLimit);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IAMMBase\\r\\n    function setPoolLiquidityLimits(DataTypes.LiquidityLimit calldata newLimits) external onlyPoolAdmin {\\r\\n        poolData.liquidityLimit.poolTvlLimit = newLimits.poolTvlLimit;\\r\\n        poolData.liquidityLimit.cooldown = newLimits.cooldown;\\r\\n        poolData.liquidityLimit.maxDepositPercentage = newLimits.maxDepositPercentage;\\r\\n        poolData.liquidityLimit.maxWithdrawPercentage = newLimits.maxWithdrawPercentage;\\r\\n        poolData.liquidityLimit.minFeeMultiplier = newLimits.minFeeMultiplier;\\r\\n        poolData.liquidityLimit.maxFeeMultiplier = newLimits.maxFeeMultiplier;\\r\\n        poolData.liquidityLimit.addLiqMode = newLimits.addLiqMode;\\r\\n        poolData.liquidityLimit.removeLiqMode = newLimits.removeLiqMode;\\r\\n        poolData.liquidityLimit.onlyAdminProvisioning = newLimits.onlyAdminProvisioning;\\r\\n        emit PoolLiquidityLimitsSet(poolData.liquidityLimit);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IAMMBase\\r\\n    function setPoolData(DataTypes.PoolData calldata newPoolData) external onlyPoolAdmin {\\r\\n        poolData.useAccessToken = newPoolData.useAccessToken;\\r\\n        poolData.accessToken = newPoolData.accessToken;\\r\\n        poolData.stableYieldAddress = newPoolData.stableYieldAddress;\\r\\n        poolData.coefficientA = newPoolData.coefficientA;\\r\\n        poolData.coefficientB = newPoolData.coefficientB;\\r\\n        poolData.coefficientC = newPoolData.coefficientC;\\r\\n        emit PoolDataSet(poolData);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/amm/LPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport {IAddressesRegistry} from \\\"../interfaces/IAddressesRegistry.sol\\\";\\r\\nimport {Errors} from \\\"../libraries/Errors.sol\\\";\\r\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LPToken\\r\\n * @author Souq.Finance\\r\\n * @notice The LP Token contract of each liquidity pool\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ncontract LPToken is ILPToken, ERC20, ERC20Burnable, Pausable {\\r\\n    address internal _underlyingAsset;\\r\\n    IAddressesRegistry internal immutable addressesRegistry;\\r\\n    address public immutable pool;\\r\\n    uint8 public immutable tokenDecimals;\\r\\n\\r\\n    constructor(\\r\\n        address _pool,\\r\\n        address registry,\\r\\n        address[] memory tokens,\\r\\n        string memory symbol,\\r\\n        string memory name,\\r\\n        uint8 _decimals\\r\\n    ) ERC20(name, symbol) {\\r\\n        tokenDecimals = _decimals;\\r\\n        pool = _pool;\\r\\n        addressesRegistry = IAddressesRegistry(registry);\\r\\n        for (uint256 i = 0; i < tokens.length; i++) {\\r\\n            IERC1155(tokens[i]).setApprovalForAll(address(pool), true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for when the the msg sender is the liquidity pool that created it only\\r\\n     */\\r\\n    modifier onlyPool() {\\r\\n        require(_msgSender() == address(pool), Errors.CALLER_MUST_BE_POOL);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals for this token. Public due to override.\\r\\n     * @return uint8 the number of decimals\\r\\n     */\\r\\n    function decimals() public view override returns (uint8) {\\r\\n        return tokenDecimals;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function getTotal() external view returns (uint256) {\\r\\n        return totalSupply();\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function getBalanceOf(address account) external view returns (uint256) {\\r\\n        return balanceOf(account);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function pause() external onlyPool {\\r\\n        //_pause already emits an event\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function unpause() external onlyPool {\\r\\n        //_unpause already emits an event\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function checkPaused() external view returns (bool) {\\r\\n        return paused();\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function setApproval20(address token, uint256 amount) external onlyPool {\\r\\n        IERC20(token).approve(pool, amount);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function mint(address to, uint256 amount) external onlyPool {\\r\\n        //_mint already emits a transfer event\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function burn(address from, uint256 amount) external onlyPool {\\r\\n        //_burn already emits a transfer event\\r\\n        _burn(from, amount);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc ILPToken\\r\\n    function RescueTokens(address token, uint256 amount, address receiver) external onlyPool {\\r\\n        //event emitted in the pool logic library\\r\\n        IERC20(token).transfer(receiver, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implementation of the ERC1155 token received hook.\\r\\n     */\\r\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external virtual returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implementation of the ERC1155 batch token received hook.\\r\\n     */\\r\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external virtual returns (bytes4) {\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/amm/MME1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport {Errors} from \\\"../libraries/Errors.sol\\\";\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\nimport {Pool1155Logic} from \\\"../libraries/Pool1155Logic.sol\\\";\\r\\nimport {Liquidity1155Logic} from \\\"../libraries/Liquidity1155Logic.sol\\\";\\r\\nimport {AMMBase} from \\\"./AMMBase.sol\\\";\\r\\nimport {IMME1155} from \\\"../interfaces/IMME1155.sol\\\";\\r\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\r\\nimport {IAddressesRegistry} from \\\"../interfaces/IAddressesRegistry.sol\\\";\\r\\nimport {IAccessManager} from \\\"../interfaces/IAccessManager.sol\\\";\\r\\nimport {IAccessNFT} from \\\"../interfaces/IAccessNFT.sol\\\";\\r\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title MME1155\\r\\n * @author Souq.Finance\\r\\n * @notice The Contract of all Pools sharing MME1155 specification for single collection of shares\\r\\n * @notice the tokenDistribution will return 0 if not found\\r\\n * @notice The fees inputted should be in wad\\r\\n * @notice The F inputted should be in wad\\r\\n * @notice the V updated should have the same decimals of the stablecoin and be in terms of the same stablecoin\\r\\n * @notice coefficients are in wad\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\ncontract MME1155 is Initializable, AMMBase, IMME1155, ReentrancyGuardUpgradeable, PausableUpgradeable, OwnableUpgradeable {\\r\\n    using Pool1155Logic for DataTypes.AMMSubPool1155[];\\r\\n\\r\\n    DataTypes.AMMSubPool1155[] public subPools;\\r\\n    address public immutable factory;\\r\\n\\r\\n    ///@notice token id -> pool\\r\\n    ///@notice subpool is = 0 if token id doesn't exist\\r\\n    mapping(uint256 => uint256) public tokenDistribution;\\r\\n\\r\\n    //Liquidity providers have a time waiting period between deposit and withdraw\\r\\n    DataTypes.Queued1155Withdrawals public queuedWithdrawals;\\r\\n\\r\\n    constructor(address _factory, address addressRegistry) AMMBase(addressRegistry) {\\r\\n        factory = _factory;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function initialize(DataTypes.PoolData memory _poolData, string memory symbol, string memory name) external initializer {\\r\\n        __Pausable_init();\\r\\n        __Ownable_init();\\r\\n        poolData = _poolData;\\r\\n        poolData.fee.royaltiesBalance = 0;\\r\\n        poolData.fee.royaltiesBalance = 0;\\r\\n        poolData.poolLPToken = Pool1155Logic.deployLPToken(\\r\\n            address(this),\\r\\n            addressesRegistry,\\r\\n            poolData.tokens,\\r\\n            symbol,\\r\\n            name,\\r\\n            IERC20(poolData.stable).decimals()\\r\\n        );\\r\\n        yieldReserve = 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for the functions to be called by the timelock contract only\\r\\n     */\\r\\n    modifier timelockOnly() {\\r\\n        if (IAddressesRegistry(addressesRegistry).getAddress(\\\"TIMELOCK\\\") != address(0)) {\\r\\n            require(\\r\\n                IAddressesRegistry(addressesRegistry).getAddress(\\\"TIMELOCK\\\") == msg.sender,\\r\\n                Errors.CALLER_NOT_TIMELOCK\\r\\n            );\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for the access token enabled functions\\r\\n     * @param tokenId the id of the access token\\r\\n     * @param functionName the name of the function with the modifier\\r\\n     */\\r\\n    modifier useAccessNFT(uint256 tokenId, string memory functionName) {\\r\\n        if (poolData.useAccessToken) {\\r\\n            require(\\r\\n                IAccessNFT(poolData.accessToken).HasAccessNFT(msg.sender, tokenId, functionName),\\r\\n                Errors.FUNCTION_REQUIRES_ACCESS_NFT\\r\\n            );\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier for when the onlyAdminProvisioning is true to restrict liquidity addition to pool admin\\r\\n     */\\r\\n    modifier checkAdminProvisioning() {\\r\\n        if (poolData.liquidityLimit.onlyAdminProvisioning) {\\r\\n            require(\\r\\n                IAccessManager(IAddressesRegistry(addressesRegistry).getAccessManager()).isPoolAdmin(msg.sender),\\r\\n                Errors.ONLY_ADMIN_CAN_ADD_LIQUIDITY\\r\\n            );\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function pause() external onlyPoolAdminOrOperations {\\r\\n        _pause();\\r\\n        ILPToken(poolData.poolLPToken).pause();\\r\\n        emit PoolPaused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function unpause() external onlyPoolAdmin {\\r\\n        _unpause();\\r\\n        ILPToken(poolData.poolLPToken).unpause();\\r\\n        emit PoolUnpaused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getTVL() external view returns (uint256) {\\r\\n        return subPools.getTVL();\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getLPPrice() external view returns (uint256) {\\r\\n        return subPools.getLPPrice(poolData.poolLPToken);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getPool(uint256 subPoolId) external view returns (DataTypes.AMMSubPool1155Details memory subpool) {\\r\\n        subpool.reserve = subPools[subPoolId].reserve;\\r\\n        subpool.totalShares = subPools[subPoolId].totalShares;\\r\\n        subpool.V = subPools[subPoolId].V;\\r\\n        subpool.F = subPools[subPoolId].F;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getQuote(\\r\\n        uint256[] calldata amounts,\\r\\n        uint256[] calldata tokenIds,\\r\\n        bool buy,\\r\\n        bool useFee\\r\\n    ) external view returns (DataTypes.Quotation memory quotation) {\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: amounts, tokenIds: tokenIds});\\r\\n        quotation = Liquidity1155Logic.getQuote(\\r\\n            DataTypes.QuoteParams({buy: buy, useFee: useFee}),\\r\\n            sharesParams,\\r\\n            poolData,\\r\\n            subPools,\\r\\n            tokenDistribution\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function swapStable(\\r\\n        uint256[] memory requiredAmounts,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256 maxStable\\r\\n    ) external nonReentrant useAccessNFT(1, \\\"swapStable\\\") whenNotPaused {\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: requiredAmounts, tokenIds: tokenIds});\\r\\n        Liquidity1155Logic.swapStable(msg.sender, maxStable, sharesParams, poolData, subPools, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function swapShares(\\r\\n        uint256[] memory amounts,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256 minStable\\r\\n    ) external nonReentrant useAccessNFT(1, \\\"swapShares\\\") whenNotPaused {\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: amounts, tokenIds: tokenIds});\\r\\n        Liquidity1155Logic.swapShares(msg.sender, minStable, yieldReserve, sharesParams, poolData, subPools, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function depositInitial(\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256[] memory amounts,\\r\\n        uint256 stableIn,\\r\\n        uint256 subPoolId\\r\\n    ) external nonReentrant onlyPoolAdmin {\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: amounts, tokenIds: tokenIds});\\r\\n        Liquidity1155Logic.depositInitial(msg.sender, subPoolId, stableIn, sharesParams, poolData, subPools, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function addLiquidityStable(\\r\\n        uint256 targetLP,\\r\\n        uint256 maxStable\\r\\n    ) external nonReentrant useAccessNFT(1, \\\"addLiquidityStable\\\") checkAdminProvisioning whenNotPaused {\\r\\n        require(poolData.liquidityLimit.addLiqMode != 1, Errors.LIQUIDITY_MODE_RESTRICTED);\\r\\n        Liquidity1155Logic.addLiquidityStable(msg.sender, targetLP, maxStable, poolData, subPools);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function addLiquidityShares(\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256[] memory amounts,\\r\\n        uint256 targetLP\\r\\n    ) external nonReentrant useAccessNFT(1, \\\"addLiquidityShares\\\") checkAdminProvisioning whenNotPaused {\\r\\n        require(poolData.liquidityLimit.addLiqMode != 0, Errors.LIQUIDITY_MODE_RESTRICTED);\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: amounts, tokenIds: tokenIds});\\r\\n        Liquidity1155Logic.addLiquidityShares(msg.sender, targetLP, sharesParams, poolData, subPools, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function removeLiquidityStable(uint256 targetLP) external nonReentrant whenNotPaused {\\r\\n        require(poolData.liquidityLimit.removeLiqMode != 1, Errors.LIQUIDITY_MODE_RESTRICTED);\\r\\n        Liquidity1155Logic.removeLiquidityStable(msg.sender, yieldReserve, targetLP, poolData, subPools, queuedWithdrawals);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function removeLiquidityShares(\\r\\n        uint256 targetLP,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256[] memory amounts\\r\\n    ) external nonReentrant whenNotPaused {\\r\\n        require(poolData.liquidityLimit.removeLiqMode != 0, Errors.LIQUIDITY_MODE_RESTRICTED);\\r\\n        DataTypes.Shares1155Params memory sharesParams = DataTypes.Shares1155Params({amounts: amounts, tokenIds: tokenIds});\\r\\n        Liquidity1155Logic.removeLiquidityShares(\\r\\n            msg.sender,\\r\\n            targetLP,\\r\\n            sharesParams,\\r\\n            poolData,\\r\\n            subPools,\\r\\n            queuedWithdrawals,\\r\\n            tokenDistribution\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function processWithdrawals(uint256 limit) external whenNotPaused {\\r\\n        Liquidity1155Logic.processWithdrawals(limit, poolData, queuedWithdrawals);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getTokenIdAvailable(uint256 tokenId) external view returns (uint256) {\\r\\n        return subPools[tokenDistribution[tokenId]].shares[tokenId];\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getSubPools(uint256[] memory tokenIds) external view returns (uint256[] memory) {\\r\\n        return Pool1155Logic.getSubPools(tokenIds, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function getSubPoolsSeq(uint256 startTokenId, uint256 endTokenId) external view returns (uint256[] memory) {\\r\\n        return Pool1155Logic.getSubPoolsSeq(startTokenId, endTokenId, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function addSubPool(uint256 v, uint256 f) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.addSubPool(v, f, subPools);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function updatePoolV(uint256[] calldata subPoolIds, uint256[] calldata vArray) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.updatePoolV(subPoolIds, vArray, subPools, poolData);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function changeSubPoolStatus(uint256[] calldata subPoolIds, bool newStatus) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.changeSubPoolStatus(subPoolIds, newStatus, subPools);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function moveReserve(uint256 moverId, uint256 movedId, uint256 amount) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.moveReserve(moverId, movedId, amount, subPools, poolData);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function moveShares(uint256 startId, uint256 endId, uint256 newSubPoolId) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.moveShares(startId, endId, newSubPoolId, subPools, poolData, tokenDistribution);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function moveSharesList(uint256 newSubPoolIds, uint256[] calldata ids) external onlyPoolAdminOrOperations {\\r\\n        Pool1155Logic.moveSharesList(newSubPoolIds, ids, subPools, poolData, tokenDistribution);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function depositIntoStableYield(uint256 amount) external onlyPoolAdmin {\\r\\n        yieldReserve += Pool1155Logic.depositIntoStableYield(amount, addressesRegistry, poolData.stableYieldAddress, yieldReserve);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function withdrawFromStableYield(uint256 amount) external onlyPoolAdmin {\\r\\n        yieldReserve -= Pool1155Logic.withdrawFromStableYield(amount, addressesRegistry, poolData.stableYieldAddress, yieldReserve);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function RescueTokens(address token, uint256 amount, address receiver) external onlyPoolAdmin {\\r\\n        Pool1155Logic.RescueTokens(token, amount, receiver, poolData.stable, poolData.poolLPToken);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IMME1155\\r\\n    function WithdrawFees(address to, uint256 amount, DataTypes.FeeType feeType) external whenNotPaused {\\r\\n        Pool1155Logic.withdrawFees(msg.sender, to, amount, feeType, poolData);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IAddressesRegistry} from \\\"./IAddressesRegistry.sol\\\";\\r\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IAccessManager\\r\\n * @author Souq.Finance\\r\\n * @notice The interface for the Access Manager Contract\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IAccessManager is IAccessControl {\\r\\n    \\r\\n    /**\\r\\n     * @notice Returns the contract address of the PoolAddressesProvider\\r\\n     * @return The address of the PoolAddressesProvider\\r\\n     */\\r\\n    function ADDRESSES_PROVIDER() external view returns (IAddressesRegistry);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the Pool Operations role\\r\\n     * @return The id of the Pool Operations role\\r\\n     */\\r\\n    function POOL_OPERATIONS_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the PoolAdmin role\\r\\n     * @return The id of the PoolAdmin role\\r\\n     */\\r\\n    function POOL_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the EmergencyAdmin role\\r\\n     * @return The id of the EmergencyAdmin role\\r\\n     */\\r\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the OracleAdmin role\\r\\n     * @return The id of the Oracle role\\r\\n     */\\r\\n    function ORACLE_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the ConnectorRouterAdmin role\\r\\n     * @return The id of the ConnectorRouterAdmin role\\r\\n     */\\r\\n    function CONNECTOR_ROUTER_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the StablecoinYieldConnectorAdmin role\\r\\n     * @return The id of the StablecoinYieldConnectorAdmin role\\r\\n     */\\r\\n    function STABLECOIN_YIELD_CONNECTOR_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the StablecoinYieldConnectorLender role\\r\\n     * @return The id of the StablecoinYieldConnectorLender role\\r\\n     */\\r\\n    function STABLECOIN_YIELD_CONNECTOR_LENDER_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the UpgraderAdmin role\\r\\n     * @return The id of the UpgraderAdmin role\\r\\n     */\\r\\n\\r\\n    function UPGRADER_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the identifier of the TimelockAdmin role\\r\\n     * @return The id of the TimelockAdmin role\\r\\n     */\\r\\n\\r\\n    function TIMELOCK_ADMIN_ROLE() external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev set the default admin for the contract\\r\\n     * @param newAdmin The new default admin address\\r\\n     */\\r\\n    function changeDefaultAdmin(address newAdmin) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev return the version of the contract\\r\\n     * @return the version of the contract\\r\\n     */\\r\\n    function getVersion() external pure returns (uint256);\\r\\n    /**\\r\\n     * @notice Set the role as admin of a specific role.\\r\\n     * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\\r\\n     * @param role The role to be managed by the admin role\\r\\n     * @param adminRole The admin role\\r\\n     */\\r\\n\\r\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as PoolAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addPoolAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as PoolAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removePoolAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is PoolAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is PoolAdmin, false otherwise\\r\\n     */\\r\\n    function isPoolAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as Pool Operations\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addPoolOperations(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as Pool Operations\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removePoolOperations(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is Pool Operations, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is Pool Operations, false otherwise\\r\\n     */\\r\\n    function isPoolOperations(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as EmergencyAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addEmergencyAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as EmergencyAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeEmergencyAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is EmergencyAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is EmergencyAdmin, false otherwise\\r\\n     */\\r\\n    function isEmergencyAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as OracleAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addOracleAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as OracleAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeOracleAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is OracleAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is OracleAdmin, false otherwise\\r\\n     */\\r\\n    function isOracleAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as ConnectorRouterAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addConnectorAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as ConnectorRouterAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeConnectorAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is ConnectorRouterAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is ConnectorRouterAdmin, false otherwise\\r\\n     */\\r\\n    function isConnectorAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as StablecoinYieldConnectorAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addStablecoinYieldAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as StablecoinYieldConnectorAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeStablecoinYieldAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is StablecoinYieldConnectorAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is StablecoinYieldConnectorAdmin, false otherwise\\r\\n     */\\r\\n    function isStablecoinYieldAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as StablecoinYieldLender\\r\\n     * @param lender The address of the new lender\\r\\n     */\\r\\n    function addStablecoinYieldLender(address lender) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an lender as StablecoinYieldLender\\r\\n     * @param lender The address of the lender to remove\\r\\n     */\\r\\n    function removeStablecoinYieldLender(address lender) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is StablecoinYieldLender, false otherwise\\r\\n     * @param lender The address to check\\r\\n     * @return True if the given address is StablecoinYieldLender, false otherwise\\r\\n     */\\r\\n    function isStablecoinYieldLender(address lender) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as UpgraderAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addUpgraderAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as UpgraderAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeUpgraderAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is UpgraderAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is UpgraderAdmin, false otherwise\\r\\n     */\\r\\n    function isUpgraderAdmin(address admin) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new admin as TimelockAdmin\\r\\n     * @param admin The address of the new admin\\r\\n     */\\r\\n    function addTimelockAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes an admin as TimelockAdmin\\r\\n     * @param admin The address of the admin to remove\\r\\n     */\\r\\n    function removeTimelockAdmin(address admin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is TimelockAdmin, false otherwise\\r\\n     * @param admin The address to check\\r\\n     * @return True if the given address is TimelockAdmin, false otherwise\\r\\n     */\\r\\n    function isTimelockAdmin(address admin) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title IAccessNFT\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the Access NFT contract\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IAccessNFT {\\r\\n    /**\\r\\n     * @dev Event emitted wjem deadline for the function name and token id combination is set\\r\\n     * @param functionName The function name in bytes32\\r\\n     * @param deadline The deadline is seconds\\r\\n     * @param tokenId The token id\\r\\n     */\\r\\n    event DeadlineSet(string functionName, bytes32 functionHash, uint256 deadline, uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev event emitted when the use of deadlines in the contract is toggled\\r\\n     * @param deadlinesOn The flag returned (true=turned on)\\r\\n     */\\r\\n    event ToggleDeadlines(bool deadlinesOn);\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if a user has access to a specific function based on ownership of NFTs. If current time > deadline of the function and token id combination\\r\\n     * @param user The address of the user\\r\\n     * @param tokenId The token id\\r\\n     * @param functionName The function name\\r\\n     * @return bool The boolean (true = has nft)\\r\\n     */\\r\\n    function HasAccessNFT(address user, uint256 tokenId, string calldata functionName) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the deadline for a specific function and token id (NFT)\\r\\n     * @param functionName The function name\\r\\n     * @param deadline The new deadline\\r\\n     * @param tokenId The token id\\r\\n     */\\r\\n    function setDeadline(string calldata functionName, uint256 deadline, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves the deadline for a specific function and NFT.\\r\\n     * @param hashedFunctionName The hashed function name\\r\\n     * @param tokenId The token id\\r\\n     * @return deadline The deadline\\r\\n     */\\r\\n    function getDeadline(bytes32 hashedFunctionName, uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Toggles the state of deadlines for function access.\\r\\n     */\\r\\n    function toggleDeadlines() external;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the fee discount percentage for a specific NFT\\r\\n     * @param tokenId The token id\\r\\n     * @param discount The discount in wei\\r\\n     */\\r\\n    function setFeeDiscount(uint256 tokenId, uint256 discount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the URI for the token metadata\\r\\n     * @param newuri The token id\\r\\n     */\\r\\n    function setURI(string memory newuri) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Burns a specific amount of tokens owned by an account\\r\\n     * @param account The account to burn from\\r\\n     * @param id The token id\\r\\n     * @param amount The amount to burn\\r\\n     */\\r\\n    function adminBurn(address account, uint256 id, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressesRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title IAddressesRegistry\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the addresses registry.\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IAddressesRegistry {\\r\\n    /**\\r\\n     * @dev Emitted when the connectors router address is updated.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event RouterUpdated(address indexed oldAddress, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when the Access manager address is updated.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event AccessManagerUpdated(address indexed oldAddress, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when the access admin address is updated.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event AccessAdminUpdated(address indexed oldAddress, address indexed newAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the collection connector address is updated.\\r\\n     * @param oldAddress the old address\\r\\n     * @param newAddress the new address\\r\\n     */\\r\\n    event CollectionConnectorUpdated(address indexed oldAddress, address indexed newAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a specific pool factory address is updated.\\r\\n     * @param id The short id of the pool factory.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n\\r\\n    event PoolFactoryUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when a specific pool factory address is added.\\r\\n     * @param id The short id of the pool factory.\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event PoolFactoryAdded(bytes32 id, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when a specific vault factory address is updated.\\r\\n     * @param id The short id of the vault factory.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event VaultFactoryUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when a specific vault factory address is added.\\r\\n     * @param id The short id of the vault factory.\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event VaultFactoryAdded(bytes32 id, address indexed newAddress);\\r\\n    /**\\r\\n     * @dev Emitted when a any address is updated.\\r\\n     * @param id The full id of the address.\\r\\n     * @param oldAddress The old address\\r\\n     * @param newAddress The new address\\r\\n     */\\r\\n    event AddressUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a proxy is deployed for an implementation\\r\\n     * @param id The full id of the address to be saved\\r\\n     * @param logic The address of the implementation\\r\\n     * @param proxy The address of the proxy deployed in that id slot\\r\\n     */\\r\\n    event ProxyDeployed(bytes32 id, address indexed logic, address indexed proxy);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a proxy is deployed for an implementation\\r\\n     * @param id The full id of the address to be upgraded\\r\\n     * @param newLogic The address of the new implementation\\r\\n     * @param proxy The address of the proxy that was upgraded\\r\\n     */\\r\\n    event ProxyUpgraded(bytes32 id, address indexed newLogic, address indexed proxy);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the identifier.\\r\\n     * @param _id The id of the contract\\r\\n     * @return The Pool proxy address\\r\\n     */\\r\\n    function getAddress(bytes32 _id) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of the identifier.\\r\\n     * @param _id The id of the contract\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setAddress(bytes32 _id, address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the connectors router defined as: CONNECTORS_ROUTER\\r\\n     * @return The address\\r\\n     */\\r\\n    function getConnectorsRouter() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of the Connectors router.\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setConnectorsRouter(address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of access manager defined as: ACCESS_MANAGER\\r\\n     * @return The address\\r\\n     */\\r\\n    function getAccessManager() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of the Access Manager.\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setAccessManager(address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of access admin defined as: ACCESS_ADMIN\\r\\n     * @return The address\\r\\n     */\\r\\n    function getAccessAdmin() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of the Access Admin.\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setAccessAdmin(address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the specific pool factory short id\\r\\n     * @param _id The pool factory id such as \\\"SVS\\\"\\r\\n     * @return The address\\r\\n     */\\r\\n    function getPoolFactoryAddress(bytes32 _id) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the full id of pool factory short id\\r\\n     * @param _id The pool factory id such as \\\"SVS\\\"\\r\\n     * @return The full id\\r\\n     */\\r\\n    function getIdFromPoolFactory(bytes32 _id) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of a specific pool factory using short id.\\r\\n     * @param _id the pool factory short id\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setPoolFactory(bytes32 _id, address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice adds a new pool factory with address and short id. The short id will be converted to full id and saved.\\r\\n     * @param _id the pool factory short id\\r\\n     * @param _add The address to add\\r\\n     */\\r\\n    function addPoolFactory(bytes32 _id, address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the specific vault factory short id\\r\\n     * @param _id The vault id such as \\\"SVS\\\"\\r\\n     * @return The address\\r\\n     */\\r\\n    function getVaultFactoryAddress(bytes32 _id) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the full id of vault factory id\\r\\n     * @param _id The vault factory id such as \\\"SVS\\\"\\r\\n     * @return The full id\\r\\n     */\\r\\n    function getIdFromVaultFactory(bytes32 _id) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of a specific vault factory using short id.\\r\\n     * @param _id the vault factory short id\\r\\n     * @param _add The address to set\\r\\n     */\\r\\n    function setVaultFactory(bytes32 _id, address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice adds a new vault factory with address and short id. The short id will be converted to full id and saved.\\r\\n     * @param _id the vault factory short id\\r\\n     * @param _add The address to add\\r\\n     */\\r\\n    function addVaultFactory(bytes32 _id, address _add) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Deploys a proxy for an implimentation and initializes then saves in the registry.\\r\\n     * @param _id the full id to be saved.\\r\\n     * @param _logic The address of the implementation\\r\\n     * @param _data The initialization low data\\r\\n     */\\r\\n    function updateImplementation(bytes32 _id, address _logic, bytes memory _data) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Updates a proxy with a new implementation logic while keeping the store intact.\\r\\n     * @param _id the full id to be saved.\\r\\n     * @param _logic The address of the new implementation\\r\\n     */\\r\\n    function updateProxy(bytes32 _id, address _logic) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMMBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IAMMBase\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the AMM Base.\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IAMMBase {\\r\\n    /**\\r\\n     * @dev Emitted when the pool fee changes\\r\\n     * @param _newFee The new fee\\r\\n     */\\r\\n    event FeeChanged(DataTypes.PoolFee _newFee);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the Pool Data struct is changed\\r\\n     * @param _data The new pool data\\r\\n     */\\r\\n    event PoolDataSet(DataTypes.PoolData _data);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the Pool Iterative limits are changed\\r\\n     * @param _limits The new pool data limit\\r\\n     */\\r\\n    event PoolIterativeLimitsSet(DataTypes.IterativeLimit _limits);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the Pool Liquidity limits are changed\\r\\n     * @param _limits The new pool data limit\\r\\n     */\\r\\n    event PoolLiquidityLimitsSet(DataTypes.LiquidityLimit _limits);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to set the pool fee\\r\\n     * @param _newFee The new fee struct\\r\\n     */\\r\\n    function setFee(DataTypes.PoolFee calldata _newFee) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to set the Pool Iterative limits for the bonding curve\\r\\n     * @param _newLimits The new limits struct\\r\\n     */\\r\\n    function setPoolIterativeLimits(DataTypes.IterativeLimit calldata _newLimits) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to set the Pool liquidity limits for deposits and withdrawals of liquidity\\r\\n     * @param _newLimits The new limits struct\\r\\n     */\\r\\n    function setPoolLiquidityLimits(DataTypes.LiquidityLimit calldata _newLimits) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to set the Pool Data - for Beta Testing\\r\\n     * @param _newPoolData the new pooldata struct\\r\\n     */\\r\\n    function setPoolData(DataTypes.PoolData calldata _newPoolData) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IConnectorRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IConnectorRouter\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the connector router\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IConnectorRouter {\\r\\n    event YieldDistributorSet(address indexed vaultAddress, address indexed yieldDistributorAddress);\\r\\n    event YieldDistributorUpdated(address indexed vaultAddress, address indexed yieldDistributorAddress);\\r\\n    event YieldDistributorDeleted(address indexed vaultAddress);\\r\\n\\r\\n    event StakingContractSet(address indexed tokenAddress, address indexed stakingContractAddress);\\r\\n    event StakingContractUpdated(address indexed tokenAddress, address indexed stakingContractAddress);\\r\\n    event StakingContractDeleted(address indexed stakingContractAddress);\\r\\n\\r\\n    event SwapContractSet(address indexed tokenAddress, address indexed swapContractAddress);\\r\\n    event SwapContractUpdated(address indexed tokenAddress, address indexed swapContractAddress);\\r\\n    event SwapContractDeleted(address indexed swapContractAddress);\\r\\n\\r\\n    event OracleConnectorSet(address indexed tokenAddress, address indexed oracleConnectorAddress);\\r\\n    event OracleConnectorUpdated(address indexed tokenAddress, address indexed oracleConnectorAddress);\\r\\n    event OracleConnectorDeleted(address indexed oracleConnectorAddress);\\r\\n\\r\\n    event CollectionConnectorSet(address indexed liquidityPool, address indexed collectionConnectorAddress, uint indexed tokenID);\\r\\n    event CollectionConnectorUpdated(address indexed liquidityPool, address indexed collectionConnectorAddress, uint indexed tokenID);\\r\\n    event CollectionConnectorDeleted(address indexed collectionConnectorAddress);\\r\\n\\r\\n    event StablecoinYieldConnectorSet(address indexed tokenAddress, address indexed stablecoinYieldConnectorAddress);\\r\\n    event StablecoinYieldConnectorUpdated(address indexed tokenAddress, address indexed stablecoinYieldConnectorAddress);\\r\\n    event StablecoinYieldConnectorDeleted(address indexed stablecoinYieldConnectorAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the initial owner and timelock address of the contract.\\r\\n     * @param timelock address\\r\\n     */\\r\\n    function initialize(address timelock) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the yield distributor contract for a given vault.\\r\\n     * @param vaultAddress address\\r\\n     * @return address of the yield distributor contract\\r\\n     */\\r\\n    function getYieldDistributor(address vaultAddress) external view returns (address);\\r\\n\\r\\n    function setYieldDistributor(address vaultAddress, address yieldDistributorAddress) external;\\r\\n\\r\\n    function updateYieldDistributor(address vaultAddress, address yieldDistributorAddress) external;\\r\\n\\r\\n    function deleteYieldDistributor(address vaultAddress) external;\\r\\n\\r\\n    function getStakingContract(address tokenAddress) external view returns (address);\\r\\n\\r\\n    function setStakingContract(address tokenAddress, address stakingContractAddress) external;\\r\\n\\r\\n    function updateStakingContract(address tokenAddress, address stakingContractAddress) external;\\r\\n\\r\\n    function deleteStakingContract(address tokenAddress) external;\\r\\n\\r\\n    function getSwapContract(address tokenAddress) external view returns (address);\\r\\n\\r\\n    function setSwapContract(address tokenAddress, address swapContractAddress) external;\\r\\n\\r\\n    function updateSwapContract(address tokenAddress, address swapContractAddress) external;\\r\\n\\r\\n    function deleteSwapContract(address tokenAddress) external;\\r\\n\\r\\n    function getOracleConnectorContract(address tokenAddress) external view returns (address);\\r\\n\\r\\n    function setOracleConnectorContract(address tokenAddress, address oracleConnectorAddress) external;\\r\\n\\r\\n    function updateOracleConnectorContract(address tokenAddress, address oracleConnectorAddress) external;\\r\\n\\r\\n    function deleteOracleConnectorContract(address tokenAddress) external;\\r\\n\\r\\n    function getCollectionConnectorContract(address liquidityPool) external view returns (DataTypes.ERC1155Collection memory);\\r\\n\\r\\n    function setCollectionConnectorContract(address liquidityPool, address collectionConnectorAddress, uint tokenID) external;\\r\\n\\r\\n    function updateCollectionConnectorContract(address liquidityPool, address collectionConnectorAddress, uint tokenID) external;\\r\\n\\r\\n    function deleteCollectionConnectorContract(address liquidityPool) external;\\r\\n\\r\\n    function getStablecoinYieldConnectorContract(address tokenAddress) external view returns (address);\\r\\n\\r\\n    function setStablecoinYieldConnectorContract(address tokenAddress, address stablecoinYieldConnectorAddress) external;\\r\\n\\r\\n    function updateStablecoinYieldConnectorContract(address tokenAddress, address stablecoinYieldConnectorAddress) external;\\r\\n\\r\\n    function deleteStablecoinYieldConnectorContract(address tokenAddress) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title ILPToken\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the LP token of 1155 MMEs\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\ninterface ILPToken {\\r\\n    /**\\r\\n     * @dev Mints LP tokens to the provided address. Can only be called by the pool.\\r\\n     * @param to the address to mint the tokens to\\r\\n     * @param amount the amount to mint\\r\\n     */\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Burns LP tokens from the provided address. Can only be called by the pool.\\r\\n     * @param from the address to burn from\\r\\n     * @param amount the amount to burn\\r\\n     */\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Unpauses all token transfers. Can only be called by the pool.\\r\\n     */\\r\\n    function unpause() external;\\r\\n\\r\\n    /**\\r\\n     * @dev Pauses all token transfers. Can only be called by the pool.\\r\\n     */\\r\\n    function pause() external;\\r\\n\\r\\n    /**\\r\\n     * @dev Check if the LP Token is paused\\r\\n     * @return bool true=paused\\r\\n     */\\r\\n    function checkPaused() external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the balance of LP tokens for the provided address.\\r\\n     * @param account The account to check balance of\\r\\n     * @return uint256 The amount of LP Tokens owned\\r\\n     */\\r\\n    function getBalanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Approves a specific amount of a token for the pool.\\r\\n     * @param token The token address to approve\\r\\n     * @param amount The amount of tokens to approve\\r\\n     */\\r\\n    function setApproval20(address token, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to rescue and send ERC20 tokens (different than the tokens used by the pool) to a receiver called by the admin\\r\\n     * @param token The address of the token contract\\r\\n     * @param amount The amount of tokens\\r\\n     * @param receiver The address of the receiver\\r\\n     */\\r\\n    function RescueTokens(address token, uint256 amount, address receiver) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the the total LP tokens\\r\\n     * @return uint256 The total number of LP tokens in circulation\\r\\n     */\\r\\n    function getTotal() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IMME1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IAddressesRegistry} from \\\"../interfaces/IAddressesRegistry.sol\\\";\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IMME1155\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the MME for ERC1155 pools with single collection.\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\ninterface IMME1155 {\\r\\n    /**\\r\\n     * @dev Emitted when pool is paused\\r\\n     * @param admin The admin address\\r\\n     */\\r\\n    event PoolPaused(address admin);\\r\\n    /**\\r\\n     * @dev Emitted when pool is unpaused\\r\\n     * @param admin The admin address\\r\\n     */\\r\\n    event PoolUnpaused(address admin);\\r\\n\\r\\n    /**\\r\\n     * @dev initialize the pool with pool data and the symbol/name of the LP Token\\r\\n     * @param _poolData The pool data structure\\r\\n     * @param symbol The symbol of the lp token\\r\\n     * @param name The name of the lp token\\r\\n     */\\r\\n    function initialize(DataTypes.PoolData memory _poolData, string memory symbol, string memory name) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to pause\\r\\n     */\\r\\n    function pause() external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to unpause\\r\\n     */\\r\\n    function unpause() external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the quote for swapping shares in buy or sell direction\\r\\n     * @param amounts The amounts of shares to buy or sell\\r\\n     * @param tokenIds The shares token ids\\r\\n     * @param buy The directional boolean. If buy direction then true\\r\\n     * @param useFee the boolean determining whether to use Fee in the calculation or not in case we want to calculate the value of the shares for liquidity\\r\\n     */\\r\\n    function getQuote(\\r\\n        uint256[] memory amounts,\\r\\n        uint256[] memory tokenIds,\\r\\n        bool buy,\\r\\n        bool useFee\\r\\n    ) external view returns (DataTypes.Quotation memory quotation);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to swap stablecoins to shares\\r\\n     * @param amounts The amounts of token ids outputted\\r\\n     * @param tokenIds The token ids outputted\\r\\n     * @param maxStable The maximum amount of stablecoin to be spent\\r\\n     */\\r\\n    function swapStable(uint256[] memory amounts, uint256[] memory tokenIds, uint256 maxStable) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to swap shares to stablecoins\\r\\n     * @param amounts The amounts of token ids outputted\\r\\n     * @param tokenIds The token ids outputted\\r\\n     * @param minStable The minimum stablecoin to receive\\r\\n     */\\r\\n    function swapShares(uint256[] memory amounts, uint256[] memory tokenIds, uint256 minStable) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the TVL of the pool in stablecoin\\r\\n     * @return uint256 The TVL\\r\\n     */\\r\\n    function getTVL() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the TVL of a specific sub pool\\r\\n     * @param id The id of the sub pool\\r\\n     * @return DataTypes.AMMSubPool1155 memory The TVL\\r\\n     */\\r\\n    function getPool(uint256 id) external view returns (DataTypes.AMMSubPool1155Details memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add liquidity using Stable coins\\r\\n     * @param targetLP The amount of target LPs outputted\\r\\n     * @param _maxStable The amount of maximum stablecoins to be spent\\r\\n     */\\r\\n    function addLiquidityStable(uint256 targetLP, uint256 _maxStable) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add liquidity using shares\\r\\n     * @param tokenIds The token ids of shares to be spent\\r\\n     * @param maxAmounts The maximum amounts of shares to be spent\\r\\n     * @param targetLP The amount of required LPs outputted\\r\\n     */\\r\\n    function addLiquidityShares(uint256[] memory tokenIds, uint256[] memory maxAmounts, uint256 targetLP) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove liquidity by shares\\r\\n     * @param targetLP The amount of LPs to be burned\\r\\n     * @param tokenIds The token ids of shares to be outputted\\r\\n     * @param maxAmounts The maximum amounts of shares to be outputted\\r\\n     */\\r\\n    function removeLiquidityShares(uint256 targetLP, uint256[] memory tokenIds, uint256[] memory maxAmounts) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove liquidity by stable coins\\r\\n     * @param targetLP The amount of LPs to be burned\\r\\n     */\\r\\n    function removeLiquidityStable(uint256 targetLP) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to process all queued transactions upto limit\\r\\n     * @param limit The number of transactions to process\\r\\n     */\\r\\n    function processWithdrawals(uint256 limit) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the LP token price\\r\\n     * @return uint256 The price\\r\\n     */\\r\\n    function getLPPrice() external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get amount of a specific token id available in the pool\\r\\n     * @param tokenId The token id\\r\\n     * @return uint256 The amount\\r\\n     */\\r\\n    function getTokenIdAvailable(uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Function that returns the subpool ids of the given token ids\\r\\n     * @param tokenIds The address of the pool\\r\\n     * @return subPools array of the subpool ids\\r\\n     */\\r\\n    function getSubPools(uint256[] memory tokenIds) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Function that returns the subpool ids of the given sequencial token ids\\r\\n     * @param startTokenId The start id of the token ids\\r\\n     * @param endTokenId The end id of the token ids\\r\\n     * @return subPools The array of the subpool ids\\r\\n     */\\r\\n    function getSubPoolsSeq(uint256 startTokenId, uint256 endTokenId) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Function that deposits the initial liquidity to specific subpool\\r\\n     * @param tokenIds The token ids array of the shares to deposit\\r\\n     * @param amounts The amounts array of the shares to deposit\\r\\n     * @param stableIn The stablecoins amount to deposit\\r\\n     * @param subPoolId The sub pool id\\r\\n     */\\r\\n    function depositInitial(uint256[] memory tokenIds, uint256[] memory amounts, uint256 stableIn, uint256 subPoolId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add a new sub pool\\r\\n     * @param v The initial V value of the sub pool\\r\\n     * @param f The initial F value of the sub pool\\r\\n     */\\r\\n    function addSubPool(uint256 v, uint256 f) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move shares sequencially to a different sub pool called by the admin\\r\\n     * @param startId The start index of the token ids to be moved\\r\\n     * @param endId The end index of the token ids to be moved\\r\\n     * @param newSubPoolId The id of the new subpool\\r\\n     */\\r\\n    function moveShares(uint256 startId, uint256 endId, uint256 newSubPoolId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move shares in an array list to a different sub pool called by the admin\\r\\n     * @param ids The array of shares ids to be moved\\r\\n     * @param newSubPoolId The id of the new subpool\\r\\n     */\\r\\n    function moveSharesList(uint256 newSubPoolId, uint256[] memory ids) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move enable or disable specific subpools by ids\\r\\n     * @param subPoolIds The sub pools ids array\\r\\n     * @param _newStatus The new status, enabled=true or disabled=false\\r\\n     */\\r\\n    function changeSubPoolStatus(uint256[] calldata subPoolIds, bool _newStatus) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move reserves between subpools\\r\\n     * @param moverId The sub pool that will move the funds from\\r\\n     * @param movedId The id of the sub pool that will move the funds to\\r\\n     * @param amount The amount to move\\r\\n     */\\r\\n    function moveReserve(uint256 moverId, uint256 movedId, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to update the v of several subpools\\r\\n     * @param subPoolIds The sub pools array\\r\\n     * @param vArray The v array\\r\\n     */\\r\\n    function updatePoolV(uint256[] calldata subPoolIds, uint256[] calldata vArray) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to deposit stablecoins from the pool to a yield generating protocol and getting synthetic tokens\\r\\n     * @param amount The amount of stablecoins\\r\\n     */\\r\\n    function depositIntoStableYield(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to withdraw stablecoins from the pool to a yield generating protocol using the synthetic tokens\\r\\n     * @param amount The amount of stablecoins to withdraw\\r\\n     */\\r\\n    function withdrawFromStableYield(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to rescue and send ERC20 tokens (different than the tokens used by the pool) to a receiver called by the admin\\r\\n     * @param token The address of the token contract\\r\\n     * @param amount The amount of tokens\\r\\n     * @param receiver The address of the receiver\\r\\n     */\\r\\n    function RescueTokens(address token, uint256 amount, address receiver) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to withdraw fees by a caller that is either the royalties or protocol address\\r\\n     * @param to The address to send the funds to\\r\\n     * @param amount The amount to withdraw\\r\\n     * @param feeType The type of the fees to withdraw\\r\\n     */\\r\\n\\r\\n    function WithdrawFees(address to, uint256 amount, DataTypes.FeeType feeType) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolFactory1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IAddressesRegistry} from \\\"./IAddressesRegistry.sol\\\";\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IPoolFactory1155\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the factory for ERC1155 pools\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\ninterface IPoolFactory1155 {\\r\\n    /**\\r\\n     * @dev Emitted when a new pool is deployed using same logic\\r\\n     * @param user The deployer\\r\\n     * @param stable The stablecoin address\\r\\n     * @param tokens The tokens address array\\r\\n     * @param proxy The proxy address deployed\\r\\n     * @param index The pool index in the factory\\r\\n     * @param symbol The symbol of the LP Token\\r\\n     * @param name The name of the LP Token\\r\\n     * @param poolTvlLimit The pool TVL limit\\r\\n     */\\r\\n    event PoolDeployed(\\r\\n        address user,\\r\\n        address stable,\\r\\n        address[] tokens,\\r\\n        address proxy,\\r\\n        uint256 index,\\r\\n        string symbol,\\r\\n        string name,\\r\\n        uint256 poolTvlLimit\\r\\n    );\\r\\n    /**\\r\\n     * @dev Emitted when the fee configuration of the factory changes\\r\\n     * @param admin The admin address\\r\\n     * @param feeConfig The new fee Configuration\\r\\n     */\\r\\n    event FeeConfigSet(address admin, DataTypes.FactoryFeeConfig feeConfig);\\r\\n    /**\\r\\n     * @dev Emitted when the pools are upgraded to new logic\\r\\n     * @param admin The admin address\\r\\n     * @param newImplementation The new implementation logic address\\r\\n     */\\r\\n    event PoolsUpgraded(address admin, address newImplementation);\\r\\n    /**\\r\\n     * @dev Emitted when the onlyPoolAdminDeployments flag changes which enables admins to deploy only\\r\\n     * @param admin The admin address\\r\\n     * @param newStatus The new status\\r\\n     */\\r\\n    event DeploymentByPoolAdminOnlySet(address admin, bool newStatus);\\r\\n\\r\\n    /**\\r\\n     * @dev This function is called only once to initialize the contract. It sets the initial pool logic contract and fee configuration.\\r\\n     * @param _poolLogic The pool logic contract address\\r\\n     * @param _feeConfig The factory fee configuration\\r\\n     */\\r\\n    function initialize(address _poolLogic, DataTypes.FactoryFeeConfig calldata _feeConfig) external;\\r\\n\\r\\n    /**\\r\\n     * @dev This function returns the fee configuration of the contract\\r\\n     * @return feeConfig The factory fee configuration\\r\\n     */\\r\\n    function getFeeConfig() external view returns (DataTypes.FactoryFeeConfig memory);\\r\\n\\r\\n    /**\\r\\n     * @dev This function sets the fee configuration of the contract\\r\\n     * @param newConfig The new factory fee configuration\\r\\n     */\\r\\n    function setFeeConfig(DataTypes.FactoryFeeConfig memory newConfig) external;\\r\\n\\r\\n    /**\\r\\n     * @dev This function sets the fee configuration of the contract\\r\\n     * @param poolData The pool data of the liquidity pool to deploy\\r\\n     * @param symbol The symbol of the LP Token\\r\\n     * @param name The name of the LP Token\\r\\n     * @return address of the new proxy\\r\\n     */\\r\\n    function deployPool(DataTypes.PoolData memory poolData, string memory symbol, string memory name) external returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev This function returns the count of pools created by the factory.\\r\\n     * @return uint256 the count\\r\\n     */\\r\\n    function getPoolsCount() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev This function takes an index as a parameter and returns the address of the pool at that index\\r\\n     * @param index the pool id\\r\\n     * @return address the proxy address of the pool\\r\\n     */\\r\\n    function getPool(uint256 index) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev This function upgrades the pools to a new logic contract. It is only callable by the upgrader. It increments the pools version and emits a PoolsUpgraded event.\\r\\n     * @param newLogic The new logic contract address\\r\\n     */\\r\\n    function upgradePools(address newLogic) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the version of the pools\\r\\n     * @return uint256 version of the pools. Only incremeted when the beacon is upgraded\\r\\n     */\\r\\n    function getPoolsVersion() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the version of the proxy\\r\\n     * @return uint256 version of the contract. Only incremeted when the proxy is upgraded\\r\\n     */\\r\\n    function getVersion() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev This function sets the status of onlyPoolAdminDeployments. It is only callable by the pool admin.\\r\\n     * @param status The new status\\r\\n     */\\r\\n    function setDeploymentByPoolAdminOnly(bool status) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IStablecoinYieldConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IStablecoinYieldConnector\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the interface of the stablecoin yield connector\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\ninterface IStablecoinYieldConnector {\\r\\n    event DepositUSDC(address indexed depositor, uint256 amount);\\r\\n    event WithdrawUSDC(address indexed withdrawer, uint256 amount);\\r\\n    event SetUSDCPool(address indexed setter, address poolAddress);\\r\\n    event ChangeCollateral(address indexed setter, address reserve, bool useAsCollateral);\\r\\n\\r\\n    function pause() external;\\r\\n\\r\\n    function unpause() external;\\r\\n\\r\\n    function getVersion() external pure returns (uint256);\\r\\n\\r\\n    function getATokenAddress() external returns (address);\\r\\n\\r\\n    function depositUSDC(uint256 amount) external;\\r\\n\\r\\n    function withdrawUSDC(uint256 amount, uint256 aAmount) external;\\r\\n\\r\\n    function setUSDCPool(address poolAddress) external;\\r\\n\\r\\n    function getBalance() external view returns (uint256);\\r\\n\\r\\n    function getReserveConfigurationData(\\r\\n        address _reserve\\r\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256, bool, bool, bool, bool, bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title library for Data structures\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the structures used by the contracts of the Souq protocol\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\nlibrary DataTypes {\\r\\n    struct ERC1155Collection {\\r\\n        address tokenAddress;\\r\\n        uint256 tokenID;\\r\\n    }\\r\\n\\r\\n    struct AMMShare1155 {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    struct Shares1155Params {\\r\\n        uint256[] amounts;\\r\\n        uint256[] tokenIds;\\r\\n    }\\r\\n\\r\\n    struct ParamGroup {\\r\\n        uint256 amount;\\r\\n        uint256 tokenId;\\r\\n        uint256 subPoolId;\\r\\n    }\\r\\n\\r\\n    struct SubPoolGroup {\\r\\n        uint256 id;\\r\\n        uint256 counter;\\r\\n        uint256 total;\\r\\n        AMMShare1155[] shares;\\r\\n        SharesCalculationReturn sharesCal;\\r\\n    }\\r\\n    struct SharePrice {\\r\\n        uint256 id;\\r\\n        uint256 value;\\r\\n        FeeReturn fees;\\r\\n    }\\r\\n    struct MoveSharesVars {\\r\\n        uint256 i;\\r\\n        uint256 poolId;\\r\\n    }\\r\\n    struct Quotation {\\r\\n        uint256 total;\\r\\n        FeeReturn fees;\\r\\n        SharePrice[] shares;\\r\\n    }\\r\\n    struct QuoteParams {\\r\\n        bool buy;\\r\\n        bool useFee;\\r\\n    }\\r\\n    struct LocalQuoteVars {\\r\\n        uint256 i;\\r\\n        uint256 y;\\r\\n        uint256 total;\\r\\n        uint256 poolId;\\r\\n        uint256 counter;\\r\\n        uint256 counterShares;\\r\\n        FeeReturn fees;\\r\\n        SubPoolGroup currentSubPool;\\r\\n        AMMShare1155 currentShare;\\r\\n        SubPoolGroup[] subPoolGroups;\\r\\n    }\\r\\n    struct LocalGroupVars {\\r\\n        uint256 i;\\r\\n        uint256 index;\\r\\n        uint256 subPoolId;\\r\\n        SharesCalculationReturn cal;\\r\\n        ParamGroup[] paramGroups;\\r\\n    }\\r\\n    struct Withdraw1155Data {\\r\\n        address to;\\r\\n        uint256 unlockTimestamp;\\r\\n        uint256 amount;\\r\\n        AMMShare1155[] shares;\\r\\n    }\\r\\n\\r\\n    struct Queued1155Withdrawals {\\r\\n        mapping(uint => Withdraw1155Data) withdrawals;\\r\\n        //Head is for reading and next is for saving\\r\\n        uint256 headId;\\r\\n        uint256 nextId;\\r\\n    }\\r\\n\\r\\n    struct AMMSubPool1155 {\\r\\n        uint256 reserve;\\r\\n        uint256 totalShares;\\r\\n        bool status;\\r\\n        uint256 V;\\r\\n        uint256 F;\\r\\n        //tokenid -> amount\\r\\n        mapping(uint256 => uint256) shares;\\r\\n    }\\r\\n\\r\\n    struct AMMSubPool1155Details {\\r\\n        uint256 reserve;\\r\\n        uint256 totalShares;\\r\\n        uint256 V;\\r\\n        uint256 F;\\r\\n    }\\r\\n\\r\\n    struct FactoryFeeConfig {\\r\\n        uint256 lpBuyFee;\\r\\n        uint256 lpSellFee;\\r\\n        uint256 minLpFee;\\r\\n        uint256 maxLpBuyFee;\\r\\n        uint256 maxLpSellFee;\\r\\n        uint256 protocolSellRatio;\\r\\n        uint256 protocolBuyRatio;\\r\\n        uint256 minProtocolRatio;\\r\\n        uint256 maxProtocolRatio;\\r\\n        uint256 royaltiesBuyFee;\\r\\n        uint256 royaltiesSellFee;\\r\\n        uint256 maxRoyaltiesFee;\\r\\n    }\\r\\n    struct PoolFee {\\r\\n        uint256 lpBuyFee;\\r\\n        uint256 lpSellFee;\\r\\n        uint256 royaltiesBuyFee;\\r\\n        uint256 royaltiesSellFee;\\r\\n        uint256 protocolBuyRatio;\\r\\n        uint256 protocolSellRatio;\\r\\n        uint256 royaltiesBalance;\\r\\n        uint256 protocolBalance;\\r\\n        address royaltiesAddress;\\r\\n        address protocolFeeAddress;\\r\\n    }\\r\\n\\r\\n    //cooldown between deposit and withdraw in seconds\\r\\n    //percentage and multiplier are in wad and wadPercentage\\r\\n    struct LiquidityLimit {\\r\\n        uint256 poolTvlLimit;\\r\\n        uint256 cooldown;\\r\\n        uint256 maxDepositPercentage;\\r\\n        uint256 maxWithdrawPercentage;\\r\\n        uint256 minFeeMultiplier;\\r\\n        uint256 maxFeeMultiplier;\\r\\n        uint8 addLiqMode;\\r\\n        uint8 removeLiqMode;\\r\\n        bool onlyAdminProvisioning;\\r\\n    }\\r\\n    struct IterativeLimit {\\r\\n        uint256 minimumF;\\r\\n        uint16 maxBulkStepSize;\\r\\n        uint16 iterations;\\r\\n    }\\r\\n\\r\\n    struct PoolData {\\r\\n        bool useAccessToken;\\r\\n        address accessToken;\\r\\n        address poolLPToken;\\r\\n        address stable;\\r\\n        address[] tokens;\\r\\n        address stableYieldAddress;\\r\\n        uint256 coefficientA;\\r\\n        uint256 coefficientB;\\r\\n        uint256 coefficientC;\\r\\n        PoolFee fee;\\r\\n        LiquidityLimit liquidityLimit;\\r\\n        IterativeLimit iterativeLimit;\\r\\n    }\\r\\n\\r\\n    struct FeeReturn {\\r\\n        uint256 totalFee;\\r\\n        uint256 swapFee;\\r\\n        uint256 lpFee;\\r\\n        uint256 royalties;\\r\\n        uint256 protocolFee;\\r\\n    }\\r\\n    struct SharesCalculationVars {\\r\\n        uint16 i;\\r\\n        uint256 V;\\r\\n        uint256 PV;\\r\\n        uint256 PV_0;\\r\\n        uint256 swapPV;\\r\\n        uint256 shares;\\r\\n        uint256 stable;\\r\\n        uint256 value;\\r\\n        uint256 den;\\r\\n        uint256 newCash;\\r\\n        uint256 newShares;\\r\\n        uint256 steps;\\r\\n        uint256 stepIndex;\\r\\n        uint256 stepAmount;\\r\\n        FeeReturn fees;\\r\\n    }\\r\\n\\r\\n    struct SharesCalculationReturn {\\r\\n        uint256 PV;\\r\\n        uint256 swapPV;\\r\\n        uint256 amount;\\r\\n        uint256 value;\\r\\n        uint256 F;\\r\\n        FeeReturn fees;\\r\\n    }\\r\\n\\r\\n    struct LiqLocalVars {\\r\\n        uint256 TVL;\\r\\n        uint256 LPPrice;\\r\\n        uint256 LPAmount;\\r\\n        uint256 stable;\\r\\n        uint256 stableTotal;\\r\\n        uint256 stableRemaining;\\r\\n        uint256 weighted;\\r\\n        uint256 poolId;\\r\\n        uint256 maxLPPerShares;\\r\\n        uint256 remainingLP;\\r\\n        uint256 i;\\r\\n        uint256 y;\\r\\n        uint256 counter;\\r\\n        AMMShare1155 currentShare;\\r\\n        SubPoolGroup currentSubPool;\\r\\n        SubPoolGroup[] subPoolGroups;\\r\\n    }\\r\\n    struct SwapLocalVars {\\r\\n        uint256 stable;\\r\\n        uint256 stableOut;\\r\\n        uint256 remaining;\\r\\n        uint256 poolId;\\r\\n        uint256 i;\\r\\n        uint256 y;\\r\\n        uint256 counter;\\r\\n        AMMShare1155 currentShare;\\r\\n        SubPoolGroup currentSubPool;\\r\\n        SubPoolGroup[] subPoolGroups;\\r\\n        FeeReturn fees;\\r\\n    }\\r\\n    enum FeeType {\\r\\n        royalties,\\r\\n        protocol\\r\\n    }\\r\\n    enum OperationType {\\r\\n        buyShares,\\r\\n        sellShares\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title library for Errors mapping\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the output of error messages reverted by the contracts of the Souq protocol\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\nlibrary Errors {\\r\\n    string public constant ADDRESS_IS_ZERO = \\\"ADDRESS_IS_ZERO\\\";\\r\\n    string public constant NOT_ENOUGH_USER_BALANCE = \\\"NOT_ENOUGH_USER_BALANCE\\\";\\r\\n    string public constant NOT_ENOUGH_APPROVED = \\\"NOT_ENOUGH_APPROVED\\\";\\r\\n    string public constant INVALID_AMOUNT = \\\"INVALID_AMOUNT\\\";\\r\\n    string public constant AMM_PAUSED = \\\"AMM_PAUSED\\\";\\r\\n    string public constant VAULT_PAUSED = \\\"VAULT_PAUSED\\\";\\r\\n    string public constant FLASHLOAN_DISABLED = \\\"FLASHLOAN_DISABLED\\\";\\r\\n    string public constant ADDRESSES_REGISTRY_NOT_SET = \\\"ADDRESSES_REGISTRY_NOT_SET\\\";\\r\\n    string public constant UPGRADEABILITY_DISABLED = \\\"UPGRADEABILITY_DISABLED\\\";\\r\\n    string public constant CALLER_NOT_UPGRADER = \\\"CALLER_NOT_UPGRADER\\\";\\r\\n    string public constant CALLER_NOT_POOL_ADMIN = \\\"CALLER_NOT_POOL_ADMIN\\\";\\r\\n    string public constant CALLER_NOT_ACCESS_ADMIN = \\\"CALLER_NOT_ACCESS_ADMIN\\\";\\r\\n    string public constant CALLER_NOT_POOL_ADMIN_OR_OPERATIONS = \\\"CALLER_NOT_POOL_ADMIN_OR_OPERATIONS\\\";\\r\\n    string public constant CALLER_NOT_ORACLE_ADMIN = \\\"CALLER_NOT_ORACLE_ADMIN\\\";\\r\\n    string public constant CALLER_NOT_TIMELOCK=\\\"CALLER_NOT_TIMELOCK\\\";\\r\\n    string public constant CALLER_NOT_TIMELOCK_ADMIN=\\\"CALLER_NOT_TIMELOCK_ADMIN\\\";\\r\\n    string public constant ADDRESS_IS_PROXY = \\\"ADDRESS_IS_PROXY\\\";\\r\\n    string public constant ARRAY_NOT_SAME_LENGTH = \\\"ARRAY_NOT_SAME_LENGTH\\\";\\r\\n    string public constant NO_SUB_POOL_AVAILABLE = \\\"NO_SUB_POOL_AVAILABLE\\\";\\r\\n    string public constant LIQUIDITY_MODE_RESTRICTED = \\\"LIQUIDITY_MODE_RESTRICTED\\\";\\r\\n    string public constant TVL_LIMIT_REACHED = \\\"TVL_LIMIT_REACHED\\\";\\r\\n    string public constant CALLER_MUST_BE_POOL = \\\"CALLER_MUST_BE_POOL\\\";\\r\\n    string public constant CANNOT_RESCUE_POOL_TOKEN = \\\"CANNOT_RESCUE_POOL_TOKEN\\\";\\r\\n    string public constant CALLER_MUST_BE_STABLEYIELD_ADMIN = \\\"CALLER_MUST_BE_STABLEYIELD_ADMIN\\\";\\r\\n    string public constant CALLER_MUST_BE_STABLEYIELD_LENDER = \\\"CALLER_MUST_BE_STABLEYIELD_LENDER\\\";\\r\\n    string public constant FUNCTION_REQUIRES_ACCESS_NFT = \\\"FUNCTION_REQUIRES_ACCESS_NFT\\\";\\r\\n    string public constant FEE_OUT_OF_BOUNDS = \\\"FEE_OUT_OF_BOUNDS\\\";\\r\\n    string public constant ONLY_ADMIN_CAN_ADD_LIQUIDITY = \\\"ONLY_ADMIN_CAN_ADD_LIQUIDITY\\\";\\r\\n    string public constant NOT_ENOUGH_POOL_RESERVE = \\\"NOT_ENOUGH_POOL_RESERVE\\\";\\r\\n    string public constant NOT_ENOUGH_SUBPOOL_RESERVE = \\\"NOT_ENOUGH_SUBPOOL_RESERVE\\\";\\r\\n    string public constant NOT_ENOUGH_SUBPOOL_SHARES = \\\"NOT_ENOUGH_SUBPOOL_SHARES\\\";\\r\\n    string public constant SUBPOOL_DISABLED = \\\"SUBPOOL_DISABLED\\\";\\r\\n    string public constant ADDRESS_NOT_CONNECTOR_ADMIN = \\\"ADDRESS_NOT_CONNECTOR_ADMIN\\\";\\r\\n    string public constant WITHDRAW_LIMIT_REACHED = \\\"WITHDRAW_LIMIT_REACHED\\\";\\r\\n    string public constant DEPOSIT_LIMIT_REACHED = \\\"DEPOSIT_LIMIT_REACHED\\\";\\r\\n    string public constant SHARES_VALUE_EXCEEDS_TARGET = \\\"SHARES_VALUE_EXCEEDS_TARGET\\\";\\r\\n    string public constant SHARES_VALUE_BELOW_TARGET = \\\"SHARES_VALUE_BELOW_TARGET\\\";\\r\\n    string public constant SHARES_TARGET_EXCEEDS_RESERVE = \\\"SHARES_TARGET_EXCEEDS_RESERVE\\\";\\r\\n    string public constant SWAPPING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS =\\r\\n        \\\"SWAPPING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\\\";\\r\\n    string public constant ADDING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS =\\r\\n        \\\"ADDING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\\\";\\r\\n    string public constant UPGRADE_DISABLED = \\\"UPGRADE_DISABLED\\\";\\r\\n    string public constant USER_CANNOT_BE_CONTRACT = \\\"USER_CANNOT_BE_CONTRACT\\\";\\r\\n    string public constant DEADLINE_NOT_FOUND = \\\"DEADLINE_NOT_FOUND\\\";\\r\\n    string public constant FLASHLOAN_PROTECTION_ENABLED = \\\"FLASHLOAN_PROTECTION_ENABLED\\\";\\r\\n    string public constant INVALID_POOL_ADDRESS = \\\"INVALID_POOL_ADDRESS\\\";\\r\\n    string public constant INVALID_SUBPOOL_ID = \\\"INVALID_SUBPOOL_ID\\\";\\r\\n    string public constant INVALID_YIELD_DISTRIBUTOR_ADDRESS=\\\"INVALID_YIELD_DISTRIBUTOR_ADDRESS\\\";\\r\\n    string public constant YIELD_DISTRIBUTOR_NOT_FOUND=\\\"YIELD_DISTRIBUTOR_NOT_FOUND\\\";\\r\\n    string public constant INVALID_TOKEN_ID=\\\"INVALID_TOKEN_ID\\\";\\r\\n    string public constant INVALID_VAULT_ADDRESS = \\\"INVALID_VAULT_ADDRESS\\\";\\r\\n    string public constant VAULT_NOT_FOUND=\\\"VAULT_NOT_FOUND\\\";\\r\\n    string public constant INVALID_TOKEN_ADDRESS=\\\"INVALID_TOKEN_ADDRESS\\\";\\r\\n    string public constant INVALID_STAKING_CONTRACT=\\\"INVALID_STAKING_CONTRACT\\\";\\r\\n    string public constant STAKING_CONTRACT_NOT_FOUND=\\\"STAKING_CONTRACT_NOT_FOUND\\\";\\r\\n    string public constant INVALID_SWAP_CONTRACT=\\\"INVALID_SWAP_CONTRACT\\\";\\r\\n    string public constant SWAP_CONTRACT_NOT_FOUND=\\\"SWAP_CONTRACT_NOT_FOUND\\\";\\r\\n    string public constant INVALID_ORACLE_CONNECTOR=\\\"INVALID_ORACLE_CONNECTOR\\\";\\r\\n    string public constant ORACLE_CONNECTOR_NOT_FOUND=\\\"ORACLE_CONNECTOR_NOT_FOUND\\\";\\r\\n    string public constant INVALID_COLLECTION_CONTRACT=\\\"INVALID_COLLECTION_CONTRACT\\\";\\r\\n    string public constant COLLECTION_CONTRACT_NOT_FOUND=\\\"COLLECTION_CONTRACT_NOT_FOUND\\\";\\r\\n    string public constant INVALID_STABLECOIN_YIELD_CONNECTOR=\\\"INVALID_STABLECOIN_YIELD_CONNECTOR\\\";\\r\\n    string public constant STABLECOIN_YIELD_CONNECTOR_NOT_FOUND=\\\"STABLECOIN_YIELD_CONNECTOR_NOT_FOUND\\\";\\r\\n    string public constant TIMELOCK_USES_ACCESS_CONTROL=\\\"TIMELOCK_USES_ACCESS_CONTROL\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Liquidity1155Logic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\nimport {Pool1155Logic} from \\\"./Pool1155Logic.sol\\\";\\r\\nimport {MathHelpers} from \\\"../libraries/MathHelpers.sol\\\";\\r\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport {Errors} from \\\"../libraries/Errors.sol\\\";\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title library for Liquidity logic of 1155 pools with single collection\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the logic functions for the AMM and MME that operate ERC1155 shares\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\nlibrary Liquidity1155Logic {\\r\\n    using Math for uint256;\\r\\n    using Pool1155Logic for DataTypes.AMMSubPool1155[];\\r\\n    /**\\r\\n     * @dev Emitted when the user initiates deposit of stablecoins and shares into a subpool\\r\\n     * @param user The user address\\r\\n     * @param subPoolId The subPool id\\r\\n     * @param stableIn The amount of stablecoin inputted\\r\\n     * @param params The token ids[] and amounts[] structure\\r\\n     * @param totalShares The new total shares count\\r\\n     * @param F The new F\\r\\n     */\\r\\n    event DepositInitiated(\\r\\n        address user,\\r\\n        uint256 subPoolId,\\r\\n        uint256 stableIn,\\r\\n        DataTypes.Shares1155Params params,\\r\\n        uint256 totalShares,\\r\\n        uint256 F\\r\\n    );\\r\\n    /**\\r\\n     * @dev Emitted when adding liquidity by a liqduity provider using stablecoins\\r\\n     * @param stableIn The amount of stablecoin inputted\\r\\n     * @param lpAmount The amount of LP token outputted\\r\\n     * @param from The address of the msg sender\\r\\n     * @notice it's here to avoid the stack too deep issue for now\\r\\n     */\\r\\n    event AddedLiqStable(uint256 stableIn, uint256 lpAmount, address from);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when adding liquidity by a liqduity provider using shares\\r\\n     * @param lpAmount The amount of LP token outputted\\r\\n     * @param from The address of the msg sender\\r\\n     * @param subPoolGroups The subpool groups including calculations and shares array\\r\\n     */\\r\\n    event AddedLiqShares(uint256 lpAmount, address from, DataTypes.SubPoolGroup[] subPoolGroups);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when removing liquidity by a liqduity provider\\r\\n     * @param stableOut The amount of stablecoin outputted\\r\\n     * @param lpAmount The amount of LP token inputted\\r\\n     * @param from The address of the msg sender\\r\\n     * @param queued If transaction is queued = true\\r\\n     */\\r\\n    event RemovedLiqStable(uint256 stableOut, uint256 lpAmount, address from, bool queued);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when removing liquidity by a liqduity provider\\r\\n     * @param lpAmount The amount of LP token inputted\\r\\n     * @param from The address of the msg sender\\r\\n     * @param queued If transaction is queued = true\\r\\n     * @param subPoolGroups The subpool groups including calculations and shares array\\r\\n     */\\r\\n    event RemovedLiqShares(uint256 lpAmount, address from, bool queued, DataTypes.SubPoolGroup[] subPoolGroups);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when swap of stable coins occures\\r\\n     * @param stableIn The amount of stablecoin supplied\\r\\n     * @param fees The fees collected\\r\\n     * @param user The user address\\r\\n     * @param subPoolGroups The subpool groups including calculations and shares array\\r\\n     */\\r\\n    event SwappedStable(uint256 stableIn, DataTypes.FeeReturn fees, address user, DataTypes.SubPoolGroup[] subPoolGroups);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when swap of shares occures\\r\\n     * @param stableOut The amount of stablecoin outputted\\r\\n     * @param fees The fees collected\\r\\n     * @param user The user address\\r\\n     * @param subPoolGroups The subpool groups including calculations and shares array\\r\\n     */\\r\\n    event SwappedShares(uint256 stableOut, DataTypes.FeeReturn fees, address user, DataTypes.SubPoolGroup[] subPoolGroups);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when withdrawals are processed after the cooldown period\\r\\n     * @param user The user that processed the withdrawals\\r\\n     * @param transactionsCount The number of transactions processed\\r\\n     */\\r\\n    event WithdrawalsProcessed(address user, uint256 transactionsCount);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to distribute liquidity to all subpools according to their weight\\r\\n     * @notice the last subpool gets the remainder, if any\\r\\n     * @param amount The account to deduct the stables from\\r\\n     * @param tvl The TVL of the pool\\r\\n     * @param poolData The liquidity pool data structure\\r\\n     * @param subPools The subpools array\\r\\n     */\\r\\n    function distributeLiquidityToAll(\\r\\n        uint256 amount,\\r\\n        uint256 tvl,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools\\r\\n    ) public {\\r\\n        require(subPools.length > 0, Errors.NO_SUB_POOL_AVAILABLE);\\r\\n        uint256 remaining = amount;\\r\\n        uint256 weighted = 0;\\r\\n        //Iterate through the subpools and add liquidity in a weighted manner and the remainder goes to the last subpool\\r\\n        for (uint256 i = 0; i < subPools.length; i++) {\\r\\n            if (subPools[i].status) {\\r\\n                if (i == subPools.length - 1) {\\r\\n                    subPools[i].reserve += remaining;\\r\\n                } else {\\r\\n                    if (tvl == 0) {\\r\\n                        subPools[i].reserve += amount / subPools.length;\\r\\n                        remaining -= amount / subPools.length;\\r\\n                    } else {\\r\\n                        weighted = (amount * Pool1155Logic.calculateTotal(subPools, i)) / tvl;\\r\\n                        remaining -= weighted;\\r\\n                        subPools[i].reserve += weighted;\\r\\n                    }\\r\\n                }\\r\\n                Pool1155Logic.updatePriceIterative(subPools, poolData, i);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function depositInitial(\\r\\n        address user,\\r\\n        uint256 subPoolId,\\r\\n        uint256 stableIn,\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external {\\r\\n        require(Pool1155Logic.calculateTotal(subPools, subPoolId) == 0, \\\"SUBPOOL_NOT_EMPTY\\\");\\r\\n        for (uint256 i = 0; i < params.tokenIds.length; i++) {\\r\\n            require(tokenDistribution[params.tokenIds[i]] == subPoolId, \\\"NOT_SAME_SUBPOOL_DISTRIBUTION\\\");\\r\\n            subPools[subPoolId].shares[params.tokenIds[i]] += params.amounts[i];\\r\\n            subPools[subPoolId].totalShares += params.amounts[i];\\r\\n        }\\r\\n        IERC1155(poolData.tokens[0]).safeBatchTransferFrom(user, poolData.poolLPToken, params.tokenIds, params.amounts, \\\"\\\");\\r\\n        subPools[subPoolId].reserve += stableIn;\\r\\n        Pool1155Logic.updatePriceIterative(subPools, poolData, subPoolId);\\r\\n        IERC20(poolData.stable).transferFrom(user, poolData.poolLPToken, stableIn);\\r\\n        ILPToken(poolData.poolLPToken).mint(\\r\\n            user,\\r\\n            MathHelpers.convertToWad(Pool1155Logic.calculateTotal(subPools, subPoolId)) / subPools.getLPPrice(poolData.poolLPToken)\\r\\n        );\\r\\n        emit DepositInitiated(user, subPoolId, stableIn, params, subPools[subPoolId].totalShares, subPools[subPoolId].F);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove liquidity by stable coins\\r\\n     * @param user The account to deduct the stables from\\r\\n     * @param targetLP The amount of LPs required\\r\\n     * @param maxStable the maximum stablecoins to transfer\\r\\n     * @param poolData The liquidity pool data structure\\r\\n     * @param subPools The subpools array\\r\\n     */\\r\\n    function addLiquidityStable(\\r\\n        address user,\\r\\n        uint256 targetLP,\\r\\n        uint256 maxStable,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools\\r\\n    ) external returns (uint256, uint256) {\\r\\n        require(user != address(0), Errors.ADDRESS_IS_ZERO);\\r\\n        require(IERC20(poolData.stable).allowance(user, address(this)) >= maxStable, Errors.NOT_ENOUGH_APPROVED);\\r\\n        require(IERC20(poolData.stable).balanceOf(user) >= maxStable, Errors.NOT_ENOUGH_USER_BALANCE);\\r\\n        DataTypes.LiqLocalVars memory vars;\\r\\n        (vars.TVL, vars.LPPrice) = subPools.getTVLAndLPPrice(poolData.poolLPToken);\\r\\n        require(poolData.liquidityLimit.poolTvlLimit >= vars.TVL + maxStable, Errors.TVL_LIMIT_REACHED);\\r\\n        //if TVL > 0 and deposit > TVL * limitPercentage, then revert where deposit is (requiredLP + totalLPOwned) * price\\r\\n        //for v1.1\\r\\n        // require(\\r\\n        //     vars.TVL == 0 ||\\r\\n        //         ((MathHelpers.convertFromWad((targetLP + ILPToken(poolData.poolLPToken).getBalanceOf(user)) * vars.LPPrice)) <=\\r\\n        //             MathHelpers.convertFromWadPercentage(vars.TVL * poolData.liquidityLimit.maxDepositPercentage)),\\r\\n        //     Errors.DEPOSIT_LIMIT_REACHED\\r\\n        // );\\r\\n        if ((MathHelpers.convertFromWad(targetLP * vars.LPPrice)) > maxStable) {\\r\\n            vars.LPAmount = MathHelpers.convertToWad(maxStable) / vars.LPPrice;\\r\\n            vars.stable = maxStable;\\r\\n        } else {\\r\\n            vars.LPAmount = targetLP;\\r\\n            vars.stable = MathHelpers.convertFromWad(targetLP * vars.LPPrice);\\r\\n        }\\r\\n        distributeLiquidityToAll(vars.stable, vars.TVL, poolData, subPools);\\r\\n\\r\\n        IERC20(poolData.stable).transferFrom(user, poolData.poolLPToken, vars.stable);\\r\\n        ILPToken(poolData.poolLPToken).mint(user, vars.LPAmount);\\r\\n        emit AddedLiqStable(vars.stable, vars.LPAmount, user);\\r\\n        return (vars.stable, vars.LPAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add liquidity by shares while grouping by subpool\\r\\n     * @param user The account to deduct stable from\\r\\n     * @param targetLP The amount of LPs required\\r\\n     * @param params The shares arrays (token ids, amounts)\\r\\n     * @param poolData The data of the liquidity pool\\r\\n     * @param subPools The subPools array\\r\\n     * @param tokenDistribution The token distribution mapping\\r\\n     */\\r\\n    function addLiquidityShares(\\r\\n        address user,\\r\\n        uint256 targetLP,\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external returns (uint256) {\\r\\n        require(user != address(0), Errors.ADDRESS_IS_ZERO);\\r\\n        require(params.tokenIds.length == params.amounts.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n        require(IERC1155(poolData.tokens[0]).isApprovedForAll(user, address(this)), Errors.NOT_ENOUGH_APPROVED);\\r\\n        DataTypes.LiqLocalVars memory vars;\\r\\n        (vars.TVL, vars.LPPrice) = subPools.getTVLAndLPPrice(poolData.poolLPToken);\\r\\n        //for v1.1\\r\\n        //if TVL > 0 and deposit > TVL * limitPercentage, then revert where deposit is (requiredLP + totalLPOwned) * price\\r\\n        // require(\\r\\n        //     vars.TVL == 0 ||\\r\\n        //         ((MathHelpers.convertFromWad((targetLP + ILPToken(poolData.poolLPToken).getBalanceOf(user)) * vars.LPPrice)) <=\\r\\n        //             MathHelpers.convertFromWadPercentage(vars.TVL * poolData.liquidityLimit.maxDepositPercentage)),\\r\\n        //     Errors.DEPOSIT_LIMIT_REACHED\\r\\n        // );\\r\\n        require(\\r\\n            poolData.liquidityLimit.poolTvlLimit >= vars.TVL + (MathHelpers.convertFromWad(targetLP * vars.LPPrice)),\\r\\n            Errors.TVL_LIMIT_REACHED\\r\\n        );\\r\\n\\r\\n        vars.remainingLP = targetLP;\\r\\n        (vars.subPoolGroups, vars.counter) = groupBySubpoolDynamic(params, subPools.length, tokenDistribution);\\r\\n        for (vars.i = 0; vars.i < vars.counter; vars.i++) {\\r\\n            vars.currentSubPool = vars.subPoolGroups[vars.i];\\r\\n            vars.poolId = vars.currentSubPool.id;\\r\\n            require(subPools[vars.poolId].status == true, Errors.SUBPOOL_DISABLED);\\r\\n            require(\\r\\n                subPools[vars.poolId].F >= poolData.iterativeLimit.minimumF,\\r\\n                Errors.ADDING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\\r\\n            );\\r\\n            vars.currentSubPool.sharesCal = Pool1155Logic.CalculateShares(\\r\\n                DataTypes.OperationType.sellShares,\\r\\n                subPools,\\r\\n                vars.poolId,\\r\\n                poolData,\\r\\n                vars.currentSubPool.total,\\r\\n                false\\r\\n            );\\r\\n            vars.maxLPPerShares = (MathHelpers.convertToWad(vars.currentSubPool.sharesCal.value) / vars.LPPrice);\\r\\n            require(vars.maxLPPerShares <= vars.remainingLP, Errors.SHARES_VALUE_EXCEEDS_TARGET);\\r\\n            vars.remainingLP -= vars.maxLPPerShares;\\r\\n            subPools[vars.poolId].totalShares += vars.currentSubPool.total;\\r\\n            subPools[vars.poolId].F = vars.currentSubPool.sharesCal.F;\\r\\n\\r\\n            for (vars.y = 0; vars.y < vars.currentSubPool.counter; vars.y++) {\\r\\n                vars.currentShare = vars.currentSubPool.shares[vars.y];\\r\\n                subPools[vars.poolId].shares[vars.currentShare.tokenId] += vars.currentShare.amount;\\r\\n                //Transfer the share tokens\\r\\n                //We cant transfer batch outside the loop since the array of token ids and amounts have a counter after grouping\\r\\n                //To generate proper token ids and amounts arrays for transfer batch, the groupBySubpoolDynamic will be redesigned and cost more gas\\r\\n                //Even if grouped and the transfer is outside the current for loop, there is still another for loop due to economy of scale approach\\r\\n                IERC1155(poolData.tokens[0]).safeTransferFrom(\\r\\n                    user,\\r\\n                    poolData.poolLPToken,\\r\\n                    vars.currentShare.tokenId,\\r\\n                    vars.currentShare.amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n            if (vars.remainingLP == 0) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        vars.LPAmount = targetLP - vars.remainingLP;\\r\\n        ILPToken(poolData.poolLPToken).mint(user, vars.LPAmount);\\r\\n        emit AddedLiqShares(vars.LPAmount, user, vars.subPoolGroups);\\r\\n        return (vars.LPAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove liquidity by stable coins\\r\\n     * @param user The account to remove LP from\\r\\n     * @param yieldReserve The current reserve deposited in yield generators\\r\\n     * @param targetLP The amount of LPs to be burned\\r\\n     * @param poolData The liquidity pool data structure\\r\\n     * @param subPools The subpools array\\r\\n     * @param queuedWithdrawals The queued withdrawals\\r\\n     */\\r\\n    function removeLiquidityStable(\\r\\n        address user,\\r\\n        uint256 yieldReserve,\\r\\n        uint256 targetLP,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.Queued1155Withdrawals storage queuedWithdrawals\\r\\n    ) external returns (uint256, uint256) {\\r\\n        require(user != address(0), Errors.ADDRESS_IS_ZERO);\\r\\n        require(ILPToken(poolData.poolLPToken).getBalanceOf(user) >= targetLP, Errors.NOT_ENOUGH_USER_BALANCE);\\r\\n        require(subPools.length > 0, Errors.NO_SUB_POOL_AVAILABLE);\\r\\n        DataTypes.LiqLocalVars memory vars;\\r\\n        (vars.TVL, vars.LPPrice) = subPools.getTVLAndLPPrice(poolData.poolLPToken);\\r\\n        //Check how much stablecoins remaining in the pool excluding yield investment\\r\\n        vars.stableRemaining = IERC20(poolData.stable).balanceOf(poolData.poolLPToken) - yieldReserve;\\r\\n        //Calculate maximum LP Tokens to remove\\r\\n        vars.remainingLP = targetLP.min(MathHelpers.convertToWad(vars.stableRemaining) / vars.LPPrice);\\r\\n        for (vars.i = 0; vars.i < subPools.length; vars.i++) {\\r\\n            if (subPools[vars.i].status) {\\r\\n                vars.weighted = vars.remainingLP.min((targetLP * Pool1155Logic.calculateTotal(subPools, vars.i)) / vars.TVL);\\r\\n                vars.stable = MathHelpers.convertFromWad(vars.weighted * vars.LPPrice);\\r\\n                vars.stable = subPools[vars.i].reserve.min(vars.stable);\\r\\n                subPools[vars.i].reserve -= vars.stable;\\r\\n                Pool1155Logic.updatePriceIterative(subPools, poolData, vars.i);\\r\\n                vars.stableTotal += vars.stable;\\r\\n                vars.remainingLP -= vars.weighted;\\r\\n            }\\r\\n        }\\r\\n        vars.LPAmount = targetLP - vars.remainingLP;\\r\\n        //If there is a cooldown, then store the stable in an array in the user data to be released later\\r\\n        if (poolData.liquidityLimit.cooldown == 0) {\\r\\n            ILPToken(poolData.poolLPToken).setApproval20(poolData.stable, vars.stableTotal);\\r\\n            IERC20(poolData.stable).transferFrom(poolData.poolLPToken, user, vars.stableTotal);\\r\\n        } else {\\r\\n            DataTypes.Withdraw1155Data storage current = queuedWithdrawals.withdrawals[queuedWithdrawals.nextId];\\r\\n            current.to = user;\\r\\n            //Using block.timestamp is safer than block number\\r\\n            //See: https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp/11072#11072\\r\\n            current.unlockTimestamp = block.timestamp + poolData.liquidityLimit.cooldown;\\r\\n            current.amount = vars.stableTotal;\\r\\n            queuedWithdrawals.nextId++;\\r\\n        }\\r\\n        ILPToken(poolData.poolLPToken).burn(user, vars.LPAmount);\\r\\n        emit RemovedLiqStable(vars.stableTotal, vars.LPAmount, user, poolData.liquidityLimit.cooldown > 0 ? true : false);\\r\\n        return (vars.stableTotal, vars.LPAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove liquidity by shares\\r\\n     * @param user The account to burn from\\r\\n     * @param targetLP The amount of LPs to be burned\\r\\n     * @param params The shares arrays (token ids, amounts)\\r\\n     * @param poolData The data of the liquidity pool\\r\\n     * @param subPools The subPools array\\r\\n     * @param queuedWithdrawals The queued withdrawals\\r\\n     * @param tokenDistribution The token distribution mapping\\r\\n     */\\r\\n    function removeLiquidityShares(\\r\\n        address user,\\r\\n        uint256 targetLP,\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.Queued1155Withdrawals storage queuedWithdrawals,\\r\\n        //mapping(uint256 => uint256) storage subPoolGroupsPointer,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external returns (uint256) {\\r\\n        require(user != address(0), Errors.ADDRESS_IS_ZERO);\\r\\n        require(params.tokenIds.length == params.amounts.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n        require(ILPToken(poolData.poolLPToken).getBalanceOf(user) >= targetLP, Errors.NOT_ENOUGH_USER_BALANCE);\\r\\n        DataTypes.LiqLocalVars memory vars;\\r\\n        //Get LP Price\\r\\n        vars.LPPrice = subPools.getLPPrice(poolData.poolLPToken);\\r\\n        vars.remainingLP = targetLP;\\r\\n        DataTypes.AMMShare1155[] storage queuedShares = queuedWithdrawals.withdrawals[queuedWithdrawals.nextId].shares;\\r\\n        //Get the grouped token ids by subpool\\r\\n        (vars.subPoolGroups, vars.counter) = groupBySubpoolDynamic(params, subPools.length, tokenDistribution);\\r\\n        //iterate the subpool groups\\r\\n        for (vars.i = 0; vars.i < vars.counter; vars.i++) {\\r\\n            vars.currentSubPool = vars.subPoolGroups[vars.i];\\r\\n            vars.poolId = vars.currentSubPool.id;\\r\\n            require(subPools[vars.poolId].status == true, Errors.SUBPOOL_DISABLED);\\r\\n            //Calculate the value of the shares inside this group\\r\\n            vars.currentSubPool.sharesCal = Pool1155Logic.CalculateShares(\\r\\n                DataTypes.OperationType.buyShares,\\r\\n                subPools,\\r\\n                vars.poolId,\\r\\n                poolData,\\r\\n                vars.currentSubPool.total,\\r\\n                false\\r\\n            );\\r\\n            vars.maxLPPerShares = MathHelpers.convertToWad(vars.currentSubPool.sharesCal.value) / vars.LPPrice;\\r\\n            require(vars.maxLPPerShares <= vars.remainingLP, Errors.SHARES_VALUE_EXCEEDS_TARGET);\\r\\n            vars.remainingLP -= vars.maxLPPerShares;\\r\\n            //Update the subpool\\r\\n            subPools[vars.poolId].totalShares -= params.amounts[vars.i];\\r\\n            subPools[vars.poolId].F = vars.currentSubPool.sharesCal.F;\\r\\n\\r\\n            for (vars.y = 0; vars.y < vars.currentSubPool.counter; vars.y++) {\\r\\n                vars.currentShare = vars.currentSubPool.shares[vars.y];\\r\\n                require(\\r\\n                    subPools[vars.poolId].shares[vars.currentShare.tokenId] >= vars.currentShare.amount,\\r\\n                    Errors.NOT_ENOUGH_SUBPOOL_SHARES\\r\\n                );\\r\\n                subPools[vars.poolId].shares[vars.currentShare.tokenId] -= vars.currentShare.amount;\\r\\n                //Transfer the share tokens\\r\\n                //We cant transfer batch outside the loop since the array of token ids and amounts have a counter after grouping\\r\\n                //To generate proper token ids and amounts arrays for transfer batch, the groupBySubpoolDynamic will be redesigned and cost more gas\\r\\n                //Even if grouped and the transfer is outside the current for loop, there is still another for loop due to economy of scale approach\\r\\n                IERC1155(poolData.tokens[0]).safeTransferFrom(\\r\\n                    poolData.poolLPToken,\\r\\n                    user,\\r\\n                    vars.currentShare.tokenId,\\r\\n                    vars.currentShare.amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n                //If there is a cooldown, then store the shares in an array in the user data to be released later\\r\\n                if (poolData.liquidityLimit.cooldown > 0) {\\r\\n                    queuedShares.push(DataTypes.AMMShare1155(params.tokenIds[vars.i], params.amounts[vars.i]));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        //If cooldown is enabled, queue the withdrawal\\r\\n        if (poolData.liquidityLimit.cooldown > 0) {\\r\\n            queuedWithdrawals.withdrawals[queuedWithdrawals.nextId].to = user;\\r\\n            //Using block.timestamp is safer than block number\\r\\n            //See: https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp/11072#11072\\r\\n            queuedWithdrawals.withdrawals[queuedWithdrawals.nextId].unlockTimestamp = block.timestamp + poolData.liquidityLimit.cooldown;\\r\\n            queuedWithdrawals.withdrawals[queuedWithdrawals.nextId].shares = queuedShares;\\r\\n            queuedWithdrawals.nextId++;\\r\\n        }\\r\\n        vars.LPAmount = targetLP - vars.remainingLP;\\r\\n        //Burn the LP Token\\r\\n        ILPToken(poolData.poolLPToken).burn(user, vars.LPAmount);\\r\\n        emit RemovedLiqShares(vars.LPAmount, user, poolData.liquidityLimit.cooldown > 0 ? true : false, vars.subPoolGroups);\\r\\n        return (vars.LPAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to process queued withdraw transactions upto limit and return number of transactions processed\\r\\n     * @notice make it update F if needed for future\\r\\n     * @param limit The number of transactions to process in queue\\r\\n     * @param poolData The liquidity pool data structure\\r\\n     * @param queuedWithdrawals The queued withdrawals\\r\\n     * @return transactions number of transactions processed. 0 = no transactions in queue\\r\\n     */\\r\\n    function processWithdrawals(\\r\\n        uint256 limit,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.Queued1155Withdrawals storage queuedWithdrawals\\r\\n    ) external returns (uint256 transactions) {\\r\\n        for (uint256 i = 0; i < limit; i++) {\\r\\n            DataTypes.Withdraw1155Data storage current = queuedWithdrawals.withdrawals[queuedWithdrawals.headId];\\r\\n            //Using block.timestamp is safer than block number\\r\\n            //See: https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp/11072#11072\\r\\n            if (current.unlockTimestamp < block.timestamp) break;\\r\\n            if (current.amount > 0) {\\r\\n                ILPToken(poolData.poolLPToken).setApproval20(poolData.stable, current.amount);\\r\\n                IERC20(poolData.stable).transferFrom(poolData.poolLPToken, current.to, current.amount);\\r\\n            }\\r\\n            for (uint256 j = 0; j < current.shares.length; j++) {\\r\\n                IERC1155(poolData.tokens[0]).safeTransferFrom(\\r\\n                    poolData.poolLPToken,\\r\\n                    current.to,\\r\\n                    current.shares[j].tokenId,\\r\\n                    current.shares[j].amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n            transactions++;\\r\\n            queuedWithdrawals.headId++;\\r\\n        }\\r\\n        if (queuedWithdrawals.nextId == queuedWithdrawals.headId) {\\r\\n            queuedWithdrawals.nextId = 0;\\r\\n            queuedWithdrawals.headId = 0;\\r\\n        }\\r\\n        emit WithdrawalsProcessed(msg.sender, transactions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that returns an array of structures that represent that subpools found that has an array of shares in those subpools and the counter represents the length of the outer and inner arrays\\r\\n     * @param  params The shares arrays (token ids, amounts) to group\\r\\n     * @param length the subpools length\\r\\n     * @param tokenDistribution the token distribution of the liquidity pool\\r\\n     * @return subPoolGroups array of DataTypes.SubPoolGroup output\\r\\n     * @return counter The counter of array elements used\\r\\n     */\\r\\n    function groupBySubpoolDynamic(\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        uint256 length,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) public view returns (DataTypes.SubPoolGroup[] memory subPoolGroups, uint256 counter) {\\r\\n        subPoolGroups = new DataTypes.SubPoolGroup[](length);\\r\\n        counter = 0;\\r\\n        DataTypes.LocalGroupVars memory vars;\\r\\n        //Get the token ids\\r\\n        if (params.tokenIds.length == 1) {\\r\\n            counter = 1;\\r\\n            subPoolGroups = new DataTypes.SubPoolGroup[](1);\\r\\n            subPoolGroups[0] = DataTypes.SubPoolGroup(\\r\\n                tokenDistribution[params.tokenIds[0]],\\r\\n                1,\\r\\n                params.amounts[0],\\r\\n                new DataTypes.AMMShare1155[](1),\\r\\n                vars.cal\\r\\n            );\\r\\n            subPoolGroups[0].shares[0] = DataTypes.AMMShare1155(params.tokenIds[0], params.amounts[0]);\\r\\n        } else {\\r\\n            //First we create an array of same length of the params and fill it with the token ids, subpool ids and amounts\\r\\n            vars.paramGroups = new DataTypes.ParamGroup[](params.tokenIds.length);\\r\\n            for (vars.i = 0; vars.i < params.tokenIds.length; vars.i++) {\\r\\n                vars.paramGroups[vars.i].subPoolId = tokenDistribution[params.tokenIds[vars.i]];\\r\\n                vars.paramGroups[vars.i].amount = params.amounts[vars.i];\\r\\n                vars.paramGroups[vars.i].tokenId = params.tokenIds[vars.i];\\r\\n            }\\r\\n            //Then we sort the new array using the insertion method\\r\\n            for (vars.i = 1; vars.i < vars.paramGroups.length; vars.i++) {\\r\\n                for (uint j = 0; j < vars.i; j++)\\r\\n                    if (vars.paramGroups[vars.i].subPoolId < vars.paramGroups[j].subPoolId) {\\r\\n                        DataTypes.ParamGroup memory x = vars.paramGroups[vars.i];\\r\\n                        vars.paramGroups[vars.i] = vars.paramGroups[j];\\r\\n                        vars.paramGroups[j] = x;\\r\\n                    }\\r\\n            }\\r\\n            //The we iterate last time through the array and construct the subpool group\\r\\n            for (vars.i = 0; vars.i < vars.paramGroups.length; vars.i++) {\\r\\n                if (vars.i == 0 || vars.paramGroups[vars.i].subPoolId != vars.paramGroups[vars.i - 1].subPoolId) {\\r\\n                    subPoolGroups[counter] = DataTypes.SubPoolGroup(\\r\\n                        vars.paramGroups[vars.i].subPoolId,\\r\\n                        0,\\r\\n                        0,\\r\\n                        new DataTypes.AMMShare1155[](vars.paramGroups.length),\\r\\n                        vars.cal\\r\\n                    );\\r\\n                    counter++;\\r\\n                }\\r\\n                vars.index = counter - 1;\\r\\n                subPoolGroups[vars.index].shares[subPoolGroups[vars.index].counter] = DataTypes.AMMShare1155(\\r\\n                    vars.paramGroups[vars.i].tokenId,\\r\\n                    vars.paramGroups[vars.i].amount\\r\\n                );\\r\\n                subPoolGroups[vars.index].total += vars.paramGroups[vars.i].amount;\\r\\n                subPoolGroups[vars.index].counter++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @dev Get full quotation\\r\\n     * @param quoteParams the quote params containing the buy/sell flag and the use fee flag\\r\\n     * @param params The shares arrays (token ids, amounts)\\r\\n     * @param poolData The liquidity pool data\\r\\n     * @param subPools the subpools array of the liquidity pool\\r\\n     * @param tokenDistribution the token distribution of the liquidity pool\\r\\n     */\\r\\n    function getQuote(\\r\\n        DataTypes.QuoteParams calldata quoteParams,\\r\\n        DataTypes.Shares1155Params calldata params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external view returns (DataTypes.Quotation memory quotation) {\\r\\n        require(params.tokenIds.length == params.amounts.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n        DataTypes.LocalQuoteVars memory vars;\\r\\n        quotation.shares = new DataTypes.SharePrice[](params.tokenIds.length);\\r\\n        //Get the grouped token ids by subpool\\r\\n        (vars.subPoolGroups, vars.counter) = groupBySubpoolDynamic(params, subPools.length, tokenDistribution);\\r\\n        for (vars.i = 0; vars.i < vars.counter; vars.i++) {\\r\\n            vars.currentSubPool = vars.subPoolGroups[vars.i];\\r\\n            vars.poolId = vars.currentSubPool.id;\\r\\n            require(subPools[vars.poolId].status == true, Errors.SUBPOOL_DISABLED);\\r\\n            //Calculate the value of the shares from its subpool\\r\\n            vars.currentSubPool.sharesCal = Pool1155Logic.CalculateShares(\\r\\n                quoteParams.buy ? DataTypes.OperationType.buyShares : DataTypes.OperationType.sellShares,\\r\\n                subPools,\\r\\n                vars.poolId,\\r\\n                poolData,\\r\\n                vars.currentSubPool.total,\\r\\n                quoteParams.useFee\\r\\n            );\\r\\n            for (vars.y = 0; vars.y < vars.currentSubPool.counter; vars.y++) {\\r\\n                vars.currentShare = vars.currentSubPool.shares[vars.y];\\r\\n                require(\\r\\n                    subPools[vars.poolId].shares[vars.currentShare.tokenId] >= vars.currentShare.amount || !quoteParams.buy,\\r\\n                    Errors.NOT_ENOUGH_SUBPOOL_SHARES\\r\\n                );\\r\\n                quotation.shares[vars.counterShares].value = vars.currentShare.amount * vars.currentSubPool.sharesCal.swapPV;\\r\\n                quotation.shares[vars.counterShares].id = vars.currentShare.tokenId;\\r\\n                quotation.shares[vars.counterShares].fees = Pool1155Logic.multiplyFees(\\r\\n                    vars.subPoolGroups[vars.i].sharesCal.fees,\\r\\n                    vars.currentShare.amount,\\r\\n                    vars.currentSubPool.total\\r\\n                );\\r\\n                vars.counterShares++;\\r\\n            }\\r\\n            quotation.fees = Pool1155Logic.addFees(quotation.fees, vars.subPoolGroups[vars.i].sharesCal.fees);\\r\\n            require(\\r\\n                subPools[vars.poolId].reserve >= vars.subPoolGroups[vars.i].sharesCal.value || quoteParams.buy,\\r\\n                Errors.NOT_ENOUGH_SUBPOOL_RESERVE\\r\\n            );\\r\\n            quotation.total += vars.subPoolGroups[vars.i].sharesCal.value;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @dev Function to the swap stablecoins to shares using grouping by subpools\\r\\n     * @param user The user address to deduct stablecoins\\r\\n     * @param maxStable the maximum stablecoins to deduct\\r\\n     * @param  params The shares arrays (token ids, amounts)\\r\\n     * @param poolData The pool data including fee configuration\\r\\n     * @param subPools the subpools array of the liquidity pool\\r\\n     * @param tokenDistribution the token distribution of the liquidity pool\\r\\n     */\\r\\n    function swapStable(\\r\\n        address user,\\r\\n        uint256 maxStable,\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external {\\r\\n        require(params.tokenIds.length == params.amounts.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n        require(IERC20(poolData.stable).allowance(user, address(this)) >= maxStable, Errors.NOT_ENOUGH_APPROVED);\\r\\n        require(IERC20(poolData.stable).balanceOf(user) >= maxStable, Errors.NOT_ENOUGH_USER_BALANCE);\\r\\n        DataTypes.SwapLocalVars memory vars;\\r\\n        vars.remaining = maxStable;\\r\\n        //Get the grouped token ids by subpool\\r\\n        (vars.subPoolGroups, vars.counter) = groupBySubpoolDynamic(params, subPools.length, tokenDistribution);\\r\\n        //iterate the subpool groups\\r\\n        for (vars.i = 0; vars.i < vars.counter; vars.i++) {\\r\\n            vars.currentSubPool = vars.subPoolGroups[vars.i];\\r\\n            vars.poolId = vars.currentSubPool.id;\\r\\n            require(subPools[vars.poolId].status == true, Errors.SUBPOOL_DISABLED);\\r\\n            //Calculate the value of the shares inside this group\\r\\n            //This requires that the total shares in the subpool >= amount requested or it reverts\\r\\n            vars.currentSubPool.sharesCal = Pool1155Logic.CalculateShares(\\r\\n                DataTypes.OperationType.buyShares,\\r\\n                subPools,\\r\\n                vars.poolId,\\r\\n                poolData,\\r\\n                vars.currentSubPool.total,\\r\\n                true\\r\\n            );\\r\\n            //If the value of the shares is higher than the remaining stablecoins to consume, continue the for.\\r\\n            // Otherwise, we would need to recalculate using the remaining stable\\r\\n            // It is better to assume that the user approved more than the shares value\\r\\n            //if (vars.currentSubPool.sharesCal.value + vars.currentSubPool.sharesCal.fees.totalFee > vars.remaining) continue;\\r\\n            require(\\r\\n                vars.currentSubPool.sharesCal.value +\\r\\n                    vars.currentSubPool.sharesCal.fees.royalties +\\r\\n                    vars.currentSubPool.sharesCal.fees.protocolFee <=\\r\\n                    vars.remaining,\\r\\n                Errors.SHARES_VALUE_EXCEEDS_TARGET\\r\\n            );\\r\\n\\r\\n            vars.remaining -= (vars.currentSubPool.sharesCal.value +\\r\\n                vars.currentSubPool.sharesCal.fees.royalties +\\r\\n                vars.currentSubPool.sharesCal.fees.protocolFee);\\r\\n            //increment the total fees for emitting the event\\r\\n            vars.fees = Pool1155Logic.addFees(vars.fees, vars.currentSubPool.sharesCal.fees);\\r\\n            //Update the reserve of stable and shares and F\\r\\n            subPools[vars.poolId].reserve += vars.currentSubPool.sharesCal.value;\\r\\n            subPools[vars.poolId].totalShares -= vars.currentSubPool.total;\\r\\n            subPools[vars.poolId].F = vars.currentSubPool.sharesCal.F;\\r\\n            //Iterate through all the shares to update their new amounts in the subpool\\r\\n            for (vars.y = 0; vars.y < vars.currentSubPool.counter; vars.y++) {\\r\\n                vars.currentShare = vars.currentSubPool.shares[vars.y];\\r\\n                require(\\r\\n                    subPools[vars.poolId].shares[vars.currentShare.tokenId] >= vars.currentShare.amount,\\r\\n                    Errors.NOT_ENOUGH_SUBPOOL_SHARES\\r\\n                );\\r\\n                subPools[vars.poolId].shares[vars.currentShare.tokenId] -= vars.currentShare.amount;\\r\\n                //Transfer the tokens\\r\\n                //We cant transfer batch outside the loop since the array of token ids and amounts have a counter after grouping\\r\\n                //To generate proper token ids and amounts arrays for transfer batch, the groupBySubpoolDynamic will be redesigned and cost more gas\\r\\n                //Even if grouped and the transfer is outside the current for loop, there is still another for loop due to economy of scale approach\\r\\n                IERC1155(poolData.tokens[0]).safeTransferFrom(\\r\\n                    poolData.poolLPToken,\\r\\n                    user,\\r\\n                    vars.currentShare.tokenId,\\r\\n                    vars.currentShare.amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        //Add to the balances of the protocol wallet and royalties address\\r\\n        poolData.fee.protocolBalance += vars.fees.protocolFee;\\r\\n        poolData.fee.royaltiesBalance += vars.fees.royalties;\\r\\n        //Transfer the total stable from the user\\r\\n        IERC20(poolData.stable).transferFrom(user, poolData.poolLPToken, maxStable - vars.remaining);\\r\\n        emit SwappedStable(maxStable - vars.remaining, vars.fees, user, vars.subPoolGroups);\\r\\n    }\\r\\n\\r\\n    /** @dev Function to the swap shares to stablecoins using grouping by subpools\\r\\n     * @notice subPoolGroupsPointer should be cleared by making it \\\"1\\\" after each iteration of the grouping\\r\\n     * @param user The user address to transfer the shares from\\r\\n     * @param  minStable The minimum stablecoins to receive\\r\\n     * @param  yieldReserve The current reserve in yield contracts\\r\\n     * @param  params The shares arrays to deduct (token ids, amounts)\\r\\n     * @param poolData The pool data including fee configuration\\r\\n     * @param subPools the subpools array of the liquidity pool\\r\\n     * @param tokenDistribution the token distribution of the liquidity pool\\r\\n     */\\r\\n    function swapShares(\\r\\n        address user,\\r\\n        uint256 minStable,\\r\\n        uint256 yieldReserve,\\r\\n        DataTypes.Shares1155Params memory params,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external {\\r\\n        require(params.tokenIds.length == params.amounts.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n\\r\\n        DataTypes.SwapLocalVars memory vars;\\r\\n        (vars.subPoolGroups, vars.counter) = groupBySubpoolDynamic(params, subPools.length, tokenDistribution);\\r\\n        //Check how much stablecoins remaining in the pool excluding yield investment\\r\\n        require(IERC20(poolData.stable).balanceOf(poolData.poolLPToken) - yieldReserve >= minStable, Errors.NOT_ENOUGH_POOL_RESERVE);\\r\\n        //Get the grouped token ids by subpool\\r\\n        for (vars.i = 0; vars.i < vars.counter; vars.i++) {\\r\\n            vars.currentSubPool = vars.subPoolGroups[vars.i];\\r\\n            vars.poolId = vars.currentSubPool.id;\\r\\n            require(\\r\\n                subPools[vars.poolId].F >= poolData.iterativeLimit.minimumF,\\r\\n                Errors.SWAPPING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\\r\\n            );\\r\\n            require(subPools[vars.poolId].status == true, Errors.SUBPOOL_DISABLED);\\r\\n            //Calculate the value of the shares inside this group\\r\\n            vars.currentSubPool.sharesCal = Pool1155Logic.CalculateShares(\\r\\n                DataTypes.OperationType.sellShares,\\r\\n                subPools,\\r\\n                vars.poolId,\\r\\n                poolData,\\r\\n                vars.currentSubPool.total,\\r\\n                true\\r\\n            );\\r\\n            vars.stable =\\r\\n                vars.currentSubPool.sharesCal.value -\\r\\n                vars.currentSubPool.sharesCal.fees.royalties -\\r\\n                vars.currentSubPool.sharesCal.fees.protocolFee;\\r\\n            //Skip this subpool if there isn't enough\\r\\n            //The pricing depends on all the shares together, otherwise we need to break them and re-iterate (future feature)\\r\\n            require(vars.currentSubPool.sharesCal.value <= subPools[vars.poolId].reserve, Errors.NOT_ENOUGH_SUBPOOL_RESERVE);\\r\\n\\r\\n            vars.stableOut += vars.stable;\\r\\n            //add the total fees for emitting the event\\r\\n            vars.fees = Pool1155Logic.addFees(vars.fees, vars.currentSubPool.sharesCal.fees);\\r\\n            //Update the reserve of stable and shares and F\\r\\n            subPools[vars.poolId].reserve -= (vars.currentSubPool.sharesCal.value);\\r\\n            subPools[vars.poolId].totalShares += vars.currentSubPool.total;\\r\\n            subPools[vars.poolId].F = vars.currentSubPool.sharesCal.F;\\r\\n            //Iterate through the shares inside the Group\\r\\n            for (vars.y = 0; vars.y < vars.currentSubPool.counter; vars.y++) {\\r\\n                vars.currentShare = vars.currentSubPool.shares[vars.y];\\r\\n                subPools[vars.poolId].shares[vars.currentShare.tokenId] += vars.currentShare.amount;\\r\\n                //Transfer the tokens\\r\\n                //We cant transfer batch outside the loop since the array of token ids and amounts have a counter after grouping\\r\\n                //To generate proper token ids and amounts arrays for transfer batch, the groupBySubpoolDynamic will be redesigned and cost more gas\\r\\n                //Even if grouped and the transfer is outside the current for loop, there is still another for loop due to economy of scale approach\\r\\n                IERC1155(poolData.tokens[0]).safeTransferFrom(\\r\\n                    user,\\r\\n                    poolData.poolLPToken,\\r\\n                    vars.currentShare.tokenId,\\r\\n                    vars.currentShare.amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        require(vars.stableOut >= minStable, Errors.SHARES_VALUE_BELOW_TARGET);\\r\\n        if (vars.stableOut > 0) {\\r\\n            //Add to the balances of the protocol wallet and royalties address\\r\\n            poolData.fee.protocolBalance += vars.fees.protocolFee;\\r\\n            poolData.fee.royaltiesBalance += vars.fees.royalties;\\r\\n            //Transfer the total stable to the user\\r\\n            ILPToken(poolData.poolLPToken).setApproval20(poolData.stable, vars.stableOut);\\r\\n            IERC20(poolData.stable).transferFrom(poolData.poolLPToken, user, vars.stableOut);\\r\\n        }\\r\\n        emit SwappedShares(vars.stableOut, vars.fees, user, vars.subPoolGroups);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/MathHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title library for the math helper functions\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the math helper functions common throughout the protocol\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\nlibrary MathHelpers {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function convertToWad(uint256 x) internal pure returns (uint256 z) {\\r\\n        z = x.mul(10 ** 18);\\r\\n    }\\r\\n\\r\\n    function convertFromWad(uint256 x) internal pure returns (uint256 z) {\\r\\n        z = x.div(10 ** 18);\\r\\n    }\\r\\n\\r\\n    function convertFromWadSqrd(uint256 x) internal pure returns (uint256 z) {\\r\\n        z = x.div(10 ** 36);\\r\\n    }\\r\\n\\r\\n    function convertToWadPercentage(uint256 x) internal pure returns (uint256 z) {\\r\\n        z = x.mul(10 ** 20);\\r\\n    }\\r\\n\\r\\n    function convertFromWadPercentage(uint256 x) internal pure returns (uint256 z) {\\r\\n        z = x.div(10 ** 20);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Pool1155Logic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\r\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport {Errors} from \\\"../libraries/Errors.sol\\\";\\r\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\r\\nimport {LPToken} from \\\"../amm/LPToken.sol\\\";\\r\\nimport {MathHelpers} from \\\"../libraries/MathHelpers.sol\\\";\\r\\nimport {IPoolFactory1155} from \\\"../interfaces/IPoolFactory1155.sol\\\";\\r\\nimport {IAccessManager} from \\\"../interfaces/IAccessManager.sol\\\";\\r\\nimport {IAddressesRegistry} from \\\"../interfaces/IAddressesRegistry.sol\\\";\\r\\nimport {IAccessNFT} from \\\"../interfaces/IAccessNFT.sol\\\";\\r\\nimport {IStablecoinYieldConnector} from \\\"../interfaces/IStablecoinYieldConnector.sol\\\";\\r\\nimport {IConnectorRouter} from \\\"../interfaces/IConnectorRouter.sol\\\";\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title library for pool logic functions for the 1155 Pools with single collection\\r\\n * @author Souq.Finance\\r\\n * @notice Defines the pure functions used by the 1155 contracts of the Souq protocol\\r\\n * @notice License: https://souq-nft-amm-v1.s3.amazonaws.com/LICENSE.md\\r\\n */\\r\\n\\r\\nlibrary Pool1155Logic {\\r\\n    using Math for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when stablecoins in the pool are deposited to a yield generating protocol\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param amount The amount of stablecoins\\r\\n     * @param yieldGeneratorAddress The address of the yield generating protocol\\r\\n     */\\r\\n    event YieldDeposited(address admin, uint256 amount, address yieldGeneratorAddress);\\r\\n    /**\\r\\n     * @dev Emitted when stablecoins in the pool are deposited to a yield generating protocol. The AToken is 1:1 the stable amount\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param amount The amount of stablecoins\\r\\n     * @param yieldGeneratorAddress The address of the yield generating protocol\\r\\n     */\\r\\n    event YieldWithdrawn(address admin, uint256 amount, address yieldGeneratorAddress);\\r\\n    /**\\r\\n     * @dev Emitted when tokens different than the tokens used by the pool are rescued for receivers by the admin\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param token The address of the token contract\\r\\n     * @param amount The amount of tokens\\r\\n     * @param receiver The address of the receiver\\r\\n     */\\r\\n    event Rescued(address admin, address token, uint256 amount, address receiver);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a new LP Token is deployed\\r\\n     * @param LPAdress The address of the LP Token\\r\\n     * @param poolAddress The address of the liquidity pool that deployed it\\r\\n     * @param tokens the addresses of the ERC1155 tokens that the liquidity pool utilizes\\r\\n     * @param symbol the symbol of the LP Token\\r\\n     * @param name the name of the LP Token\\r\\n     * @param decimals the decimals of the LP Token\\r\\n     */\\r\\n    event LPTokenDeployed(address LPAdress, address poolAddress, address[] tokens, string symbol, string name, uint8 decimals);\\r\\n    /**\\r\\n     * @dev Emitted when a new sub pool is added by the admin\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param f the initial F of the new pool\\r\\n     * @param v the initial V of the new pool\\r\\n     * @param id the id of the new sub pool\\r\\n     */\\r\\n    event AddedSubPool(address admin, uint256 v, uint256 f, uint256 id);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the V is updated for several subPools\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param poolIds the indecies of the subPools\\r\\n     * @param vArray the array of the new v's for the subPools\\r\\n     */\\r\\n    event UpdatedV(address admin, uint256[] poolIds, uint256[] vArray);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when shares of a token id range in a subpool are moved to a new sub pool\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param startId the start index of the token ids of the shares\\r\\n     * @param endId the end index of the token ids of the shares\\r\\n     * @param newSubPoolId the index of the new sub pool to move the shares to\\r\\n     */\\r\\n    event MovedShares(address admin, uint256 startId, uint256 endId, uint256 newSubPoolId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when shares of a token id array are moved to a new sub pool\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param newSubPoolId the index of the new sub pool to move the shares to\\r\\n     * @param ids the array of token ids\\r\\n     */\\r\\n    event MovedSharesList(address admin, uint256 newSubPoolId, uint256[] ids);\\r\\n\\r\\n    /**\\r\\n     * @dev Emmitted when the status of specific subpools is modified\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param subPoolIds The sub pool ids array\\r\\n     * @param newStatus The new status, enabled=true or disabled=false\\r\\n     */\\r\\n    event ChangedSubpoolStatus(address admin, uint256[] subPoolIds, bool newStatus);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when reserve is moved between subpools\\r\\n     * @param admin The admin that executed the function\\r\\n     * @param moverId the id of the subpool to move funds from\\r\\n     * @param movedId the id of the subpool to move funds to\\r\\n     * @param amount the amount of funds to move\\r\\n     */\\r\\n    event MovedReserve(address admin, uint256 moverId, uint256 movedId, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the accumulated fee balances are withdrawn by the royalties and protocol wallet addresses\\r\\n     * @param user The sender of the transaction\\r\\n     * @param to the address to send the funds to\\r\\n     * @param amount the amount being withdrawn\\r\\n     * @param feeType: string - the type of fee being withdrawan (royalties/protocol)\\r\\n     */\\r\\n    event WithdrawnFees(address user, address to, uint256 amount, string feeType);\\r\\n\\r\\n    /**\\r\\n     * @dev Function to calculate the total value of a sub pool\\r\\n     * @param subPools The sub pools array\\r\\n     * @param subPoolId the sub pool id\\r\\n     * @return uint256 The total value of a subpool\\r\\n     */\\r\\n    function calculateTotal(DataTypes.AMMSubPool1155[] storage subPools, uint256 subPoolId) public view returns (uint256) {\\r\\n        return\\r\\n            subPools[subPoolId].reserve +\\r\\n            MathHelpers.convertFromWad(subPools[subPoolId].totalShares * subPools[subPoolId].V * subPools[subPoolId].F);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the total TVL of the liquidity pool from its subpools\\r\\n     * @param subPools The subpools array\\r\\n     * @return total The TVL\\r\\n     */\\r\\n    function getTVL(DataTypes.AMMSubPool1155[] storage subPools) public view returns (uint256 total) {\\r\\n        for (uint256 i = 0; i < subPools.length; i++) {\\r\\n            total += calculateTotal(subPools, i);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the LP Token price by dividing the TVL over the total minted tokens\\r\\n     * @param subPools The subpools array\\r\\n     * @param poolLPToken The address of the LP Token\\r\\n     * @return uint256 The LP Price\\r\\n     */\\r\\n    function getLPPrice(DataTypes.AMMSubPool1155[] storage subPools, address poolLPToken) external view returns (uint256) {\\r\\n        uint256 total = ILPToken(poolLPToken).getTotal();\\r\\n        uint256 tvl = getTVL(subPools);\\r\\n        if (total == 0 || tvl == 0) {\\r\\n            return MathHelpers.convertToWad(1);\\r\\n        }\\r\\n        return MathHelpers.convertToWad(tvl) / total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the TVL and LP Token price together which saves gas if we need both variables\\r\\n     * @param subPools The subpools array\\r\\n     * @param poolLPToken The address of the LP Token\\r\\n     * @return (uint256,uint256) The TVL and LP Price\\r\\n     */\\r\\n    function getTVLAndLPPrice(DataTypes.AMMSubPool1155[] storage subPools, address poolLPToken) external view returns (uint256, uint256) {\\r\\n        uint256 total = ILPToken(poolLPToken).getTotal();\\r\\n        uint256 tvl = getTVL(subPools);\\r\\n        if (total == 0 || tvl == 0) {\\r\\n            return (tvl, MathHelpers.convertToWad(1));\\r\\n        }\\r\\n        return (tvl, (MathHelpers.convertToWad(tvl) / total));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the actual fee value structure depending on swap direction\\r\\n     * @param operation The direction of the swap\\r\\n     * @param value value of the amount to compute the fees for\\r\\n     * @param fee The fee configuration of the liquidity pool\\r\\n     * @return feeReturn The return fee structure that has the ratios\\r\\n     */\\r\\n    function calculateFees(\\r\\n        DataTypes.OperationType operation,\\r\\n        uint256 value,\\r\\n        DataTypes.PoolFee storage fee\\r\\n    ) public view returns (DataTypes.FeeReturn memory feeReturn) {\\r\\n        uint256 actualValue;\\r\\n        if (operation == DataTypes.OperationType.buyShares) {\\r\\n            actualValue = MathHelpers.convertFromWadPercentage(value * (MathHelpers.convertToWadPercentage(1) - fee.lpBuyFee));\\r\\n            feeReturn.royalties = MathHelpers.convertFromWadPercentage(fee.royaltiesBuyFee * actualValue);\\r\\n            feeReturn.lpFee = MathHelpers.convertFromWadPercentage(fee.lpBuyFee * value);\\r\\n            feeReturn.protocolFee = MathHelpers.convertFromWadPercentage(fee.protocolBuyRatio * actualValue);\\r\\n        } else if (operation == DataTypes.OperationType.sellShares) {\\r\\n            actualValue = MathHelpers.convertToWadPercentage(value) / (MathHelpers.convertToWadPercentage(1) - fee.lpSellFee);\\r\\n            feeReturn.royalties = MathHelpers.convertFromWadPercentage(fee.royaltiesSellFee * actualValue);\\r\\n            feeReturn.lpFee = MathHelpers.convertFromWadPercentage(fee.lpSellFee * value);\\r\\n            feeReturn.protocolFee = MathHelpers.convertFromWadPercentage(fee.protocolSellRatio * actualValue);\\r\\n        }\\r\\n        feeReturn.swapFee = feeReturn.lpFee + feeReturn.protocolFee;\\r\\n        feeReturn.totalFee = feeReturn.royalties + feeReturn.swapFee;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add two feeReturn structures and output 1\\r\\n     * @param x the first feeReturn struct\\r\\n     * @param y the second feeReturn struct\\r\\n     * @return z The return data structure\\r\\n     */\\r\\n    function addFees(DataTypes.FeeReturn memory x, DataTypes.FeeReturn memory y) external pure returns (DataTypes.FeeReturn memory z) {\\r\\n        //Add all the fees together\\r\\n        z.totalFee = x.totalFee + y.totalFee;\\r\\n        z.royalties = x.royalties + y.royalties;\\r\\n        z.protocolFee = x.protocolFee + y.protocolFee;\\r\\n        z.lpFee = x.lpFee + y.lpFee;\\r\\n        z.swapFee = x.swapFee + y.swapFee;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to multiply a fee structure by a number and divide by a den\\r\\n     * @param fee the original feeReturn struct\\r\\n     * @param num the numerator\\r\\n     * @param den The denominator\\r\\n     * @return feeReturn The new fee structure\\r\\n     */\\r\\n    function multiplyFees(\\r\\n        DataTypes.FeeReturn memory fee,\\r\\n        uint256 num,\\r\\n        uint256 den\\r\\n    ) external pure returns (DataTypes.FeeReturn memory feeReturn) {\\r\\n        feeReturn.totalFee = (fee.totalFee * num) / den;\\r\\n        feeReturn.royalties = (fee.royalties * num) / den;\\r\\n        feeReturn.protocolFee = (fee.protocolFee * num) / den;\\r\\n        feeReturn.lpFee = (fee.lpFee * num) / den;\\r\\n        feeReturn.swapFee = (fee.swapFee * num) / den;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to calculate the price of a share in a sub pool\\\\\\r\\n     * @param operation the operation direction\\r\\n     * @param subPools The sub pools array\\r\\n     * @param subPoolId the sub pool id\\r\\n     * @param poolData the pool data\\r\\n     * @return sharesReturn The return data structure\\r\\n     */\\r\\n    function CalculateShares(\\r\\n        DataTypes.OperationType operation,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        uint256 subPoolId,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        uint256 shares,\\r\\n        bool useFee\\r\\n    ) external view returns (DataTypes.SharesCalculationReturn memory sharesReturn) {\\r\\n        require(\\r\\n            subPools[subPoolId].totalShares >= shares || operation != DataTypes.OperationType.buyShares,\\r\\n            Errors.NOT_ENOUGH_SUBPOOL_SHARES\\r\\n        );\\r\\n        //Iterative approach\\r\\n        DataTypes.SharesCalculationVars memory vars;\\r\\n        //Initial values\\r\\n        vars.V = subPools[subPoolId].V;\\r\\n        vars.PV_0 = MathHelpers.convertFromWad(vars.V * subPools[subPoolId].F);\\r\\n        sharesReturn.PV = vars.PV_0;\\r\\n        //Calculate steps\\r\\n        vars.steps = shares / poolData.iterativeLimit.maxBulkStepSize;\\r\\n        //At first the stable = reserve\\r\\n        vars.stable = subPools[subPoolId].reserve;\\r\\n        vars.shares = subPools[subPoolId].totalShares;\\r\\n        //Iterating step sizes for enhanced results. If amount = 50, and stepsize is 15, then we iterate 4 times 15,15,15,5\\r\\n        for (vars.stepIndex = 0; vars.stepIndex < vars.steps + 1; vars.stepIndex++) {\\r\\n            vars.stepAmount = vars.stepIndex == vars.steps\\r\\n                ? (shares - ((vars.stepIndex) * poolData.iterativeLimit.maxBulkStepSize))\\r\\n                : poolData.iterativeLimit.maxBulkStepSize;\\r\\n            if (vars.stepAmount == 0) break;\\r\\n            //The value of the shares are priced first at last PV\\r\\n            vars.value = vars.stepAmount * vars.PV_0;\\r\\n            if (useFee) vars.fees = calculateFees(operation, vars.value, poolData.fee);\\r\\n            //Iterate the calculations while keeping PV_0 and stable the same and using the new PV to calculate the average and reiterate\\r\\n            for (vars.i = 0; vars.i < poolData.iterativeLimit.iterations; vars.i++) {\\r\\n                if (operation == DataTypes.OperationType.buyShares) {\\r\\n                    //if buying shares, the pool receives stable plus the swap fee and gives out shares\\r\\n                    vars.newCash = vars.stable + vars.value + (useFee ? vars.fees.lpFee : 0);\\r\\n                    vars.den =\\r\\n                        vars.newCash +\\r\\n                        ((poolData.coefficientB * (vars.shares - vars.stepAmount) * sharesReturn.PV) / poolData.coefficientC);\\r\\n                } else if (operation == DataTypes.OperationType.sellShares) {\\r\\n                    require(vars.stable >= vars.value, Errors.NOT_ENOUGH_SUBPOOL_RESERVE);\\r\\n                    //if selling shares, the pool receives shares and gives out stable - total fees from the reserve\\r\\n                    vars.newCash = vars.stable - vars.value + (useFee ? vars.fees.lpFee : 0);\\r\\n                    vars.den =\\r\\n                        vars.newCash +\\r\\n                        ((poolData.coefficientB * (vars.shares + vars.stepAmount) * sharesReturn.PV) / poolData.coefficientC);\\r\\n                }\\r\\n                //Calculate new PV and F\\r\\n                sharesReturn.F = vars.den == 0 ? 0 : (poolData.coefficientA * vars.newCash) / vars.den;\\r\\n                sharesReturn.PV = MathHelpers.convertFromWad(vars.V * sharesReturn.F);\\r\\n                //Swap PV is the price used for the swapping in the newCash\\r\\n                vars.swapPV = vars.stepAmount > 1 ? ((sharesReturn.PV + vars.PV_0) / 2) : vars.PV_0;\\r\\n                vars.value = vars.stepAmount * vars.swapPV;\\r\\n                if (useFee) vars.fees = calculateFees(operation, vars.value, poolData.fee);\\r\\n            }\\r\\n            //We add/subtract the shares to be used in the next stepsize iteration\\r\\n            vars.shares = operation == DataTypes.OperationType.buyShares ? vars.shares - vars.stepAmount : vars.shares + vars.stepAmount;\\r\\n            //At the end of iterations, the stable is now the last cash value\\r\\n            vars.stable = vars.newCash;\\r\\n            //The starting PV is now the last PV value\\r\\n            vars.PV_0 = sharesReturn.PV;\\r\\n            //Add the amounts to the return\\r\\n            sharesReturn.amount += vars.stepAmount;\\r\\n        }\\r\\n        //Calculate the actual value to return\\r\\n        sharesReturn.value = operation == DataTypes.OperationType.buyShares\\r\\n            ? vars.stable - subPools[subPoolId].reserve\\r\\n            : subPools[subPoolId].reserve - vars.stable;\\r\\n        //Calculate the final fees\\r\\n        if (useFee) sharesReturn.fees = calculateFees(operation, sharesReturn.value, poolData.fee);\\r\\n        //Average the swap PV in the return\\r\\n        sharesReturn.swapPV = sharesReturn.value / sharesReturn.amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to update the price iteratively in a subpool\\r\\n     * @param subPools The sub pools array\\r\\n     * @param poolData The pool data struct\\r\\n     * @param subPoolId the sub pool id\\r\\n     */\\r\\n    function updatePriceIterative(\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        uint256 subPoolId\\r\\n    ) public {\\r\\n        //coef is converted to wad and we also need F to be converted to wad\\r\\n        uint256 num = ((poolData.coefficientA * subPools[subPoolId].reserve));\\r\\n        uint256 temp = poolData.coefficientB * subPools[subPoolId].totalShares * subPools[subPoolId].V;\\r\\n        uint256 den = (subPools[subPoolId].reserve + (MathHelpers.convertFromWad(temp * subPools[subPoolId].F) / poolData.coefficientC));\\r\\n        subPools[subPoolId].F = den == 0 ? 0 : num / den;\\r\\n        //Iteration 0 is done, iterate through the rest\\r\\n        if (poolData.iterativeLimit.iterations > 1) {\\r\\n            for (uint256 i = 0; i < poolData.iterativeLimit.iterations - 1; i++) {\\r\\n                den = (subPools[subPoolId].reserve + (MathHelpers.convertFromWad(subPools[subPoolId].F * temp) / poolData.coefficientC));\\r\\n                subPools[subPoolId].F = den == 0 ? 0 : num / den;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to update the price in a subpool\\r\\n     * @param subPools The sub pools array\\r\\n     * @param coefficientA the coefficient A of the equation\\r\\n     * @param coefficientB the coefficient B of the equation\\r\\n     * @param coefficientC the coefficient C of the equation\\r\\n     * @param subPoolId the sub pool id\\r\\n     */\\r\\n    function updatePrice(\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        uint256 coefficientA,\\r\\n        uint256 coefficientB,\\r\\n        uint256 coefficientC,\\r\\n        uint256 subPoolId\\r\\n    ) external {\\r\\n        //coef is converted to wad and we also need F to be converted to wad\\r\\n        uint256 num = ((coefficientA * subPools[subPoolId].reserve));\\r\\n        uint256 den = (subPools[subPoolId].reserve +\\r\\n            (MathHelpers.convertFromWad(coefficientB * subPools[subPoolId].totalShares * subPools[subPoolId].F * subPools[subPoolId].V) /\\r\\n                coefficientC));\\r\\n        subPools[subPoolId].F = den == 0 ? 0 : num / den;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add a new sub pool\\r\\n     * @param v The initial V value of the sub pool\\r\\n     * @param f The initial F value of the sub pool\\r\\n     * @param subPools The subpools array\\r\\n     */\\r\\n    function addSubPool(uint256 v, uint256 f, DataTypes.AMMSubPool1155[] storage subPools) external {\\r\\n        DataTypes.AMMSubPool1155 storage newPool = subPools.push();\\r\\n        newPool.reserve = 0;\\r\\n        newPool.totalShares = 0;\\r\\n        newPool.V = v;\\r\\n        newPool.F = f;\\r\\n        newPool.status = true;\\r\\n        emit AddedSubPool(msg.sender, v, f, subPools.length - 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Function to update the V of the subpools\\r\\n     *@param subPoolIds the array of subpool ids to update\\r\\n     *@param vArray The array of V to update\\r\\n     *@param subPools The subpools array\\r\\n     */\\r\\n    function updatePoolV(\\r\\n        uint256[] calldata subPoolIds,\\r\\n        uint256[] calldata vArray,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.PoolData storage poolData\\r\\n    ) external {\\r\\n        require(subPoolIds.length == vArray.length, Errors.ARRAY_NOT_SAME_LENGTH);\\r\\n        for (uint256 i = 0; i < subPoolIds.length; i++) {\\r\\n            subPools[subPoolIds[i]].V = vArray[i];\\r\\n            updatePriceIterative(subPools, poolData, subPoolIds[i]);\\r\\n        }\\r\\n        emit UpdatedV(msg.sender, subPoolIds, vArray);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Function to move shares between sub pools\\r\\n     *@param startId The starting token id inside the subpool\\r\\n     *@param endId The ending token id inside the subpool\\r\\n     *@param newSubPoolId The id of the new subpool\\r\\n     *@param subPools The subpools array\\r\\n     *@param tokenDistribution The token distribution mapping of the liquidity pool\\r\\n     */\\r\\n    function moveShares(\\r\\n        uint256 startId,\\r\\n        uint256 endId,\\r\\n        uint256 newSubPoolId,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external {\\r\\n        DataTypes.MoveSharesVars memory vars;\\r\\n        for (vars.i = startId; vars.i < endId + 1; vars.i++) {\\r\\n            vars.poolId = tokenDistribution[vars.i];\\r\\n            if (subPools[newSubPoolId].shares[vars.i] > 0) {\\r\\n                subPools[newSubPoolId].shares[vars.i] = subPools[vars.poolId].shares[vars.i];\\r\\n                subPools[vars.poolId].shares[vars.i] = 0;\\r\\n                updatePriceIterative(subPools, poolData, vars.poolId);\\r\\n            }\\r\\n            tokenDistribution[vars.i] = newSubPoolId;\\r\\n        }\\r\\n        emit MovedShares(msg.sender, startId, endId, newSubPoolId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *@dev Function to move shares between sub pools\\r\\n     *@param newSubPoolId The id of the new subpool\\r\\n     *@param ids The token ids array to move\\r\\n     *@param subPools The subpools array\\r\\n     *@param tokenDistribution The token distribution mapping of the liquidity pool\\r\\n     */\\r\\n    function moveSharesList(\\r\\n        uint256 newSubPoolId,\\r\\n        uint256[] calldata ids,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.PoolData storage poolData,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external {\\r\\n        DataTypes.MoveSharesVars memory vars;\\r\\n        for (vars.i = 0; vars.i < ids.length; vars.i += 1) {\\r\\n            vars.poolId = tokenDistribution[ids[vars.i]];\\r\\n            if (subPools[newSubPoolId].shares[ids[vars.i]] > 0) {\\r\\n                subPools[newSubPoolId].shares[ids[vars.i]] = subPools[vars.poolId].shares[ids[vars.i]];\\r\\n                subPools[vars.poolId].shares[ids[vars.i]] = 0;\\r\\n                updatePriceIterative(subPools, poolData, vars.poolId);\\r\\n            }\\r\\n            tokenDistribution[ids[vars.i]] = newSubPoolId;\\r\\n        }\\r\\n        emit MovedSharesList(msg.sender, newSubPoolId, ids);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move enable or disable subpools by ids\\r\\n     * @param subPoolIds The sub pool ids array\\r\\n     * @param newStatus The new status, enabled=true or disabled=false\\r\\n     * @param subPools The subpools array\\r\\n     */\\r\\n    function changeSubPoolStatus(uint256[] memory subPoolIds, bool newStatus, DataTypes.AMMSubPool1155[] storage subPools) external {\\r\\n        for (uint256 i = 0; i < subPoolIds.length; i++) {\\r\\n            subPools[subPoolIds[i]].status = newStatus;\\r\\n        }\\r\\n        emit ChangedSubpoolStatus(msg.sender, subPoolIds, newStatus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to move reserves between subpools\\r\\n     * @param moverId The sub pool that will move the funds from\\r\\n     * @param movedId The id of the sub pool that will move the funds to\\r\\n     * @param amount The amount to move\\r\\n     * @param subPools The subpools array\\r\\n     */\\r\\n    function moveReserve(\\r\\n        uint256 moverId,\\r\\n        uint256 movedId,\\r\\n        uint256 amount,\\r\\n        DataTypes.AMMSubPool1155[] storage subPools,\\r\\n        DataTypes.PoolData storage poolData\\r\\n    ) external {\\r\\n        require(subPools[moverId].reserve >= amount, Errors.NOT_ENOUGH_SUBPOOL_RESERVE);\\r\\n        require(subPools.length > moverId && subPools.length > movedId, Errors.INVALID_SUBPOOL_ID);\\r\\n        subPools[moverId].reserve -= amount;\\r\\n        updatePriceIterative(subPools, poolData, moverId);\\r\\n        subPools[movedId].reserve += amount;\\r\\n        updatePriceIterative(subPools, poolData, movedId);\\r\\n        emit MovedReserve(msg.sender, moverId, movedId, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that returns the subpool ids of the given token ids\\r\\n     * @param tokenIds The address of the pool\\r\\n     * @param tokenDistribution The registry address\\r\\n     * @return subPools array of the subpool ids\\r\\n     */\\r\\n    function getSubPools(\\r\\n        uint256[] memory tokenIds,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external view returns (uint256[] memory subPools) {\\r\\n        subPools = new uint256[](tokenIds.length);\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            subPools[i] = tokenDistribution[tokenIds[i]];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that returns the subpool ids of the given sequencial token ids\\r\\n     * @param startTokenId The start id of the token ids\\r\\n     * @param endTokenId The end id of the token ids\\r\\n     * @param tokenDistribution The registry address\\r\\n     * @return subPools The array of the subpool ids\\r\\n     */\\r\\n    function getSubPoolsSeq(\\r\\n        uint256 startTokenId,\\r\\n        uint256 endTokenId,\\r\\n        mapping(uint256 => uint256) storage tokenDistribution\\r\\n    ) external view returns (uint256[] memory subPools) {\\r\\n        require(startTokenId <= endTokenId, \\\"END_ID_LESS_THAN_START\\\");\\r\\n        subPools = new uint256[](endTokenId - startTokenId + 1);\\r\\n        for (uint256 i = startTokenId; i < endTokenId + 1; i++) {\\r\\n            subPools[i] = tokenDistribution[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that deploys the LP Token of the pool\\r\\n     * @param poolAddress The address of the pool\\r\\n     * @param registry The registry address\\r\\n     * @param tokens The collection tokens to be used by the pool\\r\\n     * @param symbol The symbol of the LP Token\\r\\n     * @param name The name of the LP Token\\r\\n     * @param decimals The decimals of the LP Token\\r\\n     * @return address of the LP Token\\r\\n     */\\r\\n    function deployLPToken(\\r\\n        address poolAddress,\\r\\n        address registry,\\r\\n        address[] memory tokens,\\r\\n        string memory symbol,\\r\\n        string memory name,\\r\\n        uint8 decimals\\r\\n    ) external returns (address) {\\r\\n        ILPToken poolLPToken = new LPToken(poolAddress, registry, tokens, symbol, name, decimals);\\r\\n        emit LPTokenDeployed(address(poolLPToken), poolAddress, tokens, symbol, name, decimals);\\r\\n        return address(poolLPToken);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to rescue and send ERC20 tokens (different than the tokens used by the pool) to a receiver called by the admin\\r\\n     * @param token The address of the token contract\\r\\n     * @param amount The amount of tokens\\r\\n     * @param receiver The address of the receiver\\r\\n     * @param stableToken The address of the stablecoin to rescue\\r\\n     * @param poolLPToken The address of the pool LP Token\\r\\n     */\\r\\n    function RescueTokens(address token, uint256 amount, address receiver, address stableToken, address poolLPToken) external {\\r\\n        require(token != stableToken, Errors.CANNOT_RESCUE_POOL_TOKEN);\\r\\n        ILPToken(poolLPToken).RescueTokens(token, amount, receiver);\\r\\n        emit Rescued(msg.sender, token, amount, receiver);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to deposit stablecoins from the pool to a yield generating protocol and getting synthetic tokens\\r\\n     * @param amount The amount of stablecoins\\r\\n     * @param addressesRegistry The addresses Registry contract address\\r\\n     * @param stableYieldAddress The stable yield contract address\\r\\n     * @param yieldReserve The old yield reserve\\r\\n     */\\r\\n    function depositIntoStableYield(\\r\\n        uint256 amount,\\r\\n        address addressesRegistry,\\r\\n        address stableYieldAddress,\\r\\n        uint256 yieldReserve\\r\\n    ) external returns (uint256) {\\r\\n        IStablecoinYieldConnector(\\r\\n            IConnectorRouter(IAddressesRegistry(addressesRegistry).getConnectorsRouter()).getStablecoinYieldConnectorContract(\\r\\n                stableYieldAddress\\r\\n            )\\r\\n        ).depositUSDC(amount);\\r\\n\\r\\n        emit YieldDeposited(msg.sender, amount, stableYieldAddress);\\r\\n        // Return the updated yield reserve value\\r\\n        return yieldReserve + amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to withdraw stablecoins from the yield generating protocol to the liquidity pool\\r\\n     * @param amount The amount of stablecoins\\r\\n     * @param addressesRegistry The addresses Registry contract address\\r\\n     * @param stableYieldAddress The stable yield contract address\\r\\n     * @param yieldReserve The old yield reserve\\r\\n     */\\r\\n    function withdrawFromStableYield(\\r\\n        uint256 amount,\\r\\n        address addressesRegistry,\\r\\n        address stableYieldAddress,\\r\\n        uint256 yieldReserve\\r\\n    ) external returns (uint256) {\\r\\n        require(msg.sender != address(0), Errors.ADDRESS_IS_ZERO);\\r\\n        IStablecoinYieldConnector stableConnector = IStablecoinYieldConnector(\\r\\n            IConnectorRouter(IAddressesRegistry(addressesRegistry).getConnectorsRouter()).getStablecoinYieldConnectorContract(\\r\\n                stableYieldAddress\\r\\n            )\\r\\n        );\\r\\n        address aTokenAddress = stableConnector.getATokenAddress();\\r\\n        require(IERC20(aTokenAddress).balanceOf(address(this)) >= amount, Errors.INVALID_AMOUNT);\\r\\n        IERC20(aTokenAddress).approve(address(stableConnector), amount);\\r\\n        stableConnector.withdrawUSDC(amount, amount);\\r\\n        emit YieldWithdrawn(msg.sender, amount, stableYieldAddress);\\r\\n        // Return the updated yield reserve value\\r\\n        return yieldReserve - amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to withdraw fees by a caller that is either the royalties or protocol address\\r\\n     * @param user The caller\\r\\n     * @param to The address to send the funds to\\r\\n     * @param amount The amount to withdraw\\r\\n     * @param feeType The type of the fees to withdraw\\r\\n     * @param poolData The pool data\\r\\n     */\\r\\n    function withdrawFees(\\r\\n        address user,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        DataTypes.FeeType feeType,\\r\\n        DataTypes.PoolData storage poolData\\r\\n    ) external {\\r\\n        //If withdrawing royalties and the msg.sender matches the royalties address\\r\\n        if (feeType == DataTypes.FeeType.royalties && user == poolData.fee.royaltiesAddress && amount <= poolData.fee.royaltiesBalance) {\\r\\n            poolData.fee.royaltiesBalance -= amount;\\r\\n            ILPToken(poolData.poolLPToken).setApproval20(poolData.stable, amount);\\r\\n            IERC20(poolData.stable).transferFrom(poolData.poolLPToken, to, amount);\\r\\n            emit WithdrawnFees(user, to, amount, \\\"royalties\\\");\\r\\n        }\\r\\n        //If withdrawing protocol fees and the msg.sender matches the protocol address\\r\\n        if (feeType == DataTypes.FeeType.protocol && user == poolData.fee.protocolFeeAddress && amount <= poolData.fee.protocolBalance) {\\r\\n            poolData.fee.protocolBalance -= amount;\\r\\n            ILPToken(poolData.poolLPToken).setApproval20(poolData.stable, amount);\\r\\n            IERC20(poolData.stable).transferFrom(poolData.poolLPToken, to, amount);\\r\\n            emit WithdrawnFees(user, to, amount, \\\"protocol\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/Liquidity1155Logic.sol\": {\r\n        \"Liquidity1155Logic\": \"0xbd05b985cf7344f58fa3f3fa6fa004c5702198c5\"\r\n      },\r\n      \"contracts/libraries/Pool1155Logic.sol\": {\r\n        \"Pool1155Logic\": \"0x6b7f26770fd688f07b6f5a3170170511e53a5e87\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"_newFee\",\"type\":\"tuple\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"useAccessToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"accessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolLPToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"stableYieldAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coefficientA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientC\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"liquidityLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"iterativeLimit\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct DataTypes.PoolData\",\"name\":\"_data\",\"type\":\"tuple\"}],\"name\":\"PoolDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"_limits\",\"type\":\"tuple\"}],\"name\":\"PoolIterativeLimitsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"_limits\",\"type\":\"tuple\"}],\"name\":\"PoolLiquidityLimitsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"PoolPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"PoolUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"RescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum DataTypes.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"}],\"name\":\"WithdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"targetLP\",\"type\":\"uint256\"}],\"name\":\"addLiquidityShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStable\",\"type\":\"uint256\"}],\"name\":\"addLiquidityStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"f\",\"type\":\"uint256\"}],\"name\":\"addSubPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"subPoolIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"changeSubPoolStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"stableIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subPoolId\",\"type\":\"uint256\"}],\"name\":\"depositInitial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositIntoStableYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subPoolId\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"V\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"F\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.AMMSubPool1155Details\",\"name\":\"subpool\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useFee\",\"type\":\"bool\"}],\"name\":\"getQuote\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalties\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.FeeReturn\",\"name\":\"fees\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalties\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.FeeReturn\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.SharePrice[]\",\"name\":\"shares\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.Quotation\",\"name\":\"quotation\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getSubPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"}],\"name\":\"getSubPoolsSeq\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTVL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenIdAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"useAccessToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"accessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolLPToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"stableYieldAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coefficientA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientC\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"liquidityLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"iterativeLimit\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PoolData\",\"name\":\"_poolData\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moverId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"moveReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSubPoolId\",\"type\":\"uint256\"}],\"name\":\"moveShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSubPoolIds\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"moveSharesList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"useAccessToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"accessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolLPToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableYieldAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coefficientA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientC\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"liquidityLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"iterativeLimit\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"processWithdrawals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queuedWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"headId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"removeLiquidityShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetLP\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"newFee\",\"type\":\"tuple\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"useAccessToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"accessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolLPToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"stableYieldAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coefficientA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficientC\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBuyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSellRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.PoolFee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"liquidityLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"iterativeLimit\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PoolData\",\"name\":\"newPoolData\",\"type\":\"tuple\"}],\"name\":\"setPoolData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumF\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxBulkStepSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"iterations\",\"type\":\"uint16\"}],\"internalType\":\"struct DataTypes.IterativeLimit\",\"name\":\"newLimits\",\"type\":\"tuple\"}],\"name\":\"setPoolIterativeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolTvlLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"addLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"removeLiqMode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyAdminProvisioning\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.LiquidityLimit\",\"name\":\"newLimits\",\"type\":\"tuple\"}],\"name\":\"setPoolLiquidityLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"V\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"F\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minStable\",\"type\":\"uint256\"}],\"name\":\"swapShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requiredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxStable\",\"type\":\"uint256\"}],\"name\":\"swapStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"subPoolIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"vArray\",\"type\":\"uint256[]\"}],\"name\":\"updatePoolV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStableYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MME1155", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000005c73584fff6c172c8607225cee1b0edef5ceca800000000000000000000000032100a941722b2bf3bd7a3162fac18984809d67b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}