{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/L1/L1CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\n\\nimport { OptimismPortal } from \\\"./OptimismPortal.sol\\\";\\nimport { CrossDomainMessenger } from \\\"../universal/CrossDomainMessenger.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"../libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { L2CrossDomainMessenger } from \\\"../L2/L2CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @title L1CrossDomainMessenger\\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\\n *         interface instead of interacting with lower-level contracts directly.\\n */\\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\\n    using SafeERC20 for IERC20;\\n    /**\\n     * @notice Address of the OptimismPortal.\\n     */\\n    OptimismPortal public immutable PORTAL;\\n\\n    /**\\n     * @notice Address of the Mantle Token on L1.\\n     */\\n    address public immutable L1_MNT_ADDRESS;\\n    /**\\n     * @custom:semver 1.5.0\\n     *\\n     * @param _portal Address of the OptimismPortal contract on this network.\\n     */\\n    constructor(OptimismPortal _portal, address l1mnt)\\n        Semver(1, 5, 0)\\n        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)\\n    {\\n        PORTAL = _portal;\\n        L1_MNT_ADDRESS = l1mnt;\\n        initialize();\\n    }\\n\\n    /**\\n     * @notice Initializer.\\n     */\\n    function initialize() public initializer {\\n        __CrossDomainMessenger_init();\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _sendMessage(\\n        uint256 _mntAmount,\\n        address _to,\\n        uint64 _gasLimit,\\n        bytes memory _data\\n    ) internal override {\\n        PORTAL.depositTransaction{value: msg.value}(msg.value, _mntAmount, _to, _mntAmount, _gasLimit, false, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function sendMessage(\\n        uint256 _mntAmount,\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable override {\\n        require(_target!=tx.origin || msg.value==0, \\\"once target is an EOA, msg.value must be zero\\\");\\n        require(_target != Predeploys.BVM_ETH, \\\"target must not be BVM_ETH on L2\\\");\\n\\n        if (_mntAmount!=0){\\n            IERC20(L1_MNT_ADDRESS).safeTransferFrom(msg.sender, address(this), _mntAmount);\\n            bool success = IERC20(L1_MNT_ADDRESS).approve(address(PORTAL), _mntAmount);\\n            require(success,\\\"the approve for L1 mnt to OptimismPortal failed\\\");\\n        }\\n\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            _mntAmount,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                L2CrossDomainMessenger.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                _mntAmount,\\n                msg.value,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, _mntAmount, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable override {\\n        require(_target!=tx.origin || msg.value==0, \\\"once target is an EOA, msg.value must be zero\\\");\\n        require(_target != Predeploys.BVM_ETH, \\\"target must not be BVM_ETH on L2\\\");\\n\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            0,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                L2CrossDomainMessenger.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                0,\\n                msg.value,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, 0, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n     *         be executed via cross-chain call from the other messenger OR if the message was\\n     *         already received once and is currently being replayed.\\n     *\\n     * @param _nonce       Nonce of the message being relayed.\\n     * @param _sender      Address of the user who sent the message.\\n     * @param _target      Address that the message is targeted at.\\n     * @param _mntValue    MNT value to send with the message.\\n     * @param _ethValue    ETH value to send with the message.\\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n     * @param _message     Message to send to the target.\\n     */\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    ) external payable override {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(\\n            version <= MESSAGE_VERSION,\\n            \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\"\\n        );\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(\\n                successfulMessages[oldHash] == false,\\n                \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\"\\n            );\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\\n            _nonce,\\n            _sender,\\n            _target,\\n            _mntValue,\\n            _ethValue,\\n            _minGasLimit,\\n            _message\\n        );\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _ethValue);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(\\n                msg.value == 0,\\n                \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\"\\n            );\\n\\n            require(\\n                failedMessages[versionedHash],\\n                \\\"CrossDomainMessenger: message cannot be replayed\\\"\\n            );\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false,\\n            \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(\\n            successfulMessages[versionedHash] == false,\\n            \\\"CrossDomainMessenger: message has already been relayed\\\"\\n        );\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\\n        xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n        if (_mntValue!=0){\\n            IERC20(L1_MNT_ADDRESS).approve(_target, _mntValue);\\n        }\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _ethValue, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n        if (_mntValue!=0){\\n            IERC20(L1_MNT_ADDRESS).approve(_target, 0);\\n        }\\n        if (success) {\\n            require(!successfulMessages[versionedHash], \\\"versionedHash has already be marked as successful\\\");\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _isOtherMessenger() internal view override returns (bool) {\\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\\n        return _target == address(this) || _target == address(PORTAL);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/L1ERC721Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC721Bridge } from \\\"../universal/ERC721Bridge.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { L2ERC721Bridge } from \\\"../L2/L2ERC721Bridge.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\n\\n/**\\n * @title L1ERC721Bridge\\n * @notice The L1 ERC721 bridge is a contract which works together with the L2 ERC721 bridge to\\n *         make it possible to transfer ERC721 tokens from Ethereum to Optimism. This contract\\n *         acts as an escrow for ERC721 tokens deposited into L2.\\n */\\ncontract L1ERC721Bridge is ERC721Bridge, IERC721Receiver, Semver {\\n    /**\\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\\n     *         by ID was deposited for a given L2 token.\\n     */\\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\\n\\n    /**\\n     * @custom:semver 1.1.1\\n     *\\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\\n     */\\n    constructor(address _messenger, address _otherBridge)\\n        Semver(1, 1, 1)\\n        ERC721Bridge(_messenger, _otherBridge)\\n    {}\\n\\n    /**\\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\\n     *         recipient on this domain.\\n     *\\n     * @param _localToken  Address of the ERC721 token on this domain.\\n     * @param _remoteToken Address of the ERC721 token on the other domain.\\n     * @param _from        Address that triggered the bridge on the other domain.\\n     * @param _to          Address to receive the token on this domain.\\n     * @param _tokenId     ID of the token being deposited.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function finalizeBridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes calldata _extraData\\n    ) external onlyOtherBridge {\\n        require(_localToken != address(this), \\\"L1ERC721Bridge: local token cannot be self\\\");\\n\\n        // Checks that the L1/L2 NFT pair has a token ID that is escrowed in the L1 Bridge.\\n        require(\\n            deposits[_localToken][_remoteToken][_tokenId] == true,\\n            \\\"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\\\"\\n        );\\n\\n        // Mark that the token ID for this L1/L2 token pair is no longer escrowed in the L1\\n        // Bridge.\\n        deposits[_localToken][_remoteToken][_tokenId] = false;\\n\\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the NFT to the\\n        // withdrawer.\\n        IERC721(_localToken).safeTransferFrom(address(this), _to, _tokenId);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721Bridge\\n     */\\n    function _initiateBridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) internal override {\\n        require(_remoteToken != address(0), \\\"L1ERC721Bridge: remote token cannot be address(0)\\\");\\n\\n        // Construct calldata for _l2Token.finalizeBridgeERC721(_to, _tokenId)\\n        bytes memory message = abi.encodeWithSelector(\\n            L2ERC721Bridge.finalizeBridgeERC721.selector,\\n            _remoteToken,\\n            _localToken,\\n            _from,\\n            _to,\\n            _tokenId,\\n            _extraData\\n        );\\n\\n        // Lock token into bridge\\n        deposits[_localToken][_remoteToken][_tokenId] = true;\\n        IERC721(_localToken).safeTransferFrom(_from, address(this), _tokenId);\\n\\n        // Send calldata into L2\\n        MESSENGER.sendMessage(0, OTHER_BRIDGE, message, _minGasLimit);\\n        emit ERC721BridgeInitiated(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/L1StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { StandardBridge } from \\\"../universal/StandardBridge.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { OptimismMintableERC20 } from \\\"../universal/OptimismMintableERC20.sol\\\";\\nimport { L2StandardBridge } from \\\"../L2/L2StandardBridge.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @title L1StandardBridge\\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\\n *         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\\n *         contract. If the ERC20 token is native to L2, it will be burnt. Before Bedrock, ETH was\\n *         stored within this contract. After Bedrock, ETH is instead stored inside the\\n *         OptimismPortal contract.\\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\\n *         of some token types that may not be properly supported by this contract include, but are\\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\\n */\\ncontract L1StandardBridge is StandardBridge, Semver {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable L1_MNT_ADDRESS;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a deposit of MNT from L1 into L2 is initiated.\\n     *\\n     * @param from      Address of the depositor.\\n     * @param to        Address of the recipient on L2.\\n     * @param amount    Amount of MNT deposited.\\n     * @param extraData Extra data attached to the deposit.\\n     */\\n    event MNTDepositInitiated(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a withdrawal of MNT from L2 to L1 is finalized.\\n     *\\n     * @param from      Address of the withdrawer.\\n     * @param to        Address of the recipient on L1.\\n     * @param amount    Amount of MNT withdrawn.\\n     * @param extraData Extra data attached to the withdrawal.\\n     */\\n    event MNTWithdrawalFinalized(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\\n     *\\n     * @param from      Address of the depositor.\\n     * @param to        Address of the recipient on L2.\\n     * @param amount    Amount of ETH deposited.\\n     * @param extraData Extra data attached to the deposit.\\n     */\\n    event ETHDepositInitiated(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\\n     *\\n     * @param from      Address of the withdrawer.\\n     * @param to        Address of the recipient on L1.\\n     * @param amount    Amount of ETH withdrawn.\\n     * @param extraData Extra data attached to the withdrawal.\\n     */\\n    event ETHWithdrawalFinalized(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever an ERC20 deposit is initiated.\\n     *\\n     * @param l1Token   Address of the token on L1.\\n     * @param l2Token   Address of the corresponding token on L2.\\n     * @param from      Address of the depositor.\\n     * @param to        Address of the recipient on L2.\\n     * @param amount    Amount of the ERC20 deposited.\\n     * @param extraData Extra data attached to the deposit.\\n     */\\n    event ERC20DepositInitiated(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever an ERC20 withdrawal is finalized.\\n     *\\n     * @param l1Token   Address of the token on L1.\\n     * @param l2Token   Address of the corresponding token on L2.\\n     * @param from      Address of the withdrawer.\\n     * @param to        Address of the recipient on L1.\\n     * @param amount    Amount of the ERC20 withdrawn.\\n     * @param extraData Extra data attached to the withdrawal.\\n     */\\n    event ERC20WithdrawalFinalized(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:semver 1.1.0\\n     *\\n     * @param _messenger Address of the L1CrossDomainMessenger.\\n     */\\n    constructor(address payable _messenger, address _l1mnt)\\n        Semver(1, 1, 0)\\n        StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE))\\n    {\\n        L1_MNT_ADDRESS = _l1mnt;\\n    }\\n\\n    /**\\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n     */\\n    receive() external payable override onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ETH into the sender's account on L2.\\n     *\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ETH into a target account on L2.\\n     *         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\\n     *\\n     * @param _to          Address of the recipient on L2.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositETHTo(\\n        address _to,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external payable {\\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n    * @custom:legacy\\n     * @notice Deposits some amount of MNT into the sender's account on L2.\\n     *\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositMNT(\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external onlyEOA {\\n        _initiateMNTDeposit(msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of MNT into a target account on L2.\\n     *         Note that if MNT is sent to a contract on L2 and the call fails, then that ETH will\\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\\n     *\\n     * @param _to          Address of the recipient on L2.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositMNTTo(\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external payable {\\n        _initiateMNTDeposit(msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\\n     *\\n     * @param _l1Token     Address of the L1 token being deposited.\\n     * @param _l2Token     Address of the corresponding token on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external virtual onlyEOA {\\n        _initiateERC20Deposit(\\n            _l1Token,\\n            _l2Token,\\n            msg.sender,\\n            msg.sender,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ERC20 tokens into a target account on L2.\\n     *\\n     * @param _l1Token     Address of the L1 token being deposited.\\n     * @param _l2Token     Address of the corresponding token on L2.\\n     * @param _to          Address of the recipient on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external virtual {\\n        _initiateERC20Deposit(\\n            _l1Token,\\n            _l2Token,\\n            msg.sender,\\n            _to,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n * @custom:legacy\\n     * @notice Finalizes a withdrawal of MNT from L2.\\n     *\\n     * @param _from      Address of the withdrawer on L2.\\n     * @param _to        Address of the recipient on L1.\\n     * @param _amount    Amount of MNT to withdraw.\\n     * @param _extraData Optional data forwarded from L2.\\n     */\\n    function finalizeMantleWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) external payable {\\n        finalizeBridgeMNT(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Finalizes a withdrawal of ETH from L2.\\n     *\\n     * @param _from      Address of the withdrawer on L2.\\n     * @param _to        Address of the recipient on L1.\\n     * @param _amount    Amount of ETH to withdraw.\\n     * @param _extraData Optional data forwarded from L2.\\n     */\\n    function finalizeETHWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) external payable {\\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Finalizes a withdrawal of ERC20 tokens from L2.\\n     *\\n     * @param _l1Token   Address of the token on L1.\\n     * @param _l2Token   Address of the corresponding token on L2.\\n     * @param _from      Address of the withdrawer on L2.\\n     * @param _to        Address of the recipient on L1.\\n     * @param _amount    Amount of the ERC20 to withdraw.\\n     * @param _extraData Optional data forwarded from L2.\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) external {\\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Retrieves the access of the corresponding L2 bridge contract.\\n     *\\n     * @return Address of the corresponding L2 bridge contract.\\n     */\\n    function l2TokenBridge() external view returns (address) {\\n        return address(OTHER_BRIDGE);\\n    }\\n\\n    /**\\n     * @notice Internal function for initiating an ETH deposit.\\n     *\\n     * @param _from        Address of the sender on L1.\\n     * @param _to          Address of the recipient on L2.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2.\\n     */\\n    function _initiateETHDeposit(\\n        address _from,\\n        address _to,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal {\\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Internal function for initiating an ERC20 deposit.\\n     *\\n     * @param _l1Token     Address of the L1 token being deposited.\\n     * @param _l2Token     Address of the corresponding token on L2.\\n     * @param _from        Address of the sender on L1.\\n     * @param _to          Address of the recipient on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2.\\n     */\\n    function _initiateERC20Deposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal {\\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n * @notice Internal function for initiating an MNT deposit.\\n     *\\n     * @param _from        Address of the sender on L1.\\n     * @param _to          Address of the recipient on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2.\\n     */\\n    function _initiateMNTDeposit(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal {\\n        _initiateBridgeMNT(_from, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy ETHDepositInitiated event followed by the ETHBridgeInitiated event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit ETHDepositInitiated(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy ETHWithdrawalFinalized event followed by the ETHBridgeFinalized\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy ETHDepositInitiated event followed by the ETHBridgeInitiated event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitMNTBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit MNTDepositInitiated(_from, _to, _amount, _extraData);\\n        super._emitMNTBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy MNTWithdrawalFinalized event followed by the MNTBridgeFinalized\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitMNTBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit MNTWithdrawalFinalized(_from, _to, _amount, _extraData);\\n        super._emitMNTBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy ERC20DepositInitiated event followed by the ERC20BridgeInitiated\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit ERC20DepositInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit ERC20WithdrawalFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ETH to the sender's address on the other chain.\\n     *\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n     *         in that case.\\n     *\\n     * @param _to          Address of the receiver.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeETHTo(\\n        address _to,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public payable {\\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends MNT to the sender's address on the other chain.\\n     *\\n     * @param _amount      Amount of the MNT.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeMNT(uint256 _amount, uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\\n        _initiateBridgeMNT(msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends MNT to the sender's address on the other chain.\\n     *\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeMNTTo(\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public payable {\\n        _initiateBridgeMNT(msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public onlyEOA override {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            msg.sender,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public override {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            _to,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from      Address of the sender.\\n     * @param _to        Address of the receiver.\\n     * @param _amount    Amount of ETH being bridged.\\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\\n     *                   not be triggered with this data, but it will be emitted and can be used\\n     *                   to identify the transaction.\\n     */\\n    function finalizeBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable override onlyOtherBridge {\\n        require(msg.value == _amount, \\\"StandardBridge: amount sent does not match amount required\\\");\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(MESSENGER), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\\\"\\\");\\n        require(success, \\\"StandardBridge: ETH transfer failed\\\");\\n\\n    }\\n\\n    /**\\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the ERC20 being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public onlyOtherBridge override {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\\n        } else {\\n\\n            uint256 balanceBefore = IERC20(_localToken).balanceOf(address(this));\\n            IERC20(_localToken).safeTransfer(_to, _amount);\\n            uint256 balanceAfter = IERC20(_localToken).balanceOf(address(this));\\n            uint256 sentAmount = balanceBefore - balanceAfter;\\n\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - sentAmount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n* @notice Finalizes an MNT bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable override onlyOtherBridge {\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(MESSENGER), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        IERC20(L1_MNT_ADDRESS).safeTransferFrom(address(MESSENGER), _to, _amount);\\n\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitMNTBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of ETH being bridged.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(\\n            msg.value == _amount,\\n            \\\"L1StandardBridge: bridging ETH must include sufficient ETH value\\\"\\n        );\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n        uint256 zeroMNTValue = 0;\\n        MESSENGER.sendMessage{value: msg.value}(\\n            zeroMNTValue,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                L2StandardBridge.finalizeBridgeETH.selector,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n * @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(_localToken != address(0) && _remoteToken != Predeploys.BVM_ETH,\\n            \\\"L1StandardBridge: BridgeERC20 do not support ETH bridging.\\\");\\n        require(_localToken != L1_MNT_ADDRESS && _remoteToken != address(0x0),\\n            \\\"L1StandardBridge: BridgeERC20 do not support MNT bridging.\\\");\\n\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\\n        } else {\\n            uint256 balanceBefore = IERC20(_localToken).balanceOf(address(this));\\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\\n            uint256 balanceAfter = IERC20(_localToken).balanceOf(address(this));\\n            uint256 receivedAmount = balanceAfter - balanceBefore;\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + receivedAmount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        uint256 zeroMNTValue = 0;\\n        MESSENGER.sendMessage(\\n            zeroMNTValue,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                L2StandardBridge.finalizeBridgeERC20.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _remoteToken,\\n                _localToken,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n * @notice Sends MNT tokens to a receiver's address on the other chain.\\n     *\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(msg.value==0, \\\"L1StandardBridge: deposit MNT should not include ETH value.\\\");\\n        IERC20(L1_MNT_ADDRESS).safeTransferFrom(_from, address(this), _amount);\\n        // L1StandardBridge: approve for L1 MNT either reverts or returns true, there is no case in\\n        // which its result value is false.\\n        IERC20(L1_MNT_ADDRESS).approve(address(MESSENGER), _amount);\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitMNTBridgeInitiated(_from, _to, _amount, _extraData);\\n        MESSENGER.sendMessage{value: msg.value}(\\n            _amount,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                L2StandardBridge.finalizeBridgeMNT.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/L2OutputOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { Types } from \\\"../libraries/Types.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @title L2OutputOracle\\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\\n *         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use\\n *         these outputs to verify information about the state of L2.\\n */\\ncontract L2OutputOracle is Initializable, Semver {\\n    /**\\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\\n     *         immutable, it can safely be modified by upgrading the implementation contract.\\n     */\\n    uint256 public immutable SUBMISSION_INTERVAL;\\n\\n    /**\\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\\n     */\\n    uint256 public immutable L2_BLOCK_TIME;\\n\\n    /**\\n     * @notice The address of the challenger. Can be updated via upgrade.\\n     */\\n    address public immutable CHALLENGER;\\n\\n    /**\\n     * @notice The address of the proposer. Can be updated via upgrade.\\n     */\\n    address public immutable PROPOSER;\\n\\n    /**\\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\\n     */\\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\\n\\n    /**\\n     * @notice The number of the first L2 block recorded in this contract.\\n     */\\n    uint256 public startingBlockNumber;\\n\\n    /**\\n     * @notice The timestamp of the first L2 block recorded in this contract.\\n     */\\n    uint256 public startingTimestamp;\\n\\n    /**\\n     * @notice Array of L2 output proposals.\\n     */\\n    Types.OutputProposal[] internal l2Outputs;\\n\\n    /**\\n     * @notice Emitted when an output is proposed.\\n     *\\n     * @param outputRoot    The output root.\\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\\n     * @param l2BlockNumber The L2 block number of the output root.\\n     * @param l1Timestamp   The L1 timestamp when proposed.\\n     */\\n    event OutputProposed(\\n        bytes32 indexed outputRoot,\\n        uint256 indexed l2OutputIndex,\\n        uint256 indexed l2BlockNumber,\\n        uint256 l1Timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when outputs are deleted.\\n     *\\n     * @param prevNextOutputIndex Next L2 output index before the deletion.\\n     * @param newNextOutputIndex  Next L2 output index after the deletion.\\n     */\\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\\n\\n    /**\\n     * @custom:semver 1.3.0\\n     *\\n     * @param _submissionInterval  Interval in blocks at which checkpoints must be submitted.\\n     * @param _l2BlockTime         The time per L2 block, in seconds.\\n     * @param _startingBlockNumber The number of the first L2 block.\\n     * @param _startingTimestamp   The timestamp of the first L2 block.\\n     * @param _proposer            The address of the proposer.\\n     * @param _challenger          The address of the challenger.\\n     */\\n    constructor(\\n        uint256 _submissionInterval,\\n        uint256 _l2BlockTime,\\n        uint256 _startingBlockNumber,\\n        uint256 _startingTimestamp,\\n        address _proposer,\\n        address _challenger,\\n        uint256 _finalizationPeriodSeconds\\n    ) Semver(1, 3, 0) {\\n        require(_l2BlockTime > 0, \\\"L2OutputOracle: L2 block time must be greater than 0\\\");\\n        require(\\n            _submissionInterval > 0,\\n            \\\"L2OutputOracle: submission interval must be greater than 0\\\"\\n        );\\n\\n        SUBMISSION_INTERVAL = _submissionInterval;\\n        L2_BLOCK_TIME = _l2BlockTime;\\n        PROPOSER = _proposer;\\n        CHALLENGER = _challenger;\\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\\n\\n        initialize(_startingBlockNumber, _startingTimestamp);\\n    }\\n\\n    /**\\n     * @notice Initializer.\\n     *\\n     * @param _startingBlockNumber Block number for the first recoded L2 block.\\n     * @param _startingTimestamp   Timestamp for the first recoded L2 block.\\n     */\\n    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)\\n        public\\n        initializer\\n    {\\n        require(\\n            _startingTimestamp <= block.timestamp,\\n            \\\"L2OutputOracle: starting L2 timestamp must be less than current time\\\"\\n        );\\n\\n        startingTimestamp = _startingTimestamp;\\n        startingBlockNumber = _startingBlockNumber;\\n    }\\n\\n    /**\\n     * @notice Deletes all output proposals after and including the proposal that corresponds to\\n     *         the given output index. Only the challenger address can delete outputs.\\n     *\\n     * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this\\n     *                       output will also be deleted.\\n     */\\n    // solhint-disable-next-line ordering\\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\\n        require(\\n            msg.sender == CHALLENGER,\\n            \\\"L2OutputOracle: only the challenger address can delete outputs\\\"\\n        );\\n\\n        // Make sure we're not *increasing* the length of the array.\\n        require(\\n            _l2OutputIndex < l2Outputs.length,\\n            \\\"L2OutputOracle: cannot delete outputs after the latest output index\\\"\\n        );\\n\\n        // Do not allow deleting any outputs that have already been finalized.\\n        require(\\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,\\n            \\\"L2OutputOracle: cannot delete outputs that have already been finalized\\\"\\n        );\\n\\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\\n\\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\\n        assembly {\\n            sstore(l2Outputs.slot, _l2OutputIndex)\\n        }\\n\\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\\n    }\\n\\n    /**\\n     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The timestamp\\n     *         must be equal to the current value returned by `nextTimestamp()` in order to be\\n     *         accepted. This function may only be called by the Proposer.\\n     *\\n     * @param _outputRoot    The L2 output of the checkpoint block.\\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\\n     * @param _l1BlockNumber The block number with the specified block hash.\\n     */\\n    function proposeL2Output(\\n        bytes32 _outputRoot,\\n        uint256 _l2BlockNumber,\\n        bytes32 _l1BlockHash,\\n        uint256 _l1BlockNumber\\n    ) external {\\n        require(\\n            msg.sender == PROPOSER,\\n            \\\"L2OutputOracle: only the proposer address can propose new outputs\\\"\\n        );\\n\\n        require(\\n            _l2BlockNumber == nextBlockNumber(),\\n            \\\"L2OutputOracle: block number must be equal to next expected block number\\\"\\n        );\\n\\n        require(\\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\\n            \\\"L2OutputOracle: cannot propose L2 output in the future\\\"\\n        );\\n\\n        require(\\n            _outputRoot != bytes32(0),\\n            \\\"L2OutputOracle: L2 output proposal cannot be the zero hash\\\"\\n        );\\n\\n        if (_l1BlockHash != bytes32(0)) {\\n            // This check allows the proposer to propose an output based on a given L1 block,\\n            // without fear that it will be reorged out.\\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\\n            // attack in which the proposer's submission is censored until the block is no longer\\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\\n            // blockhash value, and delay submission until it is confident that the L1 block is\\n            // finalized.\\n            require(\\n                blockhash(_l1BlockNumber) == _l1BlockHash,\\n                \\\"L2OutputOracle: block hash does not match the hash at the expected height\\\"\\n            );\\n        }\\n\\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\\n\\n        l2Outputs.push(\\n            Types.OutputProposal({\\n                outputRoot: _outputRoot,\\n                timestamp: uint128(block.timestamp),\\n                l2BlockNumber: uint128(_l2BlockNumber)\\n            })\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns an output by index. Exists because Solidity's array access will return a\\n     *         tuple instead of a struct.\\n     *\\n     * @param _l2OutputIndex Index of the output to return.\\n     *\\n     * @return The output at the given index.\\n     */\\n    function getL2Output(uint256 _l2OutputIndex)\\n        external\\n        view\\n        returns (Types.OutputProposal memory)\\n    {\\n        return l2Outputs[_l2OutputIndex];\\n    }\\n\\n    /**\\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\\n     *         binary search to find the first output greater than or equal to the given block.\\n     *\\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\\n     *\\n     * @return Index of the first checkpoint that commits to the given L2 block number.\\n     */\\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\\n        // Make sure an output for this block number has actually been proposed.\\n        require(\\n            _l2BlockNumber <= latestBlockNumber(),\\n            \\\"L2OutputOracle: cannot get output for a block that has not been proposed\\\"\\n        );\\n\\n        // Make sure there's at least one output proposed.\\n        require(\\n            l2Outputs.length > 0,\\n            \\\"L2OutputOracle: cannot get output as no outputs have been proposed yet\\\"\\n        );\\n\\n        // Find the output via binary search, guaranteed to exist.\\n        uint256 lo = 0;\\n        uint256 hi = l2Outputs.length;\\n        while (lo < hi) {\\n            uint256 mid = (lo + hi) / 2;\\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    /**\\n     * @notice Returns the L2 output proposal that checkpoints a given L2 block number. Uses a\\n     *         binary search to find the first output greater than or equal to the given block.\\n     *\\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\\n     *\\n     * @return First checkpoint that commits to the given L2 block number.\\n     */\\n    function getL2OutputAfter(uint256 _l2BlockNumber)\\n        external\\n        view\\n        returns (Types.OutputProposal memory)\\n    {\\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\\n    }\\n\\n    /**\\n     * @notice Returns the number of outputs that have been proposed. Will revert if no outputs\\n     *         have been proposed yet.\\n     *\\n     * @return The number of outputs that have been proposed.\\n     */\\n    function latestOutputIndex() external view returns (uint256) {\\n        return l2Outputs.length - 1;\\n    }\\n\\n    /**\\n     * @notice Returns the index of the next output to be proposed.\\n     *\\n     * @return The index of the next output to be proposed.\\n     */\\n    function nextOutputIndex() public view returns (uint256) {\\n        return l2Outputs.length;\\n    }\\n\\n    /**\\n     * @notice Returns the block number of the latest submitted L2 output proposal. If no proposals\\n     *         been submitted yet then this function will return the starting block number.\\n     *\\n     * @return Latest submitted L2 block number.\\n     */\\n    function latestBlockNumber() public view returns (uint256) {\\n        return\\n            l2Outputs.length == 0\\n                ? startingBlockNumber\\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\\n    }\\n\\n    /**\\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\\n     *\\n     * @return Next L2 block number.\\n     */\\n    function nextBlockNumber() public view returns (uint256) {\\n        return latestBlockNumber() + SUBMISSION_INTERVAL;\\n    }\\n\\n    /**\\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\\n     *\\n     * @param _l2BlockNumber The L2 block number of the target block.\\n     *\\n     * @return L2 timestamp of the given block.\\n     */\\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/OptimismPortal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { L2OutputOracle } from \\\"./L2OutputOracle.sol\\\";\\nimport { SystemConfig } from \\\"./SystemConfig.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\nimport { Types } from \\\"../libraries/Types.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { SecureMerkleTrie } from \\\"../libraries/trie/SecureMerkleTrie.sol\\\";\\nimport { AddressAliasHelper } from \\\"../vendor/AddressAliasHelper.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { ResourceMetering } from \\\"./ResourceMetering.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @title OptimismPortal\\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\\n */\\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice Represents a proven withdrawal.\\n     *\\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\\n     * @custom:field timestamp     Timestamp at which the withdrawal was proven.\\n     * @custom:field l2OutputIndex Index of the output this was proven against.\\n     */\\n    struct ProvenWithdrawal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2OutputIndex;\\n    }\\n\\n    /**\\n     * @notice Version of the deposit event.\\n     */\\n    uint256 internal constant DEPOSIT_VERSION = 1;\\n\\n    /**\\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\\n     */\\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\\n\\n    /**\\n     * @notice Address of the L2OutputOracle contract.\\n     */\\n    L2OutputOracle public immutable L2_ORACLE;\\n\\n    /**\\n     * @notice Address of the SystemConfig contract.\\n     */\\n    SystemConfig public immutable SYSTEM_CONFIG;\\n\\n    /**\\n     * @notice Address that has the ability to pause and unpause withdrawals.\\n     */\\n    address public immutable GUARDIAN;\\n\\n    /**\\n     * @notice Address of  the L1 Mantle Token .\\n     */\\n    address public immutable L1_MNT_ADDRESS;\\n\\n    /**\\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\\n     *         value of this variable is the default L2 sender address, then we are NOT inside of a call\\n     *         to finalizeWithdrawalTransaction.\\n     */\\n    address public l2Sender;\\n\\n    /**\\n     * @notice A list of withdrawal hashes which have been successfully finalized.\\n     */\\n    mapping(bytes32 => bool) public finalizedWithdrawals;\\n\\n    /**\\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\\n     */\\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\\n\\n    /**\\n     * @notice Determines if cross domain messaging is paused. When set to true,\\n     *         withdrawals are paused. This may be removed in the future.\\n     */\\n    bool public paused;\\n\\n    /**\\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\\n     *         are read by the rollup node and used to derive deposit transactions on L2.\\n     *\\n     * @param from       Address that triggered the deposit transaction.\\n     * @param to         Address that the deposit transaction is directed to.\\n     * @param version    Version of this deposit transaction event.\\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\\n     */\\n    event TransactionDeposited(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed version,\\n        bytes opaqueData\\n    );\\n\\n    /**\\n     * @notice Emitted when a withdrawal transaction is proven.\\n     *\\n     * @param withdrawalHash Hash of the withdrawal transaction.\\n     */\\n    event WithdrawalProven(\\n        bytes32 indexed withdrawalHash,\\n        address indexed from,\\n        address indexed to\\n    );\\n\\n    /**\\n     * @notice Emitted when a withdrawal transaction is finalized.\\n     *\\n     * @param withdrawalHash Hash of the withdrawal transaction.\\n     * @param success        Whether the withdrawal transaction was successful.\\n     */\\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\\n\\n    /**\\n     * @notice Emitted when the pause is triggered.\\n     *\\n     * @param account Address of the account triggering the pause.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @notice Emitted when the pause is lifted.\\n     *\\n     * @param account Address of the account triggering the unpause.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @notice Reverts when paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(paused == false, \\\"OptimismPortal: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @custom:semver 1.6.0\\n     *\\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\\n     * @param _guardian                  Address that can pause deposits and withdrawals.\\n     * @param _paused                    Sets the contract's pausability state.\\n     * @param _config                    Address of the SystemConfig contract.\\n     */\\n    constructor(\\n        L2OutputOracle _l2Oracle,\\n        address _guardian,\\n        bool _paused,\\n        SystemConfig _config,\\n        address _l1MNT\\n    ) Semver(1, 7, 0) {\\n        L2_ORACLE = _l2Oracle;\\n        GUARDIAN = _guardian;\\n        SYSTEM_CONFIG = _config;\\n        L1_MNT_ADDRESS = _l1MNT;\\n        initialize(_paused);\\n    }\\n\\n    /**\\n     * @notice Initializer.\\n     */\\n    function initialize(bool _paused) public initializer {\\n        if (l2Sender == address(0)) {\\n            l2Sender = Constants.DEFAULT_L2_SENDER;\\n        }\\n        paused = _paused;\\n        __ResourceMetering_init();\\n    }\\n\\n    /**\\n     * @notice Pause deposits and withdrawals.\\n     */\\n    function pause() external {\\n        require(msg.sender == GUARDIAN, \\\"OptimismPortal: only guardian can pause\\\");\\n        paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Unpause deposits and withdrawals.\\n     */\\n    function unpause() external {\\n        require(msg.sender == GUARDIAN, \\\"OptimismPortal: only guardian can unpause\\\");\\n        paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit\\n     *         linearly increases based on the size of the calldata. This is to prevent\\n     *         users from creating L2 resource usage without paying for it. This function\\n     *         can be used when interacting with the portal to ensure forwards compatibility.\\n     *\\n     */\\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\\n        return _byteCount * 16 + 21000;\\n    }\\n    /**\\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\\n     *         calling code within their constructors, but also doesn't really matter since we're\\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\\n     */\\n    modifier onlyEOA() {\\n        require(\\n            !Address.isContract(msg.sender),\\n            \\\"StandardBridge: function can only be called from an EOA\\\"\\n        );\\n        require(\\n            msg.sender==tx.origin,\\n            \\\"StandardBridge: msg sender must equal to tx origin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\\n     *         funds be deposited to their address on L2. This is intended as a convenience\\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\\n     *         otherwise any deposited funds will be lost due to address aliasing.\\n     */\\n    // solhint-disable-next-line ordering\\n    receive() external payable onlyEOA {\\n        depositTransaction(msg.value, 0, msg.sender, 0, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\\n     */\\n    function donateETH() external payable {\\n        // Intentionally empty.\\n    }\\n\\n    /**\\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\\n     *         contract. The SystemConfig is the source of truth for the resource config.\\n     *\\n     * @return ResourceMetering.ResourceConfig\\n     */\\n    function _resourceConfig()\\n        internal\\n        view\\n        override\\n        returns (ResourceMetering.ResourceConfig memory)\\n    {\\n        return SYSTEM_CONFIG.resourceConfig();\\n    }\\n\\n    /**\\n     * @notice Proves a withdrawal transaction.\\n     *\\n     * @param _tx              Withdrawal transaction to finalize.\\n     * @param _l2OutputIndex   L2 output index to prove against.\\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\\n     */\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        uint256 _l2OutputIndex,\\n        Types.OutputRootProof calldata _outputRootProof,\\n        bytes[] calldata _withdrawalProof\\n    ) external whenNotPaused {\\n        // Prevent users from creating a deposit transaction where this address is the message\\n        // sender on L2. Because this is checked here, we do not need to check again in\\n        // `finalizeWithdrawalTransaction`.\\n        require(\\n            _tx.target != address(this),\\n            \\\"OptimismPortal: you cannot send messages to the portal contract\\\"\\n        );\\n\\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\\n        // revert if there is no output root for the given block number.\\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\\n\\n        // Verify that the output root can be generated with the elements in the proof.\\n        require(\\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\\n            \\\"OptimismPortal: invalid output root proof\\\"\\n        );\\n\\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\\n\\n        // We generally want to prevent users from proving the same withdrawal multiple times\\n        // because each successive proof will update the timestamp. A malicious user can take\\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\\n        // since withdrawals are proven before an output root is finalized, we need to allow users\\n        // to re-prove their withdrawal only in the case that the output root for their specified\\n        // output index has been updated.\\n        require(\\n            provenWithdrawal.timestamp == 0 ||\\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\\n                provenWithdrawal.outputRoot,\\n            \\\"OptimismPortal: withdrawal hash has already been proven\\\"\\n        );\\n\\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\\n        // Refer to the Solidity documentation for more information on how storage layouts are\\n        // computed for mappings.\\n        bytes32 storageKey = keccak256(\\n            abi.encode(\\n                withdrawalHash,\\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\\n            )\\n        );\\n\\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\\n        // be relayed on L1.\\n        require(\\n            SecureMerkleTrie.verifyInclusionProof(\\n                abi.encode(storageKey),\\n                hex\\\"01\\\",\\n                _withdrawalProof,\\n                _outputRootProof.messagePasserStorageRoot\\n            ),\\n            \\\"OptimismPortal: invalid withdrawal inclusion proof\\\"\\n        );\\n\\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\\n        // proven once unless it is submitted again with a different outputRoot.\\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\\n            outputRoot: outputRoot,\\n            timestamp: uint128(block.timestamp),\\n            l2OutputIndex: uint128(_l2OutputIndex)\\n        });\\n\\n        // Emit a `WithdrawalProven` event.\\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\\n    }\\n\\n    /**\\n     * @notice Finalizes a withdrawal transaction.\\n     *\\n     * @param _tx Withdrawal transaction to finalize.\\n     */\\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\\n        external\\n        whenNotPaused\\n    {\\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\\n        // than the default value when a withdrawal transaction is being finalized. This check is\\n        // a defacto reentrancy guard.\\n        require(\\n            l2Sender == Constants.DEFAULT_L2_SENDER,\\n            \\\"OptimismPortal: can only trigger one withdrawal per transaction\\\"\\n        );\\n\\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\\n\\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\\n        // a timestamp of zero.\\n        require(\\n            provenWithdrawal.timestamp != 0,\\n            \\\"OptimismPortal: withdrawal has not been proven yet\\\"\\n        );\\n\\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\\n        // safety against weird bugs in the proving step.\\n        require(\\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\\n            \\\"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\\\"\\n        );\\n\\n        // A proven withdrawal must wait at least the finalization period before it can be\\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\\n        // output the withdrawal was proven against. In effect, this means that the minimum\\n        // withdrawal time is proposal submission time + finalization period.\\n        require(\\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\\n            \\\"OptimismPortal: proven withdrawal finalization period has not elapsed\\\"\\n        );\\n\\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\\n        // corresponds to the given index has not been proposed yet.\\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\\n            provenWithdrawal.l2OutputIndex\\n        );\\n\\n        // Check that the output root that was used to prove the withdrawal is the same as the\\n        // current output root for the given output index. An output root may change if it is\\n        // deleted by the challenger address and then re-proposed.\\n        require(\\n            proposal.outputRoot == provenWithdrawal.outputRoot,\\n            \\\"OptimismPortal: output root proven is not the same as current output root\\\"\\n        );\\n\\n        // Check that the output proposal has also been finalized.\\n        require(\\n            _isFinalizationPeriodElapsed(proposal.timestamp),\\n            \\\"OptimismPortal: output proposal finalization period has not elapsed\\\"\\n        );\\n\\n        // Check that this withdrawal has not already been finalized, this is replay protection.\\n        require(\\n            finalizedWithdrawals[withdrawalHash] == false,\\n            \\\"OptimismPortal: withdrawal has already been finalized\\\"\\n        );\\n\\n        // Mark the withdrawal as finalized so it can't be replayed.\\n        finalizedWithdrawals[withdrawalHash] = true;\\n\\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\\n        l2Sender = _tx.sender;\\n\\n        // Trigger the call to the target contract. We use a custom low level method\\n        // SafeCall.callWithMinGas to ensure two key properties\\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\\n        //      amount of data (and this is OK because we don't care about the returndata here).\\n        //   2. The amount of gas provided to the execution context of the target is at least the\\n        //      gas limit specified by the user. If there is not enough gas in the current context\\n        //      to accomplish this, `callWithMinGas` will revert.\\n        if (_tx.mntValue>0){\\n            // The l1mntSuccess variable of transfer is either true or the transfer call reverted.\\n            // It will never be false.\\n            IERC20(L1_MNT_ADDRESS).transfer(_tx.target, _tx.mntValue);\\n        }\\n        require(_tx.target != L1_MNT_ADDRESS, \\\"Directly calling MNT Token is forbidden\\\");\\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.ethValue, _tx.data);\\n        // Reset the l2Sender back to the default value.\\n        l2Sender = Constants.DEFAULT_L2_SENDER;\\n\\n        // All withdrawals are immediately finalized. Replayability can\\n        // be achieved through contracts built on top of this contract\\n        emit WithdrawalFinalized(withdrawalHash, success);\\n\\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\\n        // sub call to the target contract if the minimum gas limit specified by the user would not\\n        // be sufficient to execute the sub call.\\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\\n            revert(\\\"OptimismPortal: withdrawal failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\\n     *\\n     * @param _ethTxValue BVM_ETH value to send to the recipient.\\n     * @param _mntValue   Mint MNT amount to from address on L2\\n     * @param _to         Target address on L2.\\n     * @param _mntTxValue MNT value to send to the recipient.\\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\\n     * @param _isCreation Whether or not the transaction is a contract creation.\\n     * @param _data       Data to trigger the recipient with.\\n     */\\n    function depositTransaction(\\n        uint256 _ethTxValue,\\n        uint256 _mntValue,\\n        address _to,\\n        uint256 _mntTxValue,\\n        uint64 _gasLimit,\\n        bool _isCreation,\\n        bytes memory _data\\n    ) public payable metered(_gasLimit) {\\n        // Just to be safe, make sure that people specify address(0) as the target when doing\\n        // contract creations.\\n        if (_isCreation) {\\n            require(\\n                _to == address(0),\\n                \\\"OptimismPortal: must send to address(0) when creating a contract\\\"\\n            );\\n        }\\n\\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\\n        // more for more resource usage.\\n        require(\\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\\n            \\\"OptimismPortal: gas limit too small\\\"\\n        );\\n\\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\\n        // transactions are not gossipped over the p2p network.\\n        require(_data.length <= 120_000, \\\"OptimismPortal: data too large\\\");\\n\\n        if (_mntValue != 0) {\\n            IERC20(L1_MNT_ADDRESS).safeTransferFrom(msg.sender, address(this), _mntValue);\\n        }\\n\\n        // Transform the from-address to its alias if the caller is a contract.\\n        address from = msg.sender;\\n        if (msg.sender != tx.origin) {\\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\\n        // We use opaque data so that we can update the TransactionDeposited event in the future\\n        // without breaking the current interface.\\n        bytes memory opaqueData = abi.encodePacked(\\n            _mntValue,\\n            _mntTxValue,\\n            msg.value,\\n            _ethTxValue,\\n            _gasLimit,\\n            _isCreation,\\n            _data\\n        );\\n\\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\\n        // transaction for this deposit.\\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\\n    }\\n\\n    /**\\n     * @notice Determine if a given output is finalized. Reverts if the call to\\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\\n     *\\n     * @param _l2OutputIndex Index of the L2 output to check.\\n     *\\n     * @return Whether or not the output is finalized.\\n     */\\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\\n    }\\n\\n    /**\\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\\n     *\\n     * @param _timestamp Timestamp to check.\\n     *\\n     * @return Whether or not the finalization period has elapsed.\\n     */\\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/ResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { Burn } from \\\"../libraries/Burn.sol\\\";\\nimport { Arithmetic } from \\\"../libraries/Arithmetic.sol\\\";\\n\\n/**\\n * @custom:upgradeable\\n * @title ResourceMetering\\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\\n *         updates automatically based on current demand.\\n */\\nabstract contract ResourceMetering is Initializable {\\n    /**\\n     * @notice Represents the various parameters that control the way in which resources are\\n     *         metered. Corresponds to the EIP-1559 resource metering system.\\n     *\\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\\n     */\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    /**\\n     * @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\\n     *         market. These values should be set with care as it is possible to set them in\\n     *         a way that breaks the deposit gas market. The target resource limit is defined as\\n     *         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\\n     *         single word. There is additional space for additions in the future.\\n     *\\n     * @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\\n     *                                            can be purchased per block.\\n     * @custom:field elasticityMultiplier         Determines the target resource limit along with\\n     *                                            the resource limit.\\n     * @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\\n     * @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\\n     *                                            value.\\n     * @custom:field systemTxMaxGas               The amount of gas supplied to the system\\n     *                                            transaction. This should be set to the same number\\n     *                                            that the op-node sets as the gas limit for the\\n     *                                            system transaction.\\n     * @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\\n     *                                            value.\\n     */\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    /**\\n     * @notice EIP-1559 style gas parameters.\\n     */\\n    ResourceParams public params;\\n\\n    /**\\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n     */\\n    uint256[48] private __gap;\\n\\n    /**\\n     * @notice Meters access to a function based an amount of a requested resource.\\n     *\\n     * @param _amount Amount of the resource requested.\\n     */\\n    modifier metered(uint64 _amount) {\\n        // Record initial gas amount so we can refund for it later.\\n        uint256 initialGas = gasleft();\\n\\n        // Run the underlying function.\\n        _;\\n\\n        // Run the metering function.\\n        _metered(_amount, initialGas);\\n    }\\n\\n    /**\\n     * @notice An internal function that holds all of the logic for metering a resource.\\n     *\\n     * @param _amount     Amount of the resource requested.\\n     * @param _initialGas The amount of gas before any modifier execution.\\n     */\\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\\n        // Update block number and base fee if necessary.\\n        uint256 blockDiff = block.number - params.prevBlockNum;\\n\\n        ResourceConfig memory config = _resourceConfig();\\n        int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /\\n            int256(uint256(config.elasticityMultiplier));\\n\\n        if (blockDiff > 0) {\\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\\n            // at which deposits can be created and therefore limit the potential for deposits to\\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\\n                (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\\n\\n            // Update base fee by adding the base fee delta and clamp the resulting value between\\n            // min and max.\\n            int256 newBaseFee = Arithmetic.clamp({\\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\\n                _min: int256(uint256(config.minimumBaseFee)),\\n                _max: int256(uint256(config.maximumBaseFee))\\n            });\\n\\n            // If we skipped more than one block, we also need to account for every empty block.\\n            // Empty block means there was no demand for deposits in that block, so we should\\n            // reflect this lack of demand in the fee.\\n            if (blockDiff > 1) {\\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\\n                // between min and max.\\n                newBaseFee = Arithmetic.clamp({\\n                    _value: Arithmetic.cdexp({\\n                        _coefficient: newBaseFee,\\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\\n                        _exponent: int256(blockDiff - 1)\\n                    }),\\n                    _min: int256(uint256(config.minimumBaseFee)),\\n                    _max: int256(uint256(config.maximumBaseFee))\\n                });\\n            }\\n\\n            // Update new base fee, reset bought gas, and update block number.\\n            params.prevBaseFee = uint128(uint256(newBaseFee));\\n            params.prevBoughtGas = 0;\\n            params.prevBlockNum = uint64(block.number);\\n        }\\n\\n        // Make sure we can actually buy the resource amount requested by the user.\\n        params.prevBoughtGas += _amount;\\n        require(\\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\\n            \\\"ResourceMetering: cannot buy more gas than available gas limit\\\"\\n        );\\n\\n        // Determine the amount of ETH to be paid.\\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\\n\\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\\n        // during any 1 day period in the last 5 years, so should be fine.\\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\\n\\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\\n        // effectively like a dynamic stipend (with a minimum value).\\n        uint256 usedGas = _initialGas - gasleft();\\n        if (gasCost > usedGas) {\\n            Burn.gas(gasCost - usedGas);\\n        }\\n    }\\n\\n    /**\\n     * @notice Virtual function that returns the resource config. Contracts that inherit this\\n     *         contract must implement this function.\\n     *\\n     * @return ResourceConfig\\n     */\\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\\n\\n    /**\\n     * @notice Sets initial resource parameter values. This function must either be called by the\\n     *         initializer function of an upgradeable child contract.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __ResourceMetering_init() internal onlyInitializing {\\n        if (params.prevBlockNum == 0) {\\n            params = ResourceParams({\\n                prevBaseFee: 1 gwei,\\n                prevBoughtGas: 0,\\n                prevBlockNum: uint64(block.number)\\n            });\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/SystemConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { ResourceMetering } from \\\"./ResourceMetering.sol\\\";\\n\\n/**\\n * @title SystemConfig\\n * @notice The SystemConfig contract is used to manage configuration of an Optimism network. All\\n *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2\\n *         chain.\\n */\\ncontract SystemConfig is OwnableUpgradeable, Semver {\\n    /**\\n     * @notice Enum representing different types of updates.\\n     *\\n     * @custom:value BATCHER              Represents an update to the batcher hash.\\n     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\\n     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\\n     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\\n     *                                    block distrubution.\\n     */\\n    enum UpdateType {\\n        BATCHER,                // Batcher submitter address\\n        GAS_CONFIG,             // L2 gas overhead/scalar\\n        GAS_LIMIT,              // L2 gas limit\\n        UNSAFE_BLOCK_SIGNER,    // L2 sequencer signer\\n        BASE_FEE                // L2 base fee\\n    }\\n\\n    /**\\n     * @notice Version identifier, used for upgrades.\\n     */\\n    uint256 public constant VERSION = 0;\\n\\n    /**\\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\\n     *         deterministic storage slot allows for decoupling the storage layout from the way\\n     *         that `solc` lays out storage. The `op-node` uses a storage proof to fetch this value.\\n     */\\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\\\"systemconfig.unsafeblocksigner\\\");\\n\\n    /**\\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\\n     */\\n    uint256 public overhead;\\n\\n    /**\\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\\n     */\\n    uint256 public scalar;\\n\\n    /**\\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\\n     *         as an address left-padded with zeros to 32 bytes.\\n     */\\n    bytes32 public batcherHash;\\n\\n    /**\\n     * @notice L2 block gas limit.\\n     */\\n    uint64 public gasLimit;\\n\\n    /**\\n     * @notice The configuration for the deposit fee market. Used by the OptimismPortal\\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\\n     *         so that the struct is returned instead of a tuple.\\n     */\\n    ResourceMetering.ResourceConfig internal _resourceConfig;\\n\\n    /**\\n     * @notice L2 block base fee.\\n     */\\n    uint256 public baseFee;\\n\\n    /**\\n     * @notice Emitted when configuration is updated\\n     *\\n     * @param version    SystemConfig version.\\n     * @param updateType Type of update.\\n     * @param data       Encoded update data.\\n     */\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n\\n    /**\\n     * @custom:semver 1.3.0\\n     *\\n     * @param _owner             Initial owner of the contract.\\n     * @param _overhead          Initial overhead value.\\n     * @param _scalar            Initial scalar value.\\n     * @param _batcherHash       Initial batcher hash.\\n     * @param _gasLimit          Initial gas limit.\\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\\n     * @param _config            Initial resource config.\\n     */\\n    constructor(\\n        address _owner,\\n        uint256 _overhead,\\n        uint256 _scalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        uint256 _baseFee,\\n        address _unsafeBlockSigner,\\n        ResourceMetering.ResourceConfig memory _config\\n    ) Semver(1, 3, 0) {\\n        initialize({\\n            _owner: _owner,\\n            _overhead: _overhead,\\n            _scalar: _scalar,\\n            _batcherHash: _batcherHash,\\n            _gasLimit: _gasLimit,\\n            _baseFee: _baseFee,\\n            _unsafeBlockSigner: _unsafeBlockSigner,\\n            _config: _config\\n        });\\n    }\\n\\n    /**\\n     * @notice Initializer. The resource config must be set before the\\n     *         require check.\\n     *\\n     * @param _owner             Initial owner of the contract.\\n     * @param _overhead          Initial overhead value.\\n     * @param _scalar            Initial scalar value.\\n     * @param _batcherHash       Initial batcher hash.\\n     * @param _gasLimit          Initial gas limit.\\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\\n     * @param _config            Initial ResourceConfig.\\n     */\\n    function initialize(\\n        address _owner,\\n        uint256 _overhead,\\n        uint256 _scalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        uint256 _baseFee,\\n        address _unsafeBlockSigner,\\n        ResourceMetering.ResourceConfig memory _config\\n    ) public initializer {\\n        __Ownable_init();\\n        transferOwnership(_owner);\\n        overhead = _overhead;\\n        scalar = _scalar;\\n        batcherHash = _batcherHash;\\n        gasLimit = _gasLimit;\\n        baseFee = _baseFee;\\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\\n        _setResourceConfig(_config);\\n        require(_gasLimit >= minimumGasLimit(), \\\"SystemConfig: gas limit too low\\\");\\n    }\\n\\n    /**\\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\\n     *         gas that is allocated for deposits per block plus the amount of gas that\\n     *         is allocated for the system transaction.\\n     *         This function is used to determine if changes to parameters are safe.\\n     *\\n     * @return uint64\\n     */\\n    function minimumGasLimit() public view returns (uint64) {\\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\\n    }\\n\\n    /**\\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\\n     *         propagated across the p2p network if they are signed by the key corresponding to\\n     *         this address.\\n     *\\n     * @return Address of the unsafe block signer.\\n     */\\n    // solhint-disable-next-line ordering\\n    function unsafeBlockSigner() external view returns (address) {\\n        address addr;\\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\\n        assembly {\\n            addr := sload(slot)\\n        }\\n        return addr;\\n    }\\n\\n    /**\\n     * @notice Updates the unsafe block signer address.\\n     *\\n     * @param _unsafeBlockSigner New unsafe block signer address.\\n     */\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\\n\\n        bytes memory data = abi.encode(_unsafeBlockSigner);\\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\\n    }\\n\\n    /**\\n     * @notice Updates the batcher hash.\\n     *\\n     * @param _batcherHash New batcher hash.\\n     */\\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\\n        batcherHash = _batcherHash;\\n\\n        bytes memory data = abi.encode(_batcherHash);\\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\\n    }\\n\\n    /**\\n     * @notice Updates gas config.\\n     *\\n     * @param _overhead New overhead value.\\n     * @param _scalar   New scalar value.\\n     */\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\\n        overhead = _overhead;\\n        scalar = _scalar;\\n\\n        bytes memory data = abi.encode(_overhead, _scalar);\\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\\n    }\\n\\n    /**\\n     * @notice Updates the L2 gas limit.\\n     *\\n     * @param _gasLimit New gas limit.\\n     */\\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\\n        require(_gasLimit >= minimumGasLimit(), \\\"SystemConfig: gas limit too low\\\");\\n        gasLimit = _gasLimit;\\n\\n        bytes memory data = abi.encode(_gasLimit);\\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\\n    }\\n\\n    /**\\n     * @notice Updates the L2 base fee.\\n     *\\n     * @param _baseFee New base fee.\\n     */\\n    function setBaseFee(uint256 _baseFee) external onlyOwner {\\n        baseFee = _baseFee;\\n\\n        bytes memory data = abi.encode(_baseFee);\\n        emit ConfigUpdate(VERSION, UpdateType.BASE_FEE, data);\\n    }\\n\\n    /**\\n     * @notice Low level setter for the unsafe block signer address. This function exists to\\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\\n     *\\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\\n     */\\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\\n        assembly {\\n            sstore(slot, _unsafeBlockSigner)\\n        }\\n    }\\n\\n    /**\\n     * @notice A getter for the resource config. Ensures that the struct is\\n     *         returned instead of a tuple.\\n     *\\n     * @return ResourceConfig\\n     */\\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\\n        return _resourceConfig;\\n    }\\n\\n    /**\\n     * @notice An external setter for the resource config. In the future, this\\n     *         method may emit an event that the `op-node` picks up for when the\\n     *         resource config is changed.\\n     *\\n     * @param _config The new resource config values.\\n     */\\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\\n        _setResourceConfig(_config);\\n    }\\n\\n    /**\\n     * @notice An internal setter for the resource config. Ensures that the\\n     *         config is sane before storing it by checking for invariants.\\n     *\\n     * @param _config The new resource config.\\n     */\\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\\n        // Min base fee must be less than or equal to max base fee.\\n        require(\\n            _config.minimumBaseFee <= _config.maximumBaseFee,\\n            \\\"SystemConfig: min base fee must be less than max base\\\"\\n        );\\n        // Base fee change denominator must be greater than 1.\\n        require(\\n            _config.baseFeeMaxChangeDenominator > 1,\\n            \\\"SystemConfig: denominator must be larger than 1\\\"\\n        );\\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\\n        // The gas limit must be increased before these values can be increased.\\n        require(\\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\\n            \\\"SystemConfig: gas limit too low\\\"\\n        );\\n        // Elasticity multiplier must be greater than 0.\\n        require(\\n            _config.elasticityMultiplier > 0,\\n            \\\"SystemConfig: elasticity multiplier cannot be 0\\\"\\n        );\\n        // No precision loss when computing target resource limit.\\n        require(\\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\\n            \\\"SystemConfig: precision loss with target resource limit\\\"\\n        );\\n\\n        _resourceConfig = _config;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2/L2CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { AddressAliasHelper } from \\\"../vendor/AddressAliasHelper.sol\\\";\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { CrossDomainMessenger } from \\\"../universal/CrossDomainMessenger.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { L2ToL1MessagePasser } from \\\"./L2ToL1MessagePasser.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"../libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\nimport { L1CrossDomainMessenger } from \\\"../L1/L1CrossDomainMessenger.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @custom:predeploy 0x4200000000000000000000000000000000000007\\n * @title L2CrossDomainMessenger\\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\\n *         level message passing contracts.\\n */\\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice Address of the Mantle Token on L1.\\n     */\\n    address public immutable L1_MNT_ADDRESS;\\n\\n    /**\\n     * @custom:semver 1.5.0\\n     *\\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\\n     */\\n    constructor(address _l1CrossDomainMessenger, address l1mnt)\\n        Semver(1, 5, 0)\\n        CrossDomainMessenger(_l1CrossDomainMessenger)\\n    {\\n        L1_MNT_ADDRESS = l1mnt;\\n        initialize();\\n    }\\n\\n    /**\\n     * @notice Initializer.\\n     */\\n    function initialize() public initializer {\\n        __CrossDomainMessenger_init();\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\\n     *\\n     * @return Address of the L1CrossDomainMessenger contract.\\n     */\\n    function l1CrossDomainMessenger() public view returns (address) {\\n        return OTHER_MESSENGER;\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _sendMessage(\\n        uint256 _ethValue,\\n        address _to,\\n        uint64 _gasLimit,\\n        bytes memory _data\\n    ) internal override {\\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\\n            value: msg.value\\n        }(_ethValue, _to, _gasLimit, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function sendMessage(\\n        uint256 _ethAmount,\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable override {\\n        require(_target!=tx.origin || msg.value==0, \\\"once target is an EOA, msg.value must be zero\\\");\\n        require(_target != L1_MNT_ADDRESS, \\\"target must not be MNT address on L1\\\");\\n        if (_ethAmount != 0) {\\n            IERC20(Predeploys.BVM_ETH).safeTransferFrom(msg.sender, address(this), _ethAmount);\\n        }\\n\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            _ethAmount,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                L1CrossDomainMessenger.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                msg.value,\\n                _ethAmount,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, msg.value, _ethAmount);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable override {\\n        require(_target!=tx.origin || msg.value==0, \\\"once target is an EOA, msg.value must be zero\\\");\\n        require(_target != L1_MNT_ADDRESS, \\\"target must not be MNT address on L1\\\");\\n\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            0,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                L1CrossDomainMessenger.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                msg.value,\\n                0,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, msg.value, 0);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n     *         be executed via cross-chain call from the other messenger OR if the message was\\n     *         already received once and is currently being replayed.\\n     *\\n     * @param _nonce       Nonce of the message being relayed.\\n     * @param _sender      Address of the user who sent the message.\\n     * @param _target      Address that the message is targeted at.\\n     * @param _mntValue    MNT value to send with the message.\\n     * @param _ethValue    ETH value to send with the message.\\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n     * @param _message     Message to send to the target.\\n     */\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    ) external payable override {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(\\n            version < 2,\\n            \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\"\\n        );\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(\\n                successfulMessages[oldHash] == false,\\n                \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\"\\n            );\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\\n            _nonce,\\n            _sender,\\n            _target,\\n            _mntValue,\\n            _ethValue,\\n            _minGasLimit,\\n            _message\\n        );\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _mntValue);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(\\n                msg.value == 0,\\n                \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\"\\n            );\\n\\n            require(\\n                failedMessages[versionedHash],\\n                \\\"CrossDomainMessenger: message cannot be replayed\\\"\\n            );\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false,\\n            \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(\\n            successfulMessages[versionedHash] == false,\\n            \\\"CrossDomainMessenger: message has already been relayed\\\"\\n        );\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\\n        xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n        if (_ethValue != 0) {\\n            // The ethSuccess variable of approve is either true or the approve function reverted.\\n            // It will never be false whenever its value is evaluated.\\n            IERC20(Predeploys.BVM_ETH).approve(_target, _ethValue);\\n        }\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _mntValue, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n        if (_ethValue != 0) {\\n            IERC20(Predeploys.BVM_ETH).approve(_target, 0);\\n        }\\n\\n        if (success) {\\n            require(!successfulMessages[versionedHash], \\\"versionedHash has already be marked as successful\\\");\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _isOtherMessenger() internal view override returns (bool) {\\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\\n    }\\n\\n    /**\\n     * @inheritdoc CrossDomainMessenger\\n     */\\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2/L2ERC721Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC721Bridge } from \\\"../universal/ERC721Bridge.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { L1ERC721Bridge } from \\\"../L1/L1ERC721Bridge.sol\\\";\\nimport { IOptimismMintableERC721 } from \\\"../universal/IOptimismMintableERC721.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\n\\n/**\\n * @title L2ERC721Bridge\\n * @notice The L2 ERC721 bridge is a contract which works together with the L1 ERC721 bridge to\\n *         make it possible to transfer ERC721 tokens from Ethereum to Optimism. This contract\\n *         acts as a minter for new tokens when it hears about deposits into the L1 ERC721 bridge.\\n *         This contract also acts as a burner for tokens being withdrawn.\\n *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\\n *         bridge ONLY supports ERC721s originally deployed on Ethereum. Users will need to\\n *         wait for the one-week challenge period to elapse before their Optimism-native NFT\\n *         can be refunded on L2.\\n */\\ncontract L2ERC721Bridge is ERC721Bridge, Semver {\\n    /**\\n     * @custom:semver 1.1.0\\n     *\\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\\n     */\\n    constructor(address _messenger, address _otherBridge)\\n        Semver(1, 1, 0)\\n        ERC721Bridge(_messenger, _otherBridge)\\n    {}\\n\\n    /**\\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\\n     *         recipient on this domain.\\n     *\\n     * @param _localToken  Address of the ERC721 token on this domain.\\n     * @param _remoteToken Address of the ERC721 token on the other domain.\\n     * @param _from        Address that triggered the bridge on the other domain.\\n     * @param _to          Address to receive the token on this domain.\\n     * @param _tokenId     ID of the token being deposited.\\n     * @param _extraData   Optional data to forward to L1. Data supplied here will not be used to\\n     *                     execute any code on L1 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function finalizeBridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes calldata _extraData\\n    ) external onlyOtherBridge {\\n        require(_localToken != address(this), \\\"L2ERC721Bridge: local token cannot be self\\\");\\n\\n        // Note that supportsInterface makes a callback to the _localToken address which is user\\n        // provided.\\n        require(\\n            ERC165Checker.supportsInterface(_localToken, type(IOptimismMintableERC721).interfaceId),\\n            \\\"L2ERC721Bridge: local token interface is not compliant\\\"\\n        );\\n\\n        require(\\n            _remoteToken == IOptimismMintableERC721(_localToken).remoteToken(),\\n            \\\"L2ERC721Bridge: wrong remote token for Optimism Mintable ERC721 local token\\\"\\n        );\\n\\n        // When a deposit is finalized, we give the NFT with the same tokenId to the account\\n        // on L2. Note that safeMint makes a callback to the _to address which is user provided.\\n        IOptimismMintableERC721(_localToken).safeMint(_to, _tokenId);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721Bridge\\n     */\\n    function _initiateBridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) internal override {\\n        require(_remoteToken != address(0), \\\"L2ERC721Bridge: remote token cannot be address(0)\\\");\\n\\n        // Check that the withdrawal is being initiated by the NFT owner\\n        require(\\n            _from == IOptimismMintableERC721(_localToken).ownerOf(_tokenId),\\n            \\\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\\\"\\n        );\\n\\n        // Construct calldata for l1ERC721Bridge.finalizeBridgeERC721(_to, _tokenId)\\n        // slither-disable-next-line reentrancy-events\\n        address remoteToken = IOptimismMintableERC721(_localToken).remoteToken();\\n        require(\\n            remoteToken == _remoteToken,\\n            \\\"L2ERC721Bridge: remote token does not match given value\\\"\\n        );\\n\\n        // When a withdrawal is initiated, we burn the withdrawer's NFT to prevent subsequent L2\\n        // usage\\n        // slither-disable-next-line reentrancy-events\\n        IOptimismMintableERC721(_localToken).burn(_from, _tokenId);\\n\\n        bytes memory message = abi.encodeWithSelector(\\n            L1ERC721Bridge.finalizeBridgeERC721.selector,\\n            remoteToken,\\n            _localToken,\\n            _from,\\n            _to,\\n            _tokenId,\\n            _extraData\\n        );\\n\\n        // Send message to L1 bridge\\n        // slither-disable-next-line reentrancy-events\\n        MESSENGER.sendMessage(0, OTHER_BRIDGE, message, _minGasLimit);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ERC721BridgeInitiated(_localToken, remoteToken, _from, _to, _tokenId, _extraData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2/L2StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { StandardBridge } from \\\"../universal/StandardBridge.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { OptimismMintableERC20 } from \\\"../universal/OptimismMintableERC20.sol\\\";\\nimport { L1StandardBridge } from \\\"../L1/L1StandardBridge.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @custom:predeploy 0x4200000000000000000000000000000000000010\\n * @title L2StandardBridge\\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\\n *         contract. If the ERC20 token is native to L1, it will be burnt.\\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\\n *         of some token types that may not be properly supported by this contract include, but are\\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\\n */\\ncontract L2StandardBridge is StandardBridge, Semver {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable L1_MNT_ADDRESS;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a withdrawal from L2 to L1 is initiated.\\n     *\\n     * @param l1Token   Address of the token on L1.\\n     * @param l2Token   Address of the corresponding token on L2.\\n     * @param from      Address of the withdrawer.\\n     * @param to        Address of the recipient on L1.\\n     * @param amount    Amount of the ERC20 withdrawn.\\n     * @param extraData Extra data attached to the withdrawal.\\n     */\\n    event WithdrawalInitiated(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever an ERC20 deposit is finalized.\\n     *\\n     * @param l1Token   Address of the token on L1.\\n     * @param l2Token   Address of the corresponding token on L2.\\n     * @param from      Address of the depositor.\\n     * @param to        Address of the recipient on L2.\\n     * @param amount    Amount of the ERC20 deposited.\\n     * @param extraData Extra data attached to the deposit.\\n     */\\n    event DepositFinalized(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @custom:semver 1.1.0\\n     *\\n     * @param _otherBridge Address of the L1StandardBridge.\\n     */\\n    constructor(address payable _otherBridge, address _l1mnt)\\n        Semver(1, 1, 0)\\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\\n    {\\n        L1_MNT_ADDRESS = _l1mnt;\\n    }\\n\\n    /**\\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n     */\\n    receive() external payable override onlyEOA {\\n        _initiateBridgeMNT(\\n            msg.sender,\\n            msg.sender,\\n            msg.value,\\n            RECEIVE_DEFAULT_GAS_LIMIT,\\n            bytes(\\\"\\\")\\n        );\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Initiates a withdrawal from L2 to L1.\\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\\n     *         `bridgeERC20` function to bridge native L2 tokens to L1.\\n     *\\n     * @param _l2Token     Address of the L2 token to withdraw.\\n     * @param _amount      Amount of the L2 token to withdraw.\\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\\n     * @param _extraData   Extra data attached to the withdrawal.\\n     */\\n    function withdraw(\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external payable onlyEOA {\\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Initiates a withdrawal from L2 to L1 to a target account on L1.\\n     *         Note that if ETH is sent to a contract on L1 and the call fails, then that ETH will\\n     *         be locked in the L1StandardBridge. ETH may be recoverable if the call can be\\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\\n     *         `bridgeERC20To` function to bridge native L2 tokens to L1.\\n     *\\n     * @param _l2Token     Address of the L2 token to withdraw.\\n     * @param _to          Recipient account on L1.\\n     * @param _amount      Amount of the L2 token to withdraw.\\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\\n     * @param _extraData   Extra data attached to the withdrawal.\\n     */\\n    function withdrawTo(\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external payable {\\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Finalizes a deposit from L1 to L2. To finalize a deposit of ether, use address(0)\\n     *         and the l1Token and the Legacy ERC20 ether predeploy address as the l2Token.\\n     *\\n     * @param _l1Token   Address of the L1 token to deposit.\\n     * @param _l2Token   Address of the corresponding L2 token.\\n     * @param _from      Address of the depositor.\\n     * @param _to        Address of the recipient.\\n     * @param _amount    Amount of the tokens being deposited.\\n     * @param _extraData Extra data attached to the deposit.\\n     */\\n    function finalizeDeposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) external payable {\\n        if (_l1Token == L1_MNT_ADDRESS && _l2Token == Predeploys.LEGACY_ERC20_MNT) {\\n            finalizeBridgeMNT(_from, _to, _amount, _extraData);\\n        } else if (_l1Token == address(0) && _l2Token == Predeploys.BVM_ETH) {\\n            finalizeBridgeETH(_from, _to, _amount, _extraData);\\n        } else {\\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _extraData);\\n        }\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Retrieves the access of the corresponding L1 bridge contract.\\n     *\\n     * @return Address of the corresponding L1 bridge contract.\\n     */\\n    function l1TokenBridge() external view returns (address) {\\n        return address(OTHER_BRIDGE);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Internal function to a withdrawal from L2 to L1 to a target account on L1.\\n     *\\n     * @param _l2Token     Address of the L2 token to withdraw.\\n     * @param _from        Address of the withdrawer.\\n     * @param _to          Recipient account on L1.\\n     * @param _amount      Amount of the L2 token to withdraw.\\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\\n     * @param _extraData   Extra data attached to the withdrawal.\\n     */\\n    function _initiateWithdrawal(\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal {\\n        if (_l2Token == Predeploys.BVM_ETH) {\\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _extraData);\\n        } else if (_l2Token == address(0)) {\\n            _initiateBridgeMNT(_from, _to, _amount, _minGasLimit, _extraData);\\n        } else {\\n            address l1Token = OptimismMintableERC20(_l2Token).l1Token();\\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _extraData);\\n        }\\n    }\\n\\n    /**\\n * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of ETH being bridged.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(msg.value==0, \\\"L2StandardBridge: the MNT value should be zero. \\\");\\n        IERC20(Predeploys.BVM_ETH).safeTransferFrom(msg.sender, address(this), _amount);\\n        IERC20(Predeploys.BVM_ETH).approve(Predeploys.L2_CROSS_DOMAIN_MESSENGER, _amount);\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n\\n        MESSENGER.sendMessage(\\n            _amount,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                L1StandardBridge.finalizeBridgeETH.selector,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends MNT tokens to a receiver's address on the other chain.\\n     *\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(\\n            msg.value == _amount,\\n            \\\"StandardBridge: bridging MNT must include sufficient MNT value\\\"\\n        );\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitMNTBridgeInitiated(_from, _to, _amount, _extraData);\\n        uint256 zeroETHValue = 0;\\n        MESSENGER.sendMessage{value: msg.value}(\\n            zeroETHValue,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                L1StandardBridge.finalizeBridgeMNT.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n * @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal override {\\n        require(msg.value==0, \\\"L2StandardBridge: the MNT value should be zero. \\\");\\n        require(_localToken != Predeploys.BVM_ETH && _remoteToken != address(0),\\n            \\\"L2StandardBridge: BridgeERC20 do not support ETH bridging.\\\");\\n        require(_localToken != address(0x0) && _remoteToken != L1_MNT_ADDRESS,\\n            \\\"L2StandardBridge: BridgeERC20 do not support MNT bridging.\\\");\\n\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\\n        } else {\\n            uint256 balanceBefore = IERC20(_localToken).balanceOf(address(this));\\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\\n            uint256 balanceAfter = IERC20(_localToken).balanceOf(address(this));\\n            uint256 receivedAmount = balanceAfter - balanceBefore;\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + receivedAmount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n\\n        MESSENGER.sendMessage(\\n            0,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                this.finalizeBridgeERC20.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _remoteToken,\\n                _localToken,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n    /**\\n     * @notice Emits the legacy WithdrawalInitiated event followed by the ETHBridgeInitiated event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit WithdrawalInitiated(\\n            address(0),\\n            Predeploys.BVM_ETH,\\n            _from,\\n            _to,\\n            _amount,\\n            _extraData\\n        );\\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy DepositFinalized event followed by the ETHBridgeFinalized event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit DepositFinalized(\\n            address(0),\\n            Predeploys.BVM_ETH,\\n            _from,\\n            _to,\\n            _amount,\\n            _extraData\\n        );\\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy WithdrawalInitiated event followed by the ERC20BridgeInitiated\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit WithdrawalInitiated(_remoteToken, _localToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy DepositFinalized event followed by the ERC20BridgeFinalized event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit DepositFinalized(_remoteToken, _localToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the legacy WithdrawalInitiated event followed by the MNTBridgeInitiated\\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitMNTBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit WithdrawalInitiated(L1_MNT_ADDRESS, address(0x0), _from, _to, _amount, _extraData);\\n        super._emitMNTBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n * @notice Emits the legacy DepositFinalized event followed by the ERC20BridgeFinalized event.\\n     *         This is necessary for backwards compatibility with the legacy bridge.\\n     *\\n     * @inheritdoc StandardBridge\\n     */\\n    function _emitMNTBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal override {\\n        emit DepositFinalized(L1_MNT_ADDRESS, address(0x0), _from, _to, _amount, _extraData);\\n        super._emitMNTBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ETH to the sender's address on the other chain.\\n     *\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeETH(uint256 _value, uint32 _minGasLimit, bytes calldata _extraData) public onlyEOA {\\n        _initiateBridgeETH(msg.sender, msg.sender, _value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n     *         in that case.\\n     *\\n     * @param _value       Amount of the BVM_ETH.\\n     * @param _to          Address of the receiver.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeETHTo(\\n        uint256 _value,\\n        address _to,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public {\\n        _initiateBridgeETH(msg.sender, _to, _value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n * @notice Sends MNT to a receiver's address on the other chain. Note that if MNT is sent to a\\n     *         smart contract and the call fails, the MNT will be temporarily locked in the\\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n     *         replayed with any amount of gas (call always reverts), then the MNT will be\\n     *         permanently locked in the StandardBridge on the other chain. MNT will also\\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n     *         in that case.\\n     *\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeMNT(\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public payable onlyEOA {\\n        _initiateBridgeMNT(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends MNT to a receiver's address on the other chain. Note that if MNT is sent to a\\n     *         smart contract and the call fails, the MNT will be temporarily locked in the\\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n     *         replayed with any amount of gas (call always reverts), then the MNT will be\\n     *         permanently locked in the StandardBridge on the other chain. MNT will also\\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n     *         in that case.\\n     * @param _to Address of the receiver.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeMNTTo(\\n        address _to,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public payable {\\n        _initiateBridgeMNT(msg.sender, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public onlyEOA override {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            msg.sender,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public override {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            _to,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from      Address of the sender.\\n     * @param _to        Address of the receiver.\\n     * @param _amount    Amount of ETH being bridged.\\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\\n     *                   not be triggered with this data, but it will be emitted and can be used\\n     *                   to identify the transaction.\\n     */\\n    function finalizeBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable override onlyOtherBridge {\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(MESSENGER), \\\"StandardBridge: cannot send to messenger\\\");\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n\\n        //move the BVM_ETH mint to op-geth.\\n        IERC20(Predeploys.BVM_ETH).safeTransferFrom(Predeploys.L2_CROSS_DOMAIN_MESSENGER, _to, _amount);\\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n\\n    }\\n\\n    /**\\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the ERC20 being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public onlyOtherBridge override {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\\n        } else {\\n            uint256 balanceBefore = IERC20(_localToken).balanceOf(address(this));\\n            IERC20(_localToken).safeTransfer(_to, _amount);\\n            uint256 balanceAfter = IERC20(_localToken).balanceOf(address(this));\\n            uint256 sentAmount = balanceBefore - balanceAfter;\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - sentAmount;\\n        }\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n* @notice Finalizes an MNT bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable override virtual onlyOtherBridge {\\n        require(msg.value == _amount, \\\"StandardBridge: amount sent does not match amount required\\\");\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(MESSENGER), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\\\"\\\");\\n        require(success, \\\"StandardBridge: MNT transfer failed\\\");\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitMNTBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2/L2ToL1MessagePasser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Types } from \\\"../libraries/Types.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"../libraries/Encoding.sol\\\";\\nimport { Burn } from \\\"../libraries/Burn.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { OptimismMintableERC20 } from \\\"../universal/OptimismMintableERC20.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @custom:predeploy 0x4200000000000000000000000000000000000016\\n * @title L2ToL1MessagePasser\\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\\n */\\ncontract L2ToL1MessagePasser is Semver {\\n    /**\\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\\n     */\\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\\n\\n    /**\\n     * @notice Current message version identifier.\\n     */\\n    uint16 public constant MESSAGE_VERSION = 1;\\n\\n    /**\\n     * @notice MNT Token Address on Ethereum\\n     */\\n    address public immutable L1_MNT_ADDRESS;\\n\\n    /**\\n     * @notice Includes the message hashes for all withdrawals\\n     */\\n    mapping(bytes32 => bool) public sentMessages;\\n\\n    /**\\n     * @notice A unique value hashed with each withdrawal.\\n     */\\n    uint240 internal msgNonce;\\n\\n    /**\\n     * @notice Emitted any time a withdrawal is initiated.\\n     *\\n     * @param nonce          Unique value corresponding to each withdrawal.\\n     * @param sender         The L2 account address which initiated the withdrawal.\\n     * @param target         The L1 account address the call will be send to.\\n     * @param mntValue       The MNT value submitted for withdrawal, to be forwarded to the target.\\n     * @param ethValue       The ETH value submitted for withdrawal, to be forwarded to the target.\\n     * @param gasLimit       The minimum amount of gas that must be provided when withdrawing.\\n     * @param data           The data to be forwarded to the target on L1.\\n     * @param withdrawalHash The hash of the withdrawal.\\n     */\\n    event MessagePassed(\\n        uint256 indexed nonce,\\n        address indexed sender,\\n        address indexed target,\\n        uint256 mntValue,\\n        uint256 ethValue,\\n        uint256 gasLimit,\\n        bytes data,\\n        bytes32 withdrawalHash\\n    );\\n\\n    /**\\n     * @notice Emitted when the balance of this contract is burned.\\n     *\\n     * @param amount Amount of MNT that was burned.\\n     */\\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\\n\\n    /**\\n     * @custom:semver 1.0.0\\n     */\\n    constructor(address _l1mnt) Semver(1, 0, 0) {\\n        L1_MNT_ADDRESS = _l1mnt;\\n    }\\n\\n    /**\\n     * @notice Allows users to withdraw MNT by sending directly to this contract.\\n     */\\n    receive() external payable {\\n        initiateWithdrawal(0, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @notice Removes all MNT held by this contract from the state. Used to prevent the amount of\\n     *         MNT on L2 inflating when MNT is withdrawn. Currently only way to do this is to\\n     *         create a contract and self-destruct it to itself. Anyone can call this function. Not\\n     *         incentivized since this function is very cheap.\\n     */\\n    function burn() external {\\n        uint256 balance = address(this).balance;\\n        (bool success, ) = address(0).call{value: balance}(\\\"\\\");\\n        require(success, \\\"Failed to burn MNT\\\");\\n        emit WithdrawerBalanceBurnt(balance);\\n    }\\n\\n    /**\\n     * @notice Sends a message from L2 to L1.\\n     *\\n     * @param _ethValue eth amount bridged to L1.\\n     * @param _target   Address to call on L1 execution.\\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\\n     * @param _data     Data to forward to L1 target.\\n     */\\n    function initiateWithdrawal(\\n        uint256 _ethValue,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) public payable {\\n        require(_target != L1_MNT_ADDRESS, \\\"Directly calling MNT Token is forbidden\\\");\\n        if (_ethValue != 0) {\\n            OptimismMintableERC20(Predeploys.BVM_ETH).burn(msg.sender, _ethValue);\\n        }\\n\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\\n            Types.WithdrawalTransaction({\\n                nonce: messageNonce(),\\n                sender: msg.sender,\\n                target: _target,\\n                mntValue: msg.value,\\n                ethValue: _ethValue,\\n                gasLimit: _gasLimit,\\n                data: _data\\n            })\\n        );\\n\\n        sentMessages[withdrawalHash] = true;\\n\\n        emit MessagePassed(\\n            messageNonce(),\\n            msg.sender,\\n            _target,\\n            msg.value,\\n            _ethValue,\\n            _gasLimit,\\n            _data,\\n            withdrawalHash\\n        );\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\\n     *         bytes of the message nonce. Message version allows us to treat messages as having\\n     *         different structures.\\n     *\\n     * @return Nonce of the next message to be sent, with added message version.\\n     */\\n    function messageNonce() public view returns (uint256) {\\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deployment/PortalSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { OptimismPortal } from \\\"../L1/OptimismPortal.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title PortalSender\\n * @notice The PortalSender is a simple intermediate contract that will transfer the balance of the\\n *         L1StandardBridge to the OptimismPortal during the Bedrock migration.\\n */\\ncontract PortalSender {\\n    /**\\n     * @notice Address of the OptimismPortal contract.\\n     */\\n    OptimismPortal public immutable PORTAL;\\n\\n    /**\\n     * @param _portal Address of the OptimismPortal contract.\\n     */\\n    constructor(OptimismPortal _portal) {\\n        PORTAL = _portal;\\n    }\\n\\n    /**\\n     * @notice Sends balance of this contract to the OptimismPortal.\\n                on the Mantle Mainnet, this function will donate ETH and MNT\\n     */\\n    function donate() external {\\n        uint256 totalAmount = IERC20(PORTAL.L1_MNT_ADDRESS()).balanceOf(address(this));\\n        bool succ = IERC20(PORTAL.L1_MNT_ADDRESS()).transfer(address(PORTAL),totalAmount);\\n        require(succ,\\\"donate mnt failed\\\");\\n        PORTAL.donateETH{ value: address(this).balance }();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deployment/SystemDictator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { L2OutputOracle } from \\\"../L1/L2OutputOracle.sol\\\";\\nimport { OptimismPortal } from \\\"../L1/OptimismPortal.sol\\\";\\nimport { L1CrossDomainMessenger } from \\\"../L1/L1CrossDomainMessenger.sol\\\";\\nimport { L1ERC721Bridge } from \\\"../L1/L1ERC721Bridge.sol\\\";\\nimport { L1StandardBridge } from \\\"../L1/L1StandardBridge.sol\\\";\\nimport { L1ChugSplashProxy } from \\\"../legacy/L1ChugSplashProxy.sol\\\";\\nimport { AddressManager } from \\\"../legacy/AddressManager.sol\\\";\\nimport { Proxy } from \\\"../universal/Proxy.sol\\\";\\nimport { ProxyAdmin } from \\\"../universal/ProxyAdmin.sol\\\";\\nimport { OptimismMintableERC20Factory } from \\\"../universal/OptimismMintableERC20Factory.sol\\\";\\nimport { PortalSender } from \\\"./PortalSender.sol\\\";\\nimport { SystemConfig } from \\\"../L1/SystemConfig.sol\\\";\\nimport { ResourceMetering } from \\\"../L1/ResourceMetering.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\n\\n/**\\n * @title SystemDictator\\n * @notice The SystemDictator is responsible for coordinating the deployment of a full Bedrock\\n *         system. The SystemDictator is designed to support both fresh network deployments and\\n *         upgrades to existing pre-Bedrock systems.\\n */\\ncontract SystemDictator is OwnableUpgradeable {\\n    /**\\n     * @notice Basic system configuration.\\n     */\\n    struct GlobalConfig {\\n        AddressManager addressManager;\\n        ProxyAdmin proxyAdmin;\\n        address controller;\\n        address finalOwner;\\n    }\\n\\n    /**\\n     * @notice Set of proxy addresses.\\n     */\\n    struct ProxyAddressConfig {\\n        address l2OutputOracleProxy;\\n        address optimismPortalProxy;\\n        address l1CrossDomainMessengerProxy;\\n        address l1StandardBridgeProxy;\\n        address optimismMintableERC20FactoryProxy;\\n        address l1ERC721BridgeProxy;\\n        address systemConfigProxy;\\n    }\\n\\n    /**\\n     * @notice Set of implementation addresses.\\n     */\\n    struct ImplementationAddressConfig {\\n        L2OutputOracle l2OutputOracleImpl;\\n        OptimismPortal optimismPortalImpl;\\n        L1CrossDomainMessenger l1CrossDomainMessengerImpl;\\n        L1StandardBridge l1StandardBridgeImpl;\\n        OptimismMintableERC20Factory optimismMintableERC20FactoryImpl;\\n        L1ERC721Bridge l1ERC721BridgeImpl;\\n        PortalSender portalSenderImpl;\\n        SystemConfig systemConfigImpl;\\n    }\\n\\n    /**\\n     * @notice Dynamic L2OutputOracle config.\\n     */\\n    struct L2OutputOracleDynamicConfig {\\n        uint256 l2OutputOracleStartingBlockNumber;\\n        uint256 l2OutputOracleStartingTimestamp;\\n    }\\n\\n    /**\\n     * @notice Values for the system config contract.\\n     */\\n    struct SystemConfigConfig {\\n        address owner;\\n        uint256 overhead;\\n        uint256 scalar;\\n        bytes32 batcherHash;\\n        uint64 gasLimit;\\n        uint256 baseFee;\\n        address unsafeBlockSigner;\\n        ResourceMetering.ResourceConfig resourceConfig;\\n    }\\n\\n    /**\\n     * @notice Combined system configuration.\\n     */\\n    struct DeployConfig {\\n        GlobalConfig globalConfig;\\n        ProxyAddressConfig proxyAddressConfig;\\n        ImplementationAddressConfig implementationAddressConfig;\\n        SystemConfigConfig systemConfigConfig;\\n    }\\n\\n    /**\\n     * @notice Step after which exit 1 can no longer be used.\\n     */\\n    uint8 public constant EXIT_1_NO_RETURN_STEP = 3;\\n\\n    /**\\n     * @notice Step where proxy ownership is transferred.\\n     */\\n    uint8 public constant PROXY_TRANSFER_STEP = 4;\\n\\n    /**\\n     * @notice System configuration.\\n     */\\n    DeployConfig public config;\\n\\n    /**\\n     * @notice Dynamic configuration for the L2OutputOracle.\\n     */\\n    L2OutputOracleDynamicConfig public l2OutputOracleDynamicConfig;\\n\\n    /**\\n     * @notice Dynamic configuration for the OptimismPortal. Determines\\n     *         if the system should be paused when initialized.\\n     */\\n    bool public optimismPortalDynamicConfig;\\n\\n    /**\\n     * @notice Current step;\\n     */\\n    uint8 public currentStep;\\n\\n    /**\\n     * @notice Whether or not dynamic config has been set.\\n     */\\n    bool public dynamicConfigSet;\\n\\n    /**\\n     * @notice Whether or not the deployment is finalized.\\n     */\\n    bool public finalized;\\n\\n    /**\\n     * @notice Whether or not the deployment has been exited.\\n     */\\n    bool public exited;\\n\\n    /**\\n     * @notice Address of the old L1CrossDomainMessenger implementation.\\n     */\\n    address public oldL1CrossDomainMessenger;\\n\\n    /**\\n     * @notice Checks that the current step is the expected step, then bumps the current step.\\n     *\\n     * @param _step Current step.\\n     */\\n    modifier step(uint8 _step) {\\n        require(!finalized, \\\"SystemDictator: already finalized\\\");\\n        require(!exited, \\\"SystemDictator: already exited\\\");\\n        require(currentStep == _step, \\\"SystemDictator: incorrect step\\\");\\n        _;\\n        currentStep++;\\n    }\\n\\n    /**\\n     * @notice Constructor required to ensure that the implementation of the SystemDictator is\\n     *         initialized upon deployment.\\n     */\\n    constructor() {\\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\\n\\n        // Using this shorter variable as an alias for address(0) just prevents us from having to\\n        // to use a new line for every single parameter.\\n        address zero = address(0);\\n        initialize(\\n            DeployConfig(\\n                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),\\n                ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero),\\n                ImplementationAddressConfig(\\n                    L2OutputOracle(zero),\\n                    OptimismPortal(payable(zero)),\\n                    L1CrossDomainMessenger(zero),\\n                    L1StandardBridge(payable(zero)),\\n                    OptimismMintableERC20Factory(zero),\\n                    L1ERC721Bridge(zero),\\n                    PortalSender(zero),\\n                    SystemConfig(zero)\\n                ),\\n                SystemConfigConfig(zero, 0, 0, bytes32(0), 0, 0, zero, rcfg)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @param _config System configuration.\\n     */\\n    function initialize(DeployConfig memory _config) public initializer {\\n        config = _config;\\n        currentStep = 1;\\n        __Ownable_init();\\n        _transferOwnership(config.globalConfig.controller);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to update dynamic config.\\n     *\\n     * @param _l2OutputOracleDynamicConfig Dynamic L2OutputOracle config.\\n     * @param _optimismPortalDynamicConfig Dynamic OptimismPortal config.\\n     */\\n    function updateDynamicConfig(\\n        L2OutputOracleDynamicConfig memory _l2OutputOracleDynamicConfig,\\n        bool _optimismPortalDynamicConfig\\n    ) external onlyOwner {\\n        l2OutputOracleDynamicConfig = _l2OutputOracleDynamicConfig;\\n        optimismPortalDynamicConfig = _optimismPortalDynamicConfig;\\n        dynamicConfigSet = true;\\n    }\\n\\n    /**\\n     * @notice Configures the ProxyAdmin contract.\\n     */\\n    function step1() public onlyOwner step(1) {\\n        // Set the AddressManager in the ProxyAdmin.\\n        config.globalConfig.proxyAdmin.setAddressManager(config.globalConfig.addressManager);\\n\\n        // Set the L1CrossDomainMessenger to the RESOLVED proxy type.\\n        config.globalConfig.proxyAdmin.setProxyType(\\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\\n            ProxyAdmin.ProxyType.RESOLVED\\n        );\\n\\n        // Set the implementation name for the L1CrossDomainMessenger.\\n        config.globalConfig.proxyAdmin.setImplementationName(\\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\\n            \\\"BVM_L1CrossDomainMessenger\\\"\\n        );\\n\\n        // Set the L1StandardBridge to the CHUGSPLASH proxy type.\\n        config.globalConfig.proxyAdmin.setProxyType(\\n            config.proxyAddressConfig.l1StandardBridgeProxy,\\n            ProxyAdmin.ProxyType.CHUGSPLASH\\n        );\\n\\n        // Upgrade and initialize the SystemConfig so the Sequencer can start up.\\n        config.globalConfig.proxyAdmin.upgradeAndCall(\\n            payable(config.proxyAddressConfig.systemConfigProxy),\\n            address(config.implementationAddressConfig.systemConfigImpl),\\n            abi.encodeCall(\\n                SystemConfig.initialize,\\n                (\\n                    config.systemConfigConfig.owner,\\n                    config.systemConfigConfig.overhead,\\n                    config.systemConfigConfig.scalar,\\n                    config.systemConfigConfig.batcherHash,\\n                    config.systemConfigConfig.gasLimit,\\n                    config.systemConfigConfig.baseFee,\\n                    config.systemConfigConfig.unsafeBlockSigner,\\n                    config.systemConfigConfig.resourceConfig\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Pauses the system by shutting down the L1CrossDomainMessenger and setting the\\n     *         deposit halt flag to tell the Sequencer's DTL to stop accepting deposits.\\n     */\\n    function step2() public onlyOwner step(2) {\\n        // Store the address of the old L1CrossDomainMessenger implementation. We will need this\\n        // address in the case that we have to exit early.\\n        oldL1CrossDomainMessenger = config.globalConfig.addressManager.getAddress(\\n            \\\"BVM_L1CrossDomainMessenger\\\"\\n        );\\n\\n        // Temporarily brick the L1CrossDomainMessenger by setting its implementation address to\\n        // address(0) which will cause the ResolvedDelegateProxy to revert. Better than pausing\\n        // the L1CrossDomainMessenger via pause() because it can be easily reverted.\\n        config.globalConfig.addressManager.setAddress(\\\"BVM_L1CrossDomainMessenger\\\", address(0));\\n\\n        // Set the DTL shutoff block, which will tell the DTL to stop syncing new deposits from the\\n        // CanonicalTransactionChain. We do this by setting an address in the AddressManager\\n        // because the DTL already has a reference to the AddressManager and this way we don't also\\n        // need to give it a reference to the SystemDictator.\\n        config.globalConfig.addressManager.setAddress(\\n            \\\"DTL_SHUTOFF_BLOCK\\\",\\n            address(uint160(block.number))\\n        );\\n    }\\n\\n    /**\\n     * @notice Removes deprecated addresses from the AddressManager.\\n     */\\n    function step3() public onlyOwner step(EXIT_1_NO_RETURN_STEP) {\\n        // Remove all deprecated addresses from the AddressManager\\n        string[16] memory deprecated = [\\n            \\\"BVM_CanonicalTransactionChain\\\",\\n            \\\"BVM_L2CrossDomainMessenger\\\",\\n            \\\"BVM_DecompressionPrecompileAddress\\\",\\n            \\\"BVM_Sequencer\\\",\\n            \\\"BVM_Proposer\\\",\\n            \\\"BVM_ChainStorageContainer-CTC-batches\\\",\\n            \\\"BVM_ChainStorageContainer-CTC-queue\\\",\\n            \\\"BVM_StateCommitmentChain\\\",\\n            \\\"BVM_BondManager\\\",\\n            \\\"BVM_ExecutionManager\\\",\\n            \\\"BVM_FraudVerifier\\\",\\n            \\\"BVM_StateManagerFactory\\\",\\n            \\\"BVM_StateTransitionerFactory\\\",\\n            \\\"BVM_SafetyChecker\\\",\\n            \\\"BVM_L1MultiMessageRelayer\\\",\\n            \\\"BondManager\\\"\\n        ];\\n\\n        for (uint256 i = 0; i < deprecated.length; i++) {\\n            config.globalConfig.addressManager.setAddress(deprecated[i], address(0));\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers system ownership to the ProxyAdmin.\\n     */\\n    function step4() public onlyOwner step(PROXY_TRANSFER_STEP) {\\n        // Transfer ownership of the AddressManager to the ProxyAdmin.\\n        config.globalConfig.addressManager.transferOwnership(\\n            address(config.globalConfig.proxyAdmin)\\n        );\\n\\n        // Transfer ownership of the L1StandardBridge to the ProxyAdmin.\\n        L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\\n            address(config.globalConfig.proxyAdmin)\\n        );\\n\\n        // Transfer ownership of the L1ERC721Bridge to the ProxyAdmin.\\n        Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\\n            address(config.globalConfig.proxyAdmin)\\n        );\\n    }\\n\\n    /**\\n     * @notice Upgrades and initializes proxy contracts.\\n     */\\n    function step5() public onlyOwner step(5) {\\n        // Dynamic config must be set before we can initialize the L2OutputOracle.\\n        require(dynamicConfigSet, \\\"SystemDictator: dynamic oracle config is not yet initialized\\\");\\n\\n        // Upgrade and initialize the L2OutputOracle.\\n        config.globalConfig.proxyAdmin.upgradeAndCall(\\n            payable(config.proxyAddressConfig.l2OutputOracleProxy),\\n            address(config.implementationAddressConfig.l2OutputOracleImpl),\\n            abi.encodeCall(\\n                L2OutputOracle.initialize,\\n                (\\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingBlockNumber,\\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingTimestamp\\n                )\\n            )\\n        );\\n\\n        // Upgrade and initialize the OptimismPortal.\\n        config.globalConfig.proxyAdmin.upgradeAndCall(\\n            payable(config.proxyAddressConfig.optimismPortalProxy),\\n            address(config.implementationAddressConfig.optimismPortalImpl),\\n            abi.encodeCall(OptimismPortal.initialize, (optimismPortalDynamicConfig))\\n        );\\n\\n        // Upgrade the L1CrossDomainMessenger.\\n        config.globalConfig.proxyAdmin.upgrade(\\n            payable(config.proxyAddressConfig.l1CrossDomainMessengerProxy),\\n            address(config.implementationAddressConfig.l1CrossDomainMessengerImpl)\\n        );\\n\\n        // Try to initialize the L1CrossDomainMessenger, only fail if it's already been initialized.\\n        try\\n            L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy)\\n                .initialize()\\n        {\\n            // L1CrossDomainMessenger is the one annoying edge case difference between existing\\n            // networks and fresh networks because in existing networks it'll already be\\n            // initialized but in fresh networks it won't be. Try/catch is the easiest and most\\n            // consistent way to handle this because initialized() is not exposed publicly.\\n        } catch Error(string memory reason) {\\n            require(\\n                keccak256(abi.encodePacked(reason)) ==\\n                    keccak256(\\\"Initializable: contract is already initialized\\\"),\\n                string.concat(\\\"SystemDictator: unexpected error initializing L1XDM: \\\", reason)\\n            );\\n        } catch {\\n            revert(\\\"SystemDictator: unexpected error initializing L1XDM (no reason)\\\");\\n        }\\n\\n        // Transfer ETH from the L1StandardBridge to the OptimismPortal.\\n        config.globalConfig.proxyAdmin.upgradeAndCall(\\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\\n            address(config.implementationAddressConfig.portalSenderImpl),\\n            abi.encodeCall(PortalSender.donate, ())\\n        );\\n\\n        // Upgrade the L1StandardBridge (no initializer).\\n        config.globalConfig.proxyAdmin.upgrade(\\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\\n            address(config.implementationAddressConfig.l1StandardBridgeImpl)\\n        );\\n\\n        // Upgrade the OptimismMintableERC20Factory (no initializer).\\n        config.globalConfig.proxyAdmin.upgrade(\\n            payable(config.proxyAddressConfig.optimismMintableERC20FactoryProxy),\\n            address(config.implementationAddressConfig.optimismMintableERC20FactoryImpl)\\n        );\\n\\n        // Upgrade the L1ERC721Bridge (no initializer).\\n        config.globalConfig.proxyAdmin.upgrade(\\n            payable(config.proxyAddressConfig.l1ERC721BridgeProxy),\\n            address(config.implementationAddressConfig.l1ERC721BridgeImpl)\\n        );\\n    }\\n\\n    /**\\n     * @notice Calls the first 2 steps of the migration process.\\n     */\\n    function phase1() external onlyOwner {\\n        step1();\\n        step2();\\n    }\\n\\n    /**\\n     * @notice Calls the remaining steps of the migration process, and finalizes.\\n     */\\n    function phase2() external onlyOwner {\\n        step3();\\n        step4();\\n        step5();\\n        finalize();\\n    }\\n\\n    /**\\n     * @notice Tranfers admin ownership to the final owner.\\n     */\\n    function finalize() public onlyOwner {\\n        // Transfer ownership of the ProxyAdmin to the final owner.\\n        config.globalConfig.proxyAdmin.transferOwnership(config.globalConfig.finalOwner);\\n\\n        // Optionally also transfer AddressManager and L1StandardBridge if we still own it. Might\\n        // happen if we're exiting early.\\n        if (currentStep <= PROXY_TRANSFER_STEP) {\\n            // Transfer ownership of the AddressManager to the final owner.\\n            config.globalConfig.addressManager.transferOwnership(\\n                address(config.globalConfig.finalOwner)\\n            );\\n\\n            // Transfer ownership of the L1StandardBridge to the final owner.\\n            L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\\n                address(config.globalConfig.finalOwner)\\n            );\\n\\n            // Transfer ownership of the L1ERC721Bridge to the final owner.\\n            Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\\n                address(config.globalConfig.finalOwner)\\n            );\\n        }\\n\\n        // Mark the deployment as finalized.\\n        finalized = true;\\n    }\\n\\n    /**\\n     * @notice First exit point, can only be called before step 3 is executed.\\n     */\\n    function exit1() external onlyOwner {\\n        require(\\n            currentStep == EXIT_1_NO_RETURN_STEP,\\n            \\\"SystemDictator: can only exit1 before step 3 is executed\\\"\\n        );\\n\\n        // Reset the L1CrossDomainMessenger to the old implementation.\\n        config.globalConfig.addressManager.setAddress(\\n            \\\"BVM_L1CrossDomainMessenger\\\",\\n            oldL1CrossDomainMessenger\\n        );\\n\\n        // Unset the DTL shutoff block which will allow the DTL to sync again.\\n        config.globalConfig.addressManager.setAddress(\\\"DTL_SHUTOFF_BLOCK\\\", address(0));\\n\\n        // Mark the deployment as exited.\\n        exited = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IL1ChugSplashDeployer\\n */\\ninterface IL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\\n/**\\n * @custom:legacy\\n * @title L1ChugSplashProxy\\n * @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n *         functions `setCode` and `setStorage` for changing the code or storage of the contract.\\n *\\n *         Note for future developers: do NOT make anything in this contract 'public' unless you\\n *         know what you're doing. Anything public can potentially have a function signature that\\n *         conflicts with a signature attached to the implementation contract. Public functions\\n *         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\\n *         reason not to have that modifier. And there almost certainly is not a good reason to not\\n *         have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n    /**\\n     * @notice \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a\\n     *         contract, the appended bytecode will be deployed as given.\\n     */\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice Blocks a function from being called when the parent signals that the system should\\n     *         be paused via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Makes a proxy call instead of triggering the given function when the caller is\\n     *         either the owner or the zero address. Caller can only ever be the zero address if\\n     *         this function is being called off-chain via eth_call, which is totally fine and can\\n     *         be convenient for client-side tooling. Avoids situations where the proxy and\\n     *         implementation share a sighash and the proxy function ends up being called instead\\n     *         of the implementation one.\\n     *\\n     *         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\\n     *         there's a way for someone to send a transaction with msg.sender == address(0) in any\\n     *         real context then we have much bigger problems. Primary reason to include this\\n     *         additional allowed sender is because the owner address can be changed dynamically\\n     *         and we do not want clients to have to keep track of the current owner in order to\\n     *         make an eth_call that doesn't trigger the proxied contract.\\n     */\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Sets the code that should be running behind this proxy.\\n     *\\n     *         Note: This scheme is a bit different from the standard proxy scheme where one would\\n     *         typically deploy the code separately and then set the implementation address. We're\\n     *         doing it this way because it gives us a lot more freedom on the client side. Can\\n     *         only be triggered by the contract owner.\\n     *\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\\n     *         perform upgrades in a more transparent way. Only callable by the owner.\\n     *\\n     * @param _key   Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(address _owner) external proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\\n     *         making an eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Owner address.\\n     */\\n    function getOwner() external proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address. Can only be called by the owner OR by making an\\n     *         eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Implementation address.\\n     */\\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @notice Gets the code hash for a given account.\\n     *\\n     * @param _account Address of the account to get a code hash for.\\n     *\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Arithmetic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { SignedMath } from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title Arithmetic\\n * @notice Even more math than before.\\n */\\nlibrary Arithmetic {\\n    /**\\n     * @notice Clamps a value between a minimum and maximum.\\n     *\\n     * @param _value The value to clamp.\\n     * @param _min   The minimum value.\\n     * @param _max   The maximum value.\\n     *\\n     * @return The clamped value.\\n     */\\n    function clamp(\\n        int256 _value,\\n        int256 _min,\\n        int256 _max\\n    ) internal pure returns (int256) {\\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\\n    }\\n\\n    /**\\n     * @notice (c)oefficient (d)enominator (exp)onentiation function.\\n     *         Returns the result of: c * (1 - 1/d)^exp.\\n     *\\n     * @param _coefficient Coefficient of the function.\\n     * @param _denominator Fractional denominator.\\n     * @param _exponent    Power function exponent.\\n     *\\n     * @return Result of c * (1 - 1/d)^exp.\\n     */\\n    function cdexp(\\n        int256 _coefficient,\\n        int256 _denominator,\\n        int256 _exponent\\n    ) internal pure returns (int256) {\\n        return\\n            (_coefficient *\\n                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Burn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Burn\\n * @notice Utilities for burning stuff.\\n */\\nlibrary Burn {\\n    /**\\n     * Burns a given amount of MNT.\\n     *\\n     * @param _amount Amount of MNT to burn.\\n     */\\n    function mnt(uint256 _amount) internal {\\n        new Burner{ value: _amount }();\\n    }\\n\\n    /**\\n     * Consumes a given amount of gas.\\n     *\\n     * @param _amount Amount of gas to consume.\\n     */\\n    function gas(uint256 _amount) internal view {\\n        uint256 i = 0;\\n        uint256 initialGas = gasleft();\\n        while (initialGas - gasleft() < _amount) {\\n            ++i;\\n        }\\n    }\\n}\\n\\n/**\\n * @title Burner\\n * @notice Burner self-destructs on creation and sends all MNT to itself, removing all MNT given to\\n *         the contract from the circulating supply. Self-destructing is the only way to remove MNT\\n *         from the circulating supply.\\n */\\ncontract Burner {\\n    constructor() payable {\\n        selfdestruct(payable(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Bytes\\n * @notice Bytes is a library for manipulating byte arrays.\\n */\\nlibrary Bytes {\\n    /**\\n     * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n     * @notice Slices a byte array with a given starting index and length. Returns a new byte array\\n     *         as opposed to a pointer to the original array. Will throw if trying to slice more\\n     *         bytes than exist in the array.\\n     *\\n     * @param _bytes Byte array to slice.\\n     * @param _start Starting index of the slice.\\n     * @param _length Length of the slice.\\n     *\\n     * @return Slice of the input byte array.\\n     */\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n            require(_start + _length >= _start, \\\"slice_overflow\\\");\\n            require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /**\\n     * @notice Slices a byte array with a given starting index up to the end of the original byte\\n     *         array. Returns a new array rathern than a pointer to the original.\\n     *\\n     * @param _bytes Byte array to slice.\\n     * @param _start Starting index of the slice.\\n     *\\n     * @return Slice of the input byte array.\\n     */\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    /**\\n     * @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\\n     *         Resulting nibble array will be exactly twice as long as the input byte array.\\n     *\\n     * @param _bytes Input byte array to convert.\\n     *\\n     * @return Resulting nibble array.\\n     */\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        uint256 bytesLength = _bytes.length;\\n        bytes memory nibbles = new bytes(bytesLength * 2);\\n        bytes1 b;\\n\\n        for (uint256 i = 0; i < bytesLength; ) {\\n            b = _bytes[i];\\n            nibbles[i * 2] = b >> 4;\\n            nibbles[i * 2 + 1] = b & 0x0f;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    /**\\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\\n     *\\n     * @param _bytes First byte array to compare.\\n     * @param _other Second byte array to compare.\\n     *\\n     * @return True if the two byte arrays are equal, false otherwise.\\n     */\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ResourceMetering } from \\\"../L1/ResourceMetering.sol\\\";\\n\\n/**\\n * @title Constants\\n * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\\n *         the stuff used in multiple contracts. Constants that only apply to a single contract\\n *         should be defined in that contract instead.\\n */\\nlibrary Constants {\\n    /**\\n     * @notice Special address to be used as the tx origin for gas estimation calls in the\\n     *         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\\n     *         the minimum gas limit specified by the user is not actually enough to execute the\\n     *         given message and you're attempting to estimate the actual necessary gas limit. We\\n     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to\\n     *         never have any code on any EVM chain.\\n     */\\n    address internal constant ESTIMATION_ADDRESS = address(1);\\n\\n    /**\\n     * @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\\n     *         CrossDomainMessenger contracts before an actual sender is set. This value is\\n     *         non-zero to reduce the gas cost of message passing transactions.\\n     */\\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\\n\\n    /**\\n     * @notice Returns the default values for the ResourceConfig. These are the recommended values\\n     *         for a production network.\\n     */\\n    function DEFAULT_RESOURCE_CONFIG()\\n        internal\\n        pure\\n        returns (ResourceMetering.ResourceConfig memory)\\n    {\\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\\n            maxResourceLimit: 20_000_000,\\n            elasticityMultiplier: 10,\\n            baseFeeMaxChangeDenominator: 8,\\n            minimumBaseFee: 1 gwei,\\n            systemTxMaxGas: 1_000_000,\\n            maximumBaseFee: type(uint128).max\\n        });\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Hashing } from \\\"./Hashing.sol\\\";\\nimport { RLPWriter } from \\\"./rlp/RLPWriter.sol\\\";\\n\\n/**\\n * @title Encoding\\n * @notice Encoding handles Optimism's various different encoding schemes.\\n */\\nlibrary Encoding {\\n    /**\\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n     *\\n     * @param _tx User deposit transaction to encode.\\n     *\\n     * @return RLP encoded L2 deposit transaction.\\n     */\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](10);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mntValue);\\n        raw[4] = RLPWriter.writeUint(_tx.mntTxValue);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeUint(_tx.ethValue);\\n        raw[8] = RLPWriter.writeBytes(_tx.data);\\n        raw[9] = RLPWriter.writeUint(_tx.ethTxValue);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /**\\n     * @notice Encodes the cross domain message based on the version that is encoded into the\\n     *         message nonce.\\n     *\\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _mntValue MNT value to send to the target.\\n     * @param _ethValue ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes memory) {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _mntValue, _ethValue, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n     *\\n     * @param _target Address of the target of the message.\\n     * @param _sender Address of the sender of the message.\\n     * @param _data   Data to send with the message.\\n     * @param _nonce  Message nonce.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(address,address,bytes,uint256)\\\",\\n                _target,\\n                _sender,\\n                _data,\\n                _nonce\\n            );\\n    }\\n\\n    /**\\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\\n     *\\n     * @param _nonce    Message nonce.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _mntValue MNT value to send to the target.\\n     * @param _ethValue ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(uint256,address,address,uint256,uint256,uint256,bytes)\\\",\\n                _nonce,\\n                _sender,\\n                _target,\\n                _mntValue,\\n                _ethValue,\\n                _gasLimit,\\n                _data\\n            );\\n    }\\n\\n    /**\\n     * @notice Adds a version number into the first two bytes of a message nonce.\\n     *\\n     * @param _nonce   Message nonce to encode into.\\n     * @param _version Version number to encode into the message nonce.\\n     *\\n     * @return Message nonce with version encoded into the first two bytes.\\n     */\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /**\\n     * @notice Pulls the version out of a version-encoded nonce.\\n     *\\n     * @param _nonce Message nonce with version encoded into the first two bytes.\\n     *\\n     * @return Nonce without encoded version.\\n     * @return Version of the message.\\n     */\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Encoding } from \\\"./Encoding.sol\\\";\\n\\n/**\\n * @title Hashing\\n * @notice Hashing handles Optimism's various different hashing schemes.\\n */\\nlibrary Hashing {\\n    /**\\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n     *         system.\\n     *\\n     * @param _tx User deposit transaction to hash.\\n     *\\n     * @return Hash of the RLP encoded L2 deposit transaction.\\n     */\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /**\\n     * @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n     *         of the L2 transaction that corresponds to a deposit is unique and is\\n     *         deterministically generated from L1 transaction data.\\n     *\\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n     * @param _logIndex    The index of the log that created the deposit transaction.\\n     *\\n     * @return Hash of the deposit transaction's \\\"source hash\\\".\\n     */\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /**\\n     * @notice Hashes the cross domain message based on the version that is encoded into the\\n     *         message nonce.\\n     *\\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _mntValue MNT value to send to the target.\\n     * @param _ethValue ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes32) {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _mntValue, _ethValue, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n     *\\n     * @param _target Address of the target of the message.\\n     * @param _sender Address of the sender of the message.\\n     * @param _data   Data to send with the message.\\n     * @param _nonce  Message nonce.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    ) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /**\\n     * @notice Hashes a cross domain message based on the V1 (current) encoding.\\n     *\\n     * @param _nonce    Message nonce.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _mntValue MNT value to send to the target.\\n     * @param _ethValue ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _ethValue,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                Encoding.encodeCrossDomainMessageV1(\\n                    _nonce,\\n                    _sender,\\n                    _target,\\n                    _mntValue,\\n                    _ethValue,\\n                    _gasLimit,\\n                    _data\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n     *\\n     * @param _tx Withdrawal transaction to hash.\\n     *\\n     * @return Hashed withdrawal transaction.\\n     */\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(_tx.nonce, _tx.sender, _tx.target,_tx.mntValue, _tx.ethValue, _tx.gasLimit, _tx.data)\\n            );\\n    }\\n\\n    /**\\n     * @notice Hashes the various elements of an output root proof into an output root hash which\\n     *         can be used to check if the proof is valid.\\n     *\\n     * @param _outputRootProof Output root proof which should hash to an output root.\\n     *\\n     * @return Hashed output root proof.\\n     */\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _outputRootProof.version,\\n                    _outputRootProof.stateRoot,\\n                    _outputRootProof.messagePasserStorageRoot,\\n                    _outputRootProof.latestBlockhash\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Predeploys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Predeploys\\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\\n */\\nlibrary Predeploys {\\n\\n\\n    /**\\n    * @notice Address of the BVM_ETH predeploy.\\n     */\\n    address internal constant BVM_ETH = 0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111;\\n\\n    /**\\n     * @notice Address of the L2ToL1MessagePasser predeploy.\\n     */\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\\n\\n    /**\\n     * @notice Address of the L2CrossDomainMessenger predeploy.\\n     */\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n        0x4200000000000000000000000000000000000007;\\n\\n    /**\\n     * @notice Address of the L2StandardBridge predeploy.\\n     */\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n\\n    /**\\n     * @notice Address of the L2ERC721Bridge predeploy.\\n     */\\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\\n\\n    /**\\n     * @notice Address of the SequencerFeeWallet predeploy.\\n     */\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n\\n    /**\\n     * @notice Address of the OptimismMintableERC20Factory predeploy.\\n     */\\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY =\\n        0x4200000000000000000000000000000000000012;\\n\\n    /**\\n     * @notice Address of the OptimismMintableERC721Factory predeploy.\\n     */\\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY =\\n        0x4200000000000000000000000000000000000017;\\n\\n    /**\\n     * @notice Address of the L1Block predeploy.\\n     */\\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\\n\\n    /**\\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\\n     *         and helpers for computing the L1 portion of the transaction fee.\\n     */\\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\\n     *         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\\n     */\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Address of the DeployerWhitelist predeploy. No longer active.\\n     */\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Address of the LegacyERC20MNT predeploy. Deprecated. Balances are migrated to the\\n     *         state trie as of the Bedrock upgrade. Contract has been locked and write functions\\n     *         can no longer be accessed.\\n     */\\n    address internal constant LEGACY_ERC20_MNT = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\\n     *         instead, which exposes more information about the L1 state.\\n     */\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\\n     *         L2ToL1MessagePasser contract instead.\\n     */\\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n\\n    /**\\n     * @notice Address of the ProxyAdmin predeploy.\\n     */\\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\\n\\n    /**\\n     * @notice Address of the BaseFeeVault predeploy.\\n     */\\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\\n\\n    /**\\n     * @notice Address of the L1FeeVault predeploy.\\n     */\\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\\n\\n    /**\\n     * @notice Address of the GovernanceToken predeploy.\\n     */\\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title SafeCall\\n * @notice Perform low level safe calls\\n */\\nlibrary SafeCall {\\n    /**\\n     * @notice Performs a low level call without copying any returndata.\\n     * @dev Passes no calldata to the call context.\\n     *\\n     * @param _target   Address to call\\n     * @param _gas      Amount of gas to pass to the call\\n     * @param _value    Amount of value to pass to the call\\n     */\\n    function send(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value\\n    ) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                _value, // ether value\\n                0, // inloc\\n                0, // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n        }\\n        return _success;\\n    }\\n\\n    /**\\n     * @notice Perform a low level call without copying any returndata\\n     *\\n     * @param _target   Address to call\\n     * @param _gas      Amount of gas to pass to the call\\n     * @param _value    Amount of value to pass to the call\\n     * @param _calldata Calldata to pass to the call\\n     */\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    ) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                _value, // ether value\\n                add(_calldata, 32), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n        }\\n        return _success;\\n    }\\n\\n    /**\\n     * @notice Helper function to determine if there is sufficient gas remaining within the context\\n     *         to guarantee that the minimum gas requirement for a call will be met as well as\\n     *         optionally reserving a specified amount of gas for after the call has concluded.\\n     * @param _minGas      The minimum amount of gas that may be passed to the target context.\\n     * @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n     *                     of the target context.\\n     * @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n     *         context as well as reserve `_reservedGas` for the caller after the execution of\\n     *         the target context.\\n     * @dev !!!!! FOOTGUN ALERT !!!!!\\n     *      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n     *          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n     *          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n     *          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n     *          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n     *          factors of the dynamic cost of the `CALL` opcode.\\n     *      2.) This function should *directly* precede the external call if possible. There is an\\n     *          added buffer to account for gas consumed between this check and the call, but it\\n     *          is only 5,700 gas.\\n     *      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n     *          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n     *          truncated.\\n     *      4.) Use wisely. This function is not a silver bullet.\\n     */\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas \u00d7 63 \u2265 minGas \u00d7 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(\\n                lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63)))\\n            )\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /**\\n     * @notice Perform a low level call without copying any returndata. This function\\n     *         will revert if the call cannot be performed with the specified minimum\\n     *         gas.\\n     *\\n     * @param _target   Address to call\\n     * @param _minGas   The minimum amount of gas that may be passed to the call\\n     * @param _value    Amount of value to pass to the call\\n     * @param _calldata Calldata to pass to the call\\n     */\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    ) internal returns (bool) {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success := call(\\n                gas(), // gas\\n                _target, // recipient\\n                _value, // ether value\\n                add(_calldata, 32), // inloc\\n                mload(_calldata), // inlen\\n                0x00, // outloc\\n                0x00 // outlen\\n            )\\n        }\\n        return _success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Types\\n * @notice Contains various types used throughout the Optimism contract system.\\n */\\nlibrary Types {\\n    /**\\n     * @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n     *         timestamp that the output root is posted. This timestamp is used to verify that the\\n     *         finalization period has passed since the output root was submitted.\\n     *\\n     * @custom:field outputRoot    Hash of the L2 output.\\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n     */\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /**\\n     * @notice Struct representing the elements that are hashed together to generate an output root\\n     *         which itself represents a snapshot of the L2 state.\\n     *\\n     * @custom:field version                  Version of the output root.\\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n     * @custom:field latestBlockhash          Hash of the block this output was generated from.\\n     */\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /**\\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n     *         user (as opposed to a system deposit transaction generated by the system).\\n     *\\n     * @custom:field from        Address of the sender of the transaction.\\n     * @custom:field to          Address of the recipient of the transaction.\\n     * @custom:field isCreation  True if the transaction is a contract creation.\\n     * @custom:field mntValue    Amount of MNT to mint.\\n     * @custom:field mntTxValue  MNT Value to send to the recipient.\\n     * @custom:field ethValue    Amount of ETH to mint.\\n     * @custom:field ethTxValue  ETH Value to send to the recipient.\\n     * @custom:field gasLimit    Gas limit of the transaction.\\n     * @custom:field data        Data of the transaction.\\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n     */\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 mntValue;\\n        uint256 mntTxValue;\\n        uint256 ethValue;\\n        uint256 ethTxValue;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /**\\n     * @notice Struct representing a withdrawal transaction.\\n     *\\n     * @custom:field nonce    Nonce of the withdrawal transaction\\n     * @custom:field sender   Address of the sender of the transaction.\\n     * @custom:field target   Address of the recipient of the transaction.\\n     * @custom:field mntValue MNT value to send to the recipient.\\n     * @custom:field ethValue ETH value to send to the recipient.\\n     * @custom:field gasLimit Gas limit of the transaction.\\n     * @custom:field data     Data of the transaction.\\n     */\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 mntValue;\\n        uint256 ethValue;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/rlp/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/**\\n * @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n * @title RLPReader\\n * @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n *         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n *         various tweaks to improve readability.\\n */\\nlibrary RLPReader {\\n    /**\\n     * Custom pointer type to avoid confusion between pointers and uint256s.\\n     */\\n    type MemoryPointer is uint256;\\n\\n    /**\\n     * @notice RLP item types.\\n     *\\n     * @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n     * @custom:value LIST_ITEM Represents an RLP list item.\\n     */\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /**\\n     * @notice Struct representing an RLP item.\\n     *\\n     * @custom:field length Length of the RLP item.\\n     * @custom:field ptr    Pointer to the RLP item in memory.\\n     */\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /**\\n     * @notice Max list length that this library will accept.\\n     */\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /**\\n     * @notice Converts bytes to a reference to memory position and length.\\n     *\\n     * @param _in Input bytes to convert.\\n     *\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        // Empty arrays are not RLP items.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * @notice Reads an RLP list value into a list of RLP items.\\n     *\\n     * @param _in RLP list value.\\n     *\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"RLPReader: decoded item type for list is not a list item\\\"\\n        );\\n\\n        require(\\n            listOffset + listLength == _in.length,\\n            \\\"RLPReader: list item has an invalid data remainder\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({\\n                    length: _in.length - offset,\\n                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n                })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * @notice Reads an RLP list value into a list of RLP items.\\n     *\\n     * @param _in RLP list value.\\n     *\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * @notice Reads an RLP bytes value into bytes.\\n     *\\n     * @param _in RLP bytes value.\\n     *\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"RLPReader: decoded item type for bytes is not a data item\\\"\\n        );\\n\\n        require(\\n            _in.length == itemOffset + itemLength,\\n            \\\"RLPReader: bytes value contains an invalid remainder\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * @notice Reads an RLP bytes value into bytes.\\n     *\\n     * @param _in RLP bytes value.\\n     *\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * @notice Reads the raw bytes of an RLP item.\\n     *\\n     * @param _in RLP item to read.\\n     *\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /**\\n     * @notice Decodes the length of an RLP item.\\n     *\\n     * @param _in RLP item to decode.\\n     *\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"RLPReader: length of content must be greater than string length (short string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                strLen != 1 || firstByteOfContent >= 0x80,\\n                \\\"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"RLPReader: length of content must be > than length of string length (long string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long string)\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                strLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long string)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"RLPReader: length of content must be greater than total length (long string)\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"RLPReader: length of content must be greater than list length (short list)\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"RLPReader: length of content must be > than length of list length (long list)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long list)\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                listLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long list)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"RLPReader: length of content must be greater than total length (long list)\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * @notice Copies the bytes from a memory location.\\n     *\\n     * @param _src    Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     *\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        MemoryPointer _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (_length == 0) {\\n            return out;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // solhint-disable max-line-length\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out, 32)\\n            let i := 0\\n            for {\\n\\n            } lt(i, _length) {\\n                i := add(i, 32)\\n            } {\\n                mstore(add(dest, i), mload(add(src, i)))\\n            }\\n\\n            if gt(i, _length) {\\n                mstore(add(dest, _length), 0)\\n            }\\n        }\\n\\n        return out;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/rlp/RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/trie/MerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Bytes } from \\\"../Bytes.sol\\\";\\nimport { RLPReader } from \\\"../rlp/RLPReader.sol\\\";\\n\\n/**\\n * @title MerkleTrie\\n * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\\n *         inclusion proofs. By default, this library assumes a hexary trie. One can change the\\n *         trie radix constant to support other trie radixes.\\n */\\nlibrary MerkleTrie {\\n    /**\\n     * @notice Struct representing a node in the trie.\\n     *\\n     * @custom:field encoded The RLP-encoded node.\\n     * @custom:field decoded The RLP-decoded node.\\n     */\\n    struct TrieNode {\\n        bytes encoded;\\n        RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /**\\n     * @notice Determines the number of elements per branch node.\\n     */\\n    uint256 internal constant TREE_RADIX = 16;\\n\\n    /**\\n     * @notice Branch nodes have TREE_RADIX elements and one value element.\\n     */\\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n\\n    /**\\n     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\\n     */\\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    /**\\n     * @notice Prefix for even-nibbled extension node paths.\\n     */\\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\\n\\n    /**\\n     * @notice Prefix for odd-nibbled extension node paths.\\n     */\\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\\n\\n    /**\\n     * @notice Prefix for even-nibbled leaf node paths.\\n     */\\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\\n\\n    /**\\n     * @notice Prefix for odd-nibbled leaf node paths.\\n     */\\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\\n     *\\n     * @param _key   Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n     *               nodes that make a path down to the target node.\\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n     *               correctly constructed.\\n     *\\n     * @return Whether or not the proof is valid.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool) {\\n        return Bytes.equal(_value, get(_key, _proof, _root));\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     *\\n     * @param _key   Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root  Known root of the Merkle trie.\\n     *\\n     * @return Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bytes memory) {\\n        require(_key.length > 0, \\\"MerkleTrie: empty key\\\");\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        bytes memory key = Bytes.toNibbles(_key);\\n        bytes memory currentNodeID = abi.encodePacked(_root);\\n        uint256 currentKeyIndex = 0;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            TrieNode memory currentNode = proof[i];\\n\\n            // Key index should never exceed total key length or we'll be out of bounds.\\n            require(\\n                currentKeyIndex <= key.length,\\n                \\\"MerkleTrie: key index exceeds total key length\\\"\\n            );\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 32 bytes aren't hashed.\\n                require(\\n                    Bytes.equal(currentNode.encoded, currentNodeID),\\n                    \\\"MerkleTrie: invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // Value is the last element of the decoded list (for branch nodes). There's\\n                    // some ambiguity in the Merkle trie specification because bytes(0) is a\\n                    // valid value to place into the trie, but for branch nodes bytes(0) can exist\\n                    // even when the value wasn't explicitly placed there. Geth treats a value of\\n                    // bytes(0) as \\\"key does not exist\\\" and so we do the same.\\n                    bytes memory value = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);\\n                    require(\\n                        value.length > 0,\\n                        \\\"MerkleTrie: value length must be greater than zero (branch)\\\"\\n                    );\\n\\n                    // Extra proof elements are not allowed.\\n                    require(\\n                        i == proof.length - 1,\\n                        \\\"MerkleTrie: value node must be last node in proof (branch)\\\"\\n                    );\\n\\n                    return value;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIndex += 1;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Bytes.slice(path, offset);\\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                // Whether this is a leaf node or an extension node, the path remainder MUST be a\\n                // prefix of the key remainder (or be equal to the key remainder) or the proof is\\n                // considered invalid.\\n                require(\\n                    pathRemainder.length == sharedNibbleLength,\\n                    \\\"MerkleTrie: path remainder must share all nibbles with key\\\"\\n                );\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,\\n                    // the key remainder must be exactly equal to the path remainder. We already\\n                    // did the necessary byte comparison, so it's more efficient here to check that\\n                    // the key remainder length equals the shared nibble length, which implies\\n                    // equality with the path remainder (since we already did the same check with\\n                    // the path remainder and the shared nibble length).\\n                    require(\\n                        keyRemainder.length == sharedNibbleLength,\\n                        \\\"MerkleTrie: key remainder must be identical to path remainder\\\"\\n                    );\\n\\n                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum\\n                    // state trie. Empty values are not allowed in the state trie, so we can safely\\n                    // say that if the value is empty, the key should not exist and the proof is\\n                    // invalid.\\n                    bytes memory value = RLPReader.readBytes(currentNode.decoded[1]);\\n                    require(\\n                        value.length > 0,\\n                        \\\"MerkleTrie: value length must be greater than zero (leaf)\\\"\\n                    );\\n\\n                    // Extra proof elements are not allowed.\\n                    require(\\n                        i == proof.length - 1,\\n                        \\\"MerkleTrie: value node must be last node in proof (leaf)\\\"\\n                    );\\n\\n                    return value;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node\\n                    // in the proof and increment the key index by the length of the path remainder\\n                    // which is equal to the shared nibble length.\\n                    currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                    currentKeyIndex += sharedNibbleLength;\\n                } else {\\n                    revert(\\\"MerkleTrie: received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"MerkleTrie: received an unparseable node\\\");\\n            }\\n        }\\n\\n        revert(\\\"MerkleTrie: ran out of proof elements\\\");\\n    }\\n\\n    /**\\n     * @notice Parses an array of proof elements into a new array that contains both the original\\n     *         encoded element and the RLP-decoded element.\\n     *\\n     * @param _proof Array of proof elements to parse.\\n     *\\n     * @return Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory) {\\n        uint256 length = _proof.length;\\n        TrieNode[] memory proof = new TrieNode[](length);\\n        for (uint256 i = 0; i < length; ) {\\n            proof[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the \\\"hash\\\" within the\\n     *         specification, but nodes < 32 bytes are not actually hashed.\\n     *\\n     * @param _node Node to pull an ID for.\\n     *\\n     * @return ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory) {\\n        return _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     *\\n     * @param _node Node to get a path for.\\n     *\\n     * @return Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {\\n        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two nibble arrays.\\n     *\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     *\\n     * @return Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 shared;\\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\\n        for (; shared < max && _a[shared] == _b[shared]; ) {\\n            unchecked {\\n                ++shared;\\n            }\\n        }\\n        return shared;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/trie/SecureMerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/* Library Imports */\\nimport { MerkleTrie } from \\\"./MerkleTrie.sol\\\";\\n\\n/**\\n * @title SecureMerkleTrie\\n * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\\n *         keys. Ethereum's state trie hashes input keys before storing them.\\n */\\nlibrary SecureMerkleTrie {\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\\n     *\\n     * @param _key   Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n     *               nodes that make a path down to the target node.\\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n     *               correctly constructed.\\n     *\\n     * @return Whether or not the proof is valid.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool) {\\n        bytes memory key = _getSecureKey(_key);\\n        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     *\\n     * @param _key   Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root  Known root of the Merkle trie.\\n     *\\n     * @return Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bytes memory) {\\n        bytes memory key = _getSecureKey(_key);\\n        return MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Computes the hashed version of the input key.\\n     *\\n     * @param _key Key to hash.\\n     *\\n     * @return Hashed version of the key.\\n     */\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"../libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n\\n/**\\n * @custom:legacy\\n * @title CrossDomainMessengerLegacySpacer0\\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\\n *         tree of the CrossDomainMessenger.\\n */\\ncontract CrossDomainMessengerLegacySpacer0 {\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer libAddressManager\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    address private spacer_0_0_20;\\n}\\n\\n/**\\n * @custom:legacy\\n * @title CrossDomainMessengerLegacySpacer1\\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\\n */\\ncontract CrossDomainMessengerLegacySpacer1 {\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer ContextUpgradable's __gap\\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n     *         ContextUpgradable.\\n     *\\n     */\\n    uint256[50] private spacer_1_0_1600;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer OwnableUpgradeable's _owner\\n     * @notice Spacer for backwards compatibility.\\n     *         Come from OpenZeppelin OwnableUpgradeable.\\n     */\\n    address private spacer_51_0_20;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer OwnableUpgradeable's __gap\\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n     *         OwnableUpgradeable.\\n     */\\n    uint256[49] private spacer_52_0_1568;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer PausableUpgradable's _paused\\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n     *         PausableUpgradable.\\n     */\\n    bool private spacer_101_0_1;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer PausableUpgradable's __gap\\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n     *         PausableUpgradable.\\n     */\\n    uint256[49] private spacer_102_0_1568;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    uint256 private spacer_151_0_32;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer ReentrancyGuardUpgradeable's __gap\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    uint256[49] private spacer_152_0_1568;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer blockedMessages\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    mapping(bytes32 => bool) private spacer_201_0_32;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer relayedMessages\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    mapping(bytes32 => bool) private spacer_202_0_32;\\n}\\n\\n/**\\n * @custom:upgradeable\\n * @title CrossDomainMessenger\\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\\n *         needs to be extended slightly to provide low-level message passing functionality on each\\n *         chain it's deployed on. Currently only designed for message passing between two paired\\n *         chains and does not support one-to-many interactions.\\n *\\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\\n */\\nabstract contract CrossDomainMessenger is\\n    CrossDomainMessengerLegacySpacer0,\\n    Initializable,\\n    CrossDomainMessengerLegacySpacer1\\n{\\n    using SafeERC20 for IERC20;\\n    /**\\n     * @notice Current message version identifier.\\n     */\\n    uint16 public constant MESSAGE_VERSION = 1;\\n\\n    /**\\n     * @notice Constant overhead added to the base gas for a message.\\n     */\\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\\n\\n    /**\\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\\n     */\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\\n\\n    /**\\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\\n     */\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\\n\\n    /**\\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\\n     */\\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\\n\\n    /**\\n     * @notice Gas reserved for performing the external call in `relayMessage`.\\n     */\\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\\n\\n    /**\\n     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\\n     */\\n    uint64 public constant RELAY_RESERVED_GAS = 90_000;\\n\\n    /**\\n     * @notice Gas reserved for the execution between the `hasMinGas` check and the external\\n     *         call in `relayMessage`.\\n     */\\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 55_000;\\n\\n    /**\\n     * @notice BASE gas reserved for Hashing.hashCrossDomainMessage\\n     */\\n    uint64 public constant HASH_MESSAGE_BASE_GAS = 800;\\n\\n    /**\\n     * @notice Extra gas reserved for per-byte in Hashing.hashCrossDomainMessage\\n     */\\n    uint64 public constant HASH_MESSAGE_GAS_PER_BYTE = 2;\\n\\n    /**\\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\\n     */\\n    address public immutable OTHER_MESSENGER;\\n\\n    /**\\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\\n     *         be present in this mapping if it has successfully been relayed on this chain, and\\n     *         can therefore not be relayed again.\\n     */\\n    mapping(bytes32 => bool) public successfulMessages;\\n\\n    /**\\n     * @notice Address of the sender of the currently executing message on the other chain. If the\\n     *         value of this variable is the default value (0x00000000...dead) then no message is\\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\\n     *         error if this is the case.\\n     */\\n    address internal xDomainMsgSender;\\n\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer pauseOwner\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    address internal pauseOwner_spacer;\\n\\n    /**\\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\\n     *         messageNonce getter which will insert the message version into the nonce to give you\\n     *         the actual nonce to be used for the message.\\n     */\\n    uint240 internal msgNonce;\\n\\n    /**\\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\\n     *         executed at least once. A message will not be present in this mapping if it\\n     *         successfully executed on the first attempt.\\n     */\\n    mapping(bytes32 => bool) public failedMessages;\\n\\n    /**\\n     * @notice Reserve extra slots in the storage layout for future upgrades.\\n     *         A gap size of 41 was chosen here, so that the first slot used in a child contract\\n     *         would be a multiple of 50.\\n     */\\n    uint256[41] private __gap;\\n\\n    /**\\n     * @notice Emitted whenever a message is sent to the other chain.\\n     *\\n     * @param target       Address of the recipient of the message.\\n     * @param sender       Address of the sender of the message.\\n     * @param message      Message to trigger the recipient address with.\\n     * @param messageNonce Unique nonce attached to the message.\\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\\n     */\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n\\n    /**\\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\\n     *\\n     * @param sender    Address of the sender of the message.\\n     * @param mntValue  MNT value sent along with the message to the recipient.\\n     * @param ethValue  ETH value sent along with the message to the recipient.\\n     */\\n    event SentMessageExtension1(address indexed sender, uint256 mntValue,uint256 ethValue);\\n\\n    /**\\n     * @notice Emitted whenever a message is successfully relayed on this chain.\\n     *\\n     * @param msgHash Hash of the message that was relayed.\\n     */\\n    event RelayedMessage(bytes32 indexed msgHash);\\n\\n    /**\\n     * @notice Emitted whenever a message fails to be relayed on this chain.\\n     *\\n     * @param msgHash Hash of the message that failed to be relayed.\\n     */\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /**\\n     * @param _otherMessenger Address of the messenger on the paired chain.\\n     */\\n    constructor(address _otherMessenger) {\\n        OTHER_MESSENGER = _otherMessenger;\\n    }\\n\\n    /**\\n     * @notice Sends a message to some target address on the other chain. Note that if the call\\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\\n     *         permanently locked. The same will occur if the target on the other chain is\\n     *         considered unsafe (see the _isUnsafeTarget() function).\\n     *\\n     * @param _otherSideNativeTokenAmount   Bridge the other side native token amount.\\n     * @param _target                       Target contract or wallet address.\\n     * @param _message                      Message to trigger the target address with.\\n     * @param _minGasLimit                  Minimum gas limit that the message can be executed with.\\n     */\\n    function sendMessage(\\n        uint256 _otherSideNativeTokenAmount,\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable virtual {\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            _otherSideNativeTokenAmount,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                this.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                0,\\n                msg.value,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, _otherSideNativeTokenAmount, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n* @notice Sends a message to some target address on the other chain. Note that if the call\\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\\n     *         permanently locked. The same will occur if the target on the other chain is\\n     *         considered unsafe (see the _isUnsafeTarget() function).\\n     *\\n     * @param _target                       Target contract or wallet address.\\n     * @param _message                      Message to trigger the target address with.\\n     * @param _minGasLimit                  Minimum gas limit that the message can be executed with.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _minGasLimit\\n    ) external payable virtual {\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            0,\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            abi.encodeWithSelector(\\n                this.relayMessage.selector,\\n                messageNonce(),\\n                msg.sender,\\n                _target,\\n                0,\\n                msg.value,\\n                _minGasLimit,\\n                _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, 0, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /**\\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n     *         be executed via cross-chain call from the other messenger OR if the message was\\n     *         already received once and is currently being replayed.\\n     *\\n     * @param _nonce       Nonce of the message being relayed.\\n     * @param _sender      Address of the user who sent the message.\\n     * @param _target      Address that the message is targeted at.\\n     * @param _value       ETH value to send with the message.\\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n     * @param _message     Message to send to the target.\\n     */\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _mntValue,\\n        uint256 _value,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    ) external payable virtual {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(\\n            version < 2,\\n            \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\"\\n        );\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(\\n                successfulMessages[oldHash] == false,\\n                \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\"\\n            );\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\\n            _nonce,\\n            _sender,\\n            _target,\\n            _mntValue,\\n            _value,\\n            _minGasLimit,\\n            _message\\n        );\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _value);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(\\n                msg.value == 0,\\n                \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\"\\n            );\\n\\n            require(\\n                failedMessages[versionedHash],\\n                \\\"CrossDomainMessenger: message cannot be replayed\\\"\\n            );\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false,\\n            \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(\\n            successfulMessages[versionedHash] == false,\\n            \\\"CrossDomainMessenger: message has already been relayed\\\"\\n        );\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n\\n        if (success) {\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\\n     *         executing message on the other chain. Will throw an error if there is no message\\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\\n     *\\n     * @return Address of the sender of the currently executing message on the other chain.\\n     */\\n    function xDomainMessageSender() external view returns (address) {\\n        require(\\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\\n            \\\"CrossDomainMessenger: xDomainMessageSender is not set\\\"\\n        );\\n\\n        return xDomainMsgSender;\\n    }\\n\\n    /**\\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\\n     *         bytes of the message nonce. Message version allows us to treat messages as having\\n     *         different structures.\\n     *\\n     * @return Nonce of the next message to be sent, with added message version.\\n     */\\n    function messageNonce() public view returns (uint256) {\\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\\n    }\\n\\n    /**\\n     * @notice Computes the amount of gas required to guarantee that a given message will be\\n     *         received on the other chain without running out of gas. Guaranteeing that a message\\n     *         will not run out of gas is important because this ensures that a message can always\\n     *         be replayed on the other chain if it fails to execute completely.\\n     *\\n     * @param _message     Message to compute the amount of required gas for.\\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\\n     *\\n     * @return Amount of gas required to guarantee message receipt.\\n     */\\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\\n        return\\n            // Constant overhead\\n            RELAY_CONSTANT_OVERHEAD +\\n            // Calldata overhead\\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\\n            // Hash message\\n            (uint64(_message.length) * HASH_MESSAGE_GAS_PER_BYTE) + HASH_MESSAGE_BASE_GAS +\\n            // Dynamic overhead (EIP-150)\\n            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\\n            // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas\\n            // factors. (Conservative)\\n            RELAY_CALL_OVERHEAD +\\n            // Relay reserved gas (to ensure execution of `relayMessage` completes after the\\n            // subcontext finishes executing) (Conservative)\\n            RELAY_RESERVED_GAS +\\n            // Gas reserved for the execution between the `hasMinGas` check and the `CALL`\\n            // opcode. (Conservative)\\n            RELAY_GAS_CHECK_BUFFER;\\n    }\\n\\n    /**\\n     * @notice Intializer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __CrossDomainMessenger_init() internal onlyInitializing {\\n        // We only want to set the xDomainMsgSender to the default value if it hasn't been initialized yet,\\n        // meaning that this is a fresh contract deployment.\\n        // This prevents resetting the xDomainMsgSender to the default value during an upgrade, which would enable\\n        // a reentrant withdrawal to sandwhich the upgrade replay a withdrawal twice.\\n        if (xDomainMsgSender == address(0)) {\\n            xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\\n     *         contracts because the logic for this depends on the network where the messenger is\\n     *         being deployed.\\n     *\\n     * @param _otherSideNativeTokenAmount   Bridge the other side native token amount.\\n     * @param _to                           Recipient of the message on the other chain.\\n     * @param _gasLimit                     Minimum gas limit the message can be executed with.\\n     * @param _data                         Message data.\\n     */\\n    function _sendMessage(\\n        uint256 _otherSideNativeTokenAmount,\\n        address _to,\\n        uint64 _gasLimit,\\n        bytes memory _data\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\\n     *         contracts because the logic for this depends on the network where the messenger is\\n     *         being deployed.\\n     *\\n     * @return Whether the message is coming from the other messenger.\\n     */\\n    function _isOtherMessenger() internal view virtual returns (bool);\\n\\n    /**\\n     * @notice Checks whether a given call target is a system address that could cause the\\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\\n     *         system addresses that could cause security issues, e.g., having the\\n     *         CrossDomainMessenger send messages to itself.\\n     *\\n     * @param _target Address of the contract to check.\\n     *\\n     * @return Whether or not the address is an unsafe system address.\\n     */\\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/universal/ERC721Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { CrossDomainMessenger } from \\\"./CrossDomainMessenger.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title ERC721Bridge\\n * @notice ERC721Bridge is a base contract for the L1 and L2 ERC721 bridges.\\n */\\nabstract contract ERC721Bridge {\\n    /**\\n     * @notice Messenger contract on this domain.\\n     */\\n    CrossDomainMessenger public immutable MESSENGER;\\n\\n    /**\\n     * @notice Address of the bridge on the other network.\\n     */\\n    address public immutable OTHER_BRIDGE;\\n\\n    /**\\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n     */\\n    uint256[49] private __gap;\\n\\n    /**\\n     * @notice Emitted when an ERC721 bridge to the other network is initiated.\\n     *\\n     * @param localToken  Address of the token on this domain.\\n     * @param remoteToken Address of the token on the remote domain.\\n     * @param from        Address that initiated bridging action.\\n     * @param to          Address to receive the token.\\n     * @param tokenId     ID of the specific token deposited.\\n     * @param extraData   Extra data for use on the client-side.\\n     */\\n    event ERC721BridgeInitiated(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 tokenId,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an ERC721 bridge from the other network is finalized.\\n     *\\n     * @param localToken  Address of the token on this domain.\\n     * @param remoteToken Address of the token on the remote domain.\\n     * @param from        Address that initiated bridging action.\\n     * @param to          Address to receive the token.\\n     * @param tokenId     ID of the specific token deposited.\\n     * @param extraData   Extra data for use on the client-side.\\n     */\\n    event ERC721BridgeFinalized(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 tokenId,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\\n     */\\n    modifier onlyOtherBridge() {\\n        require(\\n            msg.sender == address(MESSENGER) && MESSENGER.xDomainMessageSender() == OTHER_BRIDGE,\\n            \\\"ERC721Bridge: function can only be called from the other bridge\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\\n     */\\n    constructor(address _messenger, address _otherBridge) {\\n        require(_messenger != address(0), \\\"ERC721Bridge: messenger cannot be address(0)\\\");\\n        require(_otherBridge != address(0), \\\"ERC721Bridge: other bridge cannot be address(0)\\\");\\n\\n        MESSENGER = CrossDomainMessenger(_messenger);\\n        OTHER_BRIDGE = _otherBridge;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for messenger contract.\\n     *\\n     * @return Messenger contract on this domain.\\n     */\\n    function messenger() external view returns (CrossDomainMessenger) {\\n        return MESSENGER;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for other bridge address.\\n     *\\n     * @return Address of the bridge on the other network.\\n     */\\n    function otherBridge() external view returns (address) {\\n        return OTHER_BRIDGE;\\n    }\\n\\n    /**\\n     * @notice Initiates a bridge of an NFT to the caller's account on the other chain. Note that\\n     *         this function can only be called by EOAs. Smart contract wallets should use the\\n     *         `bridgeERC721To` function after ensuring that the recipient address on the remote\\n     *         chain exists. Also note that the current owner of the token on this chain must\\n     *         approve this contract to operate the NFT before it can be bridged.\\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\\n     *         wait for the one-week challenge period to elapse before their Optimism-native NFT\\n     *         can be refunded on L2.\\n     *\\n     * @param _localToken  Address of the ERC721 on this domain.\\n     * @param _remoteToken Address of the ERC721 on the remote domain.\\n     * @param _tokenId     Token ID to bridge.\\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\\n     *                     be used to execute any code on the other chain and is only emitted as\\n     *                     extra data for the convenience of off-chain tooling.\\n     */\\n    function bridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _tokenId,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external {\\n        // Modifier requiring sender to be EOA. This prevents against a user error that would occur\\n        // if the sender is a smart contract wallet that has a different address on the remote chain\\n        // (or doesn't have an address on the remote chain at all). The user would fail to receive\\n        // the NFT if they use this function because it sends the NFT to the same address as the\\n        // caller. This check could be bypassed by a malicious contract via initcode, but it takes\\n        // care of the user error we want to avoid.\\n        require(!Address.isContract(msg.sender), \\\"ERC721Bridge: account is not externally owned\\\");\\n\\n        _initiateBridgeERC721(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            msg.sender,\\n            _tokenId,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Initiates a bridge of an NFT to some recipient's account on the other chain. Note\\n     *         that the current owner of the token on this chain must approve this contract to\\n     *         operate the NFT before it can be bridged.\\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\\n     *         wait for the one-week challenge period to elapse before their Optimism-native NFT\\n     *         can be refunded on L2.\\n     *\\n     * @param _localToken  Address of the ERC721 on this domain.\\n     * @param _remoteToken Address of the ERC721 on the remote domain.\\n     * @param _to          Address to receive the token on the other domain.\\n     * @param _tokenId     Token ID to bridge.\\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\\n     *                     be used to execute any code on the other chain and is only emitted as\\n     *                     extra data for the convenience of off-chain tooling.\\n     */\\n    function bridgeERC721To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _tokenId,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external {\\n        require(_to != address(0), \\\"ERC721Bridge: nft recipient cannot be address(0)\\\");\\n\\n        _initiateBridgeERC721(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            _to,\\n            _tokenId,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function for initiating a token bridge to the other domain.\\n     *\\n     * @param _localToken  Address of the ERC721 on this domain.\\n     * @param _remoteToken Address of the ERC721 on the remote domain.\\n     * @param _from        Address of the sender on this domain.\\n     * @param _to          Address to receive the token on the other domain.\\n     * @param _tokenId     Token ID to bridge.\\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\\n     * @param _extraData   Optional data to forward to the other domain. Data supplied here will\\n     *                     not be used to execute any code on the other domain and is only emitted\\n     *                     as extra data for the convenience of off-chain tooling.\\n     */\\n    function _initiateBridgeERC721(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/universal/IOptimismMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IOptimismMintableERC20\\n * @notice This interface is available on the OptimismMintableERC20 contract. We declare it as a\\n *         separate interface so that it can be used in custom implementations of\\n *         OptimismMintableERC20.\\n */\\ninterface IOptimismMintableERC20 is IERC165 {\\n    function remoteToken() external view returns (address);\\n\\n    function bridge() external returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\\n/**\\n * @custom:legacy\\n * @title ILegacyMintableERC20\\n * @notice This interface was available on the legacy L2StandardERC20 contract. It remains available\\n *         on the OptimismMintableERC20 contract for backwards compatibility.\\n */\\ninterface ILegacyMintableERC20 is IERC165 {\\n    function l1Token() external view returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/universal/IOptimismMintableERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {\\n    IERC721Enumerable\\n} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\n/**\\n * @title IOptimismMintableERC721\\n * @notice Interface for contracts that are compatible with the OptimismMintableERC721 standard.\\n *         Tokens that follow this standard can be easily transferred across the ERC721 bridge.\\n */\\ninterface IOptimismMintableERC721 is IERC721Enumerable {\\n    /**\\n     * @notice Emitted when a token is minted.\\n     *\\n     * @param account Address of the account the token was minted to.\\n     * @param tokenId Token ID of the minted token.\\n     */\\n    event Mint(address indexed account, uint256 tokenId);\\n\\n    /**\\n     * @notice Emitted when a token is burned.\\n     *\\n     * @param account Address of the account the token was burned from.\\n     * @param tokenId Token ID of the burned token.\\n     */\\n    event Burn(address indexed account, uint256 tokenId);\\n\\n    /**\\n     * @notice Mints some token ID for a user, checking first that contract recipients\\n     *         are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * @param _to      Address of the user to mint the token for.\\n     * @param _tokenId Token ID to mint.\\n     */\\n    function safeMint(address _to, uint256 _tokenId) external;\\n\\n    /**\\n     * @notice Burns a token ID from a user.\\n     *\\n     * @param _from    Address of the user to burn the token from.\\n     * @param _tokenId Token ID to burn.\\n     */\\n    function burn(address _from, uint256 _tokenId) external;\\n\\n    /**\\n     * @notice Chain ID of the chain where the remote token is deployed.\\n     */\\n    function REMOTE_CHAIN_ID() external view returns (uint256);\\n\\n    /**\\n     * @notice Address of the token on the remote domain.\\n     */\\n    function REMOTE_TOKEN() external view returns (address);\\n\\n    /**\\n     * @notice Address of the ERC721 bridge on this network.\\n     */\\n    function BRIDGE() external view returns (address);\\n\\n    /**\\n     * @notice Chain ID of the chain where the remote token is deployed.\\n     */\\n    function remoteChainId() external view returns (uint256);\\n\\n    /**\\n     * @notice Address of the token on the remote domain.\\n     */\\n    function remoteToken() external view returns (address);\\n\\n    /**\\n     * @notice Address of the ERC721 bridge on this network.\\n     */\\n    function bridge() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/universal/OptimismMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport { ILegacyMintableERC20, IOptimismMintableERC20 } from \\\"./IOptimismMintableERC20.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\n\\n/**\\n * @title OptimismMintableERC20\\n * @notice OptimismMintableERC20 is a standard extension of the base ERC20 token contract designed\\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\\n *         use an OptimismMintablERC20 as the L2 representation of an L1 token, or vice-versa.\\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\\n *         meant for use on L2.\\n */\\ncontract OptimismMintableERC20 is IOptimismMintableERC20, ILegacyMintableERC20, ERC20, Semver {\\n    /**\\n     * @notice Address of the corresponding version of this token on the remote chain.\\n     */\\n    address public immutable REMOTE_TOKEN;\\n\\n    /**\\n     * @notice Address of the StandardBridge on this network.\\n     */\\n    address public immutable BRIDGE;\\n\\n    /**\\n     * @notice Emitted whenever tokens are minted for an account.\\n     *\\n     * @param account Address of the account tokens are being minted for.\\n     * @param amount  Amount of tokens minted.\\n     */\\n    event Mint(address indexed account, uint256 amount);\\n\\n    /**\\n     * @notice Emitted whenever tokens are burned from an account.\\n     *\\n     * @param account Address of the account tokens are being burned from.\\n     * @param amount  Amount of tokens burned.\\n     */\\n    event Burn(address indexed account, uint256 amount);\\n\\n    /**\\n     * @notice A modifier that only allows the bridge to call\\n     */\\n    modifier onlyBridge() {\\n        require(msg.sender == BRIDGE, \\\"OptimismMintableERC20: only bridge can mint and burn\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @custom:semver 1.0.0\\n     *\\n     * @param _bridge      Address of the L2 standard bridge.\\n     * @param _remoteToken Address of the corresponding L1 token.\\n     * @param _name        ERC20 name.\\n     * @param _symbol      ERC20 symbol.\\n     */\\n    constructor(\\n        address _bridge,\\n        address _remoteToken,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol) Semver(1, 0, 0) {\\n        REMOTE_TOKEN = _remoteToken;\\n        BRIDGE = _bridge;\\n    }\\n\\n    /**\\n     * @notice Allows the StandardBridge on this network to mint tokens.\\n     *\\n     * @param _to     Address to mint tokens to.\\n     * @param _amount Amount of tokens to mint.\\n     */\\n    function mint(address _to, uint256 _amount)\\n        external\\n        virtual\\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\\n        onlyBridge\\n    {\\n        _mint(_to, _amount);\\n        emit Mint(_to, _amount);\\n    }\\n\\n    /**\\n     * @notice Allows the StandardBridge on this network to burn tokens.\\n     *\\n     * @param _from   Address to burn tokens from.\\n     * @param _amount Amount of tokens to burn.\\n     */\\n    function burn(address _from, uint256 _amount)\\n        external\\n        virtual\\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\\n        onlyBridge\\n    {\\n        _burn(_from, _amount);\\n        emit Burn(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice ERC165 interface check function.\\n     *\\n     * @param _interfaceId Interface ID to check.\\n     *\\n     * @return Whether or not the interface is supported by this contract.\\n     */\\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\\n        bytes4 iface1 = type(IERC165).interfaceId;\\n        // Interface corresponding to the legacy L2StandardERC20.\\n        bytes4 iface2 = type(ILegacyMintableERC20).interfaceId;\\n        // Interface corresponding to the updated OptimismMintableERC20 (this contract).\\n        bytes4 iface3 = type(IOptimismMintableERC20).interfaceId;\\n        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for the remote token. Use REMOTE_TOKEN going forward.\\n     */\\n    function l1Token() public view returns (address) {\\n        return REMOTE_TOKEN;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for the bridge. Use BRIDGE going forward.\\n     */\\n    function l2Bridge() public view returns (address) {\\n        return BRIDGE;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for REMOTE_TOKEN.\\n     */\\n    function remoteToken() public view returns (address) {\\n        return REMOTE_TOKEN;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for BRIDGE.\\n     */\\n    function bridge() public view returns (address) {\\n        return BRIDGE;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/OptimismMintableERC20Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/* Contract Imports */\\nimport { OptimismMintableERC20 } from \\\"../universal/OptimismMintableERC20.sol\\\";\\nimport { Semver } from \\\"./Semver.sol\\\";\\n\\n/**\\n * @custom:proxied\\n * @custom:predeployed 0x4200000000000000000000000000000000000012\\n * @title OptimismMintableERC20Factory\\n * @notice OptimismMintableERC20Factory is a factory contract that generates OptimismMintableERC20\\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\\n *         compatible with the older StandardL2ERC20Factory contract.\\n */\\ncontract OptimismMintableERC20Factory is Semver {\\n    /**\\n     * @notice Address of the StandardBridge on this chain.\\n     */\\n    address public immutable BRIDGE;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Emitted whenever a new OptimismMintableERC20 is created. Legacy version of the newer\\n     *         OptimismMintableERC20Created event. We recommend relying on that event instead.\\n     *\\n     * @param remoteToken Address of the token on the remote chain.\\n     * @param localToken  Address of the created token on the local chain.\\n     */\\n    event StandardL2TokenCreated(address indexed remoteToken, address indexed localToken);\\n\\n    /**\\n     * @notice Emitted whenever a new OptimismMintableERC20 is created.\\n     *\\n     * @param localToken  Address of the created token on the local chain.\\n     * @param remoteToken Address of the corresponding token on the remote chain.\\n     * @param deployer    Address of the account that deployed the token.\\n     */\\n    event OptimismMintableERC20Created(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address deployer\\n    );\\n\\n    /**\\n     * @custom:semver 1.1.0\\n     *\\n     * @notice The semver MUST be bumped any time that there is a change in\\n     *         the OptimismMintableERC20 token contract since this contract\\n     *         is responsible for deploying OptimismMintableERC20 contracts.\\n     *\\n     * @param _bridge Address of the StandardBridge on this chain.\\n     */\\n    constructor(address _bridge) Semver(1, 1, 0) {\\n        BRIDGE = _bridge;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Creates an instance of the OptimismMintableERC20 contract. Legacy version of the\\n     *         newer createOptimismMintableERC20 function, which has a more intuitive name.\\n     *\\n     * @param _remoteToken Address of the token on the remote chain.\\n     * @param _name        ERC20 name.\\n     * @param _symbol      ERC20 symbol.\\n     *\\n     * @return Address of the newly created token.\\n     */\\n    function createStandardL2Token(\\n        address _remoteToken,\\n        string memory _name,\\n        string memory _symbol\\n    ) external returns (address) {\\n        return createOptimismMintableERC20(_remoteToken, _name, _symbol);\\n    }\\n\\n    /**\\n     * @notice Creates an instance of the OptimismMintableERC20 contract.\\n     *\\n     * @param _remoteToken Address of the token on the remote chain.\\n     * @param _name        ERC20 name.\\n     * @param _symbol      ERC20 symbol.\\n     *\\n     * @return Address of the newly created token.\\n     */\\n    function createOptimismMintableERC20(\\n        address _remoteToken,\\n        string memory _name,\\n        string memory _symbol\\n    ) public returns (address) {\\n        require(\\n            _remoteToken != address(0),\\n            \\\"OptimismMintableERC20Factory: must provide remote token address\\\"\\n        );\\n\\n        address localToken = address(\\n            new OptimismMintableERC20(BRIDGE, _remoteToken, _name, _symbol)\\n        );\\n\\n        // Emit the old event too for legacy support.\\n        emit StandardL2TokenCreated(_remoteToken, localToken);\\n\\n        // Emit the updated event. The arguments here differ from the legacy event, but\\n        // are consistent with the ordering used in StandardBridge events.\\n        emit OptimismMintableERC20Created(localToken, _remoteToken, msg.sender);\\n\\n        return localToken;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Proxy\\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n *         if the caller is address(0), meaning that the call originated from an off-chain\\n *         simulation.\\n */\\ncontract Proxy {\\n    /**\\n     * @notice The storage slot that holds the address of the implementation.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice The storage slot that holds the address of the owner.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice An event that is emitted each time the implementation is changed. This event is part\\n     *         of the EIP-1967 specification.\\n     *\\n     * @param implementation The address of the implementation contract\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n     *         EIP-1967 specification.\\n     *\\n     * @param previousAdmin The previous owner of the contract\\n     * @param newAdmin      The new owner of the contract\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n     *         eth_call to interact with this proxy without needing to use low-level storage\\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\\n     *         normal EVM execution.\\n     */\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\\n     *         implementation is not possible.\\n     *\\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\\n     *               transparent proxy interface.\\n     */\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Set the implementation contract address. The code at the given address will execute\\n     *         when this contract is called.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     */\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n     *         atomic execution of initialization-based upgrades.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     * @param _data           Calldata to delegatecall the new implementation with.\\n     */\\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /**\\n     * @notice Gets the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        assembly {\\n            sstore(OWNER_KEY, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        assembly {\\n            impl := sload(IMPLEMENTATION_KEY)\\n        }\\n        return impl;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Proxy } from \\\"./Proxy.sol\\\";\\nimport { AddressManager } from \\\"../legacy/AddressManager.sol\\\";\\nimport { L1ChugSplashProxy } from \\\"../legacy/L1ChugSplashProxy.sol\\\";\\n\\n/**\\n * @title IStaticERC1967Proxy\\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\\n */\\ninterface IStaticERC1967Proxy {\\n    function implementation() external view returns (address);\\n\\n    function admin() external view returns (address);\\n}\\n\\n/**\\n * @title IStaticL1ChugSplashProxy\\n * @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\\n */\\ninterface IStaticL1ChugSplashProxy {\\n    function getImplementation() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n}\\n\\n/**\\n * @title ProxyAdmin\\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\\n *         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\\n *         with the various types of proxies that have been deployed by Optimism in the past.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @notice The proxy types that the ProxyAdmin can manage.\\n     *\\n     * @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\\n     * @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\\n     * @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\\n     */\\n    enum ProxyType {\\n        ERC1967,\\n        CHUGSPLASH,\\n        RESOLVED\\n    }\\n\\n    /**\\n     * @notice A mapping of proxy types, used for backwards compatibility.\\n     */\\n    mapping(address => ProxyType) public proxyType;\\n\\n    /**\\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\\n     *         manually kept up to date with changes in the AddressManager for this contract\\n     *         to be able to work as an admin for the ResolvedDelegateProxy type.\\n     */\\n    mapping(address => string) public implementationName;\\n\\n    /**\\n     * @notice The address of the address manager, this is required to manage the\\n     *         ResolvedDelegateProxy type.\\n     */\\n    AddressManager public addressManager;\\n\\n    /**\\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\\n     */\\n    bool internal upgrading;\\n\\n    /**\\n     * @param _owner Address of the initial owner of this contract.\\n     */\\n    constructor(address _owner) Ownable() {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\\n     *         proxy types.\\n     *\\n     * @param _address Address of the proxy.\\n     * @param _type    Type of the proxy.\\n     */\\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\\n        proxyType[_address] = _type;\\n    }\\n\\n    /**\\n     * @notice Sets the implementation name for a given address. Only required for\\n     *         ResolvedDelegateProxy type proxies that have an implementation name.\\n     *\\n     * @param _address Address of the ResolvedDelegateProxy.\\n     * @param _name    Name of the implementation for the proxy.\\n     */\\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\\n        implementationName[_address] = _name;\\n    }\\n\\n    /**\\n     * @notice Set the address of the AddressManager. This is required to manage legacy\\n     *         ResolvedDelegateProxy type proxy contracts.\\n     *\\n     * @param _address Address of the AddressManager.\\n     */\\n    function setAddressManager(AddressManager _address) external onlyOwner {\\n        addressManager = _address;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Set an address in the address manager. Since only the owner of the AddressManager\\n     *         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\\n     *         gives the owner of the ProxyAdmin the ability to modify addresses directly.\\n     *\\n     * @param _name    Name to set within the AddressManager.\\n     * @param _address Address to attach to the given name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        addressManager.setAddress(_name, _address);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Set the upgrading status for the Chugsplash proxy type.\\n     *\\n     * @param _upgrading Whether or not the system is upgrading.\\n     */\\n    function setUpgrading(bool _upgrading) external onlyOwner {\\n        upgrading = _upgrading;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\\n     *\\n     * @return Whether or not there is an upgrade going on. May not actually tell you whether an\\n     *         upgrade is going on, since we don't currently plan to use this variable for anything\\n     *         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\\n     */\\n    function isUpgrading() external view returns (bool) {\\n        return upgrading;\\n    }\\n\\n    /**\\n     * @notice Returns the implementation of the given proxy address.\\n     *\\n     * @param _proxy Address of the proxy to get the implementation of.\\n     *\\n     * @return Address of the implementation of the proxy.\\n     */\\n    function getProxyImplementation(address _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).implementation();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.getAddress(implementationName[_proxy]);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the admin of the given proxy address.\\n     *\\n     * @param _proxy Address of the proxy to get the admin of.\\n     *\\n     * @return Address of the admin of the proxy.\\n     */\\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).admin();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.owner();\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the admin of the given proxy address.\\n     *\\n     * @param _proxy    Address of the proxy to update.\\n     * @param _newAdmin Address of the new proxy admin.\\n     */\\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).changeAdmin(_newAdmin);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            addressManager.transferOwnership(_newAdmin);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes a proxy's implementation contract.\\n     *\\n     * @param _proxy          Address of the proxy to upgrade.\\n     * @param _implementation Address of the new implementation address.\\n     */\\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeTo(_implementation);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setStorage(\\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                bytes32(uint256(uint160(_implementation)))\\n            );\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            string memory name = implementationName[_proxy];\\n            addressManager.setAddress(name, _implementation);\\n        } else {\\n            // It should not be possible to retrieve a ProxyType value which is not matched by\\n            // one of the previous conditions.\\n            assert(false);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\\n     *\\n     * @param _proxy          Address of the proxy to upgrade.\\n     * @param _implementation Address of the new implementation address.\\n     * @param _data           Data to trigger the new implementation with.\\n     */\\n    function upgradeAndCall(\\n        address payable _proxy,\\n        address _implementation,\\n        bytes memory _data\\n    ) external payable onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\\n        } else {\\n            // reverts if proxy type is unknown\\n            upgrade(_proxy, _implementation);\\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\\n            require(success, \\\"ProxyAdmin: call to proxy after upgrade failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/Semver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @title Semver\\n * @notice Semver is a simple contract for managing contract versions.\\n */\\ncontract Semver {\\n    /**\\n     * @notice Contract version number (major).\\n     */\\n    uint256 private immutable MAJOR_VERSION;\\n\\n    /**\\n     * @notice Contract version number (minor).\\n     */\\n    uint256 private immutable MINOR_VERSION;\\n\\n    /**\\n     * @notice Contract version number (patch).\\n     */\\n    uint256 private immutable PATCH_VERSION;\\n\\n    /**\\n     * @param _major Version number (major).\\n     * @param _minor Version number (minor).\\n     * @param _patch Version number (patch).\\n     */\\n    constructor(\\n        uint256 _major,\\n        uint256 _minor,\\n        uint256 _patch\\n    ) {\\n        MAJOR_VERSION = _major;\\n        MINOR_VERSION = _minor;\\n        PATCH_VERSION = _patch;\\n    }\\n\\n    /**\\n     * @notice Returns the full semver contract version.\\n     *\\n     * @return Semver contract version as a string.\\n     */\\n    function version() public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    Strings.toString(MAJOR_VERSION),\\n                    \\\".\\\",\\n                    Strings.toString(MINOR_VERSION),\\n                    \\\".\\\",\\n                    Strings.toString(PATCH_VERSION)\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { IOptimismMintableERC20, ILegacyMintableERC20 } from \\\"./IOptimismMintableERC20.sol\\\";\\nimport { CrossDomainMessenger } from \\\"./CrossDomainMessenger.sol\\\";\\nimport { OptimismMintableERC20 } from \\\"./OptimismMintableERC20.sol\\\";\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\n\\n/**\\n * @custom:upgradeable\\n * @title StandardBridge\\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\\n *         the core bridging logic, including escrowing tokens that are native to the local chain\\n *         and minting/burning tokens that are native to the remote chain.\\n */\\nabstract contract StandardBridge {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\\n     */\\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\\n\\n    /**\\n     * @notice Messenger contract on this domain.\\n     */\\n    CrossDomainMessenger public immutable MESSENGER;\\n\\n    /**\\n     * @notice Corresponding bridge on the other domain.\\n     */\\n    StandardBridge public immutable OTHER_BRIDGE;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer messenger\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    address private spacer_0_0_20;\\n\\n    /**\\n     * @custom:legacy\\n     * @custom:spacer l2TokenBridge\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    address private spacer_1_0_20;\\n\\n\\n    /**\\n * @custom:legacy\\n     * @custom:spacer l1MantleAddress\\n     * @notice Spacer for backwards compatibility.\\n     */\\n    address private spacer_2_0_20;\\n\\n    /**\\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\\n     */\\n    mapping(address => mapping(address => uint256)) public deposits;\\n\\n    /**\\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n     *         A gap size of 47 was chosen here, so that the first slot used in a child contract\\n     *         would be a multiple of 50.\\n     */\\n    uint256[47] private __gap;\\n\\n    /**\\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\\n     *\\n     * @param from      Address of the sender.\\n     * @param to        Address of the receiver.\\n     * @param amount    Amount of ETH sent.\\n     * @param extraData Extra data sent with the transaction.\\n     */\\n    event ETHBridgeInitiated(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an ETH bridge is finalized on this chain.\\n     *\\n     * @param from      Address of the sender.\\n     * @param to        Address of the receiver.\\n     * @param amount    Amount of ETH sent.\\n     * @param extraData Extra data sent with the transaction.\\n     */\\n    event ETHBridgeFinalized(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an MNT bridge is initiated to the other chain.\\n     *\\n     * @param from        Address of the sender.\\n     * @param to          Address of the receiver.\\n     * @param amount      Amount of the MNT sent.\\n     * @param extraData   Extra data sent with the transaction.\\n     */\\n    event MNTBridgeInitiated(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an MNT bridge is finalized on this chain.\\n     *\\n     * @param from        Address of the sender.\\n     * @param to          Address of the receiver.\\n     * @param amount      Amount of the MNT sent.\\n     * @param extraData   Extra data sent with the transaction.\\n     */\\n    event MNTBridgeFinalized(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\\n     *\\n     * @param localToken  Address of the ERC20 on this chain.\\n     * @param remoteToken Address of the ERC20 on the remote chain.\\n     * @param from        Address of the sender.\\n     * @param to          Address of the receiver.\\n     * @param amount      Amount of the ERC20 sent.\\n     * @param extraData   Extra data sent with the transaction.\\n     */\\n    event ERC20BridgeInitiated(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\\n     *\\n     * @param localToken  Address of the ERC20 on this chain.\\n     * @param remoteToken Address of the ERC20 on the remote chain.\\n     * @param from        Address of the sender.\\n     * @param to          Address of the receiver.\\n     * @param amount      Amount of the ERC20 sent.\\n     * @param extraData   Extra data sent with the transaction.\\n     */\\n    event ERC20BridgeFinalized(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\\n     *         calling code within their constructors, but also doesn't really matter since we're\\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\\n     */\\n    modifier onlyEOA() {\\n        require(\\n            !Address.isContract(msg.sender),\\n            \\\"StandardBridge: function can only be called from an EOA\\\"\\n        );\\n        require(\\n            msg.sender==tx.origin,\\n            \\\"StandardBridge: msg sender must equal to tx origin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\\n     */\\n    modifier onlyOtherBridge() {\\n        require(\\n            msg.sender == address(MESSENGER) &&\\n                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),\\n            \\\"StandardBridge: function can only be called from the other bridge\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @param _messenger   Address of CrossDomainMessenger on this network.\\n     * @param _otherBridge Address of the other StandardBridge contract.\\n     */\\n    constructor(address payable _messenger, address payable _otherBridge) {\\n        MESSENGER = CrossDomainMessenger(_messenger);\\n        OTHER_BRIDGE = StandardBridge(_otherBridge);\\n    }\\n\\n    /**\\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n     *         Must be implemented by contracts that inherit.\\n     */\\n    receive() external payable virtual;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy getter for messenger contract.\\n     *\\n     * @return Messenger contract on this domain.\\n     */\\n    function messenger() external view returns (CrossDomainMessenger) {\\n        return MESSENGER;\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public virtual onlyEOA {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            msg.sender,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) public virtual {\\n        _initiateBridgeERC20(\\n            _localToken,\\n            _remoteToken,\\n            msg.sender,\\n            _to,\\n            _amount,\\n            _minGasLimit,\\n            _extraData\\n        );\\n    }\\n\\n    /**\\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from      Address of the sender.\\n     * @param _to        Address of the receiver.\\n     * @param _amount    Amount of ETH being bridged.\\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\\n     *                   not be triggered with this data, but it will be emitted and can be used\\n     *                   to identify the transaction.\\n     */\\n    function finalizeBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable virtual onlyOtherBridge {\\n        require(msg.value == _amount, \\\"StandardBridge: amount sent does not match amount required\\\");\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(MESSENGER), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n\\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\\\"\\\");\\n        require(success, \\\"StandardBridge: ETH transfer failed\\\");\\n    }\\n\\n    /**\\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the ERC20 being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public virtual onlyOtherBridge {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\\n        } else {\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\\n            IERC20(_localToken).safeTransfer(_to, _amount);\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n * @notice Finalizes an MNT bridge on this chain. Can only be triggered by the other\\n     *         StandardBridge contract on the remote chain.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT being bridged.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function finalizeBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) public payable virtual ;\\n\\n    /**\\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of ETH being bridged.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        require(\\n            msg.value == _amount,\\n            \\\"StandardBridge: bridging ETH must include sufficient ETH value\\\"\\n        );\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n\\n        MESSENGER.sendMessage{ value: _amount }(\\n            0,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                this.finalizeBridgeETH.selector,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the corresponding token on the remote chain.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\\n        } else {\\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n\\n        MESSENGER.sendMessage(\\n            0,\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                this.finalizeBridgeERC20.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _remoteToken,\\n                _localToken,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends MNT tokens to a receiver's address on the other chain.\\n     *\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of local tokens to deposit.\\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function _initiateBridgeMNT(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\\n     *         Just the way we like it.\\n     *\\n     * @param _token Address of the token to check.\\n     *\\n     * @return True if the token is an OptimismMintableERC20.\\n     */\\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\\n        return\\n            ERC165Checker.supportsInterface(_token, type(ILegacyMintableERC20).interfaceId) ||\\n            ERC165Checker.supportsInterface(_token, type(IOptimismMintableERC20).interfaceId);\\n    }\\n\\n    /**\\n     * @notice Checks if the \\\"other token\\\" is the correct pair token for the OptimismMintableERC20.\\n     *         Calls can be saved in the future by combining this logic with\\n     *         `_isOptimismMintableERC20`.\\n     *\\n     * @param _mintableToken OptimismMintableERC20 to check against.\\n     * @param _otherToken    Pair token to check.\\n     *\\n     * @return True if the other token is the correct pair token for the OptimismMintableERC20.\\n     */\\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (\\n            ERC165Checker.supportsInterface(_mintableToken, type(ILegacyMintableERC20).interfaceId)\\n        ) {\\n            return _otherToken == ILegacyMintableERC20(_mintableToken).l1Token();\\n        } else {\\n            return _otherToken == IOptimismMintableERC20(_mintableToken).remoteToken();\\n        }\\n    }\\n\\n    /** @notice Emits the ETHBridgeInitiated event and if necessary the appropriate legacy event\\n     *          when an ETH bridge is finalized on this chain.\\n     *\\n     * @param _from      Address of the sender.\\n     * @param _to        Address of the receiver.\\n     * @param _amount    Amount of ETH sent.\\n     * @param _extraData Extra data sent with the transaction.\\n     */\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the ETHBridgeFinalized and if necessary the appropriate legacy event when an\\n     *         ETH bridge is finalized on this chain.\\n     *\\n     * @param _from      Address of the sender.\\n     * @param _to        Address of the receiver.\\n     * @param _amount    Amount of ETH sent.\\n     * @param _extraData Extra data sent with the transaction.\\n     */\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the ERC20BridgeInitiated event and if necessary the appropriate legacy\\n     *         event when an ERC20 bridge is initiated to the other chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the ERC20 on the remote chain.\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the ERC20 sent.\\n     * @param _extraData   Extra data sent with the transaction.\\n     */\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the ERC20BridgeFinalized event and if necessary the appropriate legacy\\n     *         event when an ERC20 bridge is initiated to the other chain.\\n     *\\n     * @param _localToken  Address of the ERC20 on this chain.\\n     * @param _remoteToken Address of the ERC20 on the remote chain.\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the ERC20 sent.\\n     * @param _extraData   Extra data sent with the transaction.\\n     */\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the MNTBridgeInitiated event and if necessary the appropriate legacy\\n     *         event when an ERC20 bridge is initiated to the other chain.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT` sent.\\n     * @param _extraData   Extra data sent with the transaction.\\n     */\\n    function _emitMNTBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit MNTBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /**\\n     * @notice Emits the MNTBridgeFinalized event and if necessary the appropriate legacy\\n     *         event when an ERC20 bridge is initiated to the other chain.\\n     *\\n     * @param _from        Address of the sender.\\n     * @param _to          Address of the receiver.\\n     * @param _amount      Amount of the MNT sent.\\n     * @param _extraData   Extra data sent with the transaction.\\n     */\\n    function _emitMNTBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) internal virtual {\\n        emit MNTBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@cwia/=node_modules/clones-with-immutable-args/src/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@rari-capital/=node_modules/@rari-capital/\",\r\n      \"@rari-capital/solmate/=node_modules/@rari-capital/solmate/\",\r\n      \"clones-with-immutable-args/=node_modules/clones-with-immutable-args/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EXIT_1_NO_RETURN_STEP\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROXY_TRANSFER_STEP\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"components\":[{\"internalType\":\"contract AddressManager\",\"name\":\"addressManager\",\"type\":\"address\"},{\"internalType\":\"contract ProxyAdmin\",\"name\":\"proxyAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finalOwner\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.GlobalConfig\",\"name\":\"globalConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"l2OutputOracleProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismPortalProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1CrossDomainMessengerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1StandardBridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismMintableERC20FactoryProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1ERC721BridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"systemConfigProxy\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.ProxyAddressConfig\",\"name\":\"proxyAddressConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract L2OutputOracle\",\"name\":\"l2OutputOracleImpl\",\"type\":\"address\"},{\"internalType\":\"contract OptimismPortal\",\"name\":\"optimismPortalImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1CrossDomainMessenger\",\"name\":\"l1CrossDomainMessengerImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1StandardBridge\",\"name\":\"l1StandardBridgeImpl\",\"type\":\"address\"},{\"internalType\":\"contract OptimismMintableERC20Factory\",\"name\":\"optimismMintableERC20FactoryImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1ERC721Bridge\",\"name\":\"l1ERC721BridgeImpl\",\"type\":\"address\"},{\"internalType\":\"contract PortalSender\",\"name\":\"portalSenderImpl\",\"type\":\"address\"},{\"internalType\":\"contract SystemConfig\",\"name\":\"systemConfigImpl\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.ImplementationAddressConfig\",\"name\":\"implementationAddressConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"overhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batcherHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"gasLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unsafeBlockSigner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxResourceLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"elasticityMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"baseFeeMaxChangeDenominator\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"minimumBaseFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"systemTxMaxGas\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"maximumBaseFee\",\"type\":\"uint128\"}],\"internalType\":\"struct ResourceMetering.ResourceConfig\",\"name\":\"resourceConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct SystemDictator.SystemConfigConfig\",\"name\":\"systemConfigConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicConfigSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract AddressManager\",\"name\":\"addressManager\",\"type\":\"address\"},{\"internalType\":\"contract ProxyAdmin\",\"name\":\"proxyAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finalOwner\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.GlobalConfig\",\"name\":\"globalConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"l2OutputOracleProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismPortalProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1CrossDomainMessengerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1StandardBridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismMintableERC20FactoryProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1ERC721BridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"systemConfigProxy\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.ProxyAddressConfig\",\"name\":\"proxyAddressConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract L2OutputOracle\",\"name\":\"l2OutputOracleImpl\",\"type\":\"address\"},{\"internalType\":\"contract OptimismPortal\",\"name\":\"optimismPortalImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1CrossDomainMessenger\",\"name\":\"l1CrossDomainMessengerImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1StandardBridge\",\"name\":\"l1StandardBridgeImpl\",\"type\":\"address\"},{\"internalType\":\"contract OptimismMintableERC20Factory\",\"name\":\"optimismMintableERC20FactoryImpl\",\"type\":\"address\"},{\"internalType\":\"contract L1ERC721Bridge\",\"name\":\"l1ERC721BridgeImpl\",\"type\":\"address\"},{\"internalType\":\"contract PortalSender\",\"name\":\"portalSenderImpl\",\"type\":\"address\"},{\"internalType\":\"contract SystemConfig\",\"name\":\"systemConfigImpl\",\"type\":\"address\"}],\"internalType\":\"struct SystemDictator.ImplementationAddressConfig\",\"name\":\"implementationAddressConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"overhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batcherHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"gasLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unsafeBlockSigner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxResourceLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"elasticityMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"baseFeeMaxChangeDenominator\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"minimumBaseFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"systemTxMaxGas\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"maximumBaseFee\",\"type\":\"uint128\"}],\"internalType\":\"struct ResourceMetering.ResourceConfig\",\"name\":\"resourceConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct SystemDictator.SystemConfigConfig\",\"name\":\"systemConfigConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct SystemDictator.DeployConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2OutputOracleDynamicConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"l2OutputOracleStartingBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2OutputOracleStartingTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldL1CrossDomainMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimismPortalDynamicConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phase1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phase2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step4\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step5\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"l2OutputOracleStartingBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2OutputOracleStartingTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct SystemDictator.L2OutputOracleDynamicConfig\",\"name\":\"_l2OutputOracleDynamicConfig\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_optimismPortalDynamicConfig\",\"type\":\"bool\"}],\"name\":\"updateDynamicConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SystemDictator", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}