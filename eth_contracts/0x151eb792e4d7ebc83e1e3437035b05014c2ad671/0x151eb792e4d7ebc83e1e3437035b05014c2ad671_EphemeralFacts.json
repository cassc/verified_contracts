{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/EphemeralFacts.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport \\\"./interfaces/IRelicReceiver.sol\\\";\\nimport \\\"./interfaces/IReliquary.sol\\\";\\nimport \\\"./interfaces/IProver.sol\\\";\\nimport \\\"./interfaces/IBatchProver.sol\\\";\\nimport \\\"./interfaces/IEphemeralFacts.sol\\\";\\nimport \\\"./lib/Callbacks.sol\\\";\\n\\n/**\\n * @title EphemeralFacts\\n * @author Theori, Inc.\\n * @notice EphemeralFacts provides delivery of ephemeral facts: facts which are\\n *         passed directly to external receivers, rather than stored in the\\n *         Reliquary. It also allows placing bounties on specific fact proof\\n *         requests, which can be used to build a fact proving relay system.\\n *         Batch provers are supported, enabling an efficient request + relay\\n *         system using proof aggregation.\\n */\\ncontract EphemeralFacts is IEphemeralFacts {\\n    IReliquary immutable reliquary;\\n\\n    /// @dev track the bounty associated with each fact request\\n    mapping(bytes32 => uint256) bounties;\\n\\n    constructor(IReliquary _reliquary) {\\n        reliquary = _reliquary;\\n    }\\n\\n    /**\\n     * @dev computes the unique requestId for this fact request, used to track bounties\\n     * @param account the account associated with the fact\\n     * @param sig the fact signature\\n     * @param context context about the fact receiver callback\\n     */\\n    function requestId(\\n        address account,\\n        FactSignature sig,\\n        ReceiverContext memory context\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(account, sig, context));\\n    }\\n\\n    /**\\n     * @notice delivers the fact to the receiver, claiming any pending bounty on the request\\n     * @param context the contract to receive the fact\\n     * @param fact the fact information\\n     */\\n    function deliverFact(ReceiverContext calldata context, Fact memory fact) internal {\\n        bytes32 rid = requestId(fact.account, fact.sig, context);\\n        uint256 bounty = bounties[rid];\\n        require(\\n            context.initiator == msg.sender || bounty > 0,\\n            \\\"cannot specify an initiator which didn't request the fact\\\"\\n        );\\n        if (bounty > 0) {\\n            delete bounties[rid];\\n            emit BountyPaid(bounty, rid, msg.sender);\\n            payable(msg.sender).transfer(bounty);\\n        }\\n        bytes memory data = abi.encodeWithSelector(\\n            IRelicReceiver.receiveFact.selector,\\n            context.initiator,\\n            fact,\\n            context.extra\\n        );\\n        (bool success, bytes memory result) = Callbacks.callWithExactGas(\\n            context.gasLimit,\\n            address(context.receiver),\\n            data\\n        );\\n        if (success) {\\n            emit ReceiveSuccess(context.receiver, rid);\\n        } else if (context.requireSuccess) {\\n            Callbacks.revertWithData(result);\\n        } else {\\n            emit ReceiveFailure(context.receiver, rid);\\n        }\\n    }\\n\\n    /**\\n     * @notice proves a fact ephemerally and provides it to the receiver\\n     * @param context the ReceiverContext for delivering the fact\\n     * @param prover the prover module to use, must implement IProver\\n     * @param proof the proof to pass to the prover\\n     */\\n    function proveEphemeral(\\n        ReceiverContext calldata context,\\n        address prover,\\n        bytes calldata proof\\n    ) external payable {\\n        // reverts if the prover doesn't exist or is revoked\\n        reliquary.checkProver(reliquary.provers(prover));\\n\\n        // reverts if the prover doesn't support standard interface\\n        require(\\n            IERC165(prover).supportsInterface(type(IProver).interfaceId),\\n            \\\"Prover doesn't implement IProver\\\"\\n        );\\n\\n        Fact memory fact = IProver(prover).prove{value: msg.value}(proof, false);\\n        deliverFact(context, fact);\\n    }\\n\\n    /**\\n     * @notice proves a batch of facts ephemerally and provides them to the receivers\\n     * @param contexts the ReceiverContexts for delivering the facts\\n     * @param prover the prover module to use, must implement IBatchProver\\n     * @param proof the proof to pass to the prover\\n     */\\n    function batchProveEphemeral(\\n        ReceiverContext[] calldata contexts,\\n        address prover,\\n        bytes calldata proof\\n    ) external payable {\\n        // reverts if the prover doesn't exist or is revoked\\n        reliquary.checkProver(reliquary.provers(prover));\\n\\n        // reverts if the prover doesn't support standard interface\\n        require(\\n            IERC165(prover).supportsInterface(type(IBatchProver).interfaceId),\\n            \\\"Prover doesn't implement IBatchProver\\\"\\n        );\\n\\n        Fact[] memory facts = IBatchProver(prover).proveBatch{value: msg.value}(proof, false);\\n        require(facts.length == contexts.length);\\n\\n        for (uint256 i = 0; i < facts.length; i++) {\\n            deliverFact(contexts[i], facts[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice requests a fact to be proven asynchronously and passed to the receiver,\\n     * @param account the account associated with the fact\\n     * @param sigData the fact data which determines the fact signature (class is assumed to be NO_FEE)\\n     * @param receiver the contract to receive the fact\\n     * @param data the extra data to pass to the receiver\\n     * @param gasLimit the maxmium gas used by the receiver\\n     * @dev msg.value is added to the bounty for this fact request,\\n     *      incentivizing somebody to prove it\\n     */\\n    function requestFact(\\n        address account,\\n        bytes calldata sigData,\\n        IRelicReceiver receiver,\\n        bytes calldata data,\\n        uint256 gasLimit\\n    ) external payable {\\n        FactSignature sig = Facts.toFactSignature(Facts.NO_FEE, sigData);\\n\\n        // create the receiver context for the fact proof request\\n        // note that initiator and requireSuccess are hardcoded\\n        ReceiverContext memory context = ReceiverContext(\\n            msg.sender,\\n            receiver,\\n            data,\\n            gasLimit,\\n            false\\n        );\\n\\n        uint256 bounty = bounties[requestId(account, sig, context)] += msg.value;\\n        emit FactRequested(FactDescription(account, sigData), context, bounty);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBatchProver.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\nimport \\\"../lib/Facts.sol\\\";\\n\\npragma solidity >=0.8.12;\\n\\n/**\\n * @title IBatchProver\\n * @author Theori, Inc.\\n * @notice IBatchProver is a standard interface implemented by some Relic provers.\\n *         Supports proving multiple facts ephemerally or proving and storing\\n *         them in the Reliquary.\\n */\\ninterface IBatchProver {\\n    /**\\n     * @notice prove multiple facts ephemerally\\n     * @param proof the encoded proof, depends on the prover implementation\\n     * @param store whether to store the facts in the reliquary\\n     * @return facts the proven facts' information\\n     */\\n    function proveBatch(bytes calldata proof, bool store)\\n        external\\n        payable\\n        returns (Fact[] memory facts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEphemeralFacts.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRelicReceiver.sol\\\";\\n\\ninterface IEphemeralFacts {\\n    struct ReceiverContext {\\n        address initiator;\\n        IRelicReceiver receiver;\\n        bytes extra;\\n        uint256 gasLimit;\\n        bool requireSuccess;\\n    }\\n\\n    struct FactDescription {\\n        address account;\\n        bytes sigData;\\n    }\\n\\n    event FactRequested(FactDescription desc, ReceiverContext context, uint256 bounty);\\n\\n    event ReceiveSuccess(IRelicReceiver receiver, bytes32 requestId);\\n\\n    event ReceiveFailure(IRelicReceiver receiver, bytes32 requestId);\\n\\n    event BountyPaid(uint256 bounty, bytes32 requestId, address relayer);\\n\\n    /**\\n     * @notice proves a fact ephemerally and provides it to the receiver\\n     * @param context the ReceiverContext for delivering the fact\\n     * @param prover the prover module to use, must implement IProver\\n     * @param proof the proof to pass to the prover\\n     */\\n    function proveEphemeral(\\n        ReceiverContext calldata context,\\n        address prover,\\n        bytes calldata proof\\n    ) external payable;\\n\\n    /**\\n     * @notice proves a batch of facts ephemerally and provides them to the receivers\\n     * @param contexts the ReceiverContexts for delivering the facts\\n     * @param prover the prover module to use, must implement IBatchProver\\n     * @param proof the proof to pass to the prover\\n     */\\n    function batchProveEphemeral(\\n        ReceiverContext[] calldata contexts,\\n        address prover,\\n        bytes calldata proof\\n    ) external payable;\\n\\n    /**\\n     * @notice requests a fact to be proven asynchronously and passed to the receiver,\\n     * @param account the account associated with the fact\\n     * @param sigData the fact data which determines the fact signature (class is assumed to be NO_FEE)\\n     * @param receiver the contract to receive the fact\\n     * @param data the extra data to pass to the receiver\\n     * @param gasLimit the maxmium gas used by the receiver\\n     * @dev msg.value is added to the bounty for this fact request,\\n     *      incentivizing somebody to prove it\\n     */\\n    function requestFact(\\n        address account,\\n        bytes calldata sigData,\\n        IRelicReceiver receiver,\\n        bytes calldata data,\\n        uint256 gasLimit\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProver.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\nimport \\\"../lib/Facts.sol\\\";\\n\\npragma solidity >=0.8.12;\\n\\n/**\\n * @title IProver\\n * @author Theori, Inc.\\n * @notice IProver is a standard interface implemented by some Relic provers.\\n *         Supports proving a fact ephemerally or proving and storing it in the\\n *         Reliquary.\\n */\\ninterface IProver {\\n    /**\\n     * @notice prove a fact ephemerally\\n     * @param proof the encoded proof, depends on the prover implementation\\n     * @param store whether to store the facts in the reliquary\\n     * @return fact the proven fact information\\n     */\\n    function prove(bytes calldata proof, bool store) external payable returns (Fact memory fact);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRelicReceiver.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../lib/Facts.sol\\\";\\n\\n/**\\n * @title IRelicReceiver\\n * @author Theori, Inc.\\n * @notice IRelicReceiver has callbacks to receives ephemeral facts from Relic\\n */\\ninterface IRelicReceiver {\\n    /**\\n     * @notice receives an ephemeral fact from Relic\\n     * @param initiator the account which initiated the fact proving\\n     * @param fact the proven fact information\\n     * @param data extra data passed from the initiator - this data may come\\n     *        from untrusted parties and thus should be validated\\n     */\\n    function receiveFact(\\n        address initiator,\\n        Fact calldata fact,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReliquary.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.12;\\n\\nimport \\\"../lib/Facts.sol\\\";\\n\\ninterface IReliquary {\\n    event NewProver(address prover, uint64 version);\\n    event PendingProverAdded(address prover, uint64 version, uint64 timestamp);\\n    event ProverRevoked(address prover, uint64 version);\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    struct ProverInfo {\\n        uint64 version;\\n        FeeInfo feeInfo;\\n        bool revoked;\\n    }\\n\\n    enum FeeFlags {\\n        FeeNone,\\n        FeeNative,\\n        FeeCredits,\\n        FeeExternalDelegate,\\n        FeeExternalToken\\n    }\\n\\n    struct FeeInfo {\\n        uint8 flags;\\n        uint16 feeCredits;\\n        // feeWei = feeWeiMantissa * pow(10, feeWeiExponent)\\n        uint8 feeWeiMantissa;\\n        uint8 feeWeiExponent;\\n        uint32 feeExternalId;\\n    }\\n\\n    function ADD_PROVER_ROLE() external view returns (bytes32);\\n\\n    function CREDITS_ROLE() external view returns (bytes32);\\n\\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    function DELAY() external view returns (uint64);\\n\\n    function GOVERNANCE_ROLE() external view returns (bytes32);\\n\\n    function SUBSCRIPTION_ROLE() external view returns (bytes32);\\n\\n    function activateProver(address prover) external;\\n\\n    function addCredits(address user, uint192 amount) external;\\n\\n    function addProver(address prover, uint64 version) external;\\n\\n    function addSubscriber(address user, uint64 ts) external;\\n\\n    function assertValidBlockHash(\\n        address verifier,\\n        bytes32 hash,\\n        uint256 num,\\n        bytes memory proof\\n    ) external payable;\\n\\n    function assertValidBlockHashFromProver(\\n        address verifier,\\n        bytes32 hash,\\n        uint256 num,\\n        bytes memory proof\\n    ) external view;\\n\\n    function checkProveFactFee(address sender) external payable;\\n\\n    function checkProver(ProverInfo memory prover) external pure;\\n\\n    function credits(address user) external view returns (uint192);\\n\\n    function debugValidBlockHash(\\n        address verifier,\\n        bytes32 hash,\\n        uint256 num,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    function debugVerifyFact(address account, FactSignature factSig)\\n        external\\n        view\\n        returns (\\n            bool exists,\\n            uint64 version,\\n            bytes memory data\\n        );\\n\\n    function factFees(uint8)\\n        external\\n        view\\n        returns (\\n            uint8 flags,\\n            uint16 feeCredits,\\n            uint8 feeWeiMantissa,\\n            uint8 feeWeiExponent,\\n            uint32 feeExternalId\\n        );\\n\\n    function feeAccounts(address)\\n        external\\n        view\\n        returns (uint64 subscriberUntilTime, uint192 credits);\\n\\n    function feeExternals(uint256) external view returns (address);\\n\\n    function getFact(address account, FactSignature factSig)\\n        external\\n        view\\n        returns (\\n            bool exists,\\n            uint64 version,\\n            bytes memory data\\n        );\\n\\n    function getProveFactNativeFee(address prover) external view returns (uint256);\\n\\n    function getProveFactTokenFee(address prover) external view returns (uint256);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function getVerifyFactNativeFee(FactSignature factSig) external view returns (uint256);\\n\\n    function getVerifyFactTokenFee(FactSignature factSig) external view returns (uint256);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function initialized() external view returns (bool);\\n\\n    function isSubscriber(address user) external view returns (bool);\\n\\n    function pendingProvers(address) external view returns (uint64 timestamp, uint64 version);\\n\\n    function provers(address) external view returns (ProverInfo memory);\\n\\n    function removeCredits(address user, uint192 amount) external;\\n\\n    function removeSubscriber(address user) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function resetFact(address account, FactSignature factSig) external;\\n\\n    function revokeProver(address prover) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function setCredits(address user, uint192 amount) external;\\n\\n    function setFact(\\n        address account,\\n        FactSignature factSig,\\n        bytes memory data\\n    ) external;\\n\\n    function setFactFee(\\n        uint8 cls,\\n        FeeInfo memory feeInfo,\\n        address feeExternal\\n    ) external;\\n\\n    function setInitialized() external;\\n\\n    function setProverFee(\\n        address prover,\\n        FeeInfo memory feeInfo,\\n        address feeExternal\\n    ) external;\\n\\n    function setValidBlockFee(FeeInfo memory feeInfo, address feeExternal) external;\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    function validBlockHash(\\n        address verifier,\\n        bytes32 hash,\\n        uint256 num,\\n        bytes memory proof\\n    ) external payable returns (bool);\\n\\n    function validBlockHashFromProver(\\n        address verifier,\\n        bytes32 hash,\\n        uint256 num,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    function verifyBlockFeeInfo()\\n        external\\n        view\\n        returns (\\n            uint8 flags,\\n            uint16 feeCredits,\\n            uint8 feeWeiMantissa,\\n            uint8 feeWeiExponent,\\n            uint32 feeExternalId\\n        );\\n\\n    function verifyFact(address account, FactSignature factSig)\\n        external\\n        payable\\n        returns (\\n            bool exists,\\n            uint64 version,\\n            bytes memory data\\n        );\\n\\n    function verifyFactNoFee(address account, FactSignature factSig)\\n        external\\n        view\\n        returns (\\n            bool exists,\\n            uint64 version,\\n            bytes memory data\\n        );\\n\\n    function verifyFactVersion(address account, FactSignature factSig)\\n        external\\n        payable\\n        returns (bool exists, uint64 version);\\n\\n    function verifyFactVersionNoFee(address account, FactSignature factSig)\\n        external\\n        view\\n        returns (bool exists, uint64 version);\\n\\n    function versions(uint64) external view returns (address);\\n\\n    function withdrawFees(address token, address dest) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Callbacks.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice Helper for providing fair gas limits in callbacks, adapted from Chainlink\\n */\\nlibrary Callbacks {\\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\\n    // and some arithmetic operations.\\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\\n\\n    /**\\n     * @notice calls target address with exactly gasAmount gas and data as calldata\\n     *         or reverts if at least gasAmount gas is not available.\\n     * @param gasAmount the exact amount of gas to call with\\n     * @param target the address to call\\n     * @param data the calldata to pass\\n     * @return success whether the call succeeded\\n     */\\n    function callWithExactGas(\\n        uint256 gasAmount,\\n        address target,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory result) {\\n        // solhint-disable-next-line no-inline-assembly\\n        uint256 returnsize;\\n        assembly {\\n            function notEnoughGas() {\\n                // revert Error(\\\"not enough gas for call\\\")\\n                mstore(0x00, hex\\\"08c379a000000000000000000000000000000000000000000000000000000000\\\")\\n                mstore(0x20, hex\\\"0000002000000000000000000000000000000000000000000000000000000000\\\")\\n                mstore(0x40, hex\\\"0000001b6e6f7420656e6f7567682067617320666f722063616c6c0000000000\\\")\\n                revert(0, 0x60)\\n            }\\n            function notContract() {\\n                // revert Error(\\\"call target not contract\\\")\\n                mstore(0x00, hex\\\"08c379a000000000000000000000000000000000000000000000000000000000\\\")\\n                mstore(0x20, hex\\\"0000002000000000000000000000000000000000000000000000000000000000\\\")\\n                mstore(0x40, hex\\\"0000001a63616c6c20746172676574206e6f74206120636f6e74726163740000\\\")\\n                revert(0, 0x60)\\n            }\\n            let g := gas()\\n            // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\\n            // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\\n            // We want to ensure that we revert if gasAmount >  63//64*gas available\\n            // as we do not want to provide them with less, however that check itself costs\\n            // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\\n            // to revert if gasAmount >  63//64*gas available.\\n            if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\\n                notEnoughGas()\\n            }\\n            g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\\n            // if g - g//64 <= gasAmount, revert\\n            // (we subtract g//64 because of EIP-150)\\n            if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n                notEnoughGas()\\n            }\\n            // solidity calls check that a contract actually exists at the destination, so we do the same\\n            if iszero(extcodesize(target)) {\\n                notContract()\\n            }\\n            // call and return whether we succeeded. ignore return data\\n            // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\\n            success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n            returnsize := returndatasize()\\n        }\\n        // copy the return data\\n        result = new bytes(returnsize);\\n        assembly {\\n            returndatacopy(add(result, 0x20), 0, returnsize)\\n        }\\n    }\\n\\n    /**\\n     * @notice reverts the current call with the provided raw data\\n     * @param data the revert data to return\\n     */\\n    function revertWithData(bytes memory data) internal pure {\\n        assembly {\\n            revert(add(data, 0x20), mload(data))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Facts.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.12;\\n\\ntype FactSignature is bytes32;\\n\\nstruct Fact {\\n    address account;\\n    FactSignature sig;\\n    bytes data;\\n}\\n\\nlibrary Facts {\\n    uint8 internal constant NO_FEE = 0;\\n\\n    function toFactSignature(uint8 cls, bytes memory data) internal pure returns (FactSignature) {\\n        return FactSignature.wrap(bytes32((uint256(keccak256(data)) << 8) | cls));\\n    }\\n\\n    function toFactClass(FactSignature factSig) internal pure returns (uint8) {\\n        return uint8(uint256(FactSignature.unwrap(factSig)));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IReliquary\",\"name\":\"_reliquary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BountyPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sigData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct IEphemeralFacts.FactDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireSuccess\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IEphemeralFacts.ReceiverContext\",\"name\":\"context\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"name\":\"FactRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"ReceiveFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"ReceiveSuccess\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireSuccess\",\"type\":\"bool\"}],\"internalType\":\"struct IEphemeralFacts.ReceiverContext[]\",\"name\":\"contexts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"prover\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"batchProveEphemeral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireSuccess\",\"type\":\"bool\"}],\"internalType\":\"struct IEphemeralFacts.ReceiverContext\",\"name\":\"context\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"prover\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"proveEphemeral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sigData\",\"type\":\"bytes\"},{\"internalType\":\"contract IRelicReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"requestFact\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "EphemeralFacts", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000005e4de6bb8c6824f29c44bd3473d44da120387d08", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}