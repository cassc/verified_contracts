{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ether-deck-mk2/src/EtherDeckMk2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.24;\\n\\n/// @title Ether Deck Mk2\\n/// @author jtriley.eth\\n/// @notice a reasonably optimized smart account\\ncontract EtherDeckMk2 {\\n    /// @notice logged on dispatch set\\n    /// @param selector the selector dispatched from\\n    /// @param target the target address dispatched to\\n    event DispatchSet(bytes4 indexed selector, address indexed target);\\n\\n    /// @notice dispatcher of selectors to target addresses\\n    /// @dev occupies slot 0 for `fallback` memory optimization; if you inherit it, it must be\\n    ///      inherited first or you must add an additional memory write\\n    mapping(bytes4 => address) public dispatch;\\n\\n    /// @notice runner of calls\\n    address public runner;\\n\\n    constructor(address firstRunner) payable {\\n        assembly {\\n            sstore(runner.slot, firstRunner)\\n        }\\n    }\\n\\n    /// @notice runs a call\\n    /// @dev directives:\\n    ///      01. check if caller is runner; cache as success\\n    ///      02. copy payload to memory\\n    ///      03. make external call to target with callvalue and payload; compose success\\n    ///      04. copy returndata to memory\\n    ///      05. if success, return with returndata\\n    ///      06. else, revert with revertdata\\n    /// @param target the call target\\n    /// @param payload the call payload\\n    function run(address target, bytes calldata payload) external payable {\\n        assembly {\\n            let success := eq(caller(), sload(runner.slot))\\n\\n            calldatacopy(0x00, payload.offset, payload.length)\\n\\n            success := and(success, call(gas(), target, callvalue(), 0x00, payload.length, 0x00, 0x00))\\n\\n            returndatacopy(0x00, 0x00, returndatasize())\\n\\n            if success { return(0x00, returndatasize()) }\\n\\n            revert(0x00, returndatasize())\\n        }\\n    }\\n\\n    /// @notice runs a batch of calls\\n    /// @dev directives:\\n    ///      01. check if caller is runner; cache as success\\n    ///      02. load target offset; cache as targetPtr\\n    ///      03. load value offset; cache as valuePtr\\n    ///      04. load payload offset; cache as payloadPtr\\n    ///      05. compute end of targets; cache as targetsEnd\\n    ///      06. check that targets and values length match; compose success\\n    ///      07. check that targets and payloads length match; compose success\\n    ///      08. loop:\\n    ///          a. if targetPtr is targetsEnd, break loop\\n    ///          b. compute payload offset; cache as payload\\n    ///          c. load payload length from calldata; cache as payloadLen\\n    ///          d. copy payload to memory\\n    ///          e. load target from calldata; cache as target\\n    ///          f. make external call to target with value and payload; cache as success\\n    ///          g. increment target offset\\n    ///          h. increment value offset\\n    ///          i. increment payload offset\\n    ///      09. if success, return\\n    ///      10. else, revert\\n    /// @param targets the call targets\\n    /// @param values the call values\\n    /// @param payloads the call payloads\\n    function runBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads\\n    ) external payable {\\n        assembly {\\n            let success := eq(caller(), sload(runner.slot))\\n\\n            let targetPtr := targets.offset\\n\\n            let valuePtr := values.offset\\n\\n            let payloadPtr := payloads.offset\\n\\n            let targetsEnd := add(targets.offset, mul(targets.length, 0x20))\\n\\n            success := and(success, eq(targets.length, values.length))\\n\\n            success := and(success, eq(targets.length, payloads.length))\\n\\n            for { } 1 { } {\\n                if eq(targetPtr, targetsEnd) { break }\\n\\n                let payload := add(payloads.offset, calldataload(payloadPtr))\\n\\n                let payloadLen := calldataload(payload)\\n\\n                calldatacopy(0x00, add(0x20, payload), payloadLen)\\n\\n                let target := calldataload(targetPtr)\\n\\n                success := and(success, call(gas(), target, calldataload(valuePtr), 0x00, payloadLen, 0x00, 0x00))\\n\\n                targetPtr := add(targetPtr, 0x20)\\n\\n                valuePtr := add(valuePtr, 0x20)\\n\\n                payloadPtr := add(payloadPtr, 0x20)\\n            }\\n\\n            if success { return(0x00, 0x00) }\\n\\n            revert(0x00, 0x00)\\n        }\\n    }\\n\\n    /// @notice sets the dispatcher of a selector to a target address\\n    /// @dev directives:\\n    ///      01. revert if caller is not runner\\n    ///      02. copy selector to memory\\n    ///      03. store target in storage at `dispatch[selector]`\\n    ///      04. log dispatch set\\n    /// @dev the address set by this has full write access over the ether deck\\n    /// @param selector the selector to dispatch from\\n    /// @param target the target address to dispatch to\\n    function setDispatch(bytes4 selector, address target) external payable {\\n        assembly {\\n            if iszero(eq(caller(), sload(runner.slot))) { revert(0x00, 0x00) }\\n\\n            mstore(0x00, selector)\\n\\n            sstore(keccak256(0x00, 0x40), target)\\n\\n            log3(0x00, 0x00, 0x2c0b629fc2b386c229783b88b245e8730c1397b78e4dd4a43cd7aafdf1b39f12, selector, target)\\n        }\\n    }\\n\\n    /// @notice sets the dispatcher of an array of selector to target addresses\\n    /// @dev directives:\\n    ///      01. check if caller is runner; cache as success\\n    ///      02. check success and that selectors and targets length match, revert if not\\n    ///      03. load selector offset; cache as selectorPtr\\n    ///      04. load target offset; cache as targetPtr\\n    ///      05. compute end of selectors; cache as selectorsEnd\\n    ///      06. loop:\\n    ///          a. if selectorPtr is selectorsEnd, break loop\\n    ///          b. load selector from calldata; cache as selector\\n    ///          c. load target from calldata; cache as target\\n    ///          d. store selector in memory\\n    ///          e. store target in storage at `dispatch[selector]`\\n    ///          f. log dispatch set\\n    ///          g. increment selector offset\\n    ///          h. increment target offset\\n    function setDispatchBatch(bytes4[] calldata selectors, address[] calldata targets) external payable {\\n        assembly {\\n            let success := eq(caller(), sload(runner.slot))\\n\\n            if iszero(and(success, eq(selectors.length, targets.length))) { revert(0x00, 0x00) }\\n\\n            let selectorPtr := selectors.offset\\n\\n            let targetPtr := targets.offset\\n\\n            let selectorsEnd := add(selectors.offset, mul(selectors.length, 0x20))\\n\\n            for { } 1 { } {\\n                if eq(selectorPtr, selectorsEnd) { break }\\n\\n                let selector := calldataload(selectorPtr)\\n\\n                let target := calldataload(targetPtr)\\n\\n                mstore(0x00, selector)\\n\\n                sstore(keccak256(0x00, 0x40), target)\\n\\n                log3(0x00, 0x00, 0x2c0b629fc2b386c229783b88b245e8730c1397b78e4dd4a43cd7aafdf1b39f12, selector, target)\\n\\n                selectorPtr := add(selectorPtr, 0x20)\\n\\n                targetPtr := add(targetPtr, 0x20)\\n            }\\n        }\\n    }\\n\\n    /// @notice receives data from arbitrary context\\n    /// @dev directives:\\n    ///      01. moves selector from calldata to memory\\n    ///      02. loads `dispatch[selector]` from storage; cache as target\\n    ///      03. if target is unassigned, return selector\\n    ///      04. copy calldata to memory\\n    ///      05. make external call to target with callvalue and calldata; cache as success\\n    ///      06. copy returndata to memory\\n    ///      07. if success, return with returndata\\n    ///      08. else, revert with revertdata\\n    /// @dev default behavior for unassigned selectors is to return the selector for compliance with\\n    ///      erc standards that impose undue constraints on receivers.\\n    fallback() external payable {\\n        assembly {\\n            mstore(0x00, shl(0xe0, shr(0xe0, calldataload(0x00))))\\n\\n            let target := sload(keccak256(0x00, 0x40))\\n\\n            let success := iszero(iszero(target))\\n\\n            calldatacopy(0x00, 0x00, calldatasize())\\n\\n            success := and(success, delegatecall(gas(), target, 0x00, calldatasize(), 0x00, 0x00))\\n\\n            returndatacopy(0x00, 0x00, returndatasize())\\n\\n            if success { return(0x00, returndatasize()) }\\n\\n            revert(0x00, returndatasize())\\n        }\\n    }\\n\\n    receive() external payable { }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"ether-deck-mk2/=lib/ether-deck-mk2/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"firstRunner\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"DispatchSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"dispatch\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"run\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"}],\"name\":\"runBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"setDispatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"}],\"name\":\"setDispatchBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EtherDeckMk2", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000b47a9b6f062c33ed78630478dff9056687f840f2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}