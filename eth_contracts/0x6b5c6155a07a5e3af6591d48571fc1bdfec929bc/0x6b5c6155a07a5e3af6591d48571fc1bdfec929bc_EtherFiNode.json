{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/EtherFiNode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IEtherFiNode.sol\\\";\\nimport \\\"./interfaces/IEtherFiNodesManager.sol\\\";\\nimport \\\"./interfaces/IProtocolRevenueManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\\\";\\n\\n\\ncontract EtherFiNode is IEtherFiNode {\\n    address public etherFiNodesManager;\\n\\n    // TODO: reduce the size of these variables\\n    uint256 public localRevenueIndex;\\n    uint256 public vestedAuctionRewards;\\n    string public ipfsHashForEncryptedValidatorKey;\\n    uint32 public exitRequestTimestamp;\\n    uint32 public exitTimestamp;\\n    uint32 public stakingStartTimestamp;\\n    VALIDATOR_PHASE public phase;\\n\\n    //--------------------------------------------------------------------------------------\\n    //----------------------------------  CONSTRUCTOR   ------------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        stakingStartTimestamp = type(uint32).max;\\n    }\\n\\n    /// @notice Based on the sources where they come from, the staking rewards are split into\\n    ///  - those from the execution layer: transaction fees and MEV\\n    ///  - those from the consensus layer: staking rewards for attesting the state of the chain, \\n    ///    proposing a new block, or being selected in a validator sync committee\\n    ///  To receive the rewards from the execution layer, it should have 'receive()' function.\\n    receive() external payable {}\\n\\n    function initialize(address _etherFiNodesManager) public {\\n        require(stakingStartTimestamp == 0, \\\"already initialized\\\");\\n        require(_etherFiNodesManager != address(0), \\\"No zero addresses\\\");\\n        stakingStartTimestamp = uint32(block.timestamp);\\n        etherFiNodesManager = _etherFiNodesManager;\\n    }    \\n\\n    //--------------------------------------------------------------------------------------\\n    //-------------------------------------  SETTER   --------------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    /// @notice Set the validator phase\\n    /// @param _phase the new phase\\n    function setPhase(\\n        VALIDATOR_PHASE _phase\\n    ) external onlyEtherFiNodeManagerContract {\\n        _validatePhaseTransition(_phase);\\n        phase = _phase;\\n    }\\n\\n    /// @notice Set the deposit data\\n    /// @param _ipfsHash the deposit data\\n    function setIpfsHashForEncryptedValidatorKey(\\n        string calldata _ipfsHash\\n    ) external onlyEtherFiNodeManagerContract {\\n        ipfsHashForEncryptedValidatorKey = _ipfsHash;\\n    }\\n\\n    /// @notice Set the local revenue index\\n    /// @param _localRevenueIndex the value of the local index to set\\n    function setLocalRevenueIndex(\\n        uint256 _localRevenueIndex\\n    ) external payable onlyEtherFiNodeManagerContract {\\n        localRevenueIndex = _localRevenueIndex;\\n    }\\n\\n    /// @notice Sets the exit request timestamp\\n    /// @dev Called when a TNFT holder submits an exit request\\n    function setExitRequestTimestamp() external onlyEtherFiNodeManagerContract {\\n        require(exitRequestTimestamp == 0, \\\"Exit request was already sent.\\\");\\n        exitRequestTimestamp = uint32(block.timestamp);\\n    }\\n\\n    /// @notice Set the validators phase to exited\\n    /// @param _exitTimestamp the time the exit was complete\\n    function markExited(\\n        uint32 _exitTimestamp\\n    ) external onlyEtherFiNodeManagerContract {\\n        require(_exitTimestamp <= block.timestamp, \\\"Invalid exit timestamp\\\");\\n        _validatePhaseTransition(VALIDATOR_PHASE.EXITED);\\n        phase = VALIDATOR_PHASE.EXITED;\\n        exitTimestamp = _exitTimestamp;\\n    }\\n\\n    /// @notice Set the validators phase to EVICTED\\n    function markEvicted() external onlyEtherFiNodeManagerContract {\\n        _validatePhaseTransition(VALIDATOR_PHASE.EVICTED);\\n        phase = VALIDATOR_PHASE.EVICTED;\\n        exitTimestamp = uint32(block.timestamp);\\n    }\\n\\n    //--------------------------------------------------------------------------------------\\n    //----------------------------  STATE-CHANGING FUNCTIONS  ------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    function receiveVestedRewardsForStakers()\\n        external\\n        payable\\n        onlyProtocolRevenueManagerContract\\n    {\\n        require(\\n            vestedAuctionRewards == 0,\\n            \\\"already received the vested auction fee reward\\\"\\n        );\\n        vestedAuctionRewards = msg.value;\\n    }\\n\\n    /// @notice Sets the vested auction rewards variable to 0 to show the auction fee has been withdrawn\\n    function processVestedAuctionFeeWithdrawal() external onlyEtherFiNodeManagerContract {\\n        if (_getClaimableVestedRewards(false) > 0) {\\n            vestedAuctionRewards = 0;\\n        }\\n    }\\n\\n    /// @notice Sends funds to the rewards manager\\n    /// @param _amount The value calculated in the etherfi node manager to send to the rewards manager\\n    function moveRewardsToManager(\\n        uint256 _amount\\n    ) external onlyEtherFiNodeManagerContract {\\n        (bool sent, ) = payable(etherFiNodesManager).call{value: _amount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n\\n    function withdrawFunds(\\n        address _treasury,\\n        uint256 _treasuryAmount,\\n        address _operator,\\n        uint256 _operatorAmount,\\n        address _tnftHolder,\\n        uint256 _tnftAmount,\\n        address _bnftHolder,\\n        uint256 _bnftAmount\\n    ) external onlyEtherFiNodeManagerContract {\\n        // the recipients of the funds must be able to receive the fund\\n        // For example, if it is a smart contract, \\n        // they should implement either receive() or fallback() properly\\n        // It's designed to prevent malicious actors from pausing the withdrawals\\n        bool sent;\\n        (sent, ) = payable(_operator).call{value: _operatorAmount, gas: 2300}(\\\"\\\");\\n        _treasuryAmount += (!sent) ? _operatorAmount : 0;\\n        (sent, ) = payable(_bnftHolder).call{value: _bnftAmount, gas: 2300}(\\\"\\\");\\n        _treasuryAmount += (!sent) ? _bnftAmount : 0;\\n        (sent, ) = payable(_tnftHolder).call{value: _tnftAmount, gas: 12000}(\\\"\\\"); // to support 'receive' of LP\\n        _treasuryAmount += (!sent) ? _tnftAmount : 0;\\n        (sent, ) = _treasury.call{value: _treasuryAmount, gas: 2300}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n\\n    //--------------------------------------------------------------------------------------\\n    //--------------------------------------  GETTER  --------------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    /// @notice Compute the payouts for {staking, protocol} rewards and vested auction fee to the individuals\\n    /// @param _beaconBalance the balance of the validator in Consensus Layer\\n    /// @param _stakingRewards a flag to be set if the caller wants to compute the payouts for the staking rewards\\n    /// @param _protocolRewards a flag to be set if the caller wants to compute the payouts for the protocol rewards\\n    /// @param _vestedAuctionFee a flag to be set if the caller wants to compute the payouts for the vested auction fee\\n    /// @param _assumeFullyVested a flag to include the vested rewards assuming the vesting schedules are completed\\n    /// @param _SRsplits the splits for the Staking Rewards\\n    /// @param _PRsplits the splits for the Protocol Rewards\\n    /// @param _scale the scale\\n    ///\\n    /// @return toNodeOperator  the payout to the Node Operator\\n    /// @return toTnft          the payout to the T-NFT holder\\n    /// @return toBnft          the payout to the B-NFT holder\\n    /// @return toTreasury      the payout to the Treasury\\n    function getRewardsPayouts(\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee,\\n        bool _assumeFullyVested,\\n        IEtherFiNodesManager.RewardsSplit memory _SRsplits,\\n        IEtherFiNodesManager.RewardsSplit memory _PRsplits,\\n        uint256 _scale\\n    )\\n        public\\n        view\\n        returns (uint256 toNodeOperator, uint256 toTnft, uint256 toBnft, uint256 toTreasury)\\n    {\\n        // (operator, tnft, bnft, treasury)\\n        uint256[] memory payouts = new uint256[](4);\\n        uint256[] memory tmps = new uint256[](4);\\n\\n        if (_stakingRewards) {\\n            (tmps[0], tmps[1], tmps[2], tmps[3]) = getStakingRewardsPayouts(\\n                _beaconBalance,\\n                _SRsplits,\\n                _scale\\n            );\\n            payouts[0] += tmps[0];\\n            payouts[1] += tmps[1];\\n            payouts[2] += tmps[2];\\n            payouts[3] += tmps[3];\\n        }\\n\\n        if (_protocolRewards) {\\n            (tmps[0], tmps[1], tmps[2], tmps[3]) = getProtocolRewardsPayouts(\\n                _PRsplits,\\n                _scale\\n            );\\n            payouts[0] += tmps[0];\\n            payouts[1] += tmps[1];\\n            payouts[2] += tmps[2];\\n            payouts[3] += tmps[3];\\n        }\\n\\n        if (_vestedAuctionFee) {\\n            uint256 rewards = _getClaimableVestedRewards(_assumeFullyVested);\\n            uint256 toTnft = (rewards * 29) / 32;\\n            payouts[1] += toTnft; // 29 / 32\\n            payouts[2] += rewards - toTnft; // 3 / 32\\n        }\\n\\n        return (payouts[0], payouts[1], payouts[2], payouts[3]);\\n    }\\n\\n    /// @notice Fetch the accrued staking rewards payouts to (toNodeOperator, toTnft, toBnft, toTreasury)\\n    /// @param _beaconBalance the balance of the validator in Consensus Layer\\n    /// @param _splits the splits for the staking rewards\\n    /// @param _scale the scale = SUM(_splits)\\n    ///\\n    /// Note that since the smart contract running in the execution layer does not know the consensus layer data\\n    /// such as the status and balance of the validator, \\n    /// the partial withdrawal assumes that the validator is in active & not being slashed + the beacon balance is 32 ether.\\n    /// Therefore, you need to set _beaconBalance = 32 ether to see the same payouts for the partial withdrawal\\n    ///\\n    /// @return toNodeOperator  the payout to the Node Operator\\n    /// @return toTnft          the payout to the T-NFT holder\\n    /// @return toBnft          the payout to the B-NFT holder\\n    /// @return toTreasury      the payout to the Treasury\\n    function getStakingRewardsPayouts(\\n        uint256 _beaconBalance,\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 toNodeOperator,\\n            uint256 toTnft,\\n            uint256 toBnft,\\n            uint256 toTreasury\\n        )\\n    {\\n        uint256 stakingBalance = _beaconBalance + getWithdrawableAmount(true, false, false, false);\\n        uint256 rewards;\\n\\n        // If (Staking Principal + Staking Rewards >= 32 ether), the validator is running in a normal state\\n        // Else, the validator is getting slashed\\n        if (stakingBalance >= 32 ether) {\\n            rewards = stakingBalance - 32 ether;\\n        } else {\\n            // Without the Oracle, the exact staking rewards cannot be computed\\n            // Assume that there is no staking rewards.\\n            return (0, 0, 0, 0);\\n        }\\n\\n        (\\n            uint256 operator,\\n            uint256 tnft,\\n            uint256 bnft,\\n            uint256 treasury\\n        ) = calculatePayouts(rewards, _splits, _scale);\\n\\n        // If there was the exit request from the T-NFT holder,\\n        // but the B-NFT holder did not serve it by sending the voluntary exit message for more than 14 days\\n        // it incentivize's the node operator to do so instead\\n        // by\\n        //  - not sharing the staking rewards anymore with the node operator (see the below logic)\\n        //  - sharing the non-exit penalty with the node operator instead (~ 0.2 eth)\\n        if (exitRequestTimestamp > 0) {\\n            uint256 daysPassedSinceExitRequest = _getDaysPassedSince(\\n                exitRequestTimestamp,\\n                uint32(block.timestamp)\\n            );\\n            if (daysPassedSinceExitRequest >= 14) {\\n                treasury += operator;\\n                operator = 0;\\n            }\\n        }\\n\\n        return (operator, tnft, bnft, treasury);\\n    }\\n\\n    /// @notice Fetch the accrued protocol rewards payouts to (toNodeOperator, toTnft, toBnft, toTreasury)\\n    /// @param _splits the splits for the protocol rewards\\n    /// @param _scale the scale = SUM(_splits)\\n    ///\\n    /// @return toNodeOperator  the payout to the Node Operator\\n    /// @return toTnft          the payout to the T-NFT holder\\n    /// @return toBnft          the payout to the B-NFT holder\\n    /// @return toTreasury      the payout to the Treasury\\n    function getProtocolRewardsPayouts(\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 toNodeOperator,\\n            uint256 toTnft,\\n            uint256 toBnft,\\n            uint256 toTreasury\\n        )\\n    {\\n        uint256 rewards = getWithdrawableAmount(false, true, false, false);\\n        if (rewards == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n        return calculatePayouts(rewards, _splits, _scale);\\n    }\\n\\n    /// @notice Compute the non exit penalty for the b-nft holder\\n    /// @param _tNftExitRequestTimestamp the timestamp when the T-NFT holder asked the B-NFT holder to exit the node\\n    /// @param _bNftExitRequestTimestamp the timestamp when the B-NFT holder submitted the exit request to the beacon network\\n    function getNonExitPenalty(\\n        uint32 _tNftExitRequestTimestamp, \\n        uint32 _bNftExitRequestTimestamp\\n    ) public view returns (uint256) {\\n        if (_tNftExitRequestTimestamp == 0) {\\n            return 0;\\n        }\\n        uint128 _principal = IEtherFiNodesManager(etherFiNodesManager).nonExitPenaltyPrincipal();\\n        uint64 _dailyPenalty = IEtherFiNodesManager(etherFiNodesManager).nonExitPenaltyDailyRate();\\n        uint256 daysElapsed = _getDaysPassedSince(\\n            _tNftExitRequestTimestamp,\\n            _bNftExitRequestTimestamp\\n        );\\n\\n        // full penalty\\n        if (daysElapsed > 365) {\\n            return _principal;\\n        }\\n\\n        uint256 remaining = _principal;\\n        while (daysElapsed > 0) {\\n            uint256 exponent = Math.min(7, daysElapsed);\\n            remaining = (remaining * (100 - uint256(_dailyPenalty)) ** exponent) / (100 ** exponent);\\n            daysElapsed -= Math.min(7, daysElapsed);\\n        }\\n\\n        return _principal - remaining;\\n    }\\n\\n    /// @notice Given\\n    ///         - the current balance of the validator in Consensus Layer\\n    ///         - the current balance of the ether fi node,\\n    ///         Compute the TVLs for {node operator, t-nft holder, b-nft holder, treasury}\\n    /// @param _beaconBalance the balance of the validator in Consensus Layer\\n    /// @param _SRsplits the splits for the Staking Rewards\\n    /// @param _PRsplits the splits for the Protocol Rewards\\n    /// @param _scale the scale\\n    ///\\n    /// @return toNodeOperator  the payout to the Node Operator\\n    /// @return toTnft          the payout to the T-NFT holder\\n    /// @return toBnft          `the payout to the B-NFT holder\\n    /// @return toTreasury      the payout to the Treasury\\n    function calculateTVL(\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee,\\n        bool _assumeFullyVested,\\n        IEtherFiNodesManager.RewardsSplit memory _SRsplits,\\n        IEtherFiNodesManager.RewardsSplit memory _PRsplits,\\n        uint256 _scale\\n    ) public view returns (uint256 toNodeOperator, uint256 toTnft, uint256 toBnft, uint256 toTreasury) {\\n        uint256 balance = _beaconBalance + getWithdrawableAmount(_stakingRewards, _protocolRewards, _vestedAuctionFee, _assumeFullyVested);\\n\\n        // Compute the payouts for the rewards = (staking rewards + vested auction fee rewards)\\n        // the protocol rewards must be paid off already in 'processNodeExit'\\n        uint256[] memory payouts = new uint256[](4); // (toNodeOperator, toTnft, toBnft, toTreasury)\\n        (payouts[0], payouts[1], payouts[2], payouts[3]) = getRewardsPayouts(_beaconBalance, \\n                                                                            _stakingRewards, _protocolRewards, _vestedAuctionFee, _assumeFullyVested,\\n                                                                             _SRsplits, _PRsplits, _scale);\\n        balance -= (payouts[0] + payouts[1] + payouts[2] + payouts[3]);\\n\\n        // Compute the payouts for the principals to {B, T}-NFTs\\n        {\\n            (uint256 toBnftPrincipal, uint256 toTnftPrincipal) = calculatePrincipals(balance);\\n            payouts[1] += toTnftPrincipal;\\n            payouts[2] += toBnftPrincipal;\\n        }\\n\\n        // Apply the non-exit penalty to the B-NFT\\n        {\\n            uint256 bnftNonExitPenalty = getNonExitPenalty(exitRequestTimestamp, exitTimestamp);\\n            uint256 appliedPenalty = Math.min(payouts[2], bnftNonExitPenalty);\\n            payouts[2] -= appliedPenalty;\\n\\n            // While the NonExitPenalty keeps growing till 1 ether,\\n            //  the incentive to the node operator stops growing at 0.2 ether\\n            //  the rest goes to the treasury\\n            // - Cap the incentive to the operator under 0.2 ether.\\n            if (appliedPenalty > 0.2 ether) {\\n                payouts[0] += 0.2 ether;\\n                payouts[3] += appliedPenalty - 0.2 ether;\\n            } else {\\n                payouts[0] += appliedPenalty;\\n            }\\n        }\\n\\n        require(\\n            payouts[0] + payouts[1] + payouts[2] + payouts[3] ==\\n                _beaconBalance + getWithdrawableAmount(_stakingRewards, _protocolRewards, _vestedAuctionFee, _assumeFullyVested),\\n            \\\"Incorrect Amount\\\"\\n        );\\n        return (payouts[0], payouts[1], payouts[2], payouts[3]);\\n    }\\n\\n    /// @notice Calculates values for payouts based on certain parameters\\n    /// @param _totalAmount The total amount to split\\n    /// @param _splits The splits for the staking rewards\\n    /// @param _scale The scale = SUM(_splits)\\n    ///\\n    /// @return toNodeOperator  the payout to the Node Operator\\n    /// @return toTnft          the payout to the T-NFT holder\\n    /// @return toBnft          the payout to the B-NFT holder\\n    /// @return toTreasury      the payout to the Treasury\\n    function calculatePayouts(\\n        uint256 _totalAmount,\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    ) public pure returns (uint256 toNodeOperator, uint256 toTnft, uint256 toBnft, uint256 toTreasury) {\\n        require(\\n            _splits.nodeOperator +\\n                _splits.tnft +\\n                _splits.bnft +\\n                _splits.treasury ==\\n                _scale,\\n            \\\"Incorrect Splits\\\"\\n        );\\n        toNodeOperator = (_totalAmount * _splits.nodeOperator) / _scale;\\n        toTnft = (_totalAmount * _splits.tnft) / _scale;\\n        toBnft = (_totalAmount * _splits.bnft) / _scale;\\n        toTreasury = _totalAmount - (toBnft + toTnft + toNodeOperator);\\n        return (toNodeOperator, toTnft, toBnft, toTreasury);\\n    }\\n\\n    /// @notice Calculate the principal for the T-NFT and B-NFT holders based on the balance\\n    /// @param _balance The balance of the node\\n    /// @return toBnftPrincipal the principal for the B-NFT holder\\n    /// @return toTnftPrincipal the principal for the T-NFT holder\\n    function calculatePrincipals(\\n        uint256 _balance\\n    ) public pure returns (uint256 , uint256) {\\n        require(_balance <= 32 ether, \\\"the total principal must be lower than 32 ether\\\");\\n        uint256 toBnftPrincipal;\\n        uint256 toTnftPrincipal;\\n        if (_balance > 31.5 ether) {\\n            // 31.5 ether < balance <= 32 ether\\n            toBnftPrincipal = _balance - 30 ether;\\n        } else if (_balance > 26 ether) {\\n            // 26 ether < balance <= 31.5 ether\\n            toBnftPrincipal = 1.5 ether;\\n        } else if (_balance > 25.5 ether) {\\n            // 25.5 ether < balance <= 26 ether\\n            toBnftPrincipal = 1.5 ether - (26 ether - _balance);\\n        } else if (_balance > 16 ether) {\\n            // 16 ether <= balance <= 25.5 ether\\n            toBnftPrincipal = 1 ether;\\n        } else {\\n            // balance < 16 ether\\n            // The T-NFT and B-NFT holder's principals decrease \\n            // starting from 15 ether and 1 ether respectively.\\n            toBnftPrincipal = 625 * _balance / 10_000;\\n        }\\n        toTnftPrincipal = _balance - toBnftPrincipal;\\n        return (toBnftPrincipal, toTnftPrincipal);\\n    }\\n\\n    /// @notice Compute the withdrawable amount from the node\\n    /// @param _stakingRewards a flag to include the withdrawable amount for the staking principal + rewards\\n    /// @param _protocolRewards a flag to include the withdrawable amount for the protocol rewards\\n    /// @param _vestedAuctionFee a flag to include the withdrawable amount for the vested auction fee\\n    /// @param _assumeFullyVested a flag to include the vested rewards assuming the vesting schedules are completed\\n    function getWithdrawableAmount(bool _stakingRewards, bool _protocolRewards, bool _vestedAuctionFee, bool _assumeFullyVested) public view returns (uint256) {\\n        uint256 balance = 0;\\n        if (_stakingRewards) {\\n            balance += address(this).balance - vestedAuctionRewards;\\n        }\\n        if (_protocolRewards && localRevenueIndex > 0) {\\n            uint256 globalRevenueIndex = IProtocolRevenueManager(_protocolRevenueManagerAddress()).globalRevenueIndex();\\n            balance += globalRevenueIndex - localRevenueIndex;\\n        }\\n        if (_vestedAuctionFee) {\\n            balance += _getClaimableVestedRewards(_assumeFullyVested);\\n        }\\n        return balance;\\n    }\\n\\n    //--------------------------------------------------------------------------------------\\n    //-------------------------------  INTERNAL FUNCTIONS  ---------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    function _validatePhaseTransition(VALIDATOR_PHASE _newPhase) internal view returns (bool) {\\n        VALIDATOR_PHASE currentPhase = phase;\\n        bool pass = true;\\n\\n        // Transition rules\\n        if (currentPhase == VALIDATOR_PHASE.NOT_INITIALIZED) {\\n            pass = (_newPhase == VALIDATOR_PHASE.STAKE_DEPOSITED);\\n        } else if (currentPhase == VALIDATOR_PHASE.STAKE_DEPOSITED) {\\n            pass = (_newPhase == VALIDATOR_PHASE.LIVE || _newPhase == VALIDATOR_PHASE.CANCELLED);\\n        } else if (currentPhase == VALIDATOR_PHASE.LIVE) {\\n            pass = (_newPhase == VALIDATOR_PHASE.EXITED || _newPhase == VALIDATOR_PHASE.BEING_SLASHED || _newPhase == VALIDATOR_PHASE.EVICTED);\\n        } else if (currentPhase == VALIDATOR_PHASE.BEING_SLASHED) {\\n            pass = (_newPhase == VALIDATOR_PHASE.EXITED);\\n        } else if (currentPhase == VALIDATOR_PHASE.EXITED) {\\n            pass = (_newPhase == VALIDATOR_PHASE.FULLY_WITHDRAWN);\\n        } else {\\n            pass = false;\\n        }\\n\\n        require(pass, \\\"Invalid phase transition\\\");\\n    }\\n    \\n    function _getClaimableVestedRewards(bool _assumeFullyVested) internal view returns (uint256) {\\n        if (vestedAuctionRewards == 0) {\\n            return 0;\\n        }\\n        uint256 vestingPeriodInDays = IProtocolRevenueManager(\\n            _protocolRevenueManagerAddress()\\n        ).auctionFeeVestingPeriodForStakersInDays();\\n        uint256 daysPassed = _getDaysPassedSince(\\n            stakingStartTimestamp,\\n            uint32(block.timestamp)\\n        );\\n        bool fullyVested = _assumeFullyVested || daysPassed >= vestingPeriodInDays;\\n        if (fullyVested || phase == VALIDATOR_PHASE.EVICTED) {\\n            return vestedAuctionRewards;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _getDaysPassedSince(\\n        uint32 _startTimestamp,\\n        uint32 _endTimestamp\\n    ) public pure returns (uint256) {\\n        if (_endTimestamp <= _startTimestamp) {\\n            return 0;\\n        }\\n        uint256 timeElapsed = _endTimestamp - _startTimestamp;\\n        return uint256(timeElapsed / (24 * 3_600));\\n    }\\n\\n    function _protocolRevenueManagerAddress() internal view returns (address) {\\n        return\\n            IEtherFiNodesManager(etherFiNodesManager)\\n                .protocolRevenueManagerContract();\\n    }\\n\\n    function implementation() external view returns (address) {\\n        bytes32 slot = bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1);\\n        address implementationVariable;\\n        assembly {\\n            implementationVariable := sload(slot)\\n        }\\n\\n        IBeacon beacon = IBeacon(implementationVariable);\\n        return beacon.implementation();\\n    }\\n\\n    //--------------------------------------------------------------------------------------\\n    //-----------------------------------  MODIFIERS  --------------------------------------\\n    //--------------------------------------------------------------------------------------\\n\\n    modifier onlyEtherFiNodeManagerContract() {\\n        require(\\n            msg.sender == etherFiNodesManager,\\n            \\\"Only EtherFiNodeManager Contract\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyProtocolRevenueManagerContract() {\\n        require(\\n            msg.sender == _protocolRevenueManagerAddress(),\\n            \\\"Only protocol revenue manager contract function\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IEtherFiNode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./IEtherFiNodesManager.sol\\\";\\n\\ninterface IEtherFiNode {\\n    // State Transition Diagram for StateMachine contract:\\n    //\\n    //      NOT_INITIALIZED\\n    //              |\\n    //              \u2193\\n    //      STAKE_DEPOSITED\\n    //           /      \\\\\\n    //          /        \\\\\\n    //         \u2193          \u2193\\n    //         LIVE    CANCELLED\\n    //         |  \\\\ \\\\ \\n    //         |   \\\\ \\\\\\n    //         |   \u2193  --> EVICTED\\n    //         |  BEING_SLASHED\\n    //         |    /\\n    //         |   /\\n    //         \u2193  \u2193\\n    //         EXITED\\n    //           |\\n    //           \u2193\\n    //      FULLY_WITHDRAWN\\n    // Transitions are only allowed as directed above.\\n    // For instance, a transition from STAKE_DEPOSITED to either LIVE or CANCELLED is allowed,\\n    // but a transition from STAKE_DEPOSITED to NOT_INITIALIZED, BEING_SLASHED, or EXITED is not.\\n    //\\n    // All phase transitions should be made through the setPhase function,\\n    // which validates transitions based on these rules.\\n    enum VALIDATOR_PHASE {\\n        NOT_INITIALIZED,\\n        STAKE_DEPOSITED,\\n        LIVE,\\n        EXITED,\\n        FULLY_WITHDRAWN,\\n        CANCELLED,\\n        BEING_SLASHED,\\n        EVICTED\\n    }\\n\\n    // VIEW functions\\n    function phase() external view returns (VALIDATOR_PHASE);\\n\\n    function ipfsHashForEncryptedValidatorKey()\\n        external\\n        view\\n        returns (string memory);\\n\\n    function localRevenueIndex() external view returns (uint256);\\n\\n    function stakingStartTimestamp() external view returns (uint32);\\n\\n    function exitRequestTimestamp() external view returns (uint32);\\n\\n    function exitTimestamp() external view returns (uint32);\\n\\n    function vestedAuctionRewards() external view returns (uint256);\\n\\n    function calculatePayouts(\\n        uint256 _totalAmount,\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getStakingRewardsPayouts(\\n        uint256 _beaconBalance,\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getProtocolRewardsPayouts(\\n        IEtherFiNodesManager.RewardsSplit memory _splits,\\n        uint256 _scale\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getNonExitPenalty(\\n        uint32 _tNftExitRequestTimestamp, \\n        uint32 _bNftExitRequestTimestamp\\n    ) external view returns (uint256);\\n\\n    function getRewardsPayouts(\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee,\\n        bool _assumeFullyVested,\\n        IEtherFiNodesManager.RewardsSplit memory _SRsplits,\\n        IEtherFiNodesManager.RewardsSplit memory _PRsplits,\\n        uint256 _scale\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function calculateTVL(\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee,\\n        bool _assumeFullyVested,\\n        IEtherFiNodesManager.RewardsSplit memory _SRsplits,\\n        IEtherFiNodesManager.RewardsSplit memory _PRsplits,\\n        uint256 _scale\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    // Non-VIEW functions\\n    function setPhase(VALIDATOR_PHASE _phase) external;\\n\\n    function setIpfsHashForEncryptedValidatorKey(\\n        string calldata _ipfs\\n    ) external;\\n\\n    function setLocalRevenueIndex(uint256 _localRevenueIndex) external payable;\\n\\n    function setExitRequestTimestamp() external;\\n\\n    function markExited(uint32 _exitTimestamp) external;\\n\\n    function markEvicted() external;\\n\\n    function receiveVestedRewardsForStakers() external payable;\\n\\n    function processVestedAuctionFeeWithdrawal() external;\\n\\n    // Withdraw Rewards\\n    function moveRewardsToManager(uint256 _amount) external;\\n\\n    function withdrawFunds(\\n        address _treasury,\\n        uint256 _treasuryAmount,\\n        address _operator,\\n        uint256 _operatorAmount,\\n        address _tnftHolder,\\n        uint256 _tnftAmount,\\n        address _bnftHolder,\\n        uint256 _bnftAmount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IEtherFiNodesManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./IEtherFiNode.sol\\\";\\n\\ninterface IEtherFiNodesManager {\\n    enum ValidatorRecipientType {\\n        TNFTHOLDER,\\n        BNFTHOLDER,\\n        TREASURY,\\n        OPERATOR\\n    }\\n\\n    struct RewardsSplit {\\n        uint64 treasury;\\n        uint64 nodeOperator;\\n        uint64 tnft;\\n        uint64 bnft;\\n    }\\n\\n    // VIEW functions\\n    function numberOfValidators() external view returns (uint64);\\n    function nonExitPenaltyPrincipal() external view returns (uint64);\\n    function nonExitPenaltyDailyRate() external view returns (uint64);\\n\\n    function etherfiNodeAddress(\\n        uint256 _validatorId\\n    ) external view returns (address);\\n\\n    function phase(\\n        uint256 _validatorId\\n    ) external view returns (IEtherFiNode.VALIDATOR_PHASE phase);\\n\\n    function ipfsHashForEncryptedValidatorKey(\\n        uint256 _validatorId\\n    ) external view returns (string memory);\\n\\n    function localRevenueIndex(uint256 _validatorId) external returns (uint256);\\n\\n    function vestedAuctionRewards(\\n        uint256 _validatorId\\n    ) external returns (uint256);\\n\\n    function generateWithdrawalCredentials(\\n        address _address\\n    ) external view returns (bytes memory);\\n\\n    function getWithdrawalCredentials(\\n        uint256 _validatorId\\n    ) external view returns (bytes memory);\\n    \\n    function calculateTVL(\\n        uint256 _validatorId,\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee,\\n        bool _assumeFullyVested\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n    \\n    function isExitRequested(uint256 _validatorId) external view returns (bool);\\n\\n    function isExited(uint256 _validatorId) external view returns (bool);\\n    function isFullyWithdrawn(uint256 _validatorId) external view returns (bool);\\n    function isEvicted(uint256 _validatorId) external view returns (bool);\\n\\n    function getNonExitPenalty(\\n        uint256 _validatorId\\n    ) external view returns (uint256);\\n\\n    function getStakingRewardsPayouts(\\n        uint256 _validatorId,\\n        uint256 _beaconBalance\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getRewardsPayouts(\\n        uint256 _validatorId,\\n        uint256 _beaconBalance,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getFullWithdrawalPayouts(\\n        uint256 _validatorId\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function protocolRevenueManagerContract() external view returns (address);\\n\\n    // Non-VIEW functions\\n    function initialize(\\n        address _treasuryContract,\\n        address _auctionContract,\\n        address _stakingManagerContract,\\n        address _tnftContract,\\n        address _bnftContract,\\n        address _protocolRevenueManagerContract\\n    ) external;\\n\\n    function incrementNumberOfValidators(uint64 _count) external;\\n\\n    function registerEtherFiNode(\\n        uint256 _validatorId,\\n        address _address\\n    ) external;\\n\\n    function unregisterEtherFiNode(uint256 _validatorId) external;\\n\\n    function setStakingRewardsSplit(\\n        uint64 _treasury,\\n        uint64 _nodeOperator,\\n        uint64 _tnft,\\n        uint64 _bnft\\n    ) external;\\n\\n    function setProtocolRewardsSplit(\\n        uint64 _treasury,\\n        uint64 _nodeOperator,\\n        uint64 _tnft,\\n        uint64 _bnft\\n    ) external;\\n\\n    function setNonExitPenaltyPrincipal(\\n        uint64 _nonExitPenaltyPrincipal\\n    ) external;\\n\\n    function setNonExitPenaltyDailyRate(\\n        uint64 _nonExitPenaltyDailyRate\\n    ) external;\\n\\n    function setEtherFiNodePhase(\\n        uint256 _validatorId,\\n        IEtherFiNode.VALIDATOR_PHASE _phase\\n    ) external;\\n\\n    function setEtherFiNodeIpfsHashForEncryptedValidatorKey(\\n        uint256 _validatorId,\\n        string calldata _ipfs\\n    ) external;\\n\\n    function setEtherFiNodeLocalRevenueIndex(\\n        uint256 _validatorId,\\n        uint256 _localRevenueIndex\\n    ) external payable;\\n\\n    function sendExitRequest(uint256 _validatorId) external;\\n    function batchSendExitRequest(uint256[] calldata _validatorIds) external;\\n\\n    function processNodeExit(\\n        uint256[] calldata _validatorIds,\\n        uint32[] calldata _exitTimestamp\\n    ) external;\\n\\n    function partialWithdraw(\\n        uint256 _validatorId,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee\\n    ) external;\\n\\n    function partialWithdrawBatch(\\n        uint256[] calldata _validatorIds,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee\\n    ) external;\\n\\n    function partialWithdrawBatchGroupByOperator(\\n        address _operator,\\n        uint256[] memory _validatorIds,\\n        bool _stakingRewards,\\n        bool _protocolRewards,\\n        bool _vestedAuctionFee\\n    ) external;\\n\\n    function fullWithdraw(uint256 _validatorId) external;\\n\\n    function fullWithdrawBatch(uint256[] calldata _validatorIds) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IProtocolRevenueManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IProtocolRevenueManager {\\n    struct AuctionRevenueSplit {\\n        uint64 treasurySplit;\\n        uint64 nodeOperatorSplit;\\n        uint64 tnftHolderSplit;\\n        uint64 bnftHolderSplit;\\n    }\\n\\n    function globalRevenueIndex() external view returns (uint256);\\n\\n    function auctionFeeVestingPeriodForStakersInDays()\\n        external\\n        view\\n        returns (uint128);\\n\\n    function getAccruedAuctionRevenueRewards(\\n        uint256 _validatorId\\n    ) external view returns (uint256);\\n\\n    function addAuctionRevenue(uint256 _validatorId) external payable;\\n\\n    function distributeAuctionRevenue(\\n        uint256 _validatorId\\n    ) external returns (uint256);\\n\\n    function setEtherFiNodesManagerAddress(\\n        address _etherFiNodesManager\\n    ) external;\\n\\n    function setAuctionManagerAddress(address _auctionManager) external;\\n\\n    function setAuctionRewardVestingPeriod(uint128 _periodInDays) external;\\n\\n    function setAuctionRewardSplitForStakers(uint128 _split) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@uniswap/=lib/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v3-core/=lib/v3-core/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_startTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_endTimestamp\",\"type\":\"uint32\"}],\"name\":\"_getDaysPassedSince\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_splits\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"calculatePayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toNodeOperator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"calculatePrincipals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_beaconBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_stakingRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_protocolRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_vestedAuctionFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_assumeFullyVested\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_SRsplits\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_PRsplits\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"calculateTVL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toNodeOperator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherFiNodesManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitRequestTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tNftExitRequestTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_bNftExitRequestTimestamp\",\"type\":\"uint32\"}],\"name\":\"getNonExitPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_splits\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"getProtocolRewardsPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toNodeOperator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_beaconBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_stakingRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_protocolRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_vestedAuctionFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_assumeFullyVested\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_SRsplits\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_PRsplits\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"getRewardsPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toNodeOperator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_beaconBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"treasury\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nodeOperator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tnft\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bnft\",\"type\":\"uint64\"}],\"internalType\":\"struct IEtherFiNodesManager.RewardsSplit\",\"name\":\"_splits\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"getStakingRewardsPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toNodeOperator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBnft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stakingRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_protocolRewards\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_vestedAuctionFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_assumeFullyVested\",\"type\":\"bool\"}],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_etherFiNodesManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ipfsHashForEncryptedValidatorKey\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localRevenueIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"markEvicted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_exitTimestamp\",\"type\":\"uint32\"}],\"name\":\"markExited\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveRewardsToManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"internalType\":\"enum IEtherFiNode.VALIDATOR_PHASE\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processVestedAuctionFeeWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveVestedRewardsForStakers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setExitRequestTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ipfsHash\",\"type\":\"string\"}],\"name\":\"setIpfsHashForEncryptedValidatorKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_localRevenueIndex\",\"type\":\"uint256\"}],\"name\":\"setLocalRevenueIndex\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IEtherFiNode.VALIDATOR_PHASE\",\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"setPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingStartTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestedAuctionRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_operatorAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tnftHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tnftAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bnftHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bnftAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EtherFiNode", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}