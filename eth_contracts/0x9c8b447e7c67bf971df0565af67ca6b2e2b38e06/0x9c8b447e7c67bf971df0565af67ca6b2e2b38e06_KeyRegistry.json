{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts-BatchDepositWithKeyRegistry/interfaces/IKeyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\n\\ninterface IKeyRegistry {\\n\\n    /// @dev Emitted when BatchDeposit contract address updated\\n    event UpdateBatchDepositContract(address indexed newBatchDepositContract);\\n\\n    /// @param _newBatchDepositContract new BatchDeposit contract address\\n    function updateBatchDepositContract(address _newBatchDepositContract) external;\\n\\n    /// @dev Emitted when Asset Manager updated\\n    event UpdateAssetManager(address indexed _assetManager);\\n\\n    /// @param _assetManager assetManager address\\n    function updateAssetManager(address _assetManager) external;\\n\\n\\n    /// @dev Key structure\\n    struct KeyInfo {\\n        bytes pubkey;\\n        bytes withdrawalCredential;\\n        bytes signature;\\n    }\\n\\n    /// @dev Emitted when one key added\\n    event AddKey(bytes pubkey);\\n\\n    /// @dev AssetManager submit keys. pubkeys, withdrawalCredentials and signatures are one-to-one correspondence in array.\\n    /// @param _addr address that can use keys submitted\\n    /// @param quantity keys' quantity\\n    /// @param pubkeys pubkeys\\n    /// @param withdrawalCredentials withdrawalCredentials\\n    /// @param signatures signatures\\n    function addKeys(\\n        address _addr,\\n        uint256 quantity,\\n        bytes[] calldata pubkeys,\\n        bytes[] calldata withdrawalCredentials,\\n        bytes[] calldata signatures\\n    ) external;\\n\\n    /// @dev Emitted when one key removed\\n    event RemoveKey(bytes pubkey);\\n\\n    /// @dev AssetManager remove keys. Will remove [startIdx, endIdx] range in keys[_addr].\\n    /// @param _addr address's keys to remove\\n    /// @param startIdx start index to remove, the startIdx element is removed\\n    /// @param endIdx end index to remove, the endIdx element is removed.\\n    function removeKeys(\\n        address _addr,\\n        uint256 startIdx,\\n        uint256 endIdx\\n    ) external;\\n\\n    /// @dev Emitted when one key assigned\\n    event AssignKey(bytes pubkey);\\n\\n    /// @dev EPotter assign keys to use. require keys are enough.\\n    /// @param _addr address's keys to assign\\n    /// @param quantity quantity\\n    /// @return return pubkeys, withdrawalCredentials and signatures, they are one-to-one correspondence in array.\\n    function assignKeys(address _addr, uint256 quantity)\\n        external\\n        returns (\\n            bytes[] memory,\\n            bytes[] memory,\\n            bytes[] memory\\n        );\\n\\n    /// @dev Get total quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return total quantity\\n    function getTotalQuantity(address _addr) external view returns (uint256);\\n\\n    /// @dev Get used quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return used quantity\\n    function getUsedQuantity(address _addr) external view returns (uint256);\\n\\n    /// @dev Get unused quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return unused quantity\\n    function getUnusedQuantity(address _addr) external view returns (uint256);\\n\\n    /// @dev get keys from startIdx to endIdx\\n    /// @param _addr who's key\\n    /// @param startIdx start index\\n    /// @param endIdx end index\\n    /// @return from start index to en index, keys' info\\n    function getMultipleKeys(address _addr, uint256 startIdx, uint256 endIdx) external view returns(KeyInfo[] memory);\\n\\n    /// @dev get pointed key\\n    /// @param _addr who's key\\n    /// @param _index index\\n    function getSingleKey(address _addr, uint256 _index) external view returns(KeyInfo memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts-BatchDepositWithKeyRegistry/KeyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IKeyRegistry.sol\\\";\\n\\n\\ncontract KeyRegistry is Ownable, IKeyRegistry {\\n    uint256 public constant PUBKEY_LENGTH = 48;\\n    uint256 public constant WITHDRAWAL_CREDENTIAL_LENGTH = 32;\\n    uint256 public constant SIGNATURE_LENGTH = 96;\\n    uint256 public constant MAX_PEER_ADD_KEYS = 50;\\n\\n    address public BatchDepositContract;\\n    address public assetManager;\\n\\n    mapping(address => KeyInfo[]) public keys;\\n    mapping(address => uint256) internal next;\\n\\n    mapping(bytes32 => bool) public existingPubKeys;\\n\\n    constructor(address _assetManager) {\\n        require(address(_assetManager) != address(0), \\\"invalid asset manager address\\\");\\n        assetManager = _assetManager;\\n    }\\n\\n    /// @dev Only BatchDepositContract can call\\n    modifier onlyBatchDepositContract() {\\n        require(msg.sender == BatchDepositContract, \\\"not BatchDeposit contract\\\");\\n        _;\\n    }\\n\\n    /// @param _newBatchDepositContract new BatchDeposit contract address\\n    function updateBatchDepositContract(address _newBatchDepositContract) public onlyOwner {\\n        require(address(_newBatchDepositContract) != address(0), \\\"invalid new batchDeposit contract\\\");\\n        require(address(_newBatchDepositContract) != address(BatchDepositContract), \\\"BatchDepositContract repeat\\\");\\n        BatchDepositContract = _newBatchDepositContract;\\n        emit UpdateBatchDepositContract(_newBatchDepositContract);\\n    }\\n\\n    /// @dev Only assetManager can call\\n    modifier onlyAssetManager() {\\n        require(msg.sender == assetManager, \\\"not asset manager\\\");\\n        _;\\n    }\\n\\n    /// @param _newAssetManager new assetManager address\\n    function updateAssetManager(address _newAssetManager)\\n        public\\n        onlyOwner\\n    {\\n        require(address(_newAssetManager) != address(0), \\\"invalid new asset manager address\\\");\\n        require(address(_newAssetManager) != address(assetManager), \\\"asset manager repeat\\\");\\n        assetManager = _newAssetManager;\\n        emit UpdateAssetManager(_newAssetManager);\\n    }\\n\\n    /// @dev AssetManager submit keys. pubkeys, withdrawalCredentials and signatures are one-to-one correspondence in array.\\n    /// @param _addr address that can use keys submitted\\n    /// @param quantity keys' quantity\\n    /// @param pubkeys pubkeys\\n    /// @param withdrawalCredentials withdrawalCredentials  \\n    /// @param signatures signatures\\n    function addKeys(\\n        address _addr,\\n        uint256 quantity,\\n        bytes[] calldata pubkeys,\\n        bytes[] calldata withdrawalCredentials,\\n        bytes[] calldata signatures\\n    ) \\n        public  \\n        onlyAssetManager \\n    {\\n        require(quantity != 0, \\\"zero quantity\\\");\\n        require(quantity <= MAX_PEER_ADD_KEYS,\\\"over max key amounts\\\");\\n        require(pubkeys.length == quantity, \\\"invalid total pubkeys length\\\");\\n        require(withdrawalCredentials.length == quantity, \\\"invalid total withdrawal_credentials length\\\");\\n        require(signatures.length == quantity, \\\"invalid total signatures length\\\");\\n\\n        for (uint256 i = 0; i < quantity; ++i) {\\n            require(pubkeys[i].length == PUBKEY_LENGTH, \\\"invalid pubkey length\\\");\\n            require(withdrawalCredentials[i].length == WITHDRAWAL_CREDENTIAL_LENGTH, \\\"invalid withdrawal_credential length\\\");\\n            require(signatures[i].length == SIGNATURE_LENGTH, \\\"invalid signature length\\\");\\n\\n            KeyInfo memory keyInfo;\\n            keyInfo.pubkey = pubkeys[i];\\n\\n            // check duplicated\\n            require(!existingPubKeys[keccak256(keyInfo.pubkey)], \\\"pubkey exists\\\");\\n            existingPubKeys[keccak256(keyInfo.pubkey)] = true;\\n\\n            keyInfo.withdrawalCredential = withdrawalCredentials[i];\\n            keyInfo.signature = signatures[i];\\n\\n            keys[_addr].push(keyInfo);\\n\\n            emit AddKey(keyInfo.pubkey);\\n        }\\n    }\\n\\n    /// @dev AssetManager remove keys. Will remove [startIdx, endIdx] range in keys[_addr].\\n    /// @param _addr address's keys to remove\\n    /// @param startIdx start index to remove. The startIdx element is removed\\n    /// @param endIdx end index to remove. The endIdx element is removed.\\n    function removeKeys(\\n        address _addr,\\n        uint256 startIdx,\\n        uint256 endIdx\\n    ) \\n        public \\n        onlyAssetManager \\n    {\\n        require(startIdx < keys[_addr].length, \\\"start index oversize\\\");\\n        require(startIdx >= next[_addr], \\\"start index key used\\\");\\n        require(startIdx <= endIdx, \\\"invalid range\\\");\\n        require(endIdx < keys[_addr].length, \\\"end index oversize\\\");\\n\\n        for (uint256 i = endIdx; ; i--) {\\n            bytes memory removedPubkey = keys[_addr][i].pubkey;\\n\\n            keys[_addr][i] = keys[_addr][keys[_addr].length - 1];\\n            keys[_addr].pop();\\n\\n            delete existingPubKeys[keccak256(removedPubkey)];\\n            emit RemoveKey(removedPubkey);\\n\\n            if (i <= startIdx) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    /// @dev EPotter assign keys to use. require keys are enough.\\n    /// @param _addr address's keys to assign\\n    /// @param quantity quantity\\n    /// @return return pubkeys, withdrawalCredentials and signatures, they are one-to-one correspondence in array.\\n    function assignKeys(address _addr, uint256 quantity) public onlyBatchDepositContract returns (\\n            bytes[] memory,\\n            bytes[] memory,\\n            bytes[] memory\\n        )\\n    {\\n        require(quantity != 0, \\\"zero quantity\\\");\\n        require(next[_addr] + quantity - 1 < keys[_addr].length, \\\"keys not enough\\\");\\n\\n        bytes[] memory pubkeys = new bytes[](quantity);\\n        bytes[] memory withdrawalCredentials = new bytes[](quantity);\\n        bytes[] memory signatures = new bytes[](quantity);\\n        uint256 startIdx = next[_addr];\\n        uint256 aIdx = 0;\\n\\n        for (uint256 i = startIdx; i < (startIdx + quantity); i++) {\\n            pubkeys[aIdx] = keys[_addr][i].pubkey;\\n            withdrawalCredentials[aIdx] = keys[_addr][i].withdrawalCredential;\\n            signatures[aIdx] = keys[_addr][i].signature;\\n\\n            next[_addr]++;\\n            aIdx++;\\n            emit AssignKey(keys[_addr][i].pubkey);\\n        }\\n\\n        return (pubkeys, withdrawalCredentials, signatures);\\n    }\\n\\n    \\n\\n    /// @dev Get total quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return total quantity\\n    function getTotalQuantity(address _addr) public view returns (uint256) {\\n        return keys[_addr].length;\\n    }\\n\\n    /// @dev Get used quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return used quantity\\n    function getUsedQuantity(address _addr) public view returns (uint256){\\n        return next[_addr];\\n    }\\n\\n    /// @dev Get unused quantity of _addr's keys\\n    /// @param _addr who's key\\n    /// @return unused quantity\\n    function getUnusedQuantity(address _addr) public view returns (uint256) {\\n        return getTotalQuantity(_addr) - getUsedQuantity(_addr);\\n    }\\n\\n    /// @dev get keys from startIdx to endIdx\\n    /// @param _addr who's key\\n    /// @param startIdx start index\\n    /// @param endIdx end index\\n    /// @return from start index to en index, keys' info\\n    function getMultipleKeys(address _addr, uint256 startIdx, uint256 endIdx) public view returns(KeyInfo[] memory) {\\n        require(address(_addr) != address(0), \\\"invalid address\\\");\\n        require(startIdx <= endIdx, \\\"invalid range\\\");\\n\\n        if(endIdx == 0) {\\n            KeyInfo[] memory keyInfoZero = new KeyInfo[](0);\\n            return keyInfoZero;\\n        }\\n\\n        require(endIdx < keys[_addr].length, \\\"over max keys number\\\");\\n        uint256 quantity = (endIdx - startIdx) + 1;\\n\\n        KeyInfo[] memory keyInfo = new KeyInfo[](quantity);\\n        \\n        for(uint256 i = 0; i < quantity; i++) {\\n            keyInfo[i] = keys[_addr][i + startIdx];\\n        }\\n\\n        return keyInfo;\\n    }\\n\\n    /// @dev get pointed key\\n    /// @param _addr who's key\\n    /// @param _index index\\n    function getSingleKey(address _addr, uint256 _index) public view returns(KeyInfo memory) {\\n        require(_index < keys[_addr].length,\\\"invalid index\\\");\\n        return keys[_addr][_index];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"name\":\"AddKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"name\":\"AssignKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"name\":\"RemoveKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_assetManager\",\"type\":\"address\"}],\"name\":\"UpdateAssetManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBatchDepositContract\",\"type\":\"address\"}],\"name\":\"UpdateBatchDepositContract\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BatchDepositContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PEER_ADD_KEYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBKEY_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNATURE_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAWAL_CREDENTIAL_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"pubkeys\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"addKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"assignKeys\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"existingPubKeys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIdx\",\"type\":\"uint256\"}],\"name\":\"getMultipleKeys\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"withdrawalCredential\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IKeyRegistry.KeyInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSingleKey\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"withdrawalCredential\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IKeyRegistry.KeyInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTotalQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUnusedQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUsedQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keys\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"withdrawalCredential\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIdx\",\"type\":\"uint256\"}],\"name\":\"removeKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAssetManager\",\"type\":\"address\"}],\"name\":\"updateAssetManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBatchDepositContract\",\"type\":\"address\"}],\"name\":\"updateBatchDepositContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KeyRegistry", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ae808541133d7dcca29a11ee0381c5d38038be1d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}