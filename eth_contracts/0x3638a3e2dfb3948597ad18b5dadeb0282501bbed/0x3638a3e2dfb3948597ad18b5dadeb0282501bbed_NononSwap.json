{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/NononSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title nonon swap\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"./interfaces/INonon.sol\\\";\\n\\n// errors\\nerror Unauthorized();\\nerror OfferForNonexistentToken();\\nerror NoActiveOffer();\\nerror NotRequestedToken();\\nerror TokenHasExistingOffer();\\n\\n// state\\nstruct TokenOffer {\\n    address owner;\\n    uint16 ownedId;\\n    uint16 wantedId; // unset (zero) is considered to be open\\n}\\n\\ncontract NononSwap {\\n    uint256 public constant nononMaxSupply = 5000;\\n    address public immutable nononAddress;\\n\\n    // events\\n    event OfferCreated(address indexed owner, uint256 indexed ownedId, uint256 indexed wantedId);\\n    event OfferCancelled(address indexed owner, uint256 indexed ownedId);\\n    event SwapCompleted(uint256 indexed firstTokenId, uint256 indexed secondTokenId);\\n\\n    /**\\n     * @dev Mapping (implemented as an array for gas efficiency) between token\\n     * ids and token offers. Thus, `offers[0]` should never be defined.\\n     */\\n    TokenOffer[nononMaxSupply + 1] public offers;\\n\\n    constructor(address _nononAddress) {\\n        nononAddress = _nononAddress;\\n    }\\n\\n    /**\\n     * @dev Create a token swap offer for the owned token `_ownedId` and the\\n     * wanted token `_wantedId`. It can also be used to update already set\\n     * offers so the owner doenst need to call `removeOffer` every time they\\n     * want to change their offer.\\n     * @param _ownedId Token that `msg.sender` owns and wants to swap for\\n     * `_wantedId`\\n     * @param _wantedId Token that `msg.sender` wants, 0 if they dont care\\n     * and just want to farm friendship points.\\n     */\\n    function createTokenOffer(uint16 _ownedId, uint16 _wantedId) external {\\n        INonon nonon = INonon(nononAddress);\\n\\n        if (!nononExists(_ownedId) || (_wantedId != 0 && !nononExists(_wantedId))) {\\n            revert OfferForNonexistentToken();\\n        }\\n\\n        if (nonon.ownerOf(_ownedId) != msg.sender) {\\n            revert Unauthorized();\\n        }\\n\\n        offers[_ownedId] = TokenOffer({owner: msg.sender, ownedId: _ownedId, wantedId: _wantedId});\\n\\n        emit OfferCreated(msg.sender, _ownedId, _wantedId);\\n    }\\n\\n    function completeTokenOffer(uint16 _offerTokenId, uint16 _swapId) external {\\n        INonon nonon = INonon(nononAddress);\\n\\n        TokenOffer memory offer = offers[_offerTokenId];\\n\\n        if (offer.owner == address(0) || !nononExists(_offerTokenId)) {\\n            revert NoActiveOffer();\\n        }\\n\\n        if (offer.wantedId != 0 && _swapId != offer.wantedId) {\\n            revert NotRequestedToken();\\n        }\\n\\n        if (!nononExists(_swapId)) {\\n            revert OfferForNonexistentToken();\\n        }\\n\\n        emit SwapCompleted(_offerTokenId, _swapId);\\n\\n        assembly {\\n            sstore(add(offers.slot, _offerTokenId), 0)\\n        }\\n\\n        // transfer tokens\\n        nonon.transferFrom(msg.sender, offer.owner, _swapId);\\n        nonon.transferFrom(offer.owner, msg.sender, offer.ownedId);\\n    }\\n\\n    function removeOffer(uint16 _tokenId) external {\\n        INonon nonon = INonon(nononAddress);\\n\\n        TokenOffer memory offer = offers[_tokenId];\\n\\n        // allow removal (aka: dont revert) in one of these cases:\\n        // - the user is the creator of the offer OR\\n        // - the offer creator no longer owns the offer token OR\\n        // - the swap contract does not have approval to transfer nonons on behalf of owner OR\\n        // - msg.sender is the owner of offer.wantedId\\n        // if none of these conditions are met (inverses are all true), revert\\n        if (\\n            offer.owner != msg.sender // User is not the creator of the offer\\n                && nonon.ownerOf(_tokenId) == offer.owner // Offer creator still owns the token\\n                && nonon.isApprovedForAll(offer.owner, address(this)) // Contract is approved\\n                && (offer.wantedId == 0 || nonon.ownerOf(offer.wantedId) != msg.sender) // No wantedId or user does not own the wantedId\\n        ) {\\n            revert Unauthorized();\\n        }\\n\\n        assembly {\\n            sstore(add(offers.slot, _tokenId), 0)\\n        }\\n\\n        emit OfferCancelled(msg.sender, _tokenId);\\n    }\\n\\n    function nononExists(uint16 tokenId) internal view returns (bool success) {\\n        (success,) = nononAddress.staticcall(abi.encodeWithSignature(\\\"ownerOf(uint256)\\\", tokenId));\\n    }\\n\\n    function getAllOffers() external view returns (TokenOffer[nononMaxSupply + 1] memory) {\\n        return offers;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INonon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"ERC721A/IERC721A.sol\\\";\\n\\ninterface INonon is IERC721A {\\n    function exists(uint256 _tokenId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solady/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nononAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NoActiveOffer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRequestedToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ownedId\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ownedId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"wantedId\",\"type\":\"uint256\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"firstTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"secondTokenId\",\"type\":\"uint256\"}],\"name\":\"SwapCompleted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_offerTokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_swapId\",\"type\":\"uint16\"}],\"name\":\"completeTokenOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_ownedId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_wantedId\",\"type\":\"uint16\"}],\"name\":\"createTokenOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllOffers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"ownedId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"wantedId\",\"type\":\"uint16\"}],\"internalType\":\"struct TokenOffer[5001]\",\"name\":\"\",\"type\":\"tuple[5001]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nononAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nononMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"ownedId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"wantedId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"removeOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NononSwap", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d3607bc8c7927b348bac50dc224c28e3ce933ca6", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}