{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Randao.flatten.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// WARNING! This smart contract has not been audited.\\n// DO NOT USE THIS CONTRACT FOR PRODUCTION\\n// This is an example contract to demonstrate how to integrate an application with the audited production release of AxiomV1.\\npragma solidity 0.8.19;\\n\\n// Constants and free functions to be inlined into by AxiomV1Core\\n\\n// ZK circuit constants:\\n\\n// AxiomV1 caches blockhashes in batches, stored as Merkle roots of binary Merkle trees\\nuint32 constant BLOCK_BATCH_SIZE = 1024;\\nuint32 constant BLOCK_BATCH_DEPTH = 10;\\n\\n// constants for batch import of historical block hashes\\n// historical uploads a bigger batch of block hashes, stored as Merkle roots of binary Merkle trees\\nuint32 constant HISTORICAL_BLOCK_BATCH_SIZE = 131072; // 2 ** 17\\nuint32 constant HISTORICAL_BLOCK_BATCH_DEPTH = 17;\\n// we will consider the historical Merkle tree of blocks as a Merkle tree of the block batch roots\\nuint32 constant HISTORICAL_NUM_ROOTS = 128; // HISTORICAL_BATCH_SIZE / BLOCK_BATCH_SIZE\\n\\n// The first 4 * 3 * 32 bytes of proof calldata are reserved for two BN254 G1 points for a pairing check\\n// It will then be followed by (7 + BLOCK_BATCH_DEPTH * 2) * 32 bytes of public inputs/outputs\\nuint32 constant AUX_PEAKS_START_IDX = 608; // PUBLIC_BYTES_START_IDX + 7 * 32\\n\\n// Historical MMR Ring Buffer constants\\nuint32 constant MMR_RING_BUFFER_SIZE = 8;\\n\\n/// @dev proofData stores bytes32 and uint256 values in hi-lo format as two uint128 values because the BN254 scalar field is 254 bits\\n/// @dev The first 12 * 32 bytes of proofData are reserved for ZK proof verification data\\n// Extract public instances from proof\\n// The public instances are laid out in the proof calldata as follows:\\n// First 4 * 3 * 32 = 384 bytes are reserved for proof verification data used with the pairing precompile\\n// 384..384 + 32 * 2: prevHash (32 bytes) as two uint128 cast to uint256, because zk proof uses 254 bit field and cannot fit uint256 into a single element\\n// 384 + 32 * 2..384 + 32 * 4: endHash (32 bytes) as two uint128 cast to uint256\\n// 384 + 32 * 4..384 + 32 * 5: startBlockNumber (uint32: 4 bytes) and endBlockNumber (uint32: 4 bytes) are concatenated as `startBlockNumber . endBlockNumber` (8 bytes) and then cast to uint256\\n// 384 + 32 * 5..384 + 32 * 7: root (32 bytes) as two uint128 cast to uint256, this is the highest peak of the MMR if endBlockNumber - startBlockNumber == 1023, otherwise 0\\nfunction getBoundaryBlockData(bytes calldata proofData)\\n    pure\\n    returns (bytes32 prevHash, bytes32 endHash, uint32 startBlockNumber, uint32 endBlockNumber, bytes32 root)\\n{\\n    prevHash = bytes32(uint256(bytes32(proofData[384:416])) << 128 | uint256(bytes32(proofData[416:448])));\\n    endHash = bytes32(uint256(bytes32(proofData[448:480])) << 128 | uint256(bytes32(proofData[480:512])));\\n    startBlockNumber = uint32(bytes4(proofData[536:540]));\\n    endBlockNumber = uint32(bytes4(proofData[540:544]));\\n    root = bytes32(uint256(bytes32(proofData[544:576])) << 128 | uint256(bytes32(proofData[576:608])));\\n}\\n\\n// We have a Merkle mountain range of max depth BLOCK_BATCH_DEPTH (so length BLOCK_BATCH_DEPTH + 1 total) ordered in **decreasing** order of peak size, so:\\n// `root` from `getBoundaryBlockData` is the peak for depth BLOCK_BATCH_DEPTH\\n// `getAuxMmrPeak(proofData, i)` is the peaks for depth BLOCK_BATCH_DEPTH - 1 - i\\n// 384 + 32 * 7 + 32 * 2 * i .. 384 + 32 * 7 + 32 * 2 * (i + 1): (32 bytes) as two uint128 cast to uint256, same as blockHash\\n// Note that the decreasing ordering is *different* than the convention in library MerkleMountainRange\\nfunction getAuxMmrPeak(bytes calldata proofData, uint256 i) pure returns (bytes32) {\\n    return bytes32(\\n        uint256(bytes32(proofData[AUX_PEAKS_START_IDX + i * 64:AUX_PEAKS_START_IDX + i * 64 + 32])) << 128\\n            | uint256(bytes32(proofData[AUX_PEAKS_START_IDX + i * 64 + 32:AUX_PEAKS_START_IDX + (i + 1) * 64]))\\n    );\\n}\\n\\ninterface IAxiomV1Verifier {\\n    /// @notice A merkle proof to verify a block against the verified blocks cached by Axiom\\n    /// @dev    `BLOCK_BATCH_DEPTH = 10`\\n    struct BlockHashWitness {\\n        uint32 blockNumber;\\n        bytes32 claimedBlockHash;\\n        bytes32 prevHash;\\n        uint32 numFinal;\\n        bytes32[BLOCK_BATCH_DEPTH] merkleProof;\\n    }\\n\\n    /// @notice Verify the blockhash of block blockNumber equals claimedBlockHash. Assumes that blockNumber is within the last 256 most recent blocks.\\n    /// @param  blockNumber The block number to verify\\n    /// @param  claimedBlockHash The claimed blockhash of block blockNumber\\n    function isRecentBlockHashValid(uint32 blockNumber, bytes32 claimedBlockHash) external view returns (bool);\\n\\n    /// @notice Verify the blockhash of block witness.blockNumber equals witness.claimedBlockHash by checking against Axiom's cache of #historicalRoots.\\n    /// @dev    For block numbers within the last 256, use #isRecentBlockHashValid instead.\\n    /// @param  witness The block hash to verify and the Merkle proof to verify it\\n    ///         witness.blockNumber is the block number to verify\\n    ///         witness.claimedBlockHash is the claimed blockhash of block witness.blockNumber\\n    ///         witness.prevHash is the prevHash stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.numFinal is the numFinal stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.merkleProof is the Merkle inclusion proof of witness.claimedBlockHash to the root stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.merkleProof[i] is the sibling of the Merkle node at depth 10 - i, for i = 0, ..., 10\\n    function isBlockHashValid(BlockHashWitness calldata witness) external view returns (bool);\\n\\n    /// @notice Verify the blockhash of block blockNumber equals claimedBlockHash by checking against Axiom's cache of historical Merkle mountain ranges in #mmrRingBuffer.\\n    /// @dev    Use event logs to determine the correct bufferId and get the MMR at that index in the ring buffer.\\n    /// @param  mmr The Merkle mountain range commited to in #mmrRingBuffer(bufferId), must be correct length\\n    /// @param  bufferId The index in the ring buffer of #mmrRingBuffer\\n    /// @param  blockNumber The block number to verify\\n    /// @param  claimedBlockHash The claimed blockhash of block blockNumber\\n    /// @param  merkleProof The Merkle inclusion proof of claimedBlockHash to the corresponding peak in mmr. The correct peak is calculated from mmr.length and blockNumber.\\n    function mmrVerifyBlockHash(\\n        bytes32[] calldata mmr,\\n        uint8 bufferId,\\n        uint32 blockNumber,\\n        bytes32 claimedBlockHash,\\n        bytes32[] calldata merkleProof\\n    ) external view;\\n}\\n\\ninterface IAxiomV1Update {\\n    /// @notice Verify and store a batch of consecutive blocks, where the latest block in the batch is within the last 256 most recent blocks.\\n    /// @param  proofData The raw bytes of a zero knowledge proof to be verified by the contract.\\n    ///         proofData contains public inputs/outputs of\\n    ///         (bytes32 prevHash, bytes32 endHash, uint32 startBlockNumber, uint32 endBlockNumber, bytes32[11] mmr)\\n    ///         where the proof verifies the blockhashes of blocks [startBlockNumber, endBlockNumber], endBlockNumber - startBlockNumber <= 1023\\n    ///         - startBlockNumber must be a multiple of 1024\\n    ///         - prevHash is the parent hash of block `startBlockNumber`,\\n    ///         - endHash is the blockhash of block `endBlockNumber`,\\n    ///         - mmr is the keccak Merkle mountain range of the blockhashes of blocks [startBlockNumber, endBlockNumber], ordered from depth 10 to depth 0\\n    function updateRecent(bytes calldata proofData) external;\\n\\n    /// @notice Verify and store a batch of 1024 consecutive blocks,\\n    ///         where the latest block in the batch is verified against the blockhash cache in #historicalRoots\\n    /// @dev    The contract checks that #historicalRoots(endBlockNumber + 1) == keccak256(endHash || nextRoot || nextNumFinal)\\n    ///         where endBlockNumber, endHash are derived from proofData.\\n    ///         nextRoot and nextNumFinal should be obtained by reading event logs. For old blocks nextNumFinal is _usually_ 1024.\\n    /// @param  proofData The raw bytes of a zero knowledge proof to be verified by the contract. Has same format as in #updateRecent except\\n    ///         endBlockNumber = startBlockNumber + 1023, so the block batch size is exactly 1024\\n    ///         mmr contains the keccak Merkle root of the full Merkle tree of depth 10, followed by zeros\\n    /// @param  nextRoot The Merkle root stored in #historicalRoots(endBlockNumber + 1)\\n    /// @param  nextNumFinal The numFinal stored in #historicalRoots(endBlockNumber + 1)\\n    function updateOld(bytes32 nextRoot, uint32 nextNumFinal, bytes calldata proofData) external;\\n\\n    /// @notice Verify and store a batch of 2^17 = 128 * 1024 consecutive blocks,\\n    ///         where the latest block in the batch is verified against the blockhash cache in #historicalRoots\\n    /// @dev    Has the same effect as calling #updateOld 128 times on consecutive batches of 1024 blocks each.\\n    ///         But uses a different SNARK to verify the proof of all 2^17 blocks at once.\\n    ///         endHashProofs is used to get the intermediate parent hashes of these 1024 block batches\\n    /// @param  proofData The raw bytes of a zero knowledge proof to be verified by the contract. Has similar format as in #updateRecent except\\n    ///         we require endBlockNumber = startBlockNumber + 2^17 - 1, so the block batch size is exactly 2^17.\\n    ///         proofData contains public inputs/outputs of:\\n    ///         (bytes32 prevHash, bytes32 endHash, uint32 startBlockNumber, uint32 endBlockNumber, bytes32[18] mmr)\\n    ///         - startBlockNumber must be a multiple of 1024\\n    ///         - we require that endBlockNumber - startBlockNumber = 2^17 - 1\\n    ///         - prevHash is the parent hash of block `startBlockNumber`,\\n    ///         - endHash is the blockhash of block `endBlockNumber`,\\n    ///         - mmr[0] is the keccak Merkle root of the blockhashes of blocks [startBlockNumber, startBlockNumber + 2^17), the other entries in mmr are zeros\\n    /// @param  nextRoot The Merkle root stored in #historicalRoots(endBlockNumber + 1)\\n    /// @param  nextNumFinal The numFinal stored in #historicalRoots(endBlockNumber + 1)\\n    /// @param  roots roots[i] is the Merkle root of the blockhashes of blocks [startBlockNumber + i * 1024, startBlockNumber + (i + 1) * 1024) for i = 0, ..., 127\\n    /// @param  endHashProofs endHashProofs[i] is the Merkle inclusion proof of the blockhash of block `startBlockNumber + (i + 1) * 1024 - 1` in roots[i], for i = 0, ..., 126\\n    ///         endHashProofs[i][10] is the blockhash of block `startBlockNumber + (i + 1) * 1024 - 1`\\n    ///         endHashProofs[i][j] is the sibling of the Merkle node at depth j, for j = 0, ..., 9\\n    function updateHistorical(\\n        bytes32 nextRoot,\\n        uint32 nextNumFinal,\\n        bytes32[128] calldata roots,\\n        bytes32[11][127] calldata endHashProofs,\\n        bytes calldata proofData\\n    ) external;\\n\\n    /// @notice Extended the stored historical Merkle Mountain Range with a multiple of 1024 blockhash commitments\\n    /// @dev    The blocks to append must have already been cached by Axiom.\\n    ///         startBlockNumber must equal historicalMMR.len * 1024, but we make it an input for faster reverts\\n    /// @param  startBlockNumber The block number of the first block to append\\n    /// @param  roots roots[i] is the Merkle root of the blockhashes of blocks [startBlockNumber + i * 1024, startBlockNumber + (i + 1) * 1024) for i = 0, ..., roots.length - 1\\n    /// @param  prevHashes prevHashes[i] is the parent hash of block `startBlockNumber + i * 1024`, for i = 0, ..., roots.length - 1. prevHashes and roots must have the same length.\\n    function appendHistoricalMMR(uint32 startBlockNumber, bytes32[] calldata roots, bytes32[] calldata prevHashes)\\n        external;\\n}\\n\\ninterface IAxiomV1State {\\n    /// @notice Returns the hash of a batch of consecutive blocks previously verified by the contract\\n    /// @dev    The reads here will match the emitted #UpdateEvent\\n    /// @return historicalRoots(startBlockNumber) is 0 unless (startBlockNumber % 1024 == 0)\\n    ///         historicalRoots(startBlockNumber) = 0 if block `startBlockNumber` is not verified\\n    ///         historicalRoots(startBlockNumber) = keccak256(prevHash || root || numFinal) where || is concatenation\\n    ///         - prevHash is the parent hash of block `startBlockNumber`\\n    ///         - root is the keccak Merkle root of hash(i) for i in [0, 1024), where\\n    ///             hash(i) is the blockhash of block `startBlockNumber + i` if i < numFinal,\\n    ///             hash(i) = bytes32(0x0) if i >= numFinal\\n    ///         - 0 < numFinal <= 1024 is the number of verified consecutive roots in [startBlockNumber, startBlockNumber + numFinal)\\n    function historicalRoots(uint32 startBlockNumber) external view returns (bytes32);\\n\\n    /// @notice Returns metadata about the number of consecutive blocks from genesis stored in the contract\\n    ///         The Merkle mountain range stores a commitment to the variable length list where `list[i]` is the Merkle root of the binary tree with leaves the blockhashes of blocks [1024 * i, 1024 * (i + 1))\\n    /// @return numPeaks = bit_length(len) is the number of peaks in the Merkle mountain range\\n    /// @return len indicates that the historicalMMR commits to blockhashes of blocks [0, 1024 * len)\\n    /// @return index the current index in the ring buffer storing commitments to historicalMMRs\\n    function historicalMMR() external view returns (uint32 numPeaks, uint32 len, uint32 index);\\n\\n    /// @notice Returns the i-th Merkle root in the historical Merkle Mountain Range\\n    /// @param  i The index, `peaks[i] = root(list[((len >> i) << i) - 2^i : ((len >> i) << i)])` if 2^i & len != 0, otherwise 0\\n    ///         where root(single element) = single element,\\n    ///         list is the variable length list where `list[i]` is the Merkle root of the binary tree with leaves the blockhashes of blocks [1024 * i, 1024 * (i + 1))\\n    function historicalMMRPeaks(uint32 i) external view returns (bytes32);\\n\\n    /// @notice A ring buffer storing commitments to past historicalMMR states\\n    /// @param  index The index in the ring buffer\\n    function mmrRingBuffer(uint256 index) external view returns (bytes32);\\n}\\n\\ninterface IAxiomV1Events {\\n    /// @notice Emitted when a new batch of consecutive blocks is trustlessly verified and cached in the contract storage `historicalRoots`\\n    /// @param  startBlockNumber The block number of the first block in the batch\\n    /// @param  prevHash The parent hash of block `startBlockNumber`\\n    /// @param  root The Merkle root of hash(i) for i in [0, 1024), where hash(i) is the blockhash of block `startBlockNumber + i` if i < numFinal,\\n    ///              Otherwise hash(i) = bytes32(0x0) if i >= numFinal\\n    /// @param  numFinal The number of consecutive blocks in this batch, i.e., [startBlockNumber, startBlockNumber + numFinal) blocks are verified\\n    event UpdateEvent(uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal);\\n\\n    /// @notice Emitted when the size of the historicalMMR changes.\\n    /// @param  len The historicalMMR now stores commitment to blocks [0, 1024 * len)\\n    /// @param  index The new index in the ring buffer storing the commitment to historicalMMR\\n    event MerkleMountainRangeEvent(uint32 len, uint32 index);\\n\\n    /// @notice Emitted when the SNARK #verifierAddress changes\\n    /// @param  newAddress The new address of the SNARK verifier contract\\n    event UpgradeSnarkVerifier(address newAddress);\\n\\n    /// @notice Emitted when the SNARK #historicalVerifierAddress changes\\n    /// @param  newAddress The new address of the SNARK historical verifier contract\\n    event UpgradeHistoricalSnarkVerifier(address newAddress);\\n}\\n\\n/// @title The interface for the core Axiom V1 contract\\n/// @notice The Axiom V1 contract stores a continually updated cache of all historical block hashes\\n/// @dev The interface is broken up into many smaller pieces\\ninterface IAxiomV1 is IAxiomV1Events, IAxiomV1State, IAxiomV1Update, IAxiomV1Verifier {}\\n\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n// Original source @ https://github.com/hamdiallam/Solidity-RLP.\\n\\n/**\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * RLPItem conversions into data types *\\n     */\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\\ncontract Randao is Ownable {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for bytes;\\n\\n    address public axiomAddress;\\n    uint32 public mergeBlock;\\n\\n    // mapping between blockNumber and prevRandao\\n    mapping(uint32 => uint256) public prevRandaos;\\n\\n    event RandaoProof(uint32 blockNumber, uint256 prevRandao);\\n\\n    event UpdateAxiomAddress(address newAddress);\\n\\n    constructor(address _axiomAddress, uint32 _mergeBlock) {\\n        axiomAddress = _axiomAddress;\\n        mergeBlock = _mergeBlock;\\n        emit UpdateAxiomAddress(_axiomAddress);\\n    }\\n\\n    function updateAxiomAddress(address _axiomAddress) external onlyOwner {\\n        axiomAddress = _axiomAddress;\\n        emit UpdateAxiomAddress(_axiomAddress);\\n    }\\n\\n    function verifyRandao(IAxiomV1.BlockHashWitness calldata witness, bytes calldata header) external {\\n        if (block.number - witness.blockNumber <= 256) {\\n            require(\\n                IAxiomV1(axiomAddress).isRecentBlockHashValid(witness.blockNumber, witness.claimedBlockHash),\\n                \\\"Block hash was not validated in cache\\\"\\n            );\\n        } else {\\n            require(IAxiomV1(axiomAddress).isBlockHashValid(witness), \\\"Block hash was not validated in cache\\\");\\n        }\\n\\n        require(witness.blockNumber > mergeBlock, \\\"prevRandao is not valid before merge block\\\");\\n\\n        RLPReader.RLPItem[] memory headerItems = header.toRlpItem().toList();\\n        uint256 prevRandao = headerItems[13].toUint();\\n\\n        prevRandaos[witness.blockNumber] = prevRandao;\\n        emit RandaoProof(witness.blockNumber, prevRandao);\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=/Users/jpw/github/axiom-apps/lib/axiom-v1-contracts/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=/Users/jpw/github/axiom-apps/lib/axiom-v1-contracts/lib/openzeppelin-contracts/contracts/\",\r\n      \"axiom-contracts/=../lib/axiom-v1-contracts/\",\r\n      \"axiom-v1-contracts/=/Users/jpw/github/axiom-apps/lib/axiom-v1-contracts/contracts/\",\r\n      \"ds-test/=../lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=../lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=/Users/jpw/github/axiom-apps/lib/axiom-v1-contracts/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=../lib/openzeppelin-contracts/contracts/\",\r\n      \"utils/=../lib/utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axiomAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_mergeBlock\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevRandao\",\"type\":\"uint256\"}],\"name\":\"RandaoProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateAxiomAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"axiomAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mergeBlock\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"prevRandaos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axiomAddress\",\"type\":\"address\"}],\"name\":\"updateAxiomAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"claimedBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[10]\",\"name\":\"merkleProof\",\"type\":\"bytes32[10]\"}],\"internalType\":\"struct IAxiomV1Verifier.BlockHashWitness\",\"name\":\"witness\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"verifyRandao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Randao", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000033ea514cc54b641ad8b84e4a31d311f3722d1bb50000000000000000000000000000000000000000000000000000000000ed14f1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}