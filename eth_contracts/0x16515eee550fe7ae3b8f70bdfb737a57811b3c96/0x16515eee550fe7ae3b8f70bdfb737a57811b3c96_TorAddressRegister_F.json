{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TorAddressRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\n\\nimport {ITorAddressRegister} from \\\"./ITorAddressRegister.sol\\\";\\n\\n/**\\n * @title TorAddressRegister\\n *\\n * @notice The `TorAddressRegister` contract provides a register for tor\\n *         addresses.\\n *\\n * @dev The contract uses the `chronicle-std/Auth` module for access control.\\n *      While the register is publicly readable, state mutating functions are\\n *      only callable by auth'ed addresses.\\n *\\n *      Note that the register does not guarantee stable ordering, may contain\\n *      duplicates, and does not sanity-check newly added tor addresses.\\n */\\ncontract TorAddressRegister is ITorAddressRegister, Auth {\\n    /// @dev May contain duplicates.\\n    /// @dev Stable ordering not guaranteed.\\n    /// @dev May contain the empty string or other invalid tor addresses.\\n    string[] private _register;\\n\\n    constructor(address initialAuthed) Auth(initialAuthed) {}\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function get(uint index) external view returns (string memory) {\\n        if (index >= _register.length) {\\n            revert IndexOutOfBounds(index, _register.length);\\n        }\\n\\n        return _register[index];\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function tryGet(uint index) external view returns (bool, string memory) {\\n        if (index >= _register.length) {\\n            return (false, \\\"\\\");\\n        } else {\\n            return (true, _register[index]);\\n        }\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function list() external view returns (string[] memory) {\\n        return _register;\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function count() external view returns (uint) {\\n        return _register.length;\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function add(string calldata torAddress) external auth {\\n        _register.push(torAddress);\\n        emit TorAddressAdded(msg.sender, torAddress);\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    function add(string[] calldata torAddresses) external auth {\\n        for (uint i; i < torAddresses.length; i++) {\\n            _register.push(torAddresses[i]);\\n            emit TorAddressAdded(msg.sender, torAddresses[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc ITorAddressRegister\\n    /// @dev Note to not provide a \\\"bulk remove\\\" function as the ordering of tor\\n    ///      addresses inside the register may change during removal.\\n    function remove(uint index) external auth {\\n        if (index >= _register.length) {\\n            revert IndexOutOfBounds(index, _register.length);\\n        }\\n\\n        emit TorAddressRemoved(msg.sender, _register[index]);\\n        _register[index] = _register[_register.length - 1];\\n        _register.pop();\\n    }\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract TorAddressRegister_Feeds_1 is TorAddressRegister {\\n    constructor(address initialAuthed) TorAddressRegister(initialAuthed) {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ITorAddressRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface ITorAddressRegister {\\n    /// @notice Thrown if provided index out of bounds.\\n    /// @param index The provided index.\\n    /// @param maxIndex The maximum valid index.\\n    error IndexOutOfBounds(uint index, uint maxIndex);\\n\\n    /// @notice Emitted when new tor address added.\\n    /// @param caller The caller's address.\\n    /// @param torAddress The tor addresses added.\\n    event TorAddressAdded(address indexed caller, string torAddress);\\n\\n    /// @notice Emitted when tor address removed.\\n    /// @param caller The caller's address.\\n    /// @param torAddress The tor addresses removed..\\n    event TorAddressRemoved(address indexed caller, string torAddress);\\n\\n    /// @notice Returns the tor address at index `index`.\\n    /// @dev Reverts if index out of bounds.\\n    /// @param index The index of the tor address to return.\\n    /// @return The tor address stored at given index.\\n    function get(uint index) external view returns (string memory);\\n\\n    /// @notice Returns the tor address at index `index`.\\n    /// @param index The index of the tor address to return.\\n    /// @return True if tor address at index `index` exists, false otherwise.\\n    /// @return The tor address stored at index `index` if index exists, empty\\n    ///         string otherwise.\\n    function tryGet(uint index) external view returns (bool, string memory);\\n\\n    /// @notice Returns the full list of tor addresses stored.\\n    /// @dev May contain duplicates.\\n    /// @dev Stable ordering not guaranteed.\\n    /// @dev May contain the empty string or other invalid tor addresses.\\n    /// @return The list of tor addresses stored.\\n    function list() external view returns (string[] memory);\\n\\n    /// @notice Returns the number of tor addresses stored.\\n    /// @return The number of tor addresses stored.\\n    function count() external view returns (uint);\\n\\n    /// @notice Adds a new tor address.\\n    /// @dev Only callable by auth'ed addresses.\\n    /// @param torAddress The tor address to add.\\n    function add(string calldata torAddress) external;\\n\\n    /// @notice Adds a list of new tor addresses.\\n    /// @dev Only callable by auth'ed addresses.\\n    /// @param torAddresses The tor addresses to add.\\n    function add(string[] calldata torAddresses) external;\\n\\n    /// @notice Removes the tor address at index `index`.\\n    /// @dev Only callable by auth'ed addresses.\\n    /// @dev Reverts if index `index` out of bounds.\\n    /// @param index The index of the the tor address to remove.\\n    function remove(uint index) external;\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"IndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"torAddress\",\"type\":\"string\"}],\"name\":\"TorAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"torAddress\",\"type\":\"string\"}],\"name\":\"TorAddressRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"torAddress\",\"type\":\"string\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"torAddresses\",\"type\":\"string[]\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tryGet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TorAddressRegister_Feeds_1", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}