{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/ApolloFTWDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.3;\\n\\nimport \\\"./IApolloDAOToken.sol\\\";\\nimport \\\"./IApolloToken.sol\\\";\\nimport \\\"./third-party/UniswapV2Library.sol\\\";\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/// @title The DAO contract for the Apollo Inu token\\ncontract ApolloFTWDAO is Context {\\n    /// @notice The address & interface of the apolloDAO token contract\\n    IApolloDAOToken public immutable apolloDAOToken;\\n\\n    /// @notice Event that is emitted when a new DAO is nominated\\n    event NewDAONomination(address indexed newDAO, address indexed nominator);\\n    /// @notice Event that is emitted when a new vote is submitted\\n    event VoteSubmitted(\\n        address indexed newDAO,\\n        address indexed voter,\\n        uint256 voteAmount,\\n        bool voteFor\\n    );\\n    /// @notice Event that is emitted when a vote is withdrawn\\n    event VoteWithdrawn(address indexed newDAO, address indexed voter);\\n    /// @notice Event that is emitted when voting is closed for a nominated DAO\\n    event VotingClosed(address indexed newDAO, bool approved);\\n\\n    /// @notice A record of the current state of a DAO nomination\\n    struct DAONomination {\\n        /// The timestamp (i.e. `block.timestamp`) that the nomination was created\\n        uint256 timeOfNomination;\\n        /// The account that made the nomination\\n        address nominator;\\n        /// The total amount of votes in favor of the nomination\\n        uint256 votesFor;\\n        /// The total amount of votes against the nomination\\n        uint256 votesAgainst;\\n        /// Whether voting has closed for this nomination\\n        bool votingClosed;\\n    }\\n\\n    /// @notice A description of a single vote record by a particular account for a nomination\\n    struct DAOVotes {\\n        /// The count of tokens committed to this vote\\n        uint256 voteCount;\\n        /// Whether an account voted in favor of the nomination\\n        bool votedFor;\\n    }\\n\\n    /// @dev A mapping of the contract address of a nomination to the nomination state\\n    mapping(address => DAONomination) private _newDAONominations;\\n    /// @dev A mapping of the vote record by an account for a nominated DAO\\n    mapping(address => mapping(address => DAOVotes)) private _lockedVotes;\\n\\n    /// @notice The minimum voting duration for a particular nomination (three days).\\n    uint256 public constant daoVotingDuration = 259200;\\n    /// @notice The minimum amount of Apollo an account must hold to submit a new nomination\\n    uint256 public constant minimumDAOBalance = 10000000 * 10 ** 18;\\n    /// @notice The total amount of votes\u2014and thus Apollo tokens\u2014that are currently held by this DAO\\n    uint256 public totalLockedVotes;\\n    /// @notice The total number of DAO nominations that are open for voting\\n    uint256 public activeDAONominations;\\n\\n    /// @notice The address of the new approved DAO that will be eligible to replace this DAO\\n    address public approvedNewDAO = address(0);\\n    /// @notice The address of the privileged admin that can decide disbursements\\n    address public immutable admin;\\n    /// @notice The minimum amount of time after a new DAO is approved before it can be activated as the\\n    /// next effective DAO (two days).\\n    uint256 public constant daoUpdateDelay = 86400;\\n    /// @notice The timestamp when the new DAO was approved\\n    uint256 public daoApprovedTime;\\n\\n    ///@notice The amount that the winnings cannot exceed\\n    uint256 public maxRewardAmount = 100000 * 10 ** 18;\\n\\n    /// @notice The percentage of vote withdrawls to burn\\n    uint256 public constant daoVoteFeePercentage = 1;\\n    /// @notice The wallet that will control contest parameters\\n    address public immutable deployingWallet;\\n\\n    ///@notice Is migration open\\n    bool public isMigrationOpen = false;\\n    /// @notice The address & interface of the apollo v1 token contract\\n    IApolloToken public immutable apolloTokenV1;\\n    /// @notice Event that is emitted when a migration is completed\\n    event Migrated(address indexed holder, uint256 indexed amount);\\n    /// @notice Amount of V2 Apollo Migrated\\n    uint256 public amountMigrated;\\n    /// @notice Amount of V2 migrated per wallet\\n    mapping(address => uint256) public walletMigrated;\\n    /// @notice Airdrops are open\\n    bool public airdropEnabled = false;\\n\\n    // New award properties\\n\\n    constructor(\\n        address tokenAddress,\\n        address _admin,\\n        address _deployingWallet,\\n        address tokenV1Address\\n    ) {\\n        apolloDAOToken = IApolloDAOToken(tokenAddress);\\n        admin = _admin;\\n        deployingWallet = _deployingWallet;\\n        apolloTokenV1 = IApolloToken(tokenV1Address);\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyAdmin() {\\n        require(_msgSender() == admin, \\\"Only admin can call this function\\\");\\n        _;\\n    }\\n\\n    modifier onlyDeployingWallet() {\\n        require(\\n            _msgSender() == deployingWallet,\\n            \\\"Only deploying wallet can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    // Public functions\\n\\n    function rewardWinner(address _winner, uint256 _amount) external onlyAdmin {\\n        require(_amount < maxRewardAmount, \\\"Reward exceeds maximumallowed\\\");\\n        apolloDAOToken.transfer(_winner, _amount);\\n    }\\n\\n    /// @notice Cast a vote for an active nominated DAO\\n    /// @param voteAmount The amount of Apollo to commit to your vote\\n    /// @param newDAO The address of the nominated DAO to cast a vote for\\n    /// @param voteFor Whether you want to vote in favor of the nomination\\n    function voteForDAONomination(\\n        uint256 voteAmount,\\n        address newDAO,\\n        bool voteFor\\n    ) external {\\n        require(\\n            _newDAONominations[newDAO].timeOfNomination > 0,\\n            \\\"There is no DAO Nomination for this address\\\"\\n        );\\n        require(\\n            _lockedVotes[_msgSender()][newDAO].voteCount == 0,\\n            \\\"User already voted on this nomination\\\"\\n        );\\n        require(\\n            approvedNewDAO == address(0),\\n            \\\"There is already an approved new DAO\\\"\\n        );\\n        apolloDAOToken.transferFrom(_msgSender(), address(this), voteAmount);\\n        totalLockedVotes += voteAmount;\\n        _lockedVotes[_msgSender()][newDAO].voteCount += voteAmount;\\n        _lockedVotes[_msgSender()][newDAO].votedFor = voteFor;\\n        if (voteFor) {\\n            _newDAONominations[newDAO].votesFor += voteAmount;\\n        } else {\\n            _newDAONominations[newDAO].votesAgainst += voteAmount;\\n        }\\n        emit VoteSubmitted(newDAO, _msgSender(), voteAmount, voteFor);\\n    }\\n\\n    /// @notice Withdraw votes you have previously cast for a nomination. This can be called regardless of\\n    /// whether a nomination is active. If still active, your votes will no longer count in the final tally.\\n    /// @param newDAO The address of the nomination to withdraw your votes from\\n    function withdrawNewDAOVotes(address newDAO) external {\\n        uint256 currentVoteCount = _lockedVotes[_msgSender()][newDAO].voteCount;\\n        require(\\n            currentVoteCount > 0,\\n            \\\"You have not cast votes for this nomination\\\"\\n        );\\n        require(\\n            (totalLockedVotes - currentVoteCount) >= 0,\\n            \\\"Withdrawing would take DAO balance below expected rewards amount\\\"\\n        );\\n\\n        uint256 apolloToFee = (currentVoteCount * daoVoteFeePercentage) / 100;\\n        uint256 apolloToTransfer = currentVoteCount - apolloToFee;\\n\\n        apolloDAOToken.transfer(_msgSender(), apolloToTransfer);\\n\\n        totalLockedVotes -= currentVoteCount;\\n        _lockedVotes[_msgSender()][newDAO].voteCount -= currentVoteCount;\\n\\n        if (_lockedVotes[_msgSender()][newDAO].votedFor) {\\n            _newDAONominations[newDAO].votesFor -= currentVoteCount;\\n        } else {\\n            _newDAONominations[newDAO].votesAgainst -= currentVoteCount;\\n        }\\n        emit VoteWithdrawn(newDAO, _msgSender());\\n    }\\n\\n    /// @notice Submit a nomination for a new DAO contract\\n    /// @param newDAO The address of the new DAO contract you wish to nominate\\n    function nominateNewDAO(address newDAO) external {\\n        require(\\n            apolloDAOToken.balanceOf(_msgSender()) >= minimumDAOBalance,\\n            \\\"Nominator does not own enough APOLLO\\\"\\n        );\\n        require(\\n            _newDAONominations[newDAO].timeOfNomination == 0,\\n            \\\"This address has already been nominated\\\"\\n        );\\n        _newDAONominations[newDAO] = DAONomination({\\n            timeOfNomination: block.timestamp,\\n            nominator: _msgSender(),\\n            votesFor: 0,\\n            votesAgainst: 0,\\n            votingClosed: false\\n        });\\n        activeDAONominations += 1;\\n        emit NewDAONomination(newDAO, _msgSender());\\n    }\\n\\n    /// @notice Close voting for the provided nomination, preventing any future votes\\n    /// @param newDAO The address of the nomination to close voting for\\n    function closeNewDAOVoting(address newDAO) external {\\n        require(\\n            block.timestamp >\\n                (_newDAONominations[newDAO].timeOfNomination +\\n                    daoVotingDuration),\\n            \\\"We have not passed the minimum voting duration\\\"\\n        );\\n        require(\\n            !_newDAONominations[newDAO].votingClosed,\\n            \\\"Voting has already closed for this nomination\\\"\\n        );\\n        require(\\n            approvedNewDAO == address(0),\\n            \\\"There is already an approved new DAO\\\"\\n        );\\n\\n        bool approved = (_newDAONominations[newDAO].votesFor >\\n            _newDAONominations[newDAO].votesAgainst);\\n        if (approved) {\\n            approvedNewDAO = newDAO;\\n            daoApprovedTime = block.timestamp;\\n        }\\n        activeDAONominations -= 1;\\n        _newDAONominations[newDAO].votingClosed = true;\\n        emit VotingClosed(newDAO, approved);\\n    }\\n\\n    /// @notice Update the address of the active DAO in the Apollo token contract\\n    /// @dev This function may only be called after a new DAO is approved and after the update delay has elapsed\\n    function updateDAOAddress() external {\\n        require(\\n            approvedNewDAO != address(0),\\n            \\\"There is not an approved new DAO\\\"\\n        );\\n        require(\\n            block.timestamp > (daoApprovedTime + daoUpdateDelay),\\n            \\\"We have not finished the delay for an approved DAO\\\"\\n        );\\n        apolloDAOToken.updateDAO(approvedNewDAO);\\n    }\\n\\n    /// @notice The time the provided DAO address was nominated\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationTime(address dao) external view returns (uint256) {\\n        return _newDAONominations[dao].timeOfNomination;\\n    }\\n\\n    /// @notice The account that nominated the provided DAO address\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationNominator(\\n        address dao\\n    ) external view returns (address) {\\n        return _newDAONominations[dao].nominator;\\n    }\\n\\n    /// @notice The amount of votes in favor of a nomination\\n    /// @param dao The DAO address to check\\n    function daoNominationVotesFor(\\n        address dao\\n    ) external view returns (uint256) {\\n        return _newDAONominations[dao].votesFor;\\n    }\\n\\n    /// @notice The amount of votes against a nomination\\n    /// @param dao The DAO address to check\\n    function daoNominationVotesAgainst(\\n        address dao\\n    ) external view returns (uint256) {\\n        return _newDAONominations[dao].votesAgainst;\\n    }\\n\\n    /// @notice Whether voting is closed for the provided DAO address\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationVotingClosed(\\n        address dao\\n    ) external view returns (bool) {\\n        return _newDAONominations[dao].votingClosed;\\n    }\\n\\n    /// @notice The amount of votes pledged by the provided voter for the provided DAO nomination\\n    /// @param voter The address who cast a vote for the DAO\\n    /// @param dao The address of the nominated DAO to check\\n    function checkAddressVoteAmount(\\n        address voter,\\n        address dao\\n    ) external view returns (uint256) {\\n        return _lockedVotes[voter][dao].voteCount;\\n    }\\n\\n    function checkDAOAddressVote(\\n        address voter,\\n        address dao\\n    ) external view returns (bool) {\\n        return _lockedVotes[voter][dao].votedFor;\\n    }\\n\\n    function v1DAO() external view returns (address) {\\n        return apolloTokenV1.artistDAO();\\n    }\\n\\n    // Functions for changing contest parameters\\n\\n    function setMaxRewardAmount(\\n        uint256 newPercentage\\n    ) external onlyDeployingWallet {\\n        maxRewardAmount = newPercentage;\\n    }\\n\\n    //Migration Functions\\n    function setMigrationOpen(bool _isOpen) external onlyAdmin {\\n        isMigrationOpen = _isOpen;\\n    }\\n\\n    function migrateTokens(address _to, uint256 _amount) external {\\n        require(isMigrationOpen, \\\"Migration must be open on the V2 side\\\");\\n        require(\\n            _msgSender() == apolloTokenV1.artistDAO(),\\n            \\\"Only V1 DAO can complete a migration\\\"\\n        );\\n\\n        uint256 amountOfNewToken = _amount * 10 ** 6;\\n\\n        apolloDAOToken.transfer(_to, amountOfNewToken);\\n\\n        amountMigrated += amountOfNewToken;\\n        walletMigrated[_to] += amountOfNewToken;\\n\\n        emit Migrated(_to, amountOfNewToken);\\n    }\\n    // Airdrop functions\\n    function setAirdropOpen(bool _isOpen) external onlyDeployingWallet {\\n        airdropEnabled = _isOpen;\\n    }\\n\\n    function airdrop(\\n        address[] calldata tos,\\n        uint256[] calldata amounts\\n    ) external onlyAdmin {\\n        require(airdropEnabled, \\\"Airdrop is not enabled\\\");\\n        uint256 tosLength = tos.length;\\n        uint256 amountsLength = amounts.length;\\n        require(\\n            tosLength == amountsLength,\\n            \\\"Address and Amount arrays are not the same size\\\"\\n        );\\n\\n        for (uint256 i = 0; i < tosLength; ) {\\n            apolloDAOToken.transfer(tos[i], amounts[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/third-party/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\n\\nlibrary SafeMath {\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint160(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            )))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/IApolloToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external view returns (address);\\n}\\n\\ninterface IApolloToken {\\n    function changeArtistAddress(address newAddress) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n    function burn(uint256 burnAmount) external;\\n    function reflect(uint256 tAmount) external;\\n    function artistDAO() external view returns (address);\\n    function uniswapRouter() external view returns (IUniswapV2Router02);\\n}\\n\"\r\n    },\r\n    \"/contracts/IApolloDAOToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nenum TypeOfTransaction {\\n    BUY,\\n    SELL,\\n    TRANSFER\\n}\\n\\ninterface IApolloDAOToken {\\n    function updateDAO(address _newDAO) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function getTypeOfTransaction(\\n        address _sender,\\n        address _recipient\\n    ) external view returns (TypeOfTransaction);\\n\\n    function isMarketAddress(\\n        address _potentialMarket\\n    ) external view returns (bool);\\n\\n    function getTaxedAmount(\\n        uint256 _amount,\\n        TypeOfTransaction _transactionType\\n    ) external view returns (uint256);\\n\\n    function DAO() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_deployingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenV1Address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominator\",\"type\":\"address\"}],\"name\":\"NewDAONomination\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"voteFor\",\"type\":\"bool\"}],\"name\":\"VoteSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"VotingClosed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeDAONominations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountMigrated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apolloDAOToken\",\"outputs\":[{\"internalType\":\"contract IApolloDAOToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apolloTokenV1\",\"outputs\":[{\"internalType\":\"contract IApolloToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvedNewDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"checkAddressVoteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"checkDAOAddressVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"closeNewDAOVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoApprovedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationNominator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotesAgainst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotingClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoUpdateDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoVoteFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoVotingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMigrationOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDAOBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"nominateNewDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rewardWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"setAirdropOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"setMaxRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"setMigrationOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDAOAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v1DAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"voteFor\",\"type\":\"bool\"}],\"name\":\"voteForDAONomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletMigrated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"withdrawNewDAOVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ApolloFTWDAO", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000bc188b5dbb155b6ea693d46d98bf60b8482939b90000000000000000000000003fac49ecec57f9dff010dfdea05277bbb9398d01000000000000000000000000ad360393f3728ad3b60c0a4212660c6d7558f7b3000000000000000000000000adf86e75d8f0f57e0288d0970e7407eaa49b3cab", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}