{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n        return map._keys.values();\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20FactoryV1/ERC20/ERC20ByMetadropV1.sol\": {\r\n      \"content\": \"// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MM                                                                                                                                                            MM\\n// MM   ^                                    #####  #####   ####       # ######  ####  #####    #      # #    # #    #  ####                                     MM\\n// MM   |                                    #    # #    # #    #      # #      #    #   #      #      # ##   # #   #  #                                         MM\\n// MM   |                                    #    # #    # #    #      # #####  #        #      #      # # #  # ####    ####                                     MM\\n// MM   ^                                    #####  #####  #    #      # #      #        #      #      # #  # # #  #        #                                    MM\\n// MM   |                                    #      #   #  #    # #    # #      #    #   #      #      # #   ## #   #  #    #                                    MM\\n// MM   |                                    #      #    #  ####   ####  ######  ####    #      ###### # #    # #    #  ####                                     MM\\n// MM   ^                                                                                                                                                        MM\\n// MM   |                                                                                                                                                        MM\\n// MM   |________ Click 'Read Contract', then select:                                                                                                            MM\\n// MM                * _1___website                                                                                                                              MM\\n// MM                * _2___twitter (or X...)                                                                                                                    MM\\n// MM                * _3___telegram                                                                                                                             MM\\n// MM                * _4___discord                                                                                                                              MM\\n// MM                                                                                                                                                            MM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXKXWMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0dccdKMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:,;dXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc,.,xNMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo;..  .oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNOo;..   .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:..    ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkl,.      .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkl,..      .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOo;..       ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc'.         .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkl,.          .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkl,.           ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:'.            .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc'.             .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc'.              ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:..               .lNMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:..                .kMMMMMMMMMMMMMMMMMMMMMMMMMWKxc'.                 ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo;..                  .lNMMMMMMMMMMMMMMMMMMMMMMNOxo;..                   .kMMMMMMMMMMMMMMMMMMMMMMN0d:..                    ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMWXkl,.                      .lNMMMMMMMMMMMMMMMMMMWXOo,...                      .kMMMMMMMMMMMMMMMMMMMNOo;..                       ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMWKxc'.                         .lNMMMMMMMMMMMMMMMWXkl,.                           .kMMMMMMMMMMMMMMMWXkl,.                           ;KMMMM\\n// MMMMMMMMMMMMMMMMMMMW0d:'.                            .lNMMMMMMMMMMMMWKxc'.                              .kMMMMMMMMMMMMWKkc'.                              ;KMMMM\\n// MMMMMMMMMMMMMMMMN0d:..                               .cXMMMMMMMMMN0d:..                                 .oWMMMMMMMMWKxc'.                                 ;KMMMM\\n// MMMMMMMMMMMMWNOo;..                                   .lKWMMMWNOo;..                                     .oKWMMWN0d:..                                    ;KMMMM\\n// MMMMMMMMMWXkl,.                                        .'codol,..                                         ..;clc,..                                       ;KMMMM\\n// MMMMMMWKxc'.                                                                                                                                              :XMMMM\\n// MMMMXxc'.                                                                                                                                                'kWMMMM\\n// MMW0:.                                                                                                                                                ..:OWMMMMM\\n// MMK:.                                                                                                                                              ..;o0NMMMMMMM\\n// MMO'                                         .....                                             ..''..                                           ..:d0NMMMMMMMMMM\\n// MMO'                                     ..,lxO0Oxc..                                       .'cx0XXKkc..                                     .'cxKWMMMMMMMMMMMMM\\n// MMO'                                  ..;oOXWMMMMMWO,                                   ..,lkXWMMMMMMWx.                                  .,lkXWMMMMMMMMMMMMMMMM\\n// MMO'                               ..:d0NMMMMMMMMMMNo.                               ..;oONWMMMMMMMMMMK;                               .,oOXWMMMMMMMMMMMMMMMMMMM\\n// MMO'                            ..:d0NMMMMMMMMMMMMMWo.                            ..:d0NMMMMMMMMMMMMMMX:                           ..;oONMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'                         .'cxKWMMMMMMMMMMMMMMMMWo.                        .';cxKWMMMMMMMMMMMMMMMMMX:                        ..:d0NMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'                      .,lkXWMMMMMMMMMMMMMMMMMMMWo.                     .,ckKNWMMMMMMMMMMMMMMMMMMMMX:                     .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'                  ..;oOXMMMMMMMMMMMMMMMMMMMMMMMWo.                 ..,lkXWMMMMMMMMMMMMMMMMMMMMMMMMX:                  .,lkXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'               ..:d0NMMMMMMMMMMMMMMMMMMMMMMMMMMWo.              ..;oONWMMMMMMMMMMMMMMMMMMMMMMMMMMMX:              ..,oOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'            ..:d0NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWo.           ..:d0NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:           ..;oONMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'         .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWo.        .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:        ..:d0NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMO'      .,lkXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWo.     .'ckKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:     .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MM0,  ..;oOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWk'. .,lkXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNd...,lkXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMW0dld0NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0xxONWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKO0XWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMWX00000XWMMMMMMWX00000KWMNK000000000000KWNK0000000000000KXWMMWX0000KNMMMMMMMNKK00000000KKNWMMMMMWX000000000KKXWMMMMMMMMMWXK0OO0KXWMMMMMMNK000000000KXNMMMMMMM\\n// MMMK:..''.;OMMMMMMK:..'..;0M0;............:00;..............oNMWO;.''..lXMMMMMWd'..........',:d0WMMNl...........':dKMMMMNOo;'......';oONMMMO;..........';lOWMMMM\\n// MMMK; .;;..cXMMMMNo..,;. 'OMO' .,looooooookXXxooooc. .,looodOWM0;..:o' .oNMMMMWo.. .:oooooo:'. .lXMXc. .cdddddo:. .;0MW0:...;lddddl;...:OWMO' .,loooool,. .dNMMM\\n// MMMK;  :d, .xWMMMO, .dc. 'OMO' .lNMMMMMMMMMMMMMMMMO' .lNMMMMMMXc. 'kNo. .xWMMMWo.. .kMMMMMMWKl. .lNXc. ,0MMMMMMNo. .xWO,..;kNMMMMMMNk;. 'kWO' .lNMMMMMM0,  ;KMMM\\n// MMMK;  :0o. ;KMMXc..cKl. 'OMO' .'looooooo0MMMMMMMMO' .lNMMMMMNo. .dWMK:. 'OMMMWo.. .kMMMMMMMMX:. ,OXc. 'xXKXXK0d,..:0Nl. 'kMMMMMMMMMMO' .cXO' .cKXXXXX0o. .lXMMM\\n// MMMK;  :XK: .oNWx. ,ONl. 'OMO'  .''''''',xWMMMMMMMO' .lNMMMMWx. .:0NNNk' .;0MMWo.. .kMMMMMMMMNl. 'OXc. ..........:xXMXc. ,0MMMMMMMMMM0;  :XO'  .'''''....'oXMMMM\\n// MMMK;  :XWx. ,OK:..oNNl. 'OMO' .cKXXXXXXXWMMMMMMMMO' .lNMMMWO,  ..,,,,,.  .cXMWo.. .kMMMMMMMWk, .:KXc. .:ooool:..;oKMWd. .lXMMMMMMMMNo. .oWO' .,looooooxOXWMMMMM\\n// MMMK;  :KMXl..co..:KMNl. 'OMO' .:0KKKKKKKKXWMMMMMMO' .lNMMMK:. .:ccccccc,. .oNWo.. .oKKKKK0kl'..,OWXc. ,0MMMMMNx. .cXMXo. .;d0XXXX0x:. .lXMO' .lNMMMMMMMMMMMMMMM\\n// MMMK;  :XMMO, ....kWMNl. 'OMO'  ..........:KMMMMMMO' .lNMMXc. .oNMMMMMMMK:. .xNo.. ...........,oKWMXc. ,0MMMMMMXc. .dNMWOc'....''....'cONMMk' .lNMMMMMMMMMMMMMMM\\n// MMMNkookNMMWOooookNMMWOooxXMXxooooooooooooxXMMMMMMXxooOWMMKdooxXMMMMMMMMM0dookN0doloooooooodx0NWMMMWOooxXMMMMMMMKdookNMMMWXOxolcclodOXWMMMMXdooOWMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n\\n// SPDX-License-Identifier: BUSL 1.0\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.19;\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {EnumerableMap} from \\\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport {ERC20Spendable} from \\\"../../ThirdParty/omnus/ERC20Spendable/ERC20Spendable.sol\\\";\\nimport {IERC20ByMetadropV1} from \\\"./IERC20ByMetadropV1.sol\\\";\\nimport {IERC20FactoryByMetadropV1} from \\\"../ERC20Factory/IERC20FactoryByMetadropV1.sol\\\";\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport {IUniswapV2Locker} from \\\"../../ThirdParty/Unicrypt/IUniswapV2Locker.sol\\\";\\nimport {Ownable} from \\\"../../Global/OZ/Ownable.sol\\\";\\nimport {Revert} from \\\"../../Global/Revert.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../../Global/OZ/SafeERC20.sol\\\";\\nimport {TaxAdmin} from \\\"../../Global/TaxAdmin.sol\\\";\\n\\n/**\\n * @dev Metadrop core ERC-20 contract\\n *\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20ByMetadropV1 is\\n  Context,\\n  ERC20Spendable,\\n  IERC20ByMetadropV1,\\n  Ownable,\\n  TaxAdmin\\n{\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant version = 100010001000000000;\\n  uint256 internal constant BP_DENOM = 10000;\\n  uint256 internal constant ROUND_DEC = 100000000000;\\n\\n  IUniswapV2Locker internal immutable unicryptLocker;\\n  IUniswapV2Router02 internal immutable uniswapRouter;\\n  uint256 public immutable lpSupply;\\n  uint256 public immutable projectSupply;\\n  uint256 public immutable maxTokensPerTransaction;\\n  uint256 public immutable maxTokensPerWallet;\\n  uint256 public immutable maxProjectBuyTaxBasisPoints;\\n  uint256 public immutable maxProjectSellTaxBasisPoints;\\n  uint256 public immutable maxMetadropBuyTaxBasisPoints;\\n  uint256 public immutable maxMetadropSellTaxBasisPoints;\\n  uint256 public immutable lpLockupInDays;\\n  address public immutable metadropTreasury;\\n  address public immutable uniswapV2Pair;\\n  address internal immutable metadropV1Factory;\\n  uint256 internal immutable metadropTaxPeriodInDays;\\n  bool internal immutable tokenHasTax;\\n  bool internal immutable tokenHasLimits;\\n\\n  /** @dev {Storage Slot 1} Vars read / written as part of transfers packed to a single\\n   * slot for warm reads / writes.\\n   *   Slot 1:\\n   *      128\\n   *       32\\n   *   16 * 5\\n   *    8 * 2\\n   *   ------\\n   *      256\\n   *   ------ */\\n  uint128 public projectTaxPendingSwap;\\n  uint32 public fundedDate;\\n  uint16 public projectBuyTaxBasisPoints;\\n  uint16 public projectSellTaxBasisPoints;\\n  uint16 public metadropBuyTaxBasisPoints;\\n  uint16 public metadropSellTaxBasisPoints;\\n  uint16 public swapThresholdBasisPoints;\\n  /** @dev {autoSwapEnabled} We start with {autoSwapEnabled} OFF, as we don't want to\\n   * call this when  processing initial liquidity from this address. We turn this on when\\n   * liquidity has been loaded, and use this bool to control processing during auto-swaps\\n   * from that point onwards. */\\n  bool private autoSwapEnabled = false;\\n\\n  /** @dev {limitsEnabled} Similarly, we don't validate txn limits during liquidity loading. This is\\n   * automatically set to true when liquidity loading is complete.\\n   *\\n   * This can be set back to false by the tax admin. This is a neccesary fallback\\n   * position where on-chain actions cannot meet the validation and need to occur.\\n   * For example, someone may stake token into a staking contract over a number\\n   * of transactions until the staked balance is higher than the per txn limit.\\n   * If the developer of the staking contract has not considered the per txn\\n   * limit, and the 'unstake' method simply remits the entire user balance in\\n   * one txn, then this token would now be trapped in the staking contract. Under\\n   * these circumstances the limit can be turned off to allow the transaction to\\n   * proceed.\\n   *\\n   * After a given amount of time any successful token will have\\n   * become distributed such that a per transaction limit is less relevant. */\\n  bool private limitsEnabled = false;\\n\\n  /** @dev {Storage Slot 2} Not read in transfers etc:\\n   *      160\\n   *   ------\\n   *      160\\n   *   ------ */\\n  address public projectTreasury;\\n\\n  /** @dev {Storage Slot 3} Only written to if metadrop tax applies, otherwise no writes occur.\\n   * Note that although a uint128 supply limit applies to this contract we store this\\n   * as a uint256. As the evm uses uint256 for all vars we save the gas cost of the\\n   * implicit cast by using uint256, given there are no other vars we can sensibly\\n   * pack with. For the project tax we pack a uint128 with other vars read and written\\n   * as part of transfer processing, allowing a warm write.\\n   *   Slot 3:\\n   *      256\\n   *   ------\\n   *      256\\n   *   ------ */\\n  uint256 public metadropTaxPendingSwap;\\n\\n  /** @dev {Storage Slot 4} Not read as part of transfers etc.\\n   *    256\\n   * ------\\n   *    256\\n   * ------ */\\n  uint256 private _totalSupply;\\n\\n  /** @dev {Storage Slot 5 to n} Not read as part of transfers etc. */\\n  string private _name;\\n  string private _symbol;\\n\\n  /** @dev {Social Links} These shouldn't have _ prefix as they are public, but we want these at the top */\\n  string public _1___website;\\n  string public _2___twitter;\\n  string public _3___telegram;\\n  string public _4___discord;\\n\\n  /** @dev {_balances} Addresses balances */\\n  mapping(address => uint256) private _balances;\\n\\n  /** @dev {_allowances} Addresses allocance details */\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  /** @dev {_liquidityPools} Enumerable set for liquidity pool addresses */\\n  EnumerableSet.AddressSet private _liquidityPools;\\n\\n  /** @dev {_liquidityPools} Enumerable set for addresses where limits do not apply */\\n  EnumerableSet.AddressSet private _unlimited;\\n\\n  /**\\n   * @dev {constructor}\\n   *\\n   * @param integrationAddresses_ The project owner, uniswap router and unicrypt locker.\\n   * @param baseParams_ configuration of this ERC20.\\n   * @param supplyParams_ Supply configuration of this ERC20.\\n   * @param taxParams_  Tax configuration of this ERC20\\n   */\\n  constructor(\\n    address[3] memory integrationAddresses_,\\n    bytes memory baseParams_,\\n    bytes memory supplyParams_,\\n    bytes memory taxParams_\\n  ) {\\n    _decodeBaseParams(integrationAddresses_[0], baseParams_);\\n    uniswapRouter = IUniswapV2Router02(integrationAddresses_[1]);\\n    unicryptLocker = IUniswapV2Locker(integrationAddresses_[2]);\\n\\n    ERC20SupplyParameters memory supplyParams = abi.decode(\\n      supplyParams_,\\n      (ERC20SupplyParameters)\\n    );\\n\\n    ERC20TaxParameters memory taxParams = abi.decode(\\n      taxParams_,\\n      (ERC20TaxParameters)\\n    );\\n\\n    tokenHasLimits = _processSupplyParams(supplyParams);\\n    projectTreasury = supplyParams.projectTreasury;\\n    metadropTreasury = supplyParams.metadropTreasury;\\n    lpSupply = supplyParams.lpSupply * (10 ** decimals());\\n    projectSupply = supplyParams.projectSupply * (10 ** decimals());\\n    maxTokensPerWallet = supplyParams.maxTokensPerWallet * (10 ** decimals());\\n    maxTokensPerTransaction = supplyParams.maxTokensPerTxn * (10 ** decimals());\\n    lpLockupInDays = supplyParams.lpLockupInDays;\\n\\n    tokenHasTax = _processTaxParams(taxParams);\\n    maxProjectBuyTaxBasisPoints = taxParams.maxProjectBuyTaxBasisPoints;\\n    maxProjectSellTaxBasisPoints = taxParams.maxProjectSellTaxBasisPoints;\\n    maxMetadropBuyTaxBasisPoints = taxParams.maxMetadropBuyTaxBasisPoints;\\n    maxMetadropSellTaxBasisPoints = taxParams.maxMetadropSellTaxBasisPoints;\\n    metadropTaxPeriodInDays = taxParams.metadropTaxPeriodInDays;\\n    swapThresholdBasisPoints = uint16(taxParams.taxSwapThresholdBasisPoints);\\n\\n    metadropV1Factory = _msgSender();\\n\\n    _mintBalances(lpSupply, projectSupply);\\n\\n    uniswapV2Pair = _createPair();\\n  }\\n\\n  /**\\n   * @dev {onlyOwnerOrFactory}\\n   *\\n   * Throws if called by any account other than the owner OR factory.\\n   */\\n  modifier onlyOwnerOrFactory() {\\n    if (metadropV1Factory != _msgSender() && owner() != _msgSender()) {\\n      _revert(CallerIsNotFactoryOrProjectOwner.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev function {_decodeBaseParams}\\n   *\\n   * Decode NFT Parameters\\n   *\\n   * @param projectOwner_ The owner of this contract\\n   * @param encodedBaseParams_ The base params encoded into a bytes array\\n   */\\n  function _decodeBaseParams(\\n    address projectOwner_,\\n    bytes memory encodedBaseParams_\\n  ) internal {\\n    _transferOwnership(projectOwner_);\\n    _transferTaxAdmin(projectOwner_);\\n\\n    (\\n      _name,\\n      _symbol,\\n      _1___website,\\n      _2___twitter,\\n      _3___telegram,\\n      _4___discord\\n    ) = abi.decode(\\n      encodedBaseParams_,\\n      (string, string, string, string, string, string)\\n    );\\n  }\\n\\n  /**\\n   * @dev function {_processSupplyParams}\\n   *\\n   * Process provided supply params\\n   *\\n   * @param erc20SupplyParameters_ The supply params encoded into a bytes array\\n   */\\n  function _processSupplyParams(\\n    ERC20SupplyParameters memory erc20SupplyParameters_\\n  ) internal returns (bool tokenHasLimits_) {\\n    if (\\n      erc20SupplyParameters_.maxSupply !=\\n      (erc20SupplyParameters_.lpSupply + erc20SupplyParameters_.projectSupply)\\n    ) {\\n      _revert(SupplyTotalMismatch.selector);\\n    }\\n\\n    if (erc20SupplyParameters_.maxSupply > type(uint128).max) {\\n      _revert(MaxSupplyTooHigh.selector);\\n    }\\n\\n    if (erc20SupplyParameters_.lpLockupInDays > type(uint96).max) {\\n      _revert(LPLockUpMustFitUint96.selector);\\n    }\\n\\n    _unlimited.add(erc20SupplyParameters_.projectTreasury);\\n    _unlimited.add(address(this));\\n    _unlimited.add(address(0));\\n\\n    if (\\n      erc20SupplyParameters_.maxTokensPerTxn == 0 &&\\n      erc20SupplyParameters_.maxTokensPerWallet == 0\\n    ) {\\n      return false;\\n    } else {\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_processTaxParams}\\n   *\\n   * Process provided tax params\\n   *\\n   * @param erc20TaxParameters_ The tax params encoded into a bytes array\\n   */\\n  function _processTaxParams(\\n    ERC20TaxParameters memory erc20TaxParameters_\\n  ) internal returns (bool tokenHasTax_) {\\n    /**\\n     * @dev We use the immutable var {tokenHasTax} to avoid unneccesary storage writes and reads. If this\\n     * token does NOT have tax applied then there is no need to store or read these parameters, and we can\\n     * avoid this simply by checking the immutable var. Pass back the value for this var from this method.\\n     */\\n    if (\\n      erc20TaxParameters_.projectBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.projectSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.metadropBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.metadropSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxProjectBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxProjectSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxMetadropBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxMetadropSellTaxBasisPoints == 0\\n    ) {\\n      return false;\\n    } else {\\n      projectBuyTaxBasisPoints = uint16(\\n        erc20TaxParameters_.projectBuyTaxBasisPoints\\n      );\\n      projectSellTaxBasisPoints = uint16(\\n        erc20TaxParameters_.projectSellTaxBasisPoints\\n      );\\n      metadropBuyTaxBasisPoints = uint16(\\n        erc20TaxParameters_.metadropBuyTaxBasisPoints\\n      );\\n      metadropSellTaxBasisPoints = uint16(\\n        erc20TaxParameters_.metadropSellTaxBasisPoints\\n      );\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_mintBalances}\\n   *\\n   * Mint initial balances\\n   *\\n   * @param lpMint_ The number of tokens for liquidity\\n   * @param projectMint_ The number of tokens for the project treasury\\n   */\\n  function _mintBalances(uint256 lpMint_, uint256 projectMint_) internal {\\n    if (lpMint_ > 0) {\\n      _mint(address(this), lpMint_);\\n    }\\n    if (projectMint_ > 0) {\\n      _mint(projectTreasury, projectMint_);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_createPair}\\n   *\\n   * Create the uniswap pair\\n   *\\n   * @return uniswapV2Pair_ The pair address\\n   */\\n  function _createPair() internal returns (address uniswapV2Pair_) {\\n    if (_totalSupply > 0) {\\n      uniswapV2Pair_ = IUniswapV2Factory(uniswapRouter.factory()).createPair(\\n        address(this),\\n        uniswapRouter.WETH()\\n      );\\n\\n      _liquidityPools.add(uniswapV2Pair_);\\n      emit LiquidityPoolCreated(uniswapV2Pair_);\\n    }\\n    _unlimited.add(address(uniswapRouter));\\n    _unlimited.add(uniswapV2Pair_);\\n    return (uniswapV2Pair_);\\n  }\\n\\n  /**\\n   * @dev function {addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   */\\n  function addInitialLiquidity(\\n    uint256 lockerFee_\\n  ) public payable onlyOwnerOrFactory {\\n    if (lockerFee_ >= msg.value) {\\n      // The amount of ETH MUST exceed the locker fee, otherwise what liquidity are we adding?\\n      _revert(NoETHForLiquidityPair.selector);\\n    }\\n    _addInitialLiquidity((msg.value - lockerFee_), lockerFee_);\\n  }\\n\\n  /**\\n   * @dev function {_addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair (internal function that does the work)\\n   *\\n   * @param ethAmount_ The amount of ETH passed into the call\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   */\\n  function _addInitialLiquidity(\\n    uint256 ethAmount_,\\n    uint256 lockerFee_\\n  ) internal {\\n    // Funded date is the date of first funding. We can only add initial liquidity once. If this date is set,\\n    // we cannot proceed\\n    if (fundedDate == 0) {\\n      fundedDate = uint32(block.timestamp);\\n    } else {\\n      _revert(InitialLiquidityAlreadyAdded.selector);\\n    }\\n\\n    // Can only do this if this contract holds tokens:\\n    if (balanceOf(address(this)) == 0) {\\n      _revert(NoTokenForLiquidityPair.selector);\\n    }\\n\\n    // Approve the uniswap router for an inifinite amount (max uint256)\\n    // This means that we don't need to worry about later incrememtal\\n    // approvals on tax swaps, as the uniswap router allowance will never\\n    // be decreased (see code in decreaseAllowance for reference)\\n    _approve(address(this), address(uniswapRouter), type(uint256).max);\\n\\n    // Add the liquidity:\\n    (uint256 amountA, uint256 amountB, uint256 lpTokens) = uniswapRouter\\n      .addLiquidityETH{value: ethAmount_}(\\n      address(this),\\n      balanceOf(address(this)),\\n      0,\\n      0,\\n      address(this),\\n      block.timestamp\\n    );\\n\\n    emit InitialLiquidityAdded(amountA, amountB, lpTokens);\\n\\n    autoSwapEnabled = true;\\n    limitsEnabled = true;\\n\\n    // Lock the liqidity:\\n    _lockInitialLiquidity(lockerFee_, lpTokens);\\n  }\\n\\n  /**\\n   * @dev function {_lockInitialLiquidity}\\n   *\\n   * Lock initial liquidity on locker contract\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   * @param lpTokens_ The amount of LP tokens to be locked\\n   */\\n  function _lockInitialLiquidity(\\n    uint256 lockerFee_,\\n    uint256 lpTokens_\\n  ) internal {\\n    IERC20(uniswapV2Pair).approve(address(unicryptLocker), lpTokens_);\\n\\n    unicryptLocker.lockLPToken{value: lockerFee_}(\\n      uniswapV2Pair,\\n      IERC20(uniswapV2Pair).balanceOf(address(this)),\\n      block.timestamp + (lpLockupInDays * 1 days),\\n      payable(address(0)),\\n      true,\\n      payable(projectTreasury)\\n    );\\n\\n    emit LiquidityLocked();\\n  }\\n\\n  /**\\n   * @dev function {isLiquidityPool}\\n   *\\n   * Return if an address is a liquidity pool\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't a liquidity pool\\n   */\\n  function isLiquidityPool(address queryAddress_) public view returns (bool) {\\n    /** @dev We check the uniswapV2Pair address first as this is an immutable variable and therefore does not need\\n     * to be fetched from storage, saving gas if this address IS the uniswapV2Pool. We also add this address\\n     * to the enumerated set for ease of reference (for example it is returned in the getter), and it does\\n     * not add gas to any other calls, that still complete in 0(1) time.\\n     */\\n    return (queryAddress_ == uniswapV2Pair ||\\n      _liquidityPools.contains(queryAddress_));\\n  }\\n\\n  /**\\n   * @dev function {addLiquidityPool} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to add a liquidity pool to the pool enumerable set\\n   *\\n   * @param newLiquidityPool_ The address of the new liquidity pool\\n   */\\n  function addLiquidityPool(address newLiquidityPool_) public onlyTaxAdmin {\\n    // Don't allow calls that didn't pass an address:\\n    if (newLiquidityPool_ == address(0)) {\\n      _revert(LiquidityPoolCannotBeAddressZero.selector);\\n    }\\n    // Only allow smart contract addresses to be added, as only these can be pools:\\n    if (newLiquidityPool_.code.length == 0) {\\n      _revert(LiquidityPoolMustBeAContractAddress.selector);\\n    }\\n    // Add this to the enumerated list:\\n    _liquidityPools.add(newLiquidityPool_);\\n    emit LiquidityPoolAdded(newLiquidityPool_);\\n  }\\n\\n  /**\\n   * @dev function {removeLiquidityPool} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to remove a liquidity pool\\n   *\\n   * @param removedLiquidityPool_ The address of the old removed liquidity pool\\n   */\\n  function removeLiquidityPool(\\n    address removedLiquidityPool_\\n  ) public onlyTaxAdmin {\\n    // Remove this from the enumerated list:\\n    _liquidityPools.remove(removedLiquidityPool_);\\n    emit LiquidityPoolRemoved(removedLiquidityPool_);\\n  }\\n\\n  /**\\n   * @dev function {isUnlimited}\\n   *\\n   * Return if an address is unlimited (is not subject to per txn and per wallet limits)\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't unlimited\\n   */\\n  function isUnlimited(address queryAddress_) public view returns (bool) {\\n    return (_unlimited.contains(queryAddress_));\\n  }\\n\\n  /**\\n   * @dev function {addUnlimited} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to add an unlimited address\\n   *\\n   * @param newUnlimited_ The address of the new unlimited address\\n   */\\n  function addUnlimited(address newUnlimited_) public onlyTaxAdmin {\\n    // Add this to the enumerated list:\\n    _unlimited.add(newUnlimited_);\\n    emit UnlimitedAddressAdded(newUnlimited_);\\n  }\\n\\n  /**\\n   * @dev function {removeUnlimited} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to remove an unlimited address\\n   *\\n   * @param removedUnlimited_ The address of the old removed unlimited address\\n   */\\n  function removeUnlimited(address removedUnlimited_) public onlyTaxAdmin {\\n    // Remove this from the enumerated list:\\n    _unlimited.remove(removedUnlimited_);\\n    emit UnlimitedAddressRemoved(removedUnlimited_);\\n  }\\n\\n  /**\\n   * @dev function {setLimitsEnabledStatus} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to enable / disable tokens per txn and per holder validation.\\n   *\\n   * @param enabled_ Should limits be on?\\n   */\\n  function setLimitsEnabledStatus(bool enabled_) public onlyTaxAdmin {\\n    limitsEnabled = enabled_;\\n    emit SetLimitsEnabled(enabled_);\\n  }\\n\\n  /**\\n   * @dev function {setProjectTreasury} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to set the treasury address\\n   *\\n   * @param projectTreasury_ New treasury address\\n   */\\n  function setProjectTreasury(address projectTreasury_) public onlyTaxAdmin {\\n    projectTreasury = projectTreasury_;\\n    emit TreasuryUpdated(projectTreasury_);\\n  }\\n\\n  /**\\n   * @dev function {setSwapThresholdBasisPoints} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to set the autoswap threshold\\n   *\\n   * @param swapThresholdBasisPoints_ New swap threshold in basis points\\n   */\\n  function setSwapThresholdBasisPoints(\\n    uint16 swapThresholdBasisPoints_\\n  ) public onlyTaxAdmin {\\n    uint256 oldswapThresholdBasisPoints = swapThresholdBasisPoints;\\n    swapThresholdBasisPoints = swapThresholdBasisPoints_;\\n    emit AutoSwapThresholdUpdated(\\n      oldswapThresholdBasisPoints,\\n      swapThresholdBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev function {withdrawETH} onlyOwner\\n   *\\n   * Allows the owner to withdraw ETH\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external onlyOwner {\\n    (bool success, ) = owner().call{value: amount_}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyOwner\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn.\\n   *\\n   * @param token_ The address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(IERC20 token_, uint256 amount_) external onlyOwner {\\n    token_.safeTransfer(owner(), amount_);\\n  }\\n\\n  /**\\n   * @dev function {setProjectTaxRates} onlyTaxAdmin\\n   *\\n   * Change the tax rates, subject to max rate\\n   *\\n   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newProjectSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setProjectTaxRates(\\n    uint16 newProjectBuyTaxBasisPoints_,\\n    uint16 newProjectSellTaxBasisPoints_\\n  ) external onlyTaxAdmin {\\n    // Cannot increase above the maximum:\\n    if (newProjectBuyTaxBasisPoints_ > maxProjectBuyTaxBasisPoints) {\\n      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);\\n    }\\n    // Cannot increase above the maximum:\\n    if (newProjectSellTaxBasisPoints_ > maxProjectSellTaxBasisPoints) {\\n      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    uint16 oldBuyTaxBasisPoints = projectBuyTaxBasisPoints;\\n    projectBuyTaxBasisPoints = newProjectBuyTaxBasisPoints_;\\n\\n    uint16 oldSellTaxBasisPoints = projectSellTaxBasisPoints;\\n    projectSellTaxBasisPoints = newProjectSellTaxBasisPoints_;\\n\\n    emit ProjectTaxBasisPointsChanged(\\n      oldBuyTaxBasisPoints,\\n      newProjectBuyTaxBasisPoints_,\\n      oldSellTaxBasisPoints,\\n      newProjectSellTaxBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev function {setMetadropTaxRates} onlyTaxAdmin\\n   *\\n   * Change the tax rates, subject to max rate and minimum tax period.\\n   *\\n   * @param newMetadropBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newMetadropSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setMetadropTaxRates(\\n    uint16 newMetadropBuyTaxBasisPoints_,\\n    uint16 newMetadropSellTaxBasisPoints_\\n  ) external onlyTaxAdmin {\\n    // Cannot increase above the maximum:\\n    if (newMetadropBuyTaxBasisPoints_ > maxMetadropBuyTaxBasisPoints) {\\n      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    // Cannot increase above the maximum:\\n    if (newMetadropSellTaxBasisPoints_ > maxMetadropSellTaxBasisPoints) {\\n      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    // Reducing the basis points can only occur after the tax period:\\n    if (\\n      (newMetadropBuyTaxBasisPoints_ < metadropBuyTaxBasisPoints ||\\n        newMetadropSellTaxBasisPoints_ < metadropSellTaxBasisPoints) &&\\n      block.timestamp < (fundedDate + (metadropTaxPeriodInDays * 1 days))\\n    ) {\\n      _revert(TaxPeriodStillInForce.selector);\\n    }\\n\\n    uint16 oldBuyTaxBasisPoints = metadropBuyTaxBasisPoints;\\n    uint16 oldSellTaxBasisPoints = metadropSellTaxBasisPoints;\\n\\n    metadropBuyTaxBasisPoints = newMetadropBuyTaxBasisPoints_;\\n    metadropSellTaxBasisPoints = newMetadropSellTaxBasisPoints_;\\n\\n    emit MetadropTaxBasisPointsChanged(\\n      oldBuyTaxBasisPoints,\\n      newMetadropBuyTaxBasisPoints_,\\n      oldSellTaxBasisPoints,\\n      newMetadropSellTaxBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the default value returned by this function, unless\\n   * it's overridden.\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return 18;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-totalSupply}.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Provide easy to view tax total:\\n   */\\n  function _totalBuyTaxBasisPoints() internal view returns (uint256) {\\n    return projectBuyTaxBasisPoints + metadropBuyTaxBasisPoints;\\n  }\\n\\n  /**\\n   * @dev Provide easy to view tax total:\\n   */\\n  function _totalSellTaxBasisPoints() internal view returns (uint256) {\\n    return projectSellTaxBasisPoints + metadropSellTaxBasisPoints;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-balanceOf}.\\n   */\\n  function balanceOf(\\n    address account\\n  ) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(\\n    address to,\\n    uint256 amount\\n  ) public virtual override(ERC20Spendable, IERC20) returns (bool) {\\n    address owner = _msgSender();\\n    _transfer(\\n      owner,\\n      to,\\n      amount,\\n      (isLiquidityPool(owner) || isLiquidityPool(to))\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(\\n    address spender,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    address owner = _msgSender();\\n    _approve(owner, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {ERC20}.\\n   *\\n   * NOTE: Does not update the allowance if the current allowance\\n   * is the maximum `uint256`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` and `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   * - the caller must have allowance for ``from``'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    address spender = _msgSender();\\n    _spendAllowance(from, spender, amount);\\n    _transfer(from, to, amount, (isLiquidityPool(from) || isLiquidityPool(to)));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  ) public virtual returns (bool) {\\n    address owner = _msgSender();\\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  ) public virtual returns (bool) {\\n    address owner = _msgSender();\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance < subtractedValue) {\\n      _revert(AllowanceDecreasedBelowZero.selector);\\n    }\\n    unchecked {\\n      _approve(owner, spender, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Moves `amount` of tokens from `from` to `to`.\\n   *\\n   * This internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   */\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    bool applyTax\\n  ) internal virtual {\\n    _beforeTokenTransfer(from, to, amount);\\n\\n    // Perform pre-tax validation (e.g. amount doesn't exceed balance, max txn amount)\\n    uint256 fromBalance = _pretaxValidationAndLimits(from, to, amount);\\n\\n    // Perform autoswap if eligible\\n    _autoSwap(from, to);\\n\\n    // Process taxes\\n    uint256 amountMinusTax = _taxProcessing(applyTax, to, from, amount);\\n\\n    // Perform post-tax validation (e.g. total balance after post-tax amount applied)\\n    _posttaxValidationAndLimits(from, to, amountMinusTax);\\n\\n    _balances[from] = fromBalance - amount;\\n    _balances[to] += amountMinusTax;\\n\\n    emit Transfer(from, to, amountMinusTax);\\n\\n    _afterTokenTransfer(from, to, amount);\\n  }\\n\\n  /**\\n   * @dev function {_pretaxValidationAndLimits}\\n   *\\n   * Perform validation on pre-tax amounts\\n   *\\n   * @param from_ From address for the transaction\\n   * @param to_ To address for the transaction\\n   * @param amount_ Amount of the transaction\\n   */\\n  function _pretaxValidationAndLimits(\\n    address from_,\\n    address to_,\\n    uint256 amount_\\n  ) internal view returns (uint256 fromBalance_) {\\n    if (from_ == address(0)) {\\n      _revert(TransferFromZeroAddress.selector);\\n    }\\n\\n    if (to_ == address(0)) {\\n      _revert(TransferToZeroAddress.selector);\\n    }\\n\\n    fromBalance_ = _balances[from_];\\n\\n    if (fromBalance_ < amount_) {\\n      _revert(TransferAmountExceedsBalance.selector);\\n    }\\n\\n    // Liquidity pools aren't always going to round cleanly. This can (and does)\\n    // mean that a limit of 5,000 tokens (for example) will trigger on a transfer\\n    // of 5,000 tokens, as the transfer is actually for 5,000.00000000000000213.\\n    // While 4,999 will work fine, it isn't hugely user friendly. So we buffer\\n    // the limit with rounding decimals, which in all cases are considerably less\\n    // than one whole token:\\n    uint256 roundedLimited;\\n\\n    unchecked {\\n      roundedLimited = maxTokensPerTransaction + ROUND_DEC;\\n    }\\n\\n    if (\\n      tokenHasLimits &&\\n      limitsEnabled &&\\n      (maxTokensPerTransaction != 0) &&\\n      (amount_ > roundedLimited) &&\\n      ((isLiquidityPool(from_) && !isUnlimited(to_)) ||\\n        (isLiquidityPool(to_) && !isUnlimited(from_)))\\n    ) {\\n      _revert(MaxTokensPerTxnExceeded.selector);\\n    }\\n\\n    return (fromBalance_);\\n  }\\n\\n  /**\\n   * @dev function {_posttaxValidationAndLimits}\\n   *\\n   * Perform validation on post-tax amounts\\n   *\\n   * @param to_ To address for the transaction\\n   * @param amount_ Amount of the transaction\\n   */\\n  function _posttaxValidationAndLimits(\\n    address from_,\\n    address to_,\\n    uint256 amount_\\n  ) internal view returns (uint256 fromBalance_) {\\n    // Liquidity pools aren't always going to round cleanly. This can (and does)\\n    // mean that a limit of 5,000 tokens (for example) will trigger on a max holding\\n    // of 5,000 tokens, as the transfer to achieve that is actually for\\n    // 5,000.00000000000000213. While 4,999 will work fine, it isn't hugely user friendly.\\n    // So we buffer the limit with rounding decimals, which in all cases are considerably\\n    // less than one whole token:\\n    uint256 roundedLimited;\\n\\n    unchecked {\\n      roundedLimited = maxTokensPerWallet + ROUND_DEC;\\n    }\\n    if (\\n      tokenHasLimits &&\\n      limitsEnabled &&\\n      (maxTokensPerWallet != 0) &&\\n      (amount_ + balanceOf(to_) > roundedLimited) &&\\n      // If this is a buy (from a liquidity pool), we apply if the to_\\n      // address isn't noted as unlimited:\\n      (isLiquidityPool(from_) && !isUnlimited(to_))\\n    ) {\\n      _revert(MaxTokensPerWalletExceeded.selector);\\n    }\\n\\n    return (fromBalance_);\\n  }\\n\\n  /**\\n   * @dev function {_taxProcessing}\\n   *\\n   * Perform tax processing\\n   *\\n   * @param applyTax_ Do we apply tax to this transaction?\\n   * @param to_ The reciever of the token\\n   * @param from_ The sender of the token\\n   * @param sentAmount_ The amount being send\\n   * @return amountLessTax_ The amount that will be recieved, i.e. the send amount minus tax\\n   */\\n  function _taxProcessing(\\n    bool applyTax_,\\n    address to_,\\n    address from_,\\n    uint256 sentAmount_\\n  ) internal returns (uint256 amountLessTax_) {\\n    amountLessTax_ = sentAmount_;\\n    unchecked {\\n      if (tokenHasTax && applyTax_ && autoSwapEnabled) {\\n        uint256 tax;\\n\\n        // on sell\\n        if (isLiquidityPool(to_) && _totalSellTaxBasisPoints() > 0) {\\n          if (projectSellTaxBasisPoints > 0) {\\n            uint256 projectTax = ((sentAmount_ * projectSellTaxBasisPoints) /\\n              BP_DENOM);\\n            projectTaxPendingSwap += uint128(projectTax);\\n            tax += projectTax;\\n          }\\n          if (metadropSellTaxBasisPoints > 0) {\\n            uint256 metadropTax = ((sentAmount_ * metadropSellTaxBasisPoints) /\\n              BP_DENOM);\\n            metadropTaxPendingSwap += uint128(metadropTax);\\n            tax += metadropTax;\\n          }\\n        }\\n        // on buy\\n        else if (isLiquidityPool(from_) && _totalBuyTaxBasisPoints() > 0) {\\n          if (projectBuyTaxBasisPoints > 0) {\\n            uint256 projectTax = ((sentAmount_ * projectBuyTaxBasisPoints) /\\n              BP_DENOM);\\n            projectTaxPendingSwap += uint128(projectTax);\\n            tax += projectTax;\\n          }\\n          if (metadropBuyTaxBasisPoints > 0) {\\n            uint256 metadropTax = ((sentAmount_ * metadropBuyTaxBasisPoints) /\\n              BP_DENOM);\\n            metadropTaxPendingSwap += uint128(metadropTax);\\n            tax += metadropTax;\\n          }\\n        }\\n\\n        if (tax > 0) {\\n          _balances[address(this)] += tax;\\n          emit Transfer(from_, address(this), tax);\\n          amountLessTax_ -= tax;\\n        }\\n      }\\n    }\\n    return (amountLessTax_);\\n  }\\n\\n  /**\\n   * @dev function {_autoSwap}\\n   *\\n   * Automate the swap of accumulated tax fees to native token\\n   *\\n   * @param from_ The sender of the token\\n   */\\n  function _autoSwap(address from_, address to_) internal {\\n    if (tokenHasTax) {\\n      uint256 taxBalance = balanceOf(address(this));\\n\\n      if (_eligibleForSwap(from_, to_, taxBalance)) {\\n        // Store that a swap back is in progress:\\n        autoSwapEnabled = false;\\n        // Perform the auto swap to native token:\\n        _swapTaxForNative(taxBalance);\\n        // Flag that the autoswap is complete:\\n        autoSwapEnabled = true;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_eligibleForSwap}\\n   *\\n   * Is the current transfer eligible for autoswap\\n   *\\n   * @param from_ The sender of the token\\n   * @param taxBalance_ The current accumulated tax balance\\n   */\\n  function _eligibleForSwap(\\n    address from_,\\n    address to_,\\n    uint256 taxBalance_\\n  ) internal view returns (bool) {\\n    return (taxBalance_ >=\\n      ((_totalSupply * swapThresholdBasisPoints) / BP_DENOM) &&\\n      autoSwapEnabled &&\\n      !isLiquidityPool(from_) &&\\n      from_ != address(uniswapRouter) &&\\n      to_ != address(uniswapRouter));\\n  }\\n\\n  /**\\n   * @dev function {_swapTaxForNative}\\n   *\\n   * Swap tokens taken as tax for native token\\n   *\\n   * @param taxBalance_ The current accumulated tax balance\\n   */\\n  function _swapTaxForNative(uint256 taxBalance_) internal {\\n    uint256 preSwapBalance = address(this).balance;\\n\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = uniswapRouter.WETH();\\n\\n    uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n      taxBalance_,\\n      0,\\n      path,\\n      address(this),\\n      block.timestamp\\n    );\\n\\n    uint256 postSwapBalance = address(this).balance;\\n\\n    uint256 balanceToDistribute = postSwapBalance - preSwapBalance;\\n\\n    uint256 projectBalanceToDistribute = (balanceToDistribute *\\n      projectTaxPendingSwap) / (projectTaxPendingSwap + metadropTaxPendingSwap);\\n\\n    uint256 metadropBalanceToDistribute = (balanceToDistribute *\\n      metadropTaxPendingSwap) /\\n      (projectTaxPendingSwap + metadropTaxPendingSwap);\\n\\n    (projectTaxPendingSwap, metadropTaxPendingSwap) = (0, 0);\\n\\n    // Distribute to treasuries:\\n    bool success;\\n    (success, ) = projectTreasury.call{value: projectBalanceToDistribute}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n\\n    (success, ) = metadropTreasury.call{value: metadropBalanceToDistribute}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    if (account == address(0)) {\\n      _revert(MintToZeroAddress.selector);\\n    }\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply += amount;\\n    unchecked {\\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n      _balances[account] += amount;\\n    }\\n    emit Transfer(address(0), account, amount);\\n\\n    _afterTokenTransfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    if (account == address(0)) {\\n      _revert(BurnFromTheZeroAddress.selector);\\n    }\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    uint256 accountBalance = _balances[account];\\n    if (accountBalance < amount) {\\n      _revert(BurnExceedsBalance.selector);\\n    }\\n\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n      // Overflow not possible: amount <= accountBalance <= totalSupply.\\n      _totalSupply -= amount;\\n    }\\n\\n    emit Transfer(account, address(0), amount);\\n\\n    _afterTokenTransfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n   *\\n   * This internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    if (owner == address(0)) {\\n      _revert(ApproveFromTheZeroAddress.selector);\\n    }\\n\\n    if (spender == address(0)) {\\n      _revert(ApproveToTheZeroAddress.selector);\\n    }\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n   *\\n   * Does not update the allowance amount in case of infinite allowance.\\n   * Revert if not enough allowance is available.\\n   *\\n   * Might emit an {Approval} event.\\n   */\\n  function _spendAllowance(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance != type(uint256).max) {\\n      if (currentAllowance < amount) {\\n        _revert(InsufficientAllowance.selector);\\n      }\\n\\n      unchecked {\\n        _approve(owner, spender, currentAllowance - amount);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 value) public virtual {\\n    _burn(_msgSender(), value);\\n  }\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n   * the caller's allowance.\\n   *\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `value`.\\n   */\\n  function burnFrom(address account, uint256 value) public virtual {\\n    _spendAllowance(account, _msgSender(), value);\\n    _burn(account, value);\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * will be transferred to `to`.\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  /**\\n   * @dev Hook that is called after any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * has been transferred to `to`.\\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20FactoryV1/ERC20/IERC20ByMetadropV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IERC20ConfigByMetadropV1} from \\\"./IERC20ConfigByMetadropV1.sol\\\";\\n\\n/**\\n * @dev Metadrop core ERC-20 contract, interface\\n */\\ninterface IERC20ByMetadropV1 is\\n  IERC20,\\n  IERC20ConfigByMetadropV1,\\n  IERC20Metadata,\\n  IConfigStructures\\n{\\n  struct SocialLinks {\\n    string linkType;\\n    string link;\\n  }\\n\\n  event AutoSwapThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);\\n\\n  event ProjectTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event MetadropTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event LiquidityPoolCreated(address addedPool);\\n\\n  event LiquidityPoolAdded(address addedPool);\\n\\n  event LiquidityPoolRemoved(address removedPool);\\n\\n  event InitialLiquidityAdded(uint256 tokenA, uint256 tokenB, uint256 lpToken);\\n\\n  event LiquidityLocked();\\n\\n  event RevenueAutoSwap();\\n\\n  event SetLimitsEnabled(bool enabled);\\n\\n  event TreasuryUpdated(address treasury);\\n\\n  event UnlimitedAddressAdded(address addedUnlimted);\\n\\n  event UnlimitedAddressRemoved(address removedUnlimted);\\n\\n  /**\\n   * @dev function {addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   */\\n  function addInitialLiquidity(uint256 lockerFee_) external payable;\\n\\n  /**\\n   * @dev function {isLiquidityPool}\\n   *\\n   * Return if an address is a liquidity pool\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't a liquidity pool\\n   */\\n  function isLiquidityPool(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {addLiquidityPool} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to add a liquidity pool to the pool enumerable set\\n   *\\n   * @param newLiquidityPool_ The address of the new liquidity pool\\n   */\\n  function addLiquidityPool(address newLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {removeLiquidityPool} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to remove a liquidity pool\\n   *\\n   * @param removedLiquidityPool_ The address of the old removed liquidity pool\\n   */\\n  function removeLiquidityPool(address removedLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {isUnlimited}\\n   *\\n   * Return if an address is unlimited (is not subject to per txn and per wallet limits)\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't unlimited\\n   */\\n  function isUnlimited(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {addUnlimited} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to add an unlimited address\\n   *\\n   * @param newUnlimited_ The address of the new unlimited address\\n   */\\n  function addUnlimited(address newUnlimited_) external;\\n\\n  /**\\n   * @dev function {removeUnlimited} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to remove an unlimited address\\n   *\\n   * @param removedUnlimited_ The address of the old removed unlimited address\\n   */\\n  function removeUnlimited(address removedUnlimited_) external;\\n\\n  /**\\n   * @dev function {setLimitsEnabledStatus} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to enable / disable tokens per txn and per holder validation.\\n   *\\n   * @param enabled_ Should limits be on?\\n   */\\n  function setLimitsEnabledStatus(bool enabled_) external;\\n\\n  /**\\n   * @dev function {setProjectTreasury} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to set the treasury address\\n   *\\n   * @param projectTreasury_ New treasury address\\n   */\\n  function setProjectTreasury(address projectTreasury_) external;\\n\\n  /**\\n   * @dev function {setSwapThresholdBasisPoints} onlyTaxAdmin\\n   *\\n   * Allows the tax admin to set the autoswap threshold\\n   *\\n   * @param swapThresholdBasisPoints_ New swap threshold in basis points\\n   */\\n  function setSwapThresholdBasisPoints(\\n    uint16 swapThresholdBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {withdrawETH} onlyOwner\\n   *\\n   * Allows the owner to withdraw ETH\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external;\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyOwner\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn.\\n   *\\n   * @param token_ The address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(IERC20 token_, uint256 amount_) external;\\n\\n  /**\\n   * @dev function {setProjectTaxRates} onlyTaxAdmin\\n   *\\n   * Change the tax rates, subject to max rate\\n   *\\n   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newProjectSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setProjectTaxRates(\\n    uint16 newProjectBuyTaxBasisPoints_,\\n    uint16 newProjectSellTaxBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {setMetadropTaxRates} onlyTaxAdmin\\n   *\\n   * Change the tax rates, subject to max rate and minimum tax period.\\n   *\\n   * @param newMetadropBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newMetadropSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setMetadropTaxRates(\\n    uint16 newMetadropBuyTaxBasisPoints_,\\n    uint16 newMetadropSellTaxBasisPoints_\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20FactoryV1/ERC20/IERC20ConfigByMetadropV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IERC20ByMetadrop.sol. Interface for metadrop ERC20 standard\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.19;\\n\\ninterface IERC20ConfigByMetadropV1 {\\n  struct ERC20Config {\\n    bytes baseParameters;\\n    bytes supplyParameters;\\n    bytes taxParameters;\\n  }\\n\\n  struct ERC20BaseParameters {\\n    string name;\\n    string symbol;\\n    string website;\\n    string twitter;\\n    string telegram;\\n    string otherSocials;\\n  }\\n\\n  struct ERC20SupplyParameters {\\n    uint256 maxSupply;\\n    uint256 lpSupply;\\n    uint256 projectSupply;\\n    uint256 maxTokensPerWallet;\\n    uint256 maxTokensPerTxn;\\n    uint256 lpLockupInDays;\\n    bool addLiquidityOnCreate;\\n    address projectTreasury;\\n    address metadropTreasury;\\n  }\\n\\n  struct ERC20TaxParameters {\\n    uint256 projectBuyTaxBasisPoints;\\n    uint256 projectSellTaxBasisPoints;\\n    uint256 maxProjectBuyTaxBasisPoints;\\n    uint256 maxProjectSellTaxBasisPoints;\\n    uint256 taxSwapThresholdBasisPoints;\\n    uint256 metadropBuyTaxBasisPoints;\\n    uint256 metadropSellTaxBasisPoints;\\n    uint256 maxMetadropBuyTaxBasisPoints;\\n    uint256 maxMetadropSellTaxBasisPoints;\\n    uint256 metadropTaxPeriodInDays;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20FactoryV1/ERC20Factory/ERC20FactoryByMetadropV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL 1.0\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.19;\\n\\nimport {AuthorityModel} from \\\"../../Global/AuthorityModel.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../../Global/OZ/SafeERC20.sol\\\";\\nimport {IERC20FactoryByMetadropV1} from \\\"./IERC20FactoryByMetadropV1.sol\\\";\\nimport {IERC20ByMetadropV1} from \\\"../ERC20/IERC20ByMetadropV1.sol\\\";\\nimport {SignatureChecker} from \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IERC20ByMetadropV1, ERC20ByMetadropV1} from \\\"../ERC20/ERC20ByMetadropV1.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 factory\\n */\\ncontract ERC20FactoryByMetadropV1 is\\n  Context,\\n  IERC20FactoryByMetadropV1,\\n  AuthorityModel\\n{\\n  using SafeERC20 for IERC20;\\n\\n  // Uniswap router address\\n  address public immutable uniswapRouter;\\n  // Unicrypt locker address\\n  address public immutable unicryptLocker;\\n\\n  // Metadrop trusted oracle address\\n  address public metadropOracleAddress;\\n  // Address for all platform fee payments\\n  address public platformTreasury;\\n  // The oracle signed message validity period:\\n  // Note that maximum is 65,535, therefore 18.2 hours (which seems plenty)\\n  uint16 private messageValidityInSeconds = 30 minutes;\\n\\n  /**\\n   * @dev {constructor}\\n   *\\n   * @param superAdmin_ The address that can add and remove user authority roles. Will also be added as the\\n   * first platform admin.\\n   * @param platformAdmins_ The address(es) for the platform admin(s)\\n   * @param platformTreasury_ The address of the platform treasury. This will be used on primary vesting\\n   * for the platform share of funds and on the royalty payment splitter for the platform share.\\n   * @param metadropOracleAddress_ The address of the metadrop oracle signer\\n   * @param uniswapRouter_ The address of the uniswap router\\n   * @param unicryptLocker_ The address of the unicrypt locker\\n   */\\n  constructor(\\n    address superAdmin_,\\n    address[] memory platformAdmins_,\\n    address platformTreasury_,\\n    address metadropOracleAddress_,\\n    address uniswapRouter_,\\n    address unicryptLocker_\\n  ) {\\n    // The initial instance owner is set as the Ownable owner on all cloned contracts:\\n    if (superAdmin_ == address(0)) {\\n      _revert(SuperAdminCannotBeAddressZero.selector);\\n    }\\n\\n    // superAdmin can grant and revoke all other roles. This address MUST be secured.\\n    // For the duration of this constructor only the super admin is the deployer.\\n    // This is so the deployer can set initial authorities.\\n    // We set to the configured super admin address at the end of the constructor.\\n    superAdmin = _msgSender();\\n    // Grant platform admin to the deployer for the duration of the constructor:\\n    grantPlatformAdmin(_msgSender());\\n    // By default we will revoke the temporary authority for the deployer, BUT,\\n    // if the deployer is in the platform admin array then we want to keep that\\n    // authority, as it has been explicitly set. We handle that situation using\\n    // a bool:\\n    bool revokeDeployerPlatformAdmin = true;\\n\\n    grantPlatformAdmin(superAdmin_);\\n\\n    for (uint256 i = 0; i < platformAdmins_.length; ) {\\n      // Check if the address we are granting for is the deployer. If it is,\\n      // then the deployer address already IS a platform admin and it would be\\n      // a waste of gas to grant again. Instead, we update the bool to show that\\n      // we DON'T want to revoke this permission at the end of this method:\\n      if (platformAdmins_[i] == _msgSender()) {\\n        revokeDeployerPlatformAdmin = false;\\n      } else {\\n        grantPlatformAdmin(platformAdmins_[i]);\\n      }\\n      unchecked {\\n        i++;\\n      }\\n    }\\n\\n    // Set platform treasury:\\n    if (platformTreasury_ == address(0)) {\\n      _revert(PlatformTreasuryCannotBeAddressZero.selector);\\n    }\\n    platformTreasury = platformTreasury_;\\n\\n    if (metadropOracleAddress_ == address(0)) {\\n      _revert(MetadropOracleCannotBeAddressZero.selector);\\n    }\\n    metadropOracleAddress = metadropOracleAddress_;\\n\\n    uniswapRouter = uniswapRouter_;\\n\\n    unicryptLocker = unicryptLocker_;\\n\\n    // This is the factory\\n    factory = address(this);\\n\\n    // Revoke platform admin status of the deployer and transfer superAdmin\\n    // and ownable owner to the superAdmin_.\\n    // Revoke platform admin based on the bool flag set earlier (see above\\n    // for an explanation of how this flag is set)\\n    if (revokeDeployerPlatformAdmin) {\\n      revokePlatformAdmin(_msgSender());\\n    }\\n    if (superAdmin_ != _msgSender()) {\\n      transferSuperAdmin(superAdmin_);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {setMetadropOracleAddress} onlyPlatformAdmin\\n   *\\n   * Set the metadrop trusted oracle address\\n   *\\n   * @param metadropOracleAddress_ Trusted metadrop oracle address\\n   */\\n  function setMetadropOracleAddress(\\n    address metadropOracleAddress_\\n  ) external onlyPlatformAdmin {\\n    if (metadropOracleAddress_ == address(0)) {\\n      _revert(MetadropOracleCannotBeAddressZero.selector);\\n    }\\n    metadropOracleAddress = metadropOracleAddress_;\\n  }\\n\\n  /**\\n   * @dev function {setMessageValidityInSeconds} onlyPlatformAdmin\\n   *\\n   * Set the validity period of signed messages\\n   *\\n   * @param messageValidityInSeconds_ Validity period in seconds for messages signed by the trusted oracle\\n   */\\n  function setMessageValidityInSeconds(\\n    uint256 messageValidityInSeconds_\\n  ) external onlyPlatformAdmin {\\n    messageValidityInSeconds = uint16(messageValidityInSeconds_);\\n  }\\n\\n  /**\\n   * @dev function {setPlatformTreasury} onlySuperAdmin\\n   *\\n   * Set the address that platform fees will be paid to / can be withdrawn to.\\n   * Note that this is restricted to the highest authority level, the super\\n   * admin. Platform admins can trigger a withdrawal to the treasury, but only\\n   * the default admin can set or alter the treasury address. It is recommended\\n   * that the default admin is highly secured and restrited e.g. a multi-sig.\\n   *\\n   * @param platformTreasury_ New treasury address\\n   */\\n  function setPlatformTreasury(\\n    address platformTreasury_\\n  ) external onlySuperAdmin {\\n    if (platformTreasury_ == address(0)) {\\n      _revert(PlatformTreasuryCannotBeAddressZero.selector);\\n    }\\n    platformTreasury = platformTreasury_;\\n  }\\n\\n  /**\\n   * @dev function {withdrawETH} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ETH to be withdrawn to the treasury\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external onlyPlatformAdmin {\\n    (bool success, ) = platformTreasury.call{value: amount_}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn to the treasury\\n   *\\n   * @param token_ The contract address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(\\n    IERC20 token_,\\n    uint256 amount_\\n  ) external onlyPlatformAdmin {\\n    token_.safeTransfer(platformTreasury, amount_);\\n  }\\n\\n  /**\\n   * @dev function {createERC20}\\n   *\\n   * Create an ERC-20\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @return deployedAddress_ The deployed ERC20 contract address\\n   */\\n  function createERC20(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_\\n  ) external payable returns (address deployedAddress_) {\\n    // Check the signed message origin and time:\\n    _verifyMessage(signedMessage_);\\n\\n    // We can only proceed if the hash of the passed configuration matches the hash\\n    // signed by our oracle signer:\\n    if (\\n      !_configHashMatches(\\n        metaId_,\\n        salt_,\\n        erc20Config_,\\n        signedMessage_,\\n        lockerFee_,\\n        deploymentFee_,\\n        _msgSender()\\n      )\\n    ) {\\n      _revert(PassedConfigDoesNotMatchApproved.selector);\\n    }\\n\\n    (, , , , , , bool addLiquidityOnCreate, , ) = abi.decode(\\n      erc20Config_.supplyParameters,\\n      (\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        bool,\\n        address,\\n        address\\n      )\\n    );\\n\\n    address[3] memory integrationAddresses = [\\n      msg.sender,\\n      uniswapRouter,\\n      unicryptLocker\\n    ];\\n\\n    bytes memory deploymentData = abi.encodePacked(\\n      type(ERC20ByMetadropV1).creationCode,\\n      abi.encode(\\n        integrationAddresses,\\n        erc20Config_.baseParameters,\\n        erc20Config_.supplyParameters,\\n        erc20Config_.taxParameters\\n      )\\n    );\\n\\n    address newERC20;\\n\\n    assembly {\\n      newERC20 := create2(\\n        0,\\n        add(deploymentData, 0x20),\\n        mload(deploymentData),\\n        salt_\\n      )\\n      if iszero(extcodesize(newERC20)) {\\n        revert(0, 0)\\n      }\\n    }\\n\\n    if (addLiquidityOnCreate) {\\n      // Check the fee, we must have enough ETH for the fees, plus at least ONE wei if adding liquidity:\\n      if (msg.value < (lockerFee_ + deploymentFee_)) {\\n        _revert(IncorrectPayment.selector);\\n      }\\n\\n      // Value to pass on (for locking fee plus liquidity, if any) is the sent\\n      // amount minus the deployment fee (if any)\\n      IERC20ByMetadropV1(newERC20).addInitialLiquidity{\\n        value: msg.value - deploymentFee_\\n      }(lockerFee_);\\n    } else {\\n      // Check the fee, we must have ETH for ONLY the deployment fee\\n      if (msg.value != deploymentFee_) {\\n        _revert(IncorrectPayment.selector);\\n      }\\n    }\\n\\n    (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol(\\n      erc20Config_.baseParameters\\n    );\\n\\n    emit ERC20Created(metaId_, msg.sender, newERC20, tokenName, tokenSymbol);\\n\\n    return (newERC20);\\n  }\\n\\n  /**\\n   * @dev function {_getNameAndSymbol} Create an ERC-20\\n   *\\n   * Decode the name and symbol\\n   *\\n   * @param encodedBaseParams_ Base ERC20 params\\n   * @return name_ The name\\n   * @return symbol_ The symbol\\n   */\\n  function _getNameAndSymbol(\\n    bytes memory encodedBaseParams_\\n  ) internal pure returns (string memory name_, string memory symbol_) {\\n    (name_, symbol_, , , , ) = abi.decode(\\n      encodedBaseParams_,\\n      (string, string, string, string, string, string)\\n    );\\n    return (name_, symbol_);\\n  }\\n\\n  /**\\n   * @dev function {_verifyMessage}\\n   *\\n   * Check the signature and expiry of the passed message\\n   *\\n   * @param signedMessage_ The signed message object\\n   */\\n  function _verifyMessage(\\n    SignedDropMessageDetails calldata signedMessage_\\n  ) internal view {\\n    // Check that this signature is from the oracle signer:\\n    if (\\n      !_validSignature(\\n        signedMessage_.messageHash,\\n        signedMessage_.messageSignature\\n      )\\n    ) {\\n      _revert(InvalidOracleSignature.selector);\\n    }\\n\\n    // Check that the signature has not expired:\\n    unchecked {\\n      if (\\n        (signedMessage_.messageTimeStamp + messageValidityInSeconds) <\\n        block.timestamp\\n      ) {\\n        _revert(OracleSignatureHasExpired.selector);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_validSignature}\\n   *\\n   * Checks the the signature on the signed message is from the metadrop oracle\\n   *\\n   * @param messageHash_ The message hash signed by the trusted oracle signer. This will be the\\n   * keccack256 hash of received data about this token.\\n   * @param messageSignature_ The signed message from the backend oracle signer for validation.\\n   */\\n  function _validSignature(\\n    bytes32 messageHash_,\\n    bytes memory messageSignature_\\n  ) internal view returns (bool) {\\n    bytes32 ethSignedMessageHash = keccak256(\\n      abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash_)\\n    );\\n\\n    // Check the signature is valid:\\n    return (\\n      SignatureChecker.isValidSignatureNow(\\n        metadropOracleAddress,\\n        ethSignedMessageHash,\\n        messageSignature_\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev function {_configHashMatches}\\n   *\\n   * Check the passed config against the stored config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param deployer_ Address performing the deployment\\n   * @return matches_ Whether the hash matches (true) or not (false)\\n   */\\n  function _configHashMatches(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address deployer_\\n  ) internal pure returns (bool matches_) {\\n    // Create the hash of the passed data for comparison:\\n    bytes32 passedConfigHash = createConfigHash(\\n      metaId_,\\n      salt_,\\n      erc20Config_,\\n      signedMessage_.messageTimeStamp,\\n      lockerFee_,\\n      deploymentFee_,\\n      deployer_\\n    );\\n\\n    // Must equal the stored hash:\\n    return (passedConfigHash == signedMessage_.messageHash);\\n  }\\n\\n  /**\\n   * @dev function {createConfigHash}\\n   *\\n   * Create the config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param messageTimeStamp_ When the message for this config hash was signed\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param deployer_ Address performing the deployment\\n   * @return configHash_ The bytes32 config hash\\n   */\\n  function createConfigHash(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    uint256 messageTimeStamp_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address deployer_\\n  ) public pure returns (bytes32 configHash_) {\\n    configHash_ = keccak256(\\n      abi.encodePacked(\\n        metaId_,\\n        salt_,\\n        erc20Config_.baseParameters,\\n        erc20Config_.supplyParameters,\\n        erc20Config_.taxParameters,\\n        messageTimeStamp_,\\n        lockerFee_,\\n        deploymentFee_,\\n        deployer_\\n      )\\n    );\\n\\n    return (configHash_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20FactoryV1/ERC20Factory/IERC20FactoryByMetadropV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IErrors} from \\\"../../Global/IErrors.sol\\\";\\nimport {IERC20ConfigByMetadropV1} from \\\"../ERC20/IERC20ConfigByMetadropV1.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 factory, interface\\n */\\ninterface IERC20FactoryByMetadropV1 is\\n  IConfigStructures,\\n  IErrors,\\n  IERC20ConfigByMetadropV1\\n{\\n  event ERC20Created(\\n    string metaId,\\n    address indexed deployer,\\n    address contractInstance,\\n    string symbol,\\n    string name\\n  );\\n\\n  /**\\n   * @dev function {setMetadropOracleAddress} onlyPlatformAdmin\\n   *\\n   * Set the metadrop trusted oracle address\\n   *\\n   * @param metadropOracleAddress_ Trusted metadrop oracle address\\n   */\\n  function setMetadropOracleAddress(address metadropOracleAddress_) external;\\n\\n  /**\\n   * @dev function {setMessageValidityInSeconds} onlyPlatformAdmin\\n   *\\n   * Set the validity period of signed messages\\n   *\\n   * @param messageValidityInSeconds_ Validity period in seconds for messages signed by the trusted oracle\\n   */\\n  function setMessageValidityInSeconds(\\n    uint256 messageValidityInSeconds_\\n  ) external;\\n\\n  /**\\n   * @dev function {setPlatformTreasury} onlySuperAdmin\\n   *\\n   * Set the address that platform fees will be paid to / can be withdrawn to.\\n   * Note that this is restricted to the highest authority level, the super\\n   * admin. Platform admins can trigger a withdrawal to the treasury, but only\\n   * the default admin can set or alter the treasury address. It is recommended\\n   * that the default admin is highly secured and restrited e.g. a multi-sig.\\n   *\\n   * @param platformTreasury_ New treasury address\\n   */\\n  function setPlatformTreasury(address platformTreasury_) external;\\n\\n  /**\\n   * @dev function {withdrawETH} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ETH to be withdrawn to the treasury\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external;\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn to the treasury\\n   *\\n   * @param token_ The contract address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(IERC20 token_, uint256 amount_) external;\\n\\n  /**\\n   * @dev function {createERC20}\\n   *\\n   * Create an ERC-20\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @return deployedAddress_ The deployed ERC20 contract address\\n   */\\n  function createERC20(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_\\n  ) external payable returns (address deployedAddress_);\\n\\n  /**\\n   * @dev function {createConfigHash}\\n   *\\n   * Create the config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param messageTimeStamp_ When the message for this config hash was signed\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param deployer_ Address performing the deployment\\n   * @return configHash_ The bytes32 config hash\\n   */\\n  function createConfigHash(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    uint256 messageTimeStamp_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address deployer_\\n  ) external pure returns (bytes32 configHash_);\\n}\\n\"\r\n    },\r\n    \"contracts/Global/AuthorityModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title AuthorityModel.sol. Library for global authority components\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.19;\\n\\n/**\\n *\\n * @dev Inheritance details:\\n *      EnumerableSet           OZ enumerable mapping sets\\n *      IErrors                 Interface for platform error definitions\\n *\\n */\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IErrors} from \\\"./IErrors.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\ncontract AuthorityModel is IErrors, Revert {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  event SuperAdminTransferred(address oldSuperAdmin, address newSuperAdmin);\\n  event PlatformAdminAdded(address platformAdmin);\\n  event PlatformAdminRevoked(address platformAdmin);\\n\\n  // Address for the factory:\\n  address public factory;\\n\\n  // The super admin can grant and revoke roles\\n  address public superAdmin;\\n\\n  //\u00a0Enumerable set to store platform admins:\\n  EnumerableSet.AddressSet private _platformAdmins;\\n\\n  /** ====================================================================================================================\\n   *                                                       MODIFIERS\\n   * =====================================================================================================================\\n   */\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (modifier) onlySuperAdmin. The associated action can only be taken by the super admin (an address with the\\n   * default admin role).\\n   *\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  modifier onlySuperAdmin() {\\n    if (!isSuperAdmin(msg.sender)) revert CallerIsNotSuperAdmin(msg.sender);\\n    _;\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (modifier) onlyPlatformAdmin. The associated action can only be taken by an address with the\\n   * platform admin role.\\n   *\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  modifier onlyPlatformAdmin() {\\n    if (!isPlatformAdmin(msg.sender))\\n      revert CallerIsNotPlatformAdmin(msg.sender);\\n    _;\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                             -->GETTER\\n   * @dev (function) isSuperAdmin   check if an address is the super admin\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @return bool\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function isSuperAdmin(address queryAddress_) public view returns (bool) {\\n    return (superAdmin == queryAddress_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                             -->GETTER\\n   * @dev (function) isPlatformAdmin   check if an address is a platform admin\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @return bool\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function isPlatformAdmin(address queryAddress_) public view returns (bool) {\\n    return (_platformAdmins.contains(queryAddress_));\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) grantPlatformAdmin  Allows the super user Default Admin to add an address to the platform admin group\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param newPlatformAdmin_              The address of the new platform admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function grantPlatformAdmin(address newPlatformAdmin_) public onlySuperAdmin {\\n    if (newPlatformAdmin_ == address(0)) {\\n      _revert(PlatformAdminCannotBeAddressZero.selector);\\n    }\\n    // Add this to the enumerated list:\\n    _platformAdmins.add(newPlatformAdmin_);\\n    emit PlatformAdminAdded(newPlatformAdmin_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) revokePlatformAdmin  Allows the super user Default Admin to revoke from the platform admin group\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param oldPlatformAdmin_              The address of the old platform admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function revokePlatformAdmin(\\n    address oldPlatformAdmin_\\n  ) public onlySuperAdmin {\\n    // Remove this from the enumerated list:\\n    _platformAdmins.remove(oldPlatformAdmin_);\\n    emit PlatformAdminRevoked(oldPlatformAdmin_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) transferSuperAdmin  Allows the super user Default Admin to transfer this right to another address\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param newSuperAdmin_              The address of the new default admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function transferSuperAdmin(address newSuperAdmin_) public onlySuperAdmin {\\n    address oldSuperAdmin = superAdmin;\\n    // Update storage of this address:\\n    superAdmin = newSuperAdmin_;\\n    emit SuperAdminTransferred(oldSuperAdmin, newSuperAdmin_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IConfigStructures.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IConfigStructures.sol. Interface for common config structures used accross the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.19;\\n\\ninterface IConfigStructures {\\n  enum DropStatus {\\n    approved,\\n    deployed,\\n    cancelled\\n  }\\n\\n  enum TemplateStatus {\\n    live,\\n    terminated\\n  }\\n\\n  // The current status of the mint:\\n  //   - notEnabled: This type of mint is not part of this drop\\n  //   - notYetOpen: This type of mint is part of the drop, but it hasn't started yet\\n  //   - open: it's ready for ya, get in there.\\n  //   - finished: been and gone.\\n  //   - unknown: theoretically impossible.\\n  enum MintStatus {\\n    notEnabled,\\n    notYetOpen,\\n    open,\\n    finished,\\n    unknown\\n  }\\n\\n  struct SubListConfig {\\n    uint256 start;\\n    uint256 end;\\n    uint256 phaseMaxSupply;\\n  }\\n\\n  struct PrimarySaleModuleInstance {\\n    address instanceAddress;\\n    string instanceDescription;\\n  }\\n\\n  struct NFTModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n    bytes vestingData;\\n  }\\n\\n  struct PrimarySaleModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct ProjectBeneficiary {\\n    address payable payeeAddress;\\n    uint256 payeeShares;\\n  }\\n\\n  struct VestingConfig {\\n    uint256 start;\\n    uint256 projectUpFrontShare;\\n    uint256 projectVestedShare;\\n    uint256 vestingPeriodInDays;\\n    uint256 vestingCliff;\\n    ProjectBeneficiary[] projectPayees;\\n  }\\n\\n  struct RoyaltySplitterModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModules {\\n    InLifeModuleConfig[] modules;\\n  }\\n\\n  struct NFTConfig {\\n    uint256 supply;\\n    string name;\\n    string symbol;\\n    bytes32 positionProof;\\n    bool includePriorPhasesInMintTracking;\\n    bool singleMetadataCollection;\\n    uint256 reservedAllocation;\\n    uint256 assistanceRequestWindowInSeconds;\\n  }\\n\\n  struct Template {\\n    TemplateStatus status;\\n    uint16 templateNumber;\\n    uint32 loadedDate;\\n    address payable templateAddress;\\n    string templateDescription;\\n  }\\n\\n  struct RoyaltyDetails {\\n    address newRoyaltyPaymentSplitterInstance;\\n    uint96 royaltyFromSalesInBasisPoints;\\n  }\\n\\n  struct SignedDropMessageDetails {\\n    uint256 messageTimeStamp;\\n    bytes32 messageHash;\\n    bytes messageSignature;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IErrors.sol. Interface for error definitions used across the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.19;\\n\\ninterface IErrors {\\n  enum BondingCurveErrorType {\\n    OK, //                                                  No error\\n    INVALID_NUMITEMS, //                                    The numItem value is 0\\n    SPOT_PRICE_OVERFLOW //                                  The updated spot price doesn't fit into 128 bits\\n  }\\n\\n  error AdapterParamsMustBeEmpty(); //                      The adapter parameters on this LZ call must be empty.\\n\\n  error AddressAlreadySet(); //                             The address being set can only be set once, and is already non-0.\\n\\n  error AllowanceDecreasedBelowZero(); //                   You cannot decrease the allowance below zero.\\n\\n  error AlreadyInitialised(); //                            The contract is already initialised: it cannot be initialised twice!\\n\\n  error ApprovalCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error ApproveFromTheZeroAddress(); //                     Approval cannot be called from the zero address (indeed, how have you??).\\n\\n  error ApproveToTheZeroAddress(); //                       Approval cannot be given to the zero address.\\n\\n  error ApprovalQueryForNonexistentToken(); //              The token does not exist.\\n\\n  error AuctionStatusIsNotEnded(); //                       Throw if the action required the auction to be closed, and it isn't.\\n\\n  error AuctionStatusIsNotOpen(); //                        Throw if the action requires the auction to be open, and it isn't.\\n\\n  error AuxCallFailed(\\n    address[] modules,\\n    uint256 value,\\n    bytes data,\\n    uint256 txGas\\n  ); //                                                     An auxilliary call from the drop factory failed.\\n\\n  error BalanceQueryForZeroAddress(); //                    Cannot query the balance for the zero address.\\n\\n  error BidMustBeBelowTheFloorWhenReducingQuantity(); //    Only bids that are below the floor can reduce the quantity of the bid.\\n\\n  error BidMustBeBelowTheFloorForRefundDuringAuction(); //  Only bids that are below the floor can be refunded during the auction.\\n\\n  error BondingCurveError(BondingCurveErrorType error); //  An error of the type specified has occured in bonding curve processing.\\n\\n  error BurnExceedsBalance(); //                            The amount you have selected to burn exceeds the addresses balance.\\n\\n  error BurnFromTheZeroAddress(); //                        Tokens cannot be burned from the zero address. (Also, how have you called this!?!)\\n\\n  error CallerIsNotFactory(); //                            The caller of this function must match the factory address in storage.\\n\\n  error CallerIsNotFactoryOrProjectOwner(); //              The caller of this function must match the factory address OR project owner address.\\n\\n  error CallerIsNotTheOwner(); //                           The caller is not the owner of this contract.\\n\\n  error CallerIsNotTheTaxAdmin(); //                        The caller is not the tax admin of this contract.\\n\\n  error CallerMustBeLzApp(); //                             The caller must be an LZ application.\\n\\n  error CallerIsNotPlatformAdmin(address caller); //        The caller of this function must be part of the platformAdmin group.\\n\\n  error CallerIsNotSuperAdmin(address caller); //           The caller of this function must match the superAdmin address in storage.\\n\\n  error CannotSetNewOwnerToTheZeroAddress(); //             You can't set the owner of this contract to the zero address (address(0)).\\n\\n  error CannotSetToZeroAddress(); //                        The corresponding address cannot be set to the zero address (address(0)).\\n\\n  error CannotSetNewTaxAdminToTheZeroAddress(); //          Cannot transfer the tax admin to the zero address (address(0)).\\n\\n  error CollectionAlreadyRevealed(); //                     The collection is already revealed; you cannot call reveal again.\\n\\n  error ContractIsPaused(); //                              The call requires the contract to be unpaused, and it is paused.\\n\\n  error ContractIsNotPaused(); //                           The call required the contract to be paused, and it is NOT paused.\\n\\n  error DecreasedAllowanceBelowZero(); //                   The request would decrease the allowance below zero, and that is not allowed.\\n\\n  error DestinationIsNotTrustedSource(); //                 The destination that is being called through LZ has not been set as trusted.\\n\\n  error GasLimitIsTooLow(); //                              The gas limit for the LayerZero call is too low.\\n\\n  error IncorrectConfirmationValue(); //                    You need to enter the right confirmation value to call this funtion (usually 69420).\\n\\n  error IncorrectPayment(); //                              The function call did not include passing the correct payment.\\n\\n  error InitialLiquidityAlreadyAdded(); //                  Initial liquidity has already been added. You can't do it again.\\n\\n  error InsufficientAllowance(); //                         There is not a high enough allowance for this operation.\\n\\n  error InvalidAdapterParams(); //                          The current adapter params for LayerZero on this contract won't work :(.\\n\\n  error InvalidAddress(); //                                An address being processed in the function is not valid.\\n\\n  error InvalidEndpointCaller(); //                         The calling address is not a valid LZ endpoint. The LZ endpoint was set at contract creation\\n  //                                                        and cannot be altered after. Check the address LZ endpoint address on the contract.\\n\\n  error InvalidMinGas(); //                                 The minimum gas setting for LZ in invalid.\\n\\n  error InvalidOracleSignature(); //                        The signature provided with the contract call is not valid, either in format or signer.\\n\\n  error InvalidPayload(); //                                The LZ payload is invalid\\n\\n  error InvalidReceiver(); //                               The address used as a target for funds is not valid.\\n\\n  error InvalidSourceSendingContract(); //                  The LZ message is being related from a source contract on another chain that is NOT trusted.\\n\\n  error InvalidTotalShares(); //                            Total shares must equal 100 percent in basis points.\\n\\n  error ListLengthMismatch(); //                            Two or more lists were compared and they did not match length.\\n\\n  error LiquidityPoolMustBeAContractAddress(); //           Cannot add a non-contract as a liquidity pool.\\n\\n  error LiquidityPoolCannotBeAddressZero(); //              Cannot add a liquidity pool from the zero address.\\n\\n  error LPLockUpMustFitUint96(); //                         LP lockup is held in a uint96, so must fit.\\n\\n  error NoTrustedPathRecord(); //                           LZ needs a trusted path record for this to work. What's that, you ask?\\n\\n  error MaxBidQuantityIs255(); //                           Validation: as we use a uint8 array to track bid positions the max bid quantity is 255.\\n\\n  error MaxPublicMintAllowanceExceeded(\\n    uint256 requested,\\n    uint256 alreadyMinted,\\n    uint256 maxAllowance\\n  ); //                                                     The calling address has requested a quantity that would exceed the max allowance.\\n\\n  error MaxSupplyTooHigh(); //                              Max supply must fit in a uint128.\\n\\n  error MaxTokensPerWalletExceeded(); //                    The transfer would exceed the max tokens per wallet limit.\\n\\n  error MaxTokensPerTxnExceeded(); //                       The transfer would exceed the max tokens per transaction limit.\\n\\n  error MetadataIsLocked(); //                              The metadata on this contract is locked; it cannot be altered!\\n\\n  error MetadropFactoryOnlyOncePerReveal(); //              This function can only be called (a) by the factory and, (b) just one time!\\n\\n  error MetadropModulesOnly(); //                           Can only be called from a metadrop contract.\\n\\n  error MetadropOracleCannotBeAddressZero(); //             The metadrop Oracle cannot be the zero address (address(0)).\\n\\n  error MinGasLimitNotSet(); //                             The minimum gas limit for LayerZero has not been set.\\n\\n  error MintERC2309QuantityExceedsLimit(); //               The `quantity` minted with ERC2309 exceeds the safety limit.\\n\\n  error MintingIsClosedForever(); //                        Minting is, as the error suggests, so over (and locked forever).\\n\\n  error MintToZeroAddress(); //                             Cannot mint to the zero address.\\n\\n  error MintZeroQuantity(); //                              The quantity of tokens minted must be more than zero.\\n\\n  error NewBuyTaxBasisPointsExceedsMaximum(); //            Project owner trying to set the tax rate too high.\\n\\n  error NewSellTaxBasisPointsExceedsMaximum(); //           Project owner trying to set the tax rate too high.\\n\\n  error NoETHForLiquidityPair(); //                         No ETH has been provided for the liquidity pair.\\n\\n  error TaxPeriodStillInForce(); //                         The minimum tax period has not yet expired.\\n\\n  error NoPaymentDue(); //                                  No payment is due for this address.\\n\\n  error NoRefundForCaller(); //                             Error thrown when the calling address has no refund owed.\\n\\n  error NoStoredMessage(); //                               There is no stored message matching the passed parameters.\\n\\n  error NoTokenForLiquidityPair(); //                       There is no token to add to the LP.\\n\\n  error OperationDidNotSucceed(); //                        The operation failed (vague much?).\\n\\n  error OracleSignatureHasExpired(); //                     A signature has been provided but it is too old.\\n\\n  error OwnershipNotInitializedForExtraData(); //           The `extraData` cannot be set on an uninitialized ownership slot.\\n\\n  error OwnerQueryForNonexistentToken(); //                 The token does not exist.\\n\\n  error ParametersDoNotMatchSignedMessage(); //             The parameters passed with the signed message do not match the message itself.\\n\\n  error PassedConfigDoesNotMatchApproved(); //              The config provided on the call does not match the approved config.\\n\\n  error PauseCutOffHasPassed(); //                          The time period in which we can pause has passed; this contract can no longer be paused.\\n\\n  error PaymentMustCoverPerMintFee(); //                    The payment passed must at least cover the per mint fee for the quantity requested.\\n\\n  error PermitDidNotSucceed(); //                           The safeERC20 permit failed.\\n\\n  error PlatformAdminCannotBeAddressZero(); //              We cannot use the zero address (address(0)) as a platformAdmin.\\n\\n  error PlatformTreasuryCannotBeAddressZero(); //           The treasury address cannot be set to the zero address.\\n\\n  error ProjectOwnerCannotBeAddressZero(); //               The project owner has to be a non zero address.\\n\\n  error ProofInvalid(); //                                  The provided proof is not valid with the provided arguments.\\n\\n  error QuantityExceedsRemainingCollectionSupply(); //      The requested quantity would breach the collection supply.\\n\\n  error QuantityExceedsRemainingPhaseSupply(); //           The requested quantity would breach the phase supply.\\n\\n  error QuantityExceedsMaxPossibleCollectionSupply(); //    The requested quantity would breach the maximum trackable supply\\n\\n  error ReferralIdAlreadyUsed(); //                         This referral ID has already been used; they are one use only.\\n\\n  error RequestingMoreThanRemainingAllocation(\\n    uint256 previouslyMinted,\\n    uint256 requested,\\n    uint256 remainingAllocation\\n  ); //                                                     Number of tokens requested for this mint exceeds the remaining allocation (taking the\\n  //                                                        original allocation from the list and deducting minted tokens).\\n\\n  error RoyaltyFeeWillExceedSalePrice(); //                 The ERC2981 royalty specified will exceed the sale price.\\n\\n  error ShareTotalCannotBeZero(); //                        The total of all the shares cannot be nothing.\\n\\n  error SliceOutOfBounds(); //                              The bytes slice operation was out of bounds.\\n\\n  error SliceOverflow(); //                                 The bytes slice operation overlowed.\\n\\n  error SuperAdminCannotBeAddressZero(); //                 The superAdmin cannot be the sero address (address(0)).\\n\\n  error SupplyTotalMismatch(); //                           The sum of the team supply and lp supply does not match.\\n\\n  error SupportWindowIsNotOpen(); //                        The project owner has not requested support within the support request expiry window.\\n\\n  error TaxFreeAddressCannotBeAddressZero(); //             A tax free address cannot be address(0)\\n\\n  error TemplateCannotBeAddressZero(); //                   The address for a template cannot be address zero (address(0)).\\n\\n  error TemplateNotFound(); //                              There is no template that matches the passed template Id.\\n\\n  error ThisMintIsClosed(); //                              It's over (well, this mint is, anyway).\\n\\n  error TotalSharesMustMatchDenominator(); //               The total of all shares must equal the denominator value.\\n\\n  error TransferAmountExceedsBalance(); //                  The transfer amount exceeds the accounts available balance.\\n\\n  error TransferCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error TransferFailed(); //                                The transfer has failed.\\n\\n  error TransferFromIncorrectOwner(); //                    The token must be owned by `from`.\\n\\n  error TransferToNonERC721ReceiverImplementer(); //        Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n\\n  error TransferFromZeroAddress(); //                       Cannot transfer from the zero address. Indeed, this surely is impossible, and likely a waste to check??\\n\\n  error TransferToZeroAddress(); //                         Cannot transfer to the zero address.\\n\\n  error UnrecognisedVRFMode(); //                           Currently supported VRF modes are 0: chainlink and 1: arrng\\n\\n  error URIQueryForNonexistentToken(); //                   The token does not exist.\\n\\n  error ValueExceedsMaximum(); //                           The value sent exceeds the maximum allowed (super useful explanation huh?).\\n\\n  error VRFCoordinatorCannotBeAddressZero(); //             The VRF coordinator cannot be the zero address (address(0)).\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IErrors} from \\\"../IErrors.sol\\\";\\nimport {Revert} from \\\"../Revert.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is IErrors, Revert, Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    if (owner() != _msgSender()) {\\n      _revert(CallerIsNotTheOwner.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    if (newOwner == address(0)) {\\n      _revert(CannotSetNewOwnerToTheZeroAddress.selector);\\n    }\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IErrors} from \\\"../IErrors.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n  }\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n   * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeCall(token.transferFrom, (from, to, value))\\n    );\\n  }\\n\\n  /**\\n   * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    forceApprove(token, spender, oldAllowance + value);\\n  }\\n\\n  /**\\n   * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      if (oldAllowance < value) {\\n        revert IErrors.DecreasedAllowanceBelowZero();\\n      }\\n      forceApprove(token, spender, oldAllowance - value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n   * 0 before setting it to a non-zero value.\\n   */\\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n    bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n    if (!_callOptionalReturnBool(token, approvalCall)) {\\n      _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n      _callOptionalReturn(token, approvalCall);\\n    }\\n  }\\n\\n  /**\\n   * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n   * Revert on invalid signature.\\n   */\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    if (nonceAfter != (nonceBefore + 1)) {\\n      revert IErrors.PermitDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"call fail\\\");\\n    if ((returndata.length != 0) && !abi.decode(returndata, (bool))) {\\n      revert IErrors.OperationDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   *\\n   * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n   */\\n  function _callOptionalReturnBool(\\n    IERC20 token,\\n    bytes memory data\\n  ) private returns (bool) {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n    // and not revert is the subcall reverts.\\n\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    return\\n      success &&\\n      (returndata.length == 0 || abi.decode(returndata, (bool))) &&\\n      address(token).code.length > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title Revert.sol. For efficient reverts\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.19;\\n\\nabstract contract Revert {\\n  /**\\n   * @dev For more efficient reverts.\\n   */\\n  function _revert(bytes4 errorSelector) internal pure {\\n    assembly {\\n      mstore(0x00, errorSelector)\\n      revert(0x00, 0x04)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/TaxAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IErrors} from \\\"./IErrors.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract TaxAdmin is IErrors, Revert, Context {\\n  address private _taxAdmin;\\n\\n  event TaxAdminTransferred(\\n    address indexed previousTaxAdmin,\\n    address indexed newTaxAdmin\\n  );\\n\\n  constructor() {}\\n\\n  /**\\n   * @dev Throws if called by any account other than the tax admin.\\n   */\\n  modifier onlyTaxAdmin() {\\n    _checkTaxAdmin();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current tax admin.\\n   */\\n  function taxAdmin() public view virtual returns (address) {\\n    return _taxAdmin;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the tax admin.\\n   */\\n  function _checkTaxAdmin() internal view virtual {\\n    if (taxAdmin() != _msgSender()) {\\n      _revert(CallerIsNotTheTaxAdmin.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without a tax admin. It will not be possible to call\\n   * `onlyTaxAdmin` functions. Can only be called by the current tax admin.\\n   *\\n   * NOTE: Renouncing taxAdmin will leave the contract without an tax admim,\\n   * thereby disabling any functionality that is only available to the tax admin.\\n   */\\n  function renounceTaxAdmin() public virtual onlyTaxAdmin {\\n    _transferTaxAdmin(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers the tax admin of the contract to a new account (`newTaxAdmin`).\\n   * Can only be called by the current tax admin.\\n   */\\n  function transferTaxAdmin(address newTaxAdmin) public virtual onlyTaxAdmin {\\n    if (newTaxAdmin == address(0)) {\\n      _revert(CannotSetNewTaxAdminToTheZeroAddress.selector);\\n    }\\n    _transferTaxAdmin(newTaxAdmin);\\n  }\\n\\n  /**\\n   * @dev Transfers the tax admin of the contract to a new account (`newTaxAdmin`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferTaxAdmin(address newTaxAdmin) internal virtual {\\n    address oldTaxAdmin = _taxAdmin;\\n    _taxAdmin = newTaxAdmin;\\n    emit TaxAdminTransferred(oldTaxAdmin, newTaxAdmin);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/ERC20Spendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity 0.8.19;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IERC20Spendable} from \\\"./IERC20Spendable.sol\\\";\\nimport {IERC20SpendableReceiver} from \\\"./IERC20SpendableReceiver.sol\\\";\\n\\n/**\\n * @title ERC-7492 ERC20Spendable.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {ERC20Spendable}.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\nabstract contract ERC20Spendable is Context, IERC20Spendable {\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver,\\n   * and then the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this if you are not specifying any arguments.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   */\\n  function spend(address receiver_, uint256 spent_) public virtual {\\n    spend(receiver_, spent_, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver, and\\n   * the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this to specify a bytes argument.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   * @param arguments_ Bytes argument to send with the call. See {mock} contracts for details on encoding\\n   * and decoding arguments from bytes.\\n   */\\n  function spend(\\n    address receiver_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) public virtual {\\n    /**\\n     * @dev Transfer tokens to the receiver contract IF this is a non-0 amount. Don't try and transfer 0,\\n     * which leavesopen the possibility that the call is free. If not, the function call after will fail\\n     * and revert. Why would a {spend} method call ever be free? For example, a service provider may be\\n     * taking their ERC20 token as payment for a service. But they want to offer it for free, perhaps for a\\n     * limited time. Under this situation the spend callcan be used in all cases, but sending 0 token while\\n     * it is free, removing the need for different interfaces.\\n     *\\n     * We use the standard ERC20 public transfer method for the transfer, which means two things:\\n     * 1) This can only be called by the token owner (but that is the entire point!)\\n     * 2) We inherit all of the security checks in this method (e.g. owner has sufficient balance etc.)\\n     */\\n    if (spent_ != 0) {\\n      transfer(receiver_, spent_);\\n    }\\n\\n    /**\\n     * @dev Perform actions on the receiver and return arguments back up the callstack. In addition to allowing\\n     * the execution of the hook within the receiver, this call provides the same feature as onERC721Received\\n     * in the ERC721 standard.\\n     */\\n    if (receiver_.code.length > 0) {\\n      try\\n        IERC20SpendableReceiver(receiver_).onERC20SpendableReceived(\\n          _msgSender(),\\n          spent_,\\n          arguments_\\n        )\\n      returns (bytes4 retval, bytes memory returnedArguments) {\\n        if (\\n          retval != IERC20SpendableReceiver.onERC20SpendableReceived.selector\\n        ) {\\n          revert ERC20SpendableInvalidReveiver(receiver_);\\n        }\\n        emit SpendReceipt(\\n          _msgSender(),\\n          receiver_,\\n          spent_,\\n          arguments_,\\n          returnedArguments\\n        );\\n        /// @dev Handle returned values. Specify an override {_handleReceipt} method in your ERC20 contract if\\n        /// you wish to handle returned arguments.\\n        _handleReceipt(returnedArguments);\\n      } catch (bytes memory reason) {\\n        if (reason.length == 0) {\\n          revert ERC20SpendableInvalidReveiver(receiver_);\\n        } else {\\n          /// @solidity memory-safe-assembly\\n          assembly {\\n            revert(add(32, reason), mload(reason))\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev {_handleReceipt} Internal function called on completion of a call to {onERC20SpendableReceived}\\n   * on the {ERC20SpendableReceiver}.\\n   *\\n   * When making a token {ERC20Spendable} if you wish to process receipts you need to override\\n   * {_handleReceipt} in your contract. For an example, see {mock} contract {MockSpendableERC20ReturnedArgs}.\\n   *\\n   * @param returnedArguments_ Bytes argument to returned from the call. See {mock} contracts for details on\\n   * encoding and decoding arguments from bytes.\\n   */\\n  function _handleReceipt(bytes memory returnedArguments_) internal virtual {}\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}. This can be used to determine if an ERC20 is ERC20Spendable. For\\n   * example, a DEX may check this value, and make use of a single {spend} transaction (rather than the current\\n   * model of [approve -> pull]) if the ERC20Spendable interface is supported.\\n   *\\n   * @param interfaceId_ The bytes4 interface identifier being checked.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId_\\n  ) public view virtual returns (bool) {\\n    // The interface IDs are constants representing the first 4 bytes\\n    // of the XOR of all function selectors in the interface.\\n    // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n    // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n    return interfaceId_ == type(IERC20Spendable).interfaceId;\\n  }\\n\\n  /**\\n   * @dev override this in your implementation\\n   *\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address to, uint256 amount) public virtual returns (bool) {}\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/IERC20Spendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title ERC-7492 IERC20Spendable.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {IERC20Spendable} interface.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\n\\ninterface IERC20Spendable {\\n  /// @dev Error {ERC20SpendableInvalidReveiver} The called contract does not support ERC20Spendable.\\n  error ERC20SpendableInvalidReveiver(address receiver);\\n\\n  /// @dev Event {SpendReceipt} issued on successful return from the {ERC20SpendableReceiver} call.\\n  event SpendReceipt(\\n    address spender,\\n    address receiver,\\n    uint256 amount,\\n    bytes sentArguments,\\n    bytes returnedArguments\\n  );\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver,\\n   * and then the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this if you are not specifying any arguments.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   */\\n  function spend(address receiver_, uint256 spent_) external;\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver, and\\n   * the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this to specify a bytes argument.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   * @param arguments_ Bytes argument to send with the call. See {mock} contracts for details on encoding\\n   * and decoding arguments from bytes.\\n   */\\n  function spend(\\n    address receiver_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/IERC20SpendableReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title ERC-7492 IERC20SpendableReceiver.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {IERC20SpendableReceiver} interface.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\n\\ninterface IERC20SpendableReceiver {\\n  ///\u00a0@dev Error {CallMustBeFromSpendableToken}. The call to this method can only be from a designated spendable token.\\n  error CallMustBeFromSpendableToken();\\n\\n  /**\\n   * @dev {onERC20SpendableReceived} External function called by ERC20SpendableTokens. This\\n   * validates that the token is valid and then calls the internal {_handleSpend} method.\\n   * You must overried {_handleSpend} in your contract to perform processing you wish to occur\\n   * on token spend.\\n   *\\n   * This method will pass back the valid bytes4 selector and any bytes argument passed from\\n   * {_handleSpend}.\\n   *\\n   * @param spender_ The address spending the ERC20Spendable\\n   * @param spent_ The amount of token spent\\n   * @param arguments_ Bytes sent with the call\\n   */\\n  function onERC20SpendableReceived(\\n    address spender_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) external returns (bytes4 retval_, bytes memory returnArguments_);\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/Unicrypt/IUniswapV2Locker.sol\": {\r\n      \"content\": \"// Interface definition for UniswapV2Locker.sol\\n\\npragma solidity 0.8.19;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ninterface IERCBurn {\\n  function burn(uint256 _amount) external;\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n}\\n\\ninterface IMigrator {\\n  function migrate(\\n    address lpToken,\\n    uint256 amount,\\n    uint256 unlockDate,\\n    address owner\\n  ) external returns (bool);\\n}\\n\\ninterface IUniswapV2Locker {\\n  struct UserInfo {\\n    EnumerableSet.AddressSet lockedTokens; // records all tokens the user has locked\\n    mapping(address => uint256[]) locksForToken; // map erc20 address to lock id for that token\\n  }\\n\\n  struct TokenLock {\\n    uint256 lockDate; // the date the token was locked\\n    uint256 amount; // the amount of tokens still locked (initialAmount minus withdrawls)\\n    uint256 initialAmount; // the initial lock amount\\n    uint256 unlockDate; // the date the token can be withdrawn\\n    uint256 lockID; // lockID nonce per uni pair\\n    address owner;\\n  }\\n\\n  struct FeeStruct {\\n    uint256 ethFee; // Small eth fee to prevent spam on the platform\\n    IERCBurn secondaryFeeToken; // UNCX or UNCL\\n    uint256 secondaryTokenFee; // optional, UNCX or UNCL\\n    uint256 secondaryTokenDiscount; // discount on liquidity fee for burning secondaryToken\\n    uint256 liquidityFee; // fee on univ2 liquidity tokens\\n    uint256 referralPercent; // fee for referrals\\n    IERCBurn referralToken; // token the refferer must hold to qualify as a referrer\\n    uint256 referralHold; // balance the referrer must hold to qualify as a referrer\\n    uint256 referralDiscount; // discount on flatrate fees for using a valid referral address\\n  }\\n\\n  function setDev(address payable _devaddr) external;\\n\\n  /**\\n   * @notice set the migrator contract which allows locked lp tokens to be migrated to uniswap v3\\n   */\\n  function setMigrator(IMigrator _migrator) external;\\n\\n  function setSecondaryFeeToken(address _secondaryFeeToken) external;\\n\\n  /**\\n   * @notice referrers need to hold the specified token and hold amount to be elegible for referral fees\\n   */\\n  function setReferralTokenAndHold(\\n    IERCBurn _referralToken,\\n    uint256 _hold\\n  ) external;\\n\\n  function setFees(\\n    uint256 _referralPercent,\\n    uint256 _referralDiscount,\\n    uint256 _ethFee,\\n    uint256 _secondaryTokenFee,\\n    uint256 _secondaryTokenDiscount,\\n    uint256 _liquidityFee\\n  ) external;\\n\\n  /**\\n   * @notice whitelisted accounts dont pay flatrate fees on locking\\n   */\\n  function whitelistFeeAccount(address _user, bool _add) external;\\n\\n  /**\\n   * @notice Creates a new lock\\n   * @param _lpToken the univ2 token address\\n   * @param _amount amount of LP tokens to lock\\n   * @param _unlock_date the unix timestamp (in seconds) until unlock\\n   * @param _referral the referrer address if any or address(0) for none\\n   * @param _fee_in_eth fees can be paid in eth or in a secondary token such as UNCX with a discount on univ2 tokens\\n   * @param _withdrawer the user who can withdraw liquidity once the lock expires.\\n   */\\n  function lockLPToken(\\n    address _lpToken,\\n    uint256 _amount,\\n    uint256 _unlock_date,\\n    address payable _referral,\\n    bool _fee_in_eth,\\n    address payable _withdrawer\\n  ) external payable;\\n\\n  /**\\n   * @notice extend a lock with a new unlock date, _index and _lockID ensure the correct lock is changed\\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\\n   */\\n  function relock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _unlock_date\\n  ) external;\\n\\n  /**\\n   * @notice withdraw a specified amount from a lock. _index and _lockID ensure the correct lock is changed\\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\\n   */\\n  function withdraw(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  /**\\n   * @notice increase the amount of tokens per a specific lock, this is preferable to creating a new lock, less fees, and faster loading on our live block explorer\\n   */\\n  function incrementLock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  /**\\n   * @notice split a lock into two seperate locks, useful when a lock is about to expire and youd like to relock a portion\\n   * and withdraw a smaller portion\\n   */\\n  function splitLock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external payable;\\n\\n  /**\\n   * @notice transfer a lock to a new owner, e.g. presale project -> project owner\\n   */\\n  function transferLockOwnership(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    address payable _newOwner\\n  ) external;\\n\\n  /**\\n   * @notice migrates liquidity to uniswap v3\\n   */\\n  function migrate(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  function getNumLocksForToken(\\n    address _lpToken\\n  ) external view returns (uint256);\\n\\n  function getNumLockedTokens() external view returns (uint256);\\n\\n  function getLockedTokenAtIndex(\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  // user functions\\n  function getUserNumLockedTokens(\\n    address _user\\n  ) external view returns (uint256);\\n\\n  function getUserLockedTokenAtIndex(\\n    address _user,\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  function getUserNumLocksForToken(\\n    address _user,\\n    address _lpToken\\n  ) external view returns (uint256);\\n\\n  function getUserLockForTokenAtIndex(\\n    address _user,\\n    address _lpToken,\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256, uint256, uint256, uint256, uint256, address);\\n\\n  // whitelist\\n  function getWhitelistedUsersLength() external view returns (uint256);\\n\\n  function getWhitelistedUserAtIndex(\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  function getUserWhitelistStatus(address _user) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superAdmin_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"platformAdmins_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"platformTreasury_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metadropOracleAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unicryptLocker_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdapterParamsMustBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceDecreasedBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotOpen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"AuxCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorForRefundDuringAuction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorWhenReducingQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum IErrors.BondingCurveErrorType\",\"name\":\"error\",\"type\":\"uint8\"}],\"name\":\"BondingCurveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactoryOrProjectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotPlatformAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotSuperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheTaxAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerMustBeLzApp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewOwnerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewTaxAdminToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionAlreadyRevealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DecreasedAllowanceBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestinationIsNotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitIsTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectConfirmationValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialLiquidityAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdapterParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOracleSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayload\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSourceSendingContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LPLockUpMustFitUint96\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolMustBeAContractAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxBidQuantityIs255\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowance\",\"type\":\"uint256\"}],\"name\":\"MaxPublicMintAllowanceExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerTxnExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerWalletExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadataIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropFactoryOnlyOncePerReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropModulesOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropOracleCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinGasLimitNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingIsClosedForever\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewBuyTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewSellTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoETHForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPaymentDue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRefundForCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStoredMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokenForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTrustedPathRecord\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleSignatureHasExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersDoNotMatchSignedMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PassedConfigDoesNotMatchApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PauseCutOffHasPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentMustCoverPerMintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformTreasuryCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProjectOwnerCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProofInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsMaxPossibleCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingPhaseSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralIdAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previouslyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAllocation\",\"type\":\"uint256\"}],\"name\":\"RequestingMoreThanRemainingAllocation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltyFeeWillExceedSalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShareTotalCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SuperAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyTotalMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupportWindowIsNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxFreeAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxPeriodStillInForce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThisMintIsClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSharesMustMatchDenominator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognisedVRFMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VRFCoordinatorCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueExceedsMaximum\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metaId\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractInstance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"ERC20Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSuperAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSuperAdmin\",\"type\":\"address\"}],\"name\":\"SuperAdminTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaId_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"supplyParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct IERC20ConfigByMetadropV1.ERC20Config\",\"name\":\"erc20Config_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"messageTimeStamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deploymentFee_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer_\",\"type\":\"address\"}],\"name\":\"createConfigHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"configHash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaId_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"supplyParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct IERC20ConfigByMetadropV1.ERC20Config\",\"name\":\"erc20Config_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"messageTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct IConfigStructures.SignedDropMessageDetails\",\"name\":\"signedMessage_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lockerFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deploymentFee_\",\"type\":\"uint256\"}],\"name\":\"createERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPlatformAdmin_\",\"type\":\"address\"}],\"name\":\"grantPlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"queryAddress_\",\"type\":\"address\"}],\"name\":\"isPlatformAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"queryAddress_\",\"type\":\"address\"}],\"name\":\"isSuperAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadropOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldPlatformAdmin_\",\"type\":\"address\"}],\"name\":\"revokePlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"messageValidityInSeconds_\",\"type\":\"uint256\"}],\"name\":\"setMessageValidityInSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metadropOracleAddress_\",\"type\":\"address\"}],\"name\":\"setMetadropOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platformTreasury_\",\"type\":\"address\"}],\"name\":\"setPlatformTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSuperAdmin_\",\"type\":\"address\"}],\"name\":\"transferSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicryptLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20FactoryByMetadropV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada5600000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada56000000000000000000000000abcc7736c42713cd40ae8c2915c3b3dcdef6b83d0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000663a5c229c09b049e36dcc11a9b0d4a8eb9db2140000000000000000000000000000000000000000000000000000000000000004000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada56000000000000000000000000bf52436dbb09c97a301be66930392f61ee61c7b8000000000000000000000000e79f7a6af8d3bc37d30a172b2c9d2fd003af032b000000000000000000000000c0eba66b055aed2cc8e9e38f04e64501950cb470", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}