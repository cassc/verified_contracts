{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\"},\"SafeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\nimport \\\"IERC20.sol\\\";\\r\\n\\r\\nlibrary SafeTransfer {\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool s, ) = address(token).call(\\r\\n            abi.encodeWithSelector(\\r\\n                IERC20.transferFrom.selector,\\r\\n                from,\\r\\n                to,\\r\\n                value\\r\\n            )\\r\\n        );\\r\\n        require(s, \\\"safeTransferFrom failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool s, ) = address(token).call(\\r\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\r\\n        );\\r\\n        require(s, \\\"safeTransfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool s, ) = address(token).call(\\r\\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\\r\\n        );\\r\\n        require(s, \\\"safeApprove failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool s, ) = to.call{value: value}(new bytes(0));\\r\\n        require(s, \\\"safeTransferETH failed\\\");\\r\\n    }\\r\\n}\"},\"Sandwich.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\nimport \\\"IERC20.sol\\\";\\r\\nimport \\\"SafeTransfer.sol\\\";\\r\\n\\r\\ncontract Sandwich {\\r\\n    using SafeTransfer for IERC20;\\r\\n\\r\\n    // Authorized\\r\\n    address internal immutable user;\\r\\n    address private owner;\\r\\n    uint256 public maxWithdrawalAmount;\\r\\n\\r\\n\\r\\n\\r\\n    // Prevent reentrancy\\r\\n    bool private locked;\\r\\n\\r\\n    // transfer(address,uint256)\\r\\n    bytes4 internal constant ERC20_TRANSFER_ID = 0xa9059cbb;\\r\\n\\r\\n    // swap(uint256,uint256,address,bytes)\\r\\n    bytes4 internal constant PAIR_SWAP_ID = 0x022c0d9f;\\r\\n\\r\\n    modifier noReentrant() {\\r\\n        require(!locked, \\\"Reentrant call\\\");\\r\\n        locked = true;\\r\\n        _;\\r\\n        locked = false;\\r\\n    }\\r\\n\\r\\n    // Modifier to restrict functions to the contract owner\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Only owner can call this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Constructor sets the only owner and authorized user\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n        user = msg.sender;\\r\\n        maxWithdrawalAmount = 5 ether; // Example initial maximum withdrawal amount\\r\\n    }\\r\\n\\r\\n    // *** Receive profits from contract *** //\\r\\n    function recoverERC20(address token) public noReentrant onlyOwner {\\r\\n        IERC20(token).safeTransfer(\\r\\n            owner,\\r\\n            IERC20(token).balanceOf(address(this))\\r\\n        );\\r\\n    }\\r\\n\\r\\n \\r\\n     // Set the maximum withdrawal amount\\r\\n     function setMaxWithdrawalAmount(uint256 amount) public onlyOwner {\\r\\n    maxWithdrawalAmount = amount;\\r\\n      }\\r\\n\\r\\n\\r\\n    // Fallback function\\r\\n    fallback() external payable noReentrant onlyOwner {\\r\\n        // Assembly cannot read immutable variables\\r\\n        address memUser = user;\\r\\n\\r\\n        assembly {\\r\\n            // You can only access the fallback function if you\\u0027re authorized\\r\\n            if iszero(eq(caller(), memUser)) {\\r\\n                // Ohm (3, 3) makes your code more efficient\\r\\n                // WGMI\\r\\n                revert(3, 3)\\r\\n            }\\r\\n\\r\\n            // Extract out the variables\\r\\n            // We don\\u0027t have function signatures sweet saving EVEN MORE GAS\\r\\n\\r\\n            // bytes20\\r\\n            let token := shr(96, calldataload(0x00))\\r\\n            // bytes20\\r\\n            let pair := shr(96, calldataload(0x14))\\r\\n            // uint128\\r\\n            let amountIn := shr(128, calldataload(0x28))\\r\\n            // uint128\\r\\n            let amountOut := shr(128, calldataload(0x38))\\r\\n            // uint8\\r\\n            let tokenOutNo := shr(248, calldataload(0x48))\\r\\n\\r\\n            // **** calls token.transfer(pair, amountIn) ****\\r\\n\\r\\n            // transfer function signature\\r\\n            mstore(0x7c, ERC20_TRANSFER_ID)\\r\\n            // destination\\r\\n            mstore(0x80, pair)\\r\\n            // amount\\r\\n            mstore(0xa0, amountIn)\\r\\n\\r\\n            let s1 := call(sub(gas(), 5000), token, 0, 0x7c, 0x44, 0, 0)\\r\\n            if iszero(s1) {\\r\\n                // WGMI\\r\\n                revert(3, 3)\\r\\n            }\\r\\n\\r\\n            // ************\\r\\n            /* \\r\\n                calls pair.swap(\\r\\n                    tokenOutNo == 0 ? amountOut : 0,\\r\\n                    tokenOutNo == 1 ? amountOut : 0,\\r\\n                    address(this),\\r\\n                    new bytes(0)\\r\\n                )\\r\\n            */\\r\\n\\r\\n            // swap function signature\\r\\n            mstore(0x7c, PAIR_SWAP_ID)\\r\\n            // tokenOutNo == 0 ? ....\\r\\n            switch tokenOutNo\\r\\n            case 0 {\\r\\n                mstore(0x80, amountOut)\\r\\n                mstore(0xa0, 0)\\r\\n            }\\r\\n            case 1 {\\r\\n                mstore(0x80, 0)\\r\\n                mstore(0xa0, amountOut)\\r\\n            }\\r\\n            // address(this)\\r\\n            mstore(0xc0, address())\\r\\n            // empty bytes\\r\\n            mstore(0xe0, 0x80)\\r\\n\\r\\n            let s2 := call(sub(gas(), 5000), pair, 0, 0x7c, 0xa4, 0, 0)\\r\\n            if iszero(s2) {\\r\\n                revert(3, 3)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n  receive() external payable {\\r\\n        // The receive function allows the contract to accept incoming Ether.\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) external onlyOwner {\\r\\n        // The withdraw function allows the owner to withdraw a specified amount of Ether from the contract.\\r\\n        require(amount \\u003c= address(this).balance, \\\"Insufficient balance\\\");\\r\\n        payable(owner).transfer(amount);\\r\\n    }\\r\\n\\r\\n// Function to allow the owner to withdraw BNB\\r\\n    function withdrawBNB(uint256 amount) public onlyOwner {\\r\\n        require(amount \\u003e 0, \\\"Withdrawal amount must be greater than 0\\\");\\r\\n        require(address(this).balance \\u003e= amount, \\\"Insufficient balance in the contract\\\");\\r\\n\\r\\n        // Transfer BNB to the owner\\r\\n        payable(owner).transfer(amount);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"maxWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWithdrawalAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Sandwich", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://db2e7e781807f039e76391fd53079199e5c08f90a02f499a56e1a2a89244d7b6"}