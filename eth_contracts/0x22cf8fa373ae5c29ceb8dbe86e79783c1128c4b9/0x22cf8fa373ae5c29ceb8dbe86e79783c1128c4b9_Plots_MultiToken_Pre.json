{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract Plots_MultiToken_Presale {\r\n    using SafeERC20 for IERC20;\r\n    // Token Addresses\r\n    IERC20 public constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    \r\n    // Chainlink Price Feeds\r\n    address public constant USDTPriceFeed = 0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46;\r\n\r\n    // Admin Address\r\n    address public Admin;\r\n\r\n    // Merkle Root\r\n    bytes32 public MerkleRoot = 0xe0f30d64c14b738a082a9fde1e646e442e65b510eb2fc9600268915b382b017e;\r\n\r\n    // Params\r\n    uint256 public SaleStart;\r\n    uint256 public SaleEnd;\r\n    uint256 public PhaseOnePrice;\r\n    uint256 public PhaseTwoPrice;\r\n\r\n    uint256 public TotalRaised;\r\n    uint256 public SaleCap;\r\n    SalePhase public Phase;\r\n    address[] public Participants;\r\n    PurchaseHistory[] public SaleHistory;\r\n\r\n    mapping(address => uint256) public Allocation;\r\n    mapping(address => bool) public AllocationSet;\r\n    mapping(address => UserType) public RegisteredAs;\r\n    mapping(address => uint256) public PlotsToReceive;\r\n\r\n    enum SalePhase { AwaitingStart, Registered, Public, Over } \r\n\r\n    enum UserType { TwentyFiveFDV, FifteenFDV }\r\n\r\n    struct PurchaseHistory{\r\n        address user;\r\n        UserType RegisterationTier;\r\n        uint256 timestamp;\r\n        uint256 USDequivalent;\r\n    }\r\n\r\n    modifier OnlyAdmin() {\r\n        require(msg.sender == Admin, \"Only Admin\");\r\n        _;\r\n    }\r\n\r\n    modifier ActiveSaleOnly() {\r\n        require(GetSaleStatus() == SalePhase(1) || GetSaleStatus() == SalePhase(2) , \"Sale is not active\");\r\n        _;\r\n    }\r\n\r\n    event TokensPurchased(address indexed buyer, uint256 amount, string token);\r\n    event ProceedsSentToTreasury(uint256 usdtAmount, uint256 usdcAmount, uint256 ethAmount);\r\n    event SaleParamsSet(uint256 saleStart, uint256 saleEnd, uint256 phaseOnePrice, uint256 phaseTwoPrice, uint256 phaseOneCap);\r\n\r\n    constructor()  {\r\n        SaleStart = 1717743600;\r\n        SaleEnd = SaleStart + 259200;\r\n        PhaseOnePrice = 15000000000000000;\r\n        PhaseTwoPrice = 25000000000000000;\r\n        Phase = SalePhase(0);\r\n        \r\n        SaleCap = 1500000000000;\r\n        Admin = 0xA5Fe44F89706dbd9526D38771E2a9E215350Fe92;\r\n\r\n        emit SaleParamsSet(SaleStart, SaleEnd, PhaseOnePrice, PhaseOnePrice, PhaseTwoPrice);\r\n    }\r\n\r\n    // Purchase Functions\r\n    function PurchaseWithETH(UserType UserRegistration, uint256 UserPoints, bytes32[] memory Proof) public ActiveSaleOnly payable {\r\n        if (UserRegistration == UserType.TwentyFiveFDV && GetSaleStatus() == SalePhase(1)) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(msg.sender))), \"Invalid credentials\");\r\n        } else if (UserRegistration == UserType.FifteenFDV) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(StringUtils.concatenate(msg.sender, UserPoints)))), \"Invalid credentials\");\r\n        }\r\n\r\n        if (PlotsToReceive[msg.sender] == 0){\r\n            Participants.push(msg.sender);\r\n        }\r\n\r\n        if (!AllocationSet[msg.sender] && UserRegistration == UserType.FifteenFDV) {\r\n            SetAllocationInUSD(UserPoints);\r\n            AllocationSet[msg.sender] = true;\r\n            RegisteredAs[msg.sender] = UserType(1);\r\n        }else if(!AllocationSet[msg.sender]){\r\n            RegisteredAs[msg.sender] = UserType(0);\r\n            SetAllocationInUSD(50000);\r\n        }else{\r\n            require(RegisteredAs[msg.sender] == UserRegistration);\r\n        }\r\n\r\n        uint256 PlotstoReceive = ConvertEthToPlots(msg.value, UserRegistration);\r\n        uint256 StableEquivalent = ConvertEthToStable(msg.value);\r\n        require(StableEquivalent >= 50000000, \"Invalid amount\");\r\n        require(TotalRaised + StableEquivalent <= SaleCap, \"Sale cap reached\");\r\n\r\n        require(Allocation[msg.sender] >= StableEquivalent, \"Invalid allocation\");\r\n        Allocation[msg.sender] -= StableEquivalent;\r\n\r\n        TotalRaised += StableEquivalent;\r\n        PlotsToReceive[msg.sender] += PlotstoReceive;\r\n\r\n        SaleHistory.push(PurchaseHistory(msg.sender, UserRegistration, block.timestamp, StableEquivalent));\r\n        emit TokensPurchased(msg.sender, PlotstoReceive, \"ETH\");\r\n    }\r\n\r\n    function PurchaseWithUSDT(uint256 amount, UserType UserRegistration, uint256 UserPoints, bytes32[] memory Proof) public ActiveSaleOnly {\r\n        require(amount >= 50000000, \"Invalid amount\");\r\n        require(TotalRaised + amount <= SaleCap, \"Sale cap reached\");\r\n        if (UserRegistration == UserType.TwentyFiveFDV && GetSaleStatus() == SalePhase(1)) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(msg.sender))), \"Invalid credentials\");\r\n        } else if (UserRegistration == UserType.FifteenFDV) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(StringUtils.concatenate(msg.sender, UserPoints)))), \"Invalid credentials\");\r\n        }\r\n\r\n        if (PlotsToReceive[msg.sender] == 0){\r\n            Participants.push(msg.sender);\r\n        }\r\n\r\n        if (!AllocationSet[msg.sender] && UserRegistration == UserType.FifteenFDV) {\r\n            SetAllocationInUSD(UserPoints);\r\n            AllocationSet[msg.sender] = true;\r\n            RegisteredAs[msg.sender] = UserType(1);\r\n        }else if(!AllocationSet[msg.sender]){\r\n            RegisteredAs[msg.sender] = UserType(0);\r\n            SetAllocationInUSD(50000);\r\n        }else{\r\n            require(RegisteredAs[msg.sender] == UserRegistration);\r\n        }\r\n\r\n        uint256 PlotstoReceive = ConvertStableToPlots(amount, UserRegistration);\r\n        require(Allocation[msg.sender] >= amount, \"Invalid allocation\");\r\n        Allocation[msg.sender] -= amount;\r\n        \r\n        USDT.safeTransferFrom(msg.sender, address(this), amount);\r\n        TotalRaised += amount;\r\n        PlotsToReceive[msg.sender] += PlotstoReceive;\r\n\r\n        SaleHistory.push(PurchaseHistory(msg.sender, UserRegistration, block.timestamp, amount));\r\n        emit TokensPurchased(msg.sender, PlotstoReceive, \"USDT\");\r\n    }\r\n\r\n    function PurchaseWithUSDC(uint256 amount, UserType UserRegistration, uint256 UserPoints, bytes32[] memory Proof) public ActiveSaleOnly {\r\n        require(amount >= 50000000, \"Invalid amount\");\r\n        require(TotalRaised + amount <= SaleCap, \"Sale cap reached\");\r\n        if (UserRegistration == UserType.TwentyFiveFDV && GetSaleStatus() == SalePhase(1)) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(msg.sender))), \"Invalid credentials\");\r\n        } else if (UserRegistration == UserType.FifteenFDV) {\r\n            require(VerifyCredentials(Proof, keccak256(abi.encodePacked(StringUtils.concatenate(msg.sender, UserPoints)))), \"Invalid credentials\");\r\n        }\r\n\r\n        if (PlotsToReceive[msg.sender] == 0){\r\n            Participants.push(msg.sender);\r\n        }\r\n\r\n        if (!AllocationSet[msg.sender] && UserRegistration == UserType.FifteenFDV) {\r\n            SetAllocationInUSD(UserPoints);\r\n            AllocationSet[msg.sender] = true;\r\n            RegisteredAs[msg.sender] = UserType(1);\r\n        }else if(!AllocationSet[msg.sender]){\r\n            RegisteredAs[msg.sender] = UserType(0);\r\n            SetAllocationInUSD(50000);\r\n        }else{\r\n            require(RegisteredAs[msg.sender] == UserRegistration);\r\n        }\r\n\r\n        uint256 PlotstoReceive = ConvertStableToPlots(amount, UserRegistration);\r\n        require(Allocation[msg.sender] >= amount, \"Invalid allocation\");\r\n        Allocation[msg.sender] -= amount;\r\n        \r\n        USDC.safeTransferFrom(msg.sender, address(this), amount); \r\n        TotalRaised += amount;\r\n        PlotsToReceive[msg.sender] += PlotstoReceive;\r\n\r\n        SaleHistory.push(PurchaseHistory(msg.sender, UserRegistration, block.timestamp, amount));\r\n        emit TokensPurchased(msg.sender, PlotstoReceive, \"USDC\");\r\n    }\r\n\r\n    function SetAllocationInUSD(uint256 allocation) internal {\r\n        Allocation[msg.sender] = allocation * 10**6 / 2;\r\n    }\r\n\r\n    // Utility Functions\r\n\r\n    function ConvertEthToStable(uint256 amountIn) public view returns (uint256) {\r\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(USDTPriceFeed);\r\n        (, int256 priceusdt, , , ) = priceFeed.latestRoundData();\r\n        uint256 uintprice = uint256(priceusdt);\r\n        uint256 amountInWei = amountIn * 10**6;\r\n        uint256 usdAmount = (amountInWei) / uintprice;\r\n        return usdAmount;\r\n    }\r\n\r\n    function ConvertStableToPlots(uint256 amountIn, UserType rate) public view returns (uint256) {\r\n        if (rate == UserType.TwentyFiveFDV) {\r\n            return (amountIn * 10**30) / PhaseTwoPrice;\r\n        } else {\r\n            return (amountIn * 10**30) / PhaseOnePrice;\r\n        }\r\n    }\r\n\r\n    function ConvertEthToPlots(uint256 amountIn, UserType rate) public view returns (uint256) {\r\n        uint256 StableEquivalent = ConvertEthToStable(amountIn);\r\n        return ConvertStableToPlots(StableEquivalent, rate);\r\n    }    \r\n\r\n    function VerifySaleEligibility(UserType UserRegistration, uint256 UserPoints, address UserAddress, bytes32[] memory proof) public view returns (bool) {\r\n        if (UserRegistration == UserType.TwentyFiveFDV) {\r\n            return VerifyCredentials(proof, keccak256(abi.encodePacked(UserAddress)));\r\n        } else if (UserRegistration == UserType.FifteenFDV) {\r\n            return VerifyCredentials(proof, keccak256(abi.encodePacked(StringUtils.concatenate(UserAddress, UserPoints))));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function VerifyCredentials(bytes32[] memory proof, bytes32 leaf) public view returns (bool) {\r\n        return verify(proof, MerkleRoot, leaf);\r\n    }\r\n\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        return computedHash == root;\r\n    }\r\n\r\n    function ChangeSaleEnd(uint256 _SaleEnd) public OnlyAdmin {\r\n        SaleEnd = _SaleEnd;\r\n    }\r\n\r\n    function SendProceedsToTreasury() public OnlyAdmin {\r\n        uint256 usdtBalance = USDT.balanceOf(address(this));\r\n        uint256 usdcBalance = USDC.balanceOf(address(this));\r\n        uint256 ethBalance = address(this).balance;\r\n\r\n        USDT.safeTransfer(Admin, usdtBalance);\r\n        USDC.safeTransfer(Admin, usdcBalance);\r\n        payable(Admin).transfer(ethBalance);\r\n\r\n        emit ProceedsSentToTreasury(usdtBalance, usdcBalance, ethBalance);\r\n    }\r\n\r\n    function GetSaleStatus() public view returns (SalePhase Status) {\r\n        if (block.timestamp >= SaleStart && block.timestamp <= SaleEnd && TotalRaised < SaleCap) {\r\n            if(SaleStart + 43200 >= block.timestamp){\r\n                return SalePhase(1);\r\n            }\r\n            else{\r\n                return SalePhase(2);\r\n            }\r\n        } else if(SaleEnd <= block.timestamp){\r\n            return SalePhase(3);\r\n        } else if(SaleStart >= block.timestamp){\r\n            return SalePhase(0);\r\n        }\r\n    }\r\n\r\n    function LatestSaleIndex() public view returns(uint256 index){\r\n        return(SaleHistory.length - 1);\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    uint256 public tokenCap;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    address private operator;\r\n    address private ZeroAddress;\r\n    //variable Declarations\r\n    \r\n      \r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event BurnEvent(address indexed burner, uint256 indexed buramount);\r\n    event ManageMinterEvent(address indexed newminter);\r\n    //Event Declarations \r\n    \r\n    mapping(address => uint256) balances;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    \r\n    mapping(address => bool) minter;\r\n    \r\n    constructor(uint256 _TokenCap, string memory _name, string memory _symbol){\r\n        tokenCap = _TokenCap;\r\n        totalSupply = 0;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = 18;\r\n        operator = msg.sender;\r\n    }\r\n    \r\n    \r\n    function balanceOf(address Address) public view returns (uint256 balance){\r\n        return balances[Address];\r\n    }\r\n\r\n    function approve(address delegate, uint _amount) public returns (bool) {\r\n        allowance[msg.sender][delegate] = _amount;\r\n        emit Approval(msg.sender, delegate, _amount);\r\n        return true;\r\n    }\r\n    //Approves an address to spend your coins\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[_from]);    \r\n        require(_amount <= allowance[_from][msg.sender]); \r\n    \r\n        balances[_from] = balances[_from]-(_amount);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    //Transfer From an other address\r\n\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function Mint(address _MintTo, uint256 _MintAmount) public {\r\n        require (minter[msg.sender] == true);\r\n        require (totalSupply+(_MintAmount) <= tokenCap);\r\n        balances[_MintTo] = balances[_MintTo]+(_MintAmount);\r\n        totalSupply = totalSupply+(_MintAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(ZeroAddress ,_MintTo, _MintAmount);\r\n    }\r\n    //Mints tokens to your address \r\n\r\n\r\n    function Burn(uint256 _BurnAmount) public {\r\n        require (balances[msg.sender] >= _BurnAmount);\r\n        balances[msg.sender] = balances[msg.sender]-(_BurnAmount);\r\n        totalSupply = totalSupply-(_BurnAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(msg.sender, ZeroAddress, _BurnAmount);\r\n        emit BurnEvent(msg.sender, _BurnAmount);\r\n        \r\n    }\r\n\r\n    function ManageMinter(bool IsMinter, address _address) public returns(address){\r\n        require (msg.sender == operator);\r\n\r\n        minter[_address] = IsMinter;\r\n\r\n        emit ManageMinterEvent(_address);\r\n        return (_address);\r\n    }\r\n\r\n\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\nlibrary StringUtils {\r\n    // Convert address to string\r\n    function addressToString(address _addr) internal pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(uint160(_addr)));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2 + i * 2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    // Convert uint256 to string\r\n    function uintToString(uint256 _value) internal pure returns (string memory) {\r\n        if (_value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = _value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (_value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(_value % 10)));\r\n            _value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    // Function to concatenate address and points\r\n    function concatenate(address _addr, uint256 _points) internal pure returns (string memory) {\r\n        string memory addrStr = addressToString(_addr);\r\n        string memory pointsStr = uintToString(_points);\r\n        return string(abi.encodePacked(addrStr, pointsStr));\r\n    }\r\n}\r\n\r\n\r\n//Merkle Verification Libraries\r\nlibrary Hashes {\r\n    /**\r\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\r\n     *\r\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n     */\r\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\r\n        return a < b ? _efficientKeccak256(a, b) : _efficientKeccak256(b, a);\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\r\n     */\r\n    function _efficientKeccak256(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MerkleProof {\r\n    /**\r\n     *@dev The multiproof provided is not valid.\r\n     */\r\n    error MerkleProofInvalidMultiproof();\r\n\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the Merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        if (leavesLen + proofLen != totalHashes + 1) {\r\n            revert MerkleProofInvalidMultiproof();\r\n        }\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            if (proofPos != proofLen) {\r\n                revert MerkleProofInvalidMultiproof();\r\n            }\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the Merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        if (leavesLen + proofLen != totalHashes + 1) {\r\n            revert MerkleProofInvalidMultiproof();\r\n        }\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            if (proofPos != proofLen) {\r\n                revert MerkleProofInvalidMultiproof();\r\n            }\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"ProceedsSentToTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"phaseOnePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"phaseTwoPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"phaseOneCap\",\"type\":\"uint256\"}],\"name\":\"SaleParamsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Allocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AllocationSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_SaleEnd\",\"type\":\"uint256\"}],\"name\":\"ChangeSaleEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"ConvertEthToPlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"ConvertEthToStable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"ConvertStableToPlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetSaleStatus\",\"outputs\":[{\"internalType\":\"enum Plots_MultiToken_Presale.SalePhase\",\"name\":\"Status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LatestSaleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Participants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Phase\",\"outputs\":[{\"internalType\":\"enum Plots_MultiToken_Presale.SalePhase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PhaseOnePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PhaseTwoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PlotsToReceive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"UserRegistration\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"UserPoints\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"}],\"name\":\"PurchaseWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"UserRegistration\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"UserPoints\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"}],\"name\":\"PurchaseWithUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"UserRegistration\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"UserPoints\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"}],\"name\":\"PurchaseWithUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RegisteredAs\",\"outputs\":[{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SaleCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SaleEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SaleHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"RegisterationTier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDequivalent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SaleStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SendProceedsToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"VerifyCredentials\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Plots_MultiToken_Presale.UserType\",\"name\":\"UserRegistration\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"UserPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"VerifySaleEligibility\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Plots_MultiToken_Presale", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ab5beb1b6efa497cda90f3f2789955739d877dec25c78a1c54fa853fd5985fea"}