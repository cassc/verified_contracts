{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/N.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.21;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ninterface IdexFactory {\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface In {\\r\\n    //events\\r\\n    event SwapThresholdChange(uint threshold);\\r\\n    event OverLiquifiedThresholdChange(uint threshold);\\r\\n    event OnSetTaxes(\\r\\n        uint buy,\\r\\n        uint sell,\\r\\n        uint transfer_\\r\\n    );\\r\\n    event ManualSwapChange(bool status);\\r\\n    event MaxWalletBalanceUpdated(uint256 percent);\\r\\n    event MaxTransactionAmountUpdated(uint256 percent);\\r\\n    event ExcludeAccount(address indexed account, bool indexed exclude);\\r\\n    event ExcludeFromWalletLimits(\\r\\n        address indexed account,\\r\\n        bool indexed exclude\\r\\n    );\\r\\n    event ExcludeFromTransactionLimits(\\r\\n        address indexed account,\\r\\n        bool indexed exclude\\r\\n    );\\r\\n    event OwnerSwap();\\r\\n    event OnEnableTrading();\\r\\n    event RecoverETH();\\r\\n    event NewPairSet(address indexed Pair, bool indexed Add);\\r\\n    event LimitTo20PercentLP();\\r\\n    event NewRouterSet(address indexed _newdex);\\r\\n    event NewFeeWalletSet(\\r\\n        address indexed taxwallet\\r\\n    );\\r\\n    event RecoverTokens(uint256 indexed amount);\\r\\n    event TokensAirdroped(\\r\\n        address indexed sender,\\r\\n        uint256 indexed total,\\r\\n        uint256 indexed amount\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IdexRouter {\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n}\\r\\n\\r\\ncontract N is IERC20, Ownable, In {\\r\\n    mapping(address => uint) private _balances;\\r\\n    mapping(address => mapping(address => uint)) private _allowances;\\r\\n    mapping(address => bool) private excludedFromWalletLimits;\\r\\n    mapping(address => bool) private excludedFromTransactionLimits;\\r\\n    mapping(address => bool) public excludedFromFees;\\r\\n    mapping(address => bool) public isPair;\\r\\n\\r\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\r\\n    bytes32 public constant AUTHENTICATOR_ROLE =\\r\\n        keccak256(\\\"AUTHENTICATOR_ROLE\\\");\\r\\n\\r\\n    //strings\\r\\n    string private constant _name = \\\"nsurance\\\";\\r\\n    string private constant _symbol = \\\"n\\\";\\r\\n\\r\\n    //uints\\r\\n    uint private constant InitialSupply = 1_000_000_000_000 * 10 ** _decimals;\\r\\n\\r\\n    //Tax by divisor of MAXTAXDENOMINATOR\\r\\n    uint public buyTax = 400;\\r\\n    uint public sellTax = 400;\\r\\n    uint public transferTax = 400;\\r\\n\\r\\n    uint constant taxPct = 10000;\\r\\n    uint constant TAX_DENOMINATOR = 10000;\\r\\n    uint constant MAXTAXDENOMINATOR = 1000;\\r\\n    //swapTreshold dynamic by LP pair balance\\r\\n    uint public swapTreshold = 8;\\r\\n    uint private LaunchBlock;\\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public maxWalletBalance;\\r\\n\\r\\n    IdexRouter private _dexRouter;\\r\\n\\r\\n    //addresses\\r\\n    address private dexRouter;\\r\\n    address private _dexPairAddress;\\r\\n    address constant deadWallet = 0x000000000000000000000000000000000000dEaD;\\r\\n    address private taxWallet;\\r\\n    address private deployer;\\r\\n\\r\\n    //bools\\r\\n    bool private _isSwappingContractModifier;\\r\\n    bool public manualSwap;\\r\\n\\r\\n    //modifiers\\r\\n    modifier lockTheSwap() {\\r\\n        _isSwappingContractModifier = true;\\r\\n        _;\\r\\n        _isSwappingContractModifier = false;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _DexRouter,\\r\\n        address _taxWallet\\r\\n    ) {\\r\\n        deployer = msg.sender;\\r\\n        taxWallet = _taxWallet;\\r\\n        dexRouter = _DexRouter;\\r\\n\\r\\n        _balances[msg.sender] = InitialSupply;\\r\\n        emit Transfer(address(0), msg.sender, InitialSupply);\\r\\n\\r\\n        // Setting exclusions\\r\\n        SetExclusions(\\r\\n            [\\r\\n                msg.sender,\\r\\n                dexRouter,\\r\\n                address(this)\\r\\n            ],\\r\\n            [\\r\\n                msg.sender,\\r\\n                deadWallet,\\r\\n                address(this)\\r\\n            ],\\r\\n            [\\r\\n                msg.sender,\\r\\n                deadWallet,\\r\\n                address(this)\\r\\n            ]\\r\\n        );\\r\\n    }\\r\\n    /**\\r\\n     * @notice Set Exclusions\\r\\n     * @dev This function is for set exclusions.\\r\\n     * @param feeExclusions The array of address to be excluded from fees.\\r\\n     * @param walletLimitExclusions The array of address to be excluded from wallet limits.\\r\\n     * @param transactionLimitExclusions The array of address to be excluded from transaction limits.\\r\\n     */\\r\\n    function SetExclusions(\\r\\n        address[3] memory feeExclusions,\\r\\n        address[3] memory walletLimitExclusions,\\r\\n        address[3] memory transactionLimitExclusions\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i < feeExclusions.length; ++i) {\\r\\n            excludedFromFees[feeExclusions[i]] = true;\\r\\n        }\\r\\n        for (uint256 i = 0; i < walletLimitExclusions.length; ++i) {\\r\\n            excludedFromWalletLimits[walletLimitExclusions[i]] = true;\\r\\n        }\\r\\n        for (uint256 i = 0; i < transactionLimitExclusions.length; ++i) {\\r\\n            excludedFromTransactionLimits[transactionLimitExclusions[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to transfer tokens from one address to another.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) internal {\\r\\n        require(sender != address(0), \\\"Transfer from zero\\\");\\r\\n        require(recipient != address(0), \\\"Transfer to zero\\\");\\r\\n\\r\\n        if (excludedFromFees[sender] || excludedFromFees[recipient])\\r\\n            _feelessTransfer(sender, recipient, amount);\\r\\n        else {\\r\\n            require(LaunchBlock > 0, \\\"trading not yet enabled\\\");\\r\\n            _taxedTransfer(sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer amount of tokens with fees.\\r\\n     * @param sender The address of user to send tokens.\\r\\n     * @param recipient The address of user to be recieved tokens.\\r\\n     * @param amount The token amount to transfer.\\r\\n     */\\r\\n    function _taxedTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) internal {\\r\\n        uint senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"Transfer exceeds balance\\\");\\r\\n        bool excludedFromWalletLimitsAccount = excludedFromWalletLimits[\\r\\n            sender\\r\\n        ] || excludedFromWalletLimits[recipient];\\r\\n        bool excludedFromTXNLimitsAccount = excludedFromTransactionLimits[\\r\\n            sender\\r\\n        ] || excludedFromTransactionLimits[recipient];\\r\\n        if (isPair[sender] && !excludedFromWalletLimitsAccount) {\\r\\n            if (!excludedFromTXNLimitsAccount) {\\r\\n                require(\\r\\n                    amount <= maxTransactionAmount,\\r\\n                    \\\"Transfer amount exceeds the maxTxAmount.\\\"\\r\\n                );\\r\\n            }\\r\\n            uint256 contractBalanceRecepient = balanceOf(recipient);\\r\\n            require(\\r\\n                contractBalanceRecepient + amount <= maxWalletBalance,\\r\\n                \\\"Exceeds maximum wallet token amount.\\\"\\r\\n            );\\r\\n        } else if (isPair[recipient] && !excludedFromTXNLimitsAccount) {\\r\\n            require(\\r\\n                amount <= maxTransactionAmount,\\r\\n                \\\"Sell transfer amount exceeds the maxSellTransactionAmount.\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        bool isBuy = isPair[sender];\\r\\n        bool isSell = isPair[recipient];\\r\\n        uint tax;\\r\\n\\r\\n        if (isSell) {\\r\\n            tax = sellTax;\\r\\n        } else if (isBuy) {\\r\\n            tax = buyTax;\\r\\n        } else if(!isBuy && !isSell) { \\r\\n            tax = transferTax; \\r\\n        } else {\\r\\n            uint256 contractBalanceRecepient = balanceOf(recipient);\\r\\n            if (!excludedFromWalletLimitsAccount) {\\r\\n                require(\\r\\n                    contractBalanceRecepient + amount <= maxWalletBalance,\\r\\n                    \\\"Exceeds maximum wallet token amount.\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            (sender != _dexPairAddress) &&\\r\\n            (!manualSwap) &&\\r\\n            (!_isSwappingContractModifier)\\r\\n        ) _swapContractToken(false);\\r\\n        uint contractToken = _calculateFee(\\r\\n            amount,\\r\\n            tax,\\r\\n            taxPct\\r\\n        );\\r\\n        uint taxedAmount = amount - contractToken;\\r\\n\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[address(this)] += contractToken;\\r\\n        _balances[recipient] += taxedAmount;\\r\\n\\r\\n        emit Transfer(sender, recipient, taxedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates fee based of set amounts\\r\\n     * @param amount The amount to calculate fee on\\r\\n     * @param tax The tax to calculate fee with\\r\\n     * @param taxPercent The tax percent to calculate fee with\\r\\n     */\\r\\n    function _calculateFee(\\r\\n        uint amount,\\r\\n        uint tax,\\r\\n        uint taxPercent\\r\\n    ) internal pure returns (uint) {\\r\\n        return\\r\\n            (amount * tax * taxPercent) / (TAX_DENOMINATOR * TAX_DENOMINATOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer amount of tokens without fees.\\r\\n     * @dev In feelessTransfer, there isn't limit as well.\\r\\n     * @param sender The address of user to send tokens.\\r\\n     * @param recipient The address of user to be recieveid tokens.\\r\\n     * @param amount The token amount to transfer.\\r\\n     */\\r\\n    function _feelessTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) internal {\\r\\n        uint senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"Transfer exceeds balance\\\");\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Swap tokens for eth.\\r\\n     * @dev This function is for swap tokens for eth.\\r\\n     * @param newSwapTresholdPermille Set the swap % of LP pair holdings.\\r\\n     */\\r\\n    function setSwapTreshold(\\r\\n        uint newSwapTresholdPermille\\r\\n    ) external onlyOwner {\\r\\n        require(newSwapTresholdPermille <= 10); //MaxTreshold= 1%\\r\\n        swapTreshold = newSwapTresholdPermille;\\r\\n        emit SwapThresholdChange(newSwapTresholdPermille);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the current taxes.\\r\\n     * @notice buy must be less than MAXTAXDENOMINATOR.\\r\\n     * @notice sell must be less than MAXTAXDENOMINATOR.\\r\\n     * @notice transfer_ must be less than MAXTAXDENOMINATOR.\\r\\n     * @dev This function is for set the current taxes.\\r\\n     * @param buy The buy tax.\\r\\n     * @param sell The sell tax.\\r\\n     * @param transfer_ The transfer tax.\\r\\n     */\\r\\n    function SetTaxes(\\r\\n        uint buy,\\r\\n        uint sell,\\r\\n        uint transfer_\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            buy <= MAXTAXDENOMINATOR &&\\r\\n                sell <= MAXTAXDENOMINATOR &&\\r\\n                transfer_ <= MAXTAXDENOMINATOR,\\r\\n            \\\"Tax exceeds maxTax\\\"\\r\\n        );\\r\\n\\r\\n        buyTax = buy;\\r\\n        sellTax = sell;\\r\\n        transferTax = transfer_;\\r\\n        emit OnSetTaxes(buy, sell, transfer_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps contract tokens based on various parameters.\\r\\n     * @param ignoreLimits Whether to ignore the token swap limits.\\r\\n     */\\r\\n    function _swapContractToken(bool ignoreLimits) internal lockTheSwap {\\r\\n        uint contractBalance = _balances[address(this)];\\r\\n        uint totalTax = taxPct;\\r\\n        uint tokensToSwap = (_balances[_dexPairAddress] * swapTreshold) / 1000;\\r\\n\\r\\n        if (totalTax == 0) return;\\r\\n\\r\\n        if (ignoreLimits) {\\r\\n            tokensToSwap = _balances[address(this)];\\r\\n        } else if (contractBalance < tokensToSwap) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        _swapTokenForETH(tokensToSwap);\\r\\n\\r\\n        if (tokensToSwap != 0) {\\r\\n            (bool sent, ) = taxWallet.call{value: address(this).balance}(\\\"\\\");\\r\\n            require(sent, \\\"Failed to send ETH to Insurance wallet\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Swap tokens for eth.\\r\\n     * @dev This function is for swap tokens for eth.\\r\\n     * @param amount The token amount to swap.\\r\\n     */\\r\\n    function _swapTokenForETH(uint amount) private {\\r\\n        _approve(address(this), address(_dexRouter), amount);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _dexRouter.WETH();\\r\\n\\r\\n        try\\r\\n            _dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                amount,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )\\r\\n        {} catch {}\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add initial liquidity to dex.\\r\\n     * @dev This function is for add liquidity to dex.\\r\\n     */\\r\\n    function _addInitLiquidity() private {\\r\\n        uint tokenAmount = balanceOf(address(this));\\r\\n        _approve(address(this), address(_dexRouter), tokenAmount);\\r\\n        _dexRouter.addLiquidityETH{value: address(this).balance}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            0,\\r\\n            deployer,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get Burned tokens.\\r\\n     * @dev This function is for get burned tokens.\\r\\n     */\\r\\n    function getBurnedTokens() public view returns (uint) {\\r\\n        return _balances[address(0xdead)];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get circulating supply.\\r\\n     * @dev This function is for get circulating supply.\\r\\n     */\\r\\n    function getCirculatingSupply() public view returns (uint) {\\r\\n        return InitialSupply - _balances[address(0xdead)];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the current Pair.\\r\\n     * @dev This function is for set the current Pair.\\r\\n     * @param Pair The pair address.\\r\\n     * @param Add The status of add or remove.\\r\\n     */\\r\\n    function SetPair(address Pair, bool Add) internal {\\r\\n        require(Pair != _dexPairAddress, \\\"can't readd pair\\\");\\r\\n        require(Pair != address(0), \\\"Address should not be 0\\\");\\r\\n        isPair[Pair] = Add;\\r\\n        emit NewPairSet(Pair, Add);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a pair.\\r\\n     * @dev This function is for add a pair.\\r\\n     * @param Pair The pair address.\\r\\n     */\\r\\n    function AddPair(address Pair) external onlyOwner {\\r\\n        SetPair(Pair, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a pair.\\r\\n     * @dev This function is for add a pair.\\r\\n     * @param Pair The pair address.\\r\\n     */\\r\\n    function RemovePair(address Pair) external onlyOwner {\\r\\n        SetPair(Pair, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set Manual Swap Mode\\r\\n     * @dev This function is for set manual swap mode.\\r\\n     * @param manual The status of manual swap mode.\\r\\n     */\\r\\n    function SwitchManualSwap(bool manual) external onlyOwner {\\r\\n        manualSwap = manual;\\r\\n        emit ManualSwapChange(manual);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Swap contract tokens.\\r\\n     * @dev This function is for swap contract tokens.\\r\\n     * @param all The status of swap all tokens in contract.\\r\\n     */\\r\\n    function SwapContractToken(bool all) external onlyOwner {\\r\\n        _swapContractToken(all);\\r\\n        emit OwnerSwap();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set a new router address\\r\\n     * @dev This function is for set a new router address.\\r\\n     * @param _newdex The new router address.\\r\\n     */\\r\\n    function SetNewRouter(address _newdex) external onlyOwner {\\r\\n        require(_newdex != address(0), \\\"Address should not be 0\\\");\\r\\n        require(_newdex != dexRouter, \\\"Address is same\\\");\\r\\n        dexRouter = _newdex;\\r\\n        emit NewRouterSet(_newdex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set new tax receiver wallet.\\r\\n     * @dev This function is for set new tax receiver wallet.\\r\\n     * @param NewTaxWallet The new tax wallet address.\\r\\n     */\\r\\n    function SetFeeWallets(\\r\\n        address NewTaxWallet\\r\\n    ) external onlyOwner {\\r\\n        require(NewTaxWallet != address(0), \\\"Address should not be 0\\\");\\r\\n\\r\\n        taxWallet = NewTaxWallet;\\r\\n        emit NewFeeWalletSet(NewTaxWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set Wallet Limits\\r\\n     * @dev This function is for set wallet limits.\\r\\n     * @param walPct The max wallet balance percent.\\r\\n     * @param txnPct The max transaction amount percent.\\r\\n     */\\r\\n    function SetLimits(\\r\\n        uint256 walPct,\\r\\n        uint256 txnPct\\r\\n    ) external onlyOwner {\\r\\n        require(walPct >= 10, \\\"min 0.1%\\\");\\r\\n        require(walPct <= 10000, \\\"max 100%\\\");\\r\\n        maxWalletBalance = (InitialSupply * walPct) / 10000;\\r\\n        emit MaxWalletBalanceUpdated(walPct);\\r\\n\\r\\n        require(txnPct >= 10, \\\"min 0.1%\\\");\\r\\n        require(txnPct <= 10000, \\\"max 100%\\\");\\r\\n        maxTransactionAmount = (InitialSupply * txnPct) / 10000;\\r\\n        emit MaxTransactionAmountUpdated(txnPct);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice AirDrop Tokens\\r\\n     * @dev This function is for airdrop tokens.\\r\\n     * @param accounts The array of address to be airdroped.\\r\\n     * @param amounts The array of amount to be airdroped.\\r\\n     */\\r\\n    function Airdropper(\\r\\n        address[] calldata accounts,\\r\\n        uint256[] calldata amounts\\r\\n    ) external onlyOwner {\\r\\n        uint256 length = accounts.length;\\r\\n        require(length == amounts.length, \\\"array length mismatched\\\");\\r\\n        uint256 airdropAmount = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            // updating balance directly instead of calling transfer to save gas\\r\\n            _balances[accounts[i]] += amounts[i];\\r\\n            airdropAmount += amounts[i];\\r\\n            emit Transfer(msg.sender, accounts[i], amounts[i]);\\r\\n        }\\r\\n        _balances[msg.sender] -= airdropAmount;\\r\\n\\r\\n        emit TokensAirdroped(msg.sender, length, airdropAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set to exclude an address from fees.\\r\\n     * @dev This function is for set to exclude an address from fees.\\r\\n     * @param account The address of user to be excluded from fees.\\r\\n     * @param exclude The status of exclude.\\r\\n     */\\r\\n    function ExcludeAccountFromFees(\\r\\n        address account,\\r\\n        bool exclude\\r\\n    ) external onlyOwner {\\r\\n        require(account != address(this), \\\"can't Include the contract\\\");\\r\\n        require(account != address(0), \\\"Address should not be 0\\\");\\r\\n        excludedFromFees[account] = exclude;\\r\\n        emit ExcludeAccount(account, exclude);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set to exclude an address from transaction limits.\\r\\n     * @dev This function is for set to exclude an address from transaction limits.\\r\\n     * @param account The address of user to be excluded from transaction limits.\\r\\n     * @param exclude The status of exclude.\\r\\n     */\\r\\n    function SetExcludedAccountFromTransactionLimits(\\r\\n        address account,\\r\\n        bool exclude\\r\\n    ) external onlyOwner {\\r\\n        require(account != address(0), \\\"Address should not be 0\\\");\\r\\n        excludedFromTransactionLimits[account] = exclude;\\r\\n        emit ExcludeFromTransactionLimits(account, exclude);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set to exclude an address from wallet limits.\\r\\n     * @dev This function is for set to exclude an address from wallet limits.\\r\\n     * @param account The address of user to be excluded from wallet limits.\\r\\n     * @param exclude The status of exclude.\\r\\n     */\\r\\n    function SetExcludedAccountFromWalletLimits(\\r\\n        address account,\\r\\n        bool exclude\\r\\n    ) external onlyOwner {\\r\\n        require(account != address(0), \\\"Address should not be 0\\\");\\r\\n        excludedFromWalletLimits[account] = exclude;\\r\\n        emit ExcludeFromWalletLimits(account, exclude);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to start trading.\\r\\n     * @dev This function is for used to start trading.\\r\\n     */\\r\\n    function SetupEnableTrading() external onlyOwner {\\r\\n        require(LaunchBlock == 0, \\\"AlreadyLaunched\\\");\\r\\n\\r\\n        _dexRouter = IdexRouter(dexRouter);\\r\\n        _dexPairAddress = IdexFactory(_dexRouter.factory()).createPair(\\r\\n            address(this),\\r\\n            _dexRouter.WETH()\\r\\n        );\\r\\n        isPair[_dexPairAddress] = true;\\r\\n\\r\\n        _addInitLiquidity();\\r\\n\\r\\n        LaunchBlock = block.number;\\r\\n\\r\\n        maxWalletBalance = (InitialSupply * 12) / 10000; // 0.12%\\r\\n        maxTransactionAmount = (InitialSupply * 12) / 10000; // 0.12%\\r\\n        emit OnEnableTrading();\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external pure override returns (uint) {\\r\\n        return InitialSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function isExcludedFromWalletLimits(\\r\\n        address account\\r\\n    ) public view returns (bool) {\\r\\n        return excludedFromWalletLimits[account];\\r\\n    }\\r\\n\\r\\n    function isExcludedFromTransferLimits(\\r\\n        address account\\r\\n    ) public view returns (bool) {\\r\\n        return excludedFromTransactionLimits[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address spender\\r\\n    ) external view override returns (uint) {\\r\\n        return _allowances[_owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint amount\\r\\n    ) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address _owner, address spender, uint amount) private {\\r\\n        require(_owner != address(0), \\\"Approve from zero\\\");\\r\\n        require(spender != address(0), \\\"Approve to zero\\\");\\r\\n        _allowances[_owner][spender] = amount;\\r\\n        emit Approval(_owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint currentAllowance = _allowances[sender][msg.sender];\\r\\n        require(currentAllowance >= amount, \\\"Transfer > allowance\\\");\\r\\n        _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint addedValue\\r\\n    ) external returns (bool) {\\r\\n        _approve(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowances[msg.sender][spender] + addedValue\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint subtractedValue\\r\\n    ) external returns (bool) {\\r\\n        uint currentAllowance = _allowances[msg.sender][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"<0 allowance\\\");\\r\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to remove excess ETH from contract\\r\\n     * @dev This function is for used to remove excess ETH from contract.\\r\\n     * @param amountPercentage The amount percentage to recover.\\r\\n     */\\r\\n    function emergencyETHrecovery(\\r\\n        uint256 amountPercentage\\r\\n    ) external onlyOwner {\\r\\n        uint256 amountETH = address(this).balance;\\r\\n        (bool sent, ) = msg.sender.call{\\r\\n            value: (amountETH * amountPercentage) / 100\\r\\n        }(\\\"\\\");\\r\\n        sent = true;\\r\\n        emit RecoverETH();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to remove excess Tokens from contract\\r\\n     * @dev This function is for used to remove excess Tokens from contract.\\r\\n     * @param tokenAddress The token address to recover.\\r\\n     * @param amountPercentage The amount percentage to recover.\\r\\n     */\\r\\n    function emergencyTokenrecovery(\\r\\n        address tokenAddress,\\r\\n        uint256 amountPercentage\\r\\n    ) external onlyOwner {\\r\\n        require(tokenAddress != address(0));\\r\\n        require(tokenAddress != address(_dexPairAddress));\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        uint256 tokenAmount = token.balanceOf(address(this));\\r\\n        token.transfer(msg.sender, (tokenAmount * amountPercentage) / 100);\\r\\n\\r\\n        emit RecoverTokens(tokenAmount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DexRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_taxWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeFromTransactionLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeFromWalletLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LimitTo20PercentLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ManualSwapChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"MaxWalletBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taxwallet\",\"type\":\"address\"}],\"name\":\"NewFeeWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"NewPairSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newdex\",\"type\":\"address\"}],\"name\":\"NewRouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"}],\"name\":\"OnSetTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"OverLiquifiedThresholdChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RecoverETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"SwapThresholdChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensAirdroped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTHENTICATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Pair\",\"type\":\"address\"}],\"name\":\"AddPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"Airdropper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Pair\",\"type\":\"address\"}],\"name\":\"RemovePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"SetExcludedAccountFromTransactionLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"SetExcludedAccountFromWalletLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NewTaxWallet\",\"type\":\"address\"}],\"name\":\"SetFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walPct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txnPct\",\"type\":\"uint256\"}],\"name\":\"SetLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newdex\",\"type\":\"address\"}],\"name\":\"SetNewRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"all\",\"type\":\"bool\"}],\"name\":\"SwapContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"SwitchManualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"emergencyETHrecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"emergencyTokenrecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromTransferLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromWalletLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"setSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "N", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000a576463273e4a459b39a518be7fc79ebecf6b7c7", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}