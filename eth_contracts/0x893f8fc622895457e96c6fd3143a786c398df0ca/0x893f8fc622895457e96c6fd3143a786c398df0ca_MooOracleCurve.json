{"SourceCode": "// SPDX-License-Identifier: -- WISE --\r\n\r\npragma solidity =0.8.21;\r\n\r\n/**\r\n * @author Christoph Krpoun\r\n * @author Ren\u00e9 Hochmuth\r\n * @author Vitally Marinchenko\r\n */\r\n\r\n/**\r\n * @dev Purpose of this contract is to give safe on-chian price feeds\r\n * for noo tokens which consists out of curve Lp tokens. It can be used\r\n * for normal and meta curve pools as long as the underlying token of\r\n * the curve pool have a chainLink price feed.\r\n *\r\n * Normale curve pools have a fixed number of underlying tokens in contrast\r\n * to meta pools which are a combination of a token plus a curve LP token\r\n * (e.g MIM + 3Crv).\r\n * The price feed contract can separate between both types automatically during\r\n * deployment (by setting {_metaTokenLength} equal to zero).\r\n *\r\n * Additionally, this contracts has a security check against price manipulation\r\n * by crosschecking possible swap outcomes of all permutaions of the underlying\r\n * assets. This results in higher gas costs for these kind of price feeds\r\n * and scales with n!/[(n-2)!2!] where n is the overall underlying token number\r\n * of the moo token.\r\n *\r\n * ATTENTION: THESE PRICE FEEDS ARE ONLY SAVE YOU A RE-ENTRANCY GUARD TRANSACTION\r\n * IS PERFORMED BEFORE CALL (E.G. TINY SWAP FOR USED CURVE POOL UPDATING VARIABLES!)\r\n */\r\n\r\nerror NotMaster();\r\nerror NotProposed();\r\n\r\ncontract OwnableMaster {\r\n\r\n    address public master;\r\n    address public proposedMaster;\r\n\r\n    address constant ZERO_ADDRESS = address(0x0);\r\n\r\n    modifier onlyProposed() {\r\n        _onlyProposed();\r\n        _;\r\n    }\r\n\r\n    function _onlyMaster()\r\n        private\r\n        view\r\n    {\r\n        if (msg.sender == master) {\r\n            return;\r\n        }\r\n\r\n        revert NotMaster();\r\n    }\r\n\r\n    modifier onlyMaster() {\r\n        _onlyMaster();\r\n        _;\r\n    }\r\n\r\n    function _onlyProposed()\r\n        private\r\n        view\r\n    {\r\n        if (msg.sender == proposedMaster) {\r\n            return;\r\n        }\r\n\r\n        revert NotProposed();\r\n    }\r\n\r\n    constructor(\r\n        address _master\r\n    ) {\r\n        master = _master;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to propose next master.\r\n     * Must be claimed by proposer.\r\n     */\r\n    function proposeOwner(\r\n        address _proposedOwner\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        proposedMaster = _proposedOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to claim master role.\r\n     * Must be called by proposer.\r\n     */\r\n    function claimOwnership()\r\n        external\r\n        onlyProposed\r\n    {\r\n        master = proposedMaster;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes master role.\r\n     * No ability to be in control.\r\n     */\r\n    function renounceOwnership()\r\n        external\r\n        onlyMaster\r\n    {\r\n        master = ZERO_ADDRESS;\r\n        proposedMaster = ZERO_ADDRESS;\r\n    }\r\n}\r\n\r\ninterface IWiseOracleHub {\r\n\r\n    function latestResolver(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTokensFromUSD(\r\n        address _tokenAddress,\r\n        uint256 _usdValue\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTokensInUSD(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function chainLinkIsDead(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function decimalsUSD()\r\n        external\r\n        pure\r\n        returns (uint8);\r\n\r\n    function previousValue(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function setPreviousValue(\r\n        address _tokenAddress\r\n    )\r\n        external;\r\n\r\n    function addOracle(\r\n        address _tokenAddress,\r\n        address _priceFeedAddress,\r\n        address[] memory _underlyingFeedTokens\r\n    )\r\n        external;\r\n\r\n    function recalibrate(\r\n        address _tokenAddress\r\n    )\r\n        external;\r\n\r\n    function recalibratePreview(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IMooTokenVault {\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 _shares\r\n    )\r\n        external;\r\n\r\n    function getPricePerFullShare()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n\r\n    function depositAll()\r\n        external;\r\n}\r\n\r\ninterface IPriceFeed {\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n\r\n    function description()\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function version()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRoundData(\r\n        uint80 _roundId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestAnswer()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function phaseId()\r\n        external\r\n        view\r\n        returns(\r\n            uint16 phaseId\r\n        );\r\n\r\n    function aggregator()\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ninterface ICurve {\r\n\r\n    function add_liquidity(\r\n        address _pool,\r\n        uint256[4] memory _depositAmounts,\r\n        uint256 _minOutAmount\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address _userAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function get_dy(\r\n        uint256 i,\r\n        uint256 j,\r\n        uint256 dx\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchange(\r\n        int128 fromIndex,\r\n        int128 toIndex,\r\n        uint256 exactAmountFrom,\r\n        uint256 minReceiveAmount\r\n    )\r\n        external;\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    )\r\n        external;\r\n\r\n    function remove_liquidity(\r\n        address _pool,\r\n        uint256 _burnAmount,\r\n        uint256[4] memory coins\r\n    )\r\n        external;\r\n\r\n    function remove_liquidity_one_coin(\r\n        address _addy,\r\n        uint256 _burnAmount,\r\n        int128 _i,\r\n        uint256 _minReceived\r\n    )\r\n        external;\r\n\r\n    function coins(\r\n        uint256 arg0\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balances(\r\n        uint256 arg0\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    event  Deposit(\r\n        address indexed dst,\r\n        uint wad\r\n    );\r\n\r\n    event  Withdrawal(\r\n        address indexed src,\r\n        uint wad\r\n    );\r\n}\r\n\r\nerror IsManipulated(\r\n    uint256 difference,\r\n    uint256 tolerance\r\n);\r\n\r\ncontract MooOracleCurve is OwnableMaster {\r\n\r\n    // ---- Variables ----\r\n\r\n    // Number of first layer tokens\r\n    uint8 immutable public tokenLength;\r\n\r\n    // Moo token decimals\r\n    uint8 immutable public mooDecimals;\r\n\r\n    // USD value decimals from oracleHub.\r\n    uint8 immutable public targetDecimalsUSD;\r\n\r\n    // Number of second layer tokens\r\n    uint8 immutable public metaTokenLength;\r\n\r\n    // Curve Lp token decimals\r\n    uint256 immutable public curveDecimals;\r\n\r\n    // Allowed deviation for manipulation check in USD\r\n    uint256 public deviationTolerance;\r\n\r\n    // Valued to chech if curve lp is manipulated. Related to make liqudation still profitale\r\n    uint256 public priceRefValueUsd = 50000E18;\r\n\r\n    // Curve pool contract address\r\n    address immutable public curvePoolAddress;\r\n\r\n    // Curve Lp token address\r\n    address immutable public curveTokenAddress;\r\n\r\n    // Curve second layer Lp token address (e.g Crv pool for MimCrv token)\r\n    address immutable public curveSecondLayerTokenAddress;\r\n\r\n    // Curve second layer pool contract address (e.g Crv pool for MimCrv token)\r\n    address immutable public curveSecondLayerPoolAddress;\r\n\r\n    // Array for all underlying token of the correspoding LP token\r\n    address[] public virtualTokenAddresses;\r\n\r\n    // Decimals of price feed\r\n    uint8 constant _decimals = 8;\r\n\r\n    // Number of all posible permutations\r\n    uint8 public permutationCount;\r\n\r\n    // Difference between targetDecimalsUSD and _decimals\r\n    uint8 immutable decimalDifference;\r\n\r\n\r\n    // ---- Interfaces ----\r\n\r\n    // Curve Lp token interface\r\n    ICurve immutable CURVE_TOKEN;\r\n\r\n    // Curve pool interface\r\n    ICurve immutable CURVE_POOL;\r\n\r\n    // Curve second layer pool interface\r\n    ICurve immutable CURVE_2_LAYER_POOL;\r\n\r\n    // Curve second layer Lp token interface\r\n    ICurve immutable CURVE_2_LAYER_TOKEN;\r\n\r\n    // Moo vault interface\r\n    IMooTokenVault immutable public MOO;\r\n\r\n    // WISE oracleHub interface\r\n    IWiseOracleHub immutable public ORACLE_HUB;\r\n\r\n\r\n    // ---- Mappings ----\r\n\r\n    // Mapping to save all pair combinations of all virtuall token addresses\r\n    mapping (uint8 => uint8[]) permutations;\r\n\r\n    // Mapping to save all first layer tokens\r\n    mapping (uint8 => address) curveCoins;\r\n\r\n    // Mapping to save all second layer tokens\r\n    mapping (uint8 => address) curveSecondLayerCoins;\r\n\r\n\r\n    // ---- Constants ----\r\n\r\n    // Precision factor for computations\r\n    uint256 constant PRECISION_FACTOR_E18 = 1 ether;\r\n\r\n    // Onchain address to identify ETH\r\n    address constant CURVE_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    // ---- Structures ----\r\n\r\n    // Struct for passing constructor arguments\r\n    struct CurveInterfaces {\r\n        ICurve curvePool;\r\n        ICurve curveLPToken;\r\n        ICurve curveSecondLayerPool;\r\n        ICurve curveSecondLayerToken;\r\n    }\r\n\r\n    // ---- Modifier ----\r\n\r\n    modifier checkRelativePrices() {\r\n        _checkRelativePrices();\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        CurveInterfaces memory _curveInterfaces,\r\n        IMooTokenVault _Moo,\r\n        address[] memory _virtualTokenAdd,\r\n        uint256 _deviationTolerance,\r\n        uint8 _tokenLength,\r\n        uint8 _metaTokenLength,\r\n        address _oracleHubAddress\r\n    )\r\n        OwnableMaster(\r\n            msg.sender\r\n        )\r\n    {\r\n        tokenLength = _tokenLength;\r\n        metaTokenLength = _metaTokenLength;\r\n        deviationTolerance = _deviationTolerance;\r\n        virtualTokenAddresses = _virtualTokenAdd;\r\n\r\n        ORACLE_HUB = IWiseOracleHub(\r\n            _oracleHubAddress\r\n        );\r\n\r\n        _setPermutations(\r\n            virtualTokenAddresses.length\r\n        );\r\n\r\n        MOO = _Moo;\r\n\r\n        CURVE_TOKEN = _curveInterfaces.curveLPToken;\r\n        CURVE_POOL = _curveInterfaces.curvePool;\r\n        CURVE_2_LAYER_POOL = _curveInterfaces.curveSecondLayerPool;\r\n        CURVE_2_LAYER_TOKEN = _curveInterfaces.curveSecondLayerToken;\r\n\r\n        mooDecimals = MOO.decimals();\r\n        curveDecimals = CURVE_TOKEN.decimals();\r\n        targetDecimalsUSD = ORACLE_HUB.decimalsUSD();\r\n\r\n        decimalDifference = targetDecimalsUSD - _decimals;\r\n\r\n        curveTokenAddress = address(\r\n            CURVE_TOKEN\r\n        );\r\n\r\n        curvePoolAddress = address(\r\n            CURVE_POOL\r\n        );\r\n\r\n        curveSecondLayerPoolAddress = address(\r\n            CURVE_2_LAYER_POOL\r\n        );\r\n\r\n        curveSecondLayerTokenAddress = address(\r\n            CURVE_2_LAYER_TOKEN\r\n        );\r\n\r\n        for (uint8 i = 0; i < tokenLength; ++i) {\r\n            curveCoins[i] = CURVE_POOL.coins(i);\r\n        }\r\n\r\n        for (uint8 i = 0; i < metaTokenLength; ++i) {\r\n            curveSecondLayerCoins[i] = CURVE_2_LAYER_POOL.coins(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Read function returning decimals of\r\n     * derivative moo token oracle.\r\n     */\r\n    function decimals()\r\n        external\r\n        pure\r\n        returns (uint8)\r\n    {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Read function returning moo token latest USD\r\n     * value. Sums up all token balances of the underlying\r\n     * curve LP token and corverts each summand into a\r\n     * USD value using {getTokensInUSD} from WISE oracleHub.\r\n     * Relates this sum to {totalSupply} of the curve LP token.\r\n     * Afterwards sets the USD amount per LP token in realtion to\r\n     * Moo token using {getPricePerFullShare}.\r\n     */\r\n    function latestAnswer()\r\n        public\r\n        view\r\n        checkRelativePrices()\r\n        returns (uint256)\r\n    {\r\n        return _calculateMooTokenValue(\r\n            _calculateCurveLPValue(\r\n                _assetSumUSD8Decimals()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Read function returning the latest round data\r\n     * wrapped inside latestRoundData selector. For latest\r\n     * implementation of oracleHub since it uses\r\n     * {latestRoundData} to get latest answer. {latestAnswer}\r\n     * itself is [deprecated] (see chainLink).\r\n     */\r\n    function latestRoundData()\r\n        public\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        return (\r\n            roundId,\r\n            int256(latestAnswer()),\r\n            startedAt,\r\n            updatedAt,\r\n            answeredInRound\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Changes values related to low liquidity check\r\n     * in case curve gets hacked so users are not locked\r\n    */\r\n    function changeLowLiquidityCheckVariables(\r\n        uint256 _newPriceRefValueUsd,\r\n        uint256 _newDeviationTolerance\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        priceRefValueUsd = _newPriceRefValueUsd;\r\n        deviationTolerance = _newDeviationTolerance;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function summing up the USD value\r\n     * of all second layer assets from a curve meta\r\n     * pool.\r\n     */\r\n    function _secondLayerAssetSumUSD8Decimals()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetSumUSD8Decimals;\r\n\r\n        for (uint8 i = 0; i < metaTokenLength; ++i) {\r\n\r\n            address token = curveSecondLayerCoins[i];\r\n\r\n            uint256 balance = token == CURVE_ETH_ADDRESS\r\n                ? curveSecondLayerPoolAddress.balance\r\n                : CURVE_2_LAYER_POOL.balances(i);\r\n\r\n            assetSumUSD8Decimals += ORACLE_HUB.getTokensInUSD(\r\n                token,\r\n                balance\r\n            ) / 10 ** decimalDifference;\r\n        }\r\n\r\n        assetSumUSD8Decimals = assetSumUSD8Decimals\r\n            * CURVE_2_LAYER_TOKEN.balanceOf(curvePoolAddress)\r\n            / CURVE_2_LAYER_TOKEN.totalSupply();\r\n\r\n        return assetSumUSD8Decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function summing up the USD value\r\n     * of all assets inside a curve pool.\r\n     */\r\n    function _assetSumUSD8Decimals()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetSumUSD8Decimals;\r\n\r\n        for (uint8 i = 0; i < tokenLength; ++i) {\r\n\r\n            address token = curveCoins[i];\r\n\r\n            if (token == curveSecondLayerTokenAddress) {\r\n                assetSumUSD8Decimals += _secondLayerAssetSumUSD8Decimals();\r\n                continue;\r\n            }\r\n\r\n            uint256 balance = token == CURVE_ETH_ADDRESS\r\n                ? curvePoolAddress.balance\r\n                : CURVE_POOL.balances(i);\r\n\r\n            assetSumUSD8Decimals += ORACLE_HUB.getTokensInUSD(\r\n                token,\r\n                balance\r\n            ) / 10 ** decimalDifference;\r\n        }\r\n\r\n        return assetSumUSD8Decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function relating the\r\n     * {_curveLPValue} to the price per full\r\n     * share.\r\n     */\r\n    function _calculateMooTokenValue(\r\n        uint256 _curveLPValue\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return MOO.getPricePerFullShare()\r\n            * _curveLPValue\r\n            / (10 ** mooDecimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function used for security\r\n     * checks against price manipulation. Depending\r\n     * on curve pool type it checks posibler swaps\r\n     * result from underlying curve pool tokens\r\n     * to use the result for later price deviation\r\n     * checks.\r\n     */\r\n    function _getReceiveAmountCurve(\r\n        bool _metapool,\r\n        uint256 _from,\r\n        uint256 _to,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_metapool) {\r\n            return CURVE_POOL.get_dy_underlying(\r\n                int128(uint128(_from)),\r\n                int128(uint128(_to)),\r\n                _tokenAmount\r\n            );\r\n        }\r\n\r\n        return CURVE_POOL.get_dy(\r\n            _from,\r\n            _to,\r\n            _tokenAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function used for security\r\n     * checks against price manipulation. Checks\r\n     * swap outcomes for all possible pair\r\n     * permutations of the underlying curve pool\r\n     * tokens and relates the result to a predefined\r\n     * threshold for the price feed.\r\n     */\r\n    function _checkRelativePrices()\r\n        private\r\n        view\r\n    {\r\n        for (uint8 i = 0; i < permutationCount; ++i) {\r\n\r\n            uint8 currentCombinationFrom = permutations[i][0];\r\n            uint8 currentCombinationTo = permutations[i][1];\r\n\r\n            uint256 tokenAmount =  ORACLE_HUB.getTokensFromUSD(\r\n                virtualTokenAddresses[currentCombinationFrom],\r\n                priceRefValueUsd\r\n            );\r\n\r\n            uint256 receiveAmount = _getReceiveAmountCurve(\r\n                curveSecondLayerPoolAddress > ZERO_ADDRESS,\r\n                currentCombinationFrom,\r\n                currentCombinationTo,\r\n                tokenAmount\r\n            );\r\n\r\n            uint256 usdAmount = ORACLE_HUB.getTokensInUSD(\r\n                virtualTokenAddresses[currentCombinationTo],\r\n                receiveAmount\r\n            );\r\n\r\n            _checkIfManipulated(\r\n                usdAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function comparing\r\n     * USD amount with prefedined\r\n     * {deviationTolerance}.\r\n     */\r\n    function _checkIfManipulated(\r\n        uint256 _usdAmount\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        uint256 difference = _usdAmount > priceRefValueUsd\r\n            ? _usdAmount - priceRefValueUsd\r\n            : priceRefValueUsd - _usdAmount;\r\n\r\n        if (difference > deviationTolerance) {\r\n            revert IsManipulated(\r\n                difference,\r\n                deviationTolerance\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function calculating USD\r\n     * price per curve LP token.\r\n     */\r\n    function _calculateCurveLPValue(\r\n        uint256 _assetSum\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _assetSum\r\n            * 10 ** curveDecimals\r\n            / CURVE_TOKEN.totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal combinatorical function\r\n     * setting all possible pairs (a,b) of an\r\n     * underlying set X. Cardinallity of this\r\n     * power set P(X) goes with the binomial\r\n     * coefficient n!/[(n-2)!2!] where n is\r\n     * the cardinallity of X.\r\n     */\r\n    function _setPermutations(\r\n        uint256 _count\r\n    )\r\n        internal\r\n    {\r\n        uint8[2] memory buffer;\r\n\r\n        uint256 len = _count - 1;\r\n        uint8 mapCount;\r\n        uint8 j;\r\n        uint8 k;\r\n\r\n        for (j = 0; j < len; j++) {\r\n\r\n            for (k = j + 1; k <= len; k++) {\r\n\r\n                buffer[0] = j;\r\n                buffer[1] = k;\r\n\r\n                permutations[mapCount] = buffer;\r\n                mapCount += 1;\r\n            }\r\n        }\r\n\r\n        permutationCount = mapCount;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract ICurve\",\"name\":\"curvePool\",\"type\":\"address\"},{\"internalType\":\"contract ICurve\",\"name\":\"curveLPToken\",\"type\":\"address\"},{\"internalType\":\"contract ICurve\",\"name\":\"curveSecondLayerPool\",\"type\":\"address\"},{\"internalType\":\"contract ICurve\",\"name\":\"curveSecondLayerToken\",\"type\":\"address\"}],\"internalType\":\"struct MooOracleCurve.CurveInterfaces\",\"name\":\"_curveInterfaces\",\"type\":\"tuple\"},{\"internalType\":\"contract IMooTokenVault\",\"name\":\"_Moo\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_virtualTokenAdd\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_deviationTolerance\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_tokenLength\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_metaTokenLength\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_oracleHubAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerance\",\"type\":\"uint256\"}],\"name\":\"IsManipulated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MOO\",\"outputs\":[{\"internalType\":\"contract IMooTokenVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE_HUB\",\"outputs\":[{\"internalType\":\"contract IWiseOracleHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPriceRefValueUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDeviationTolerance\",\"type\":\"uint256\"}],\"name\":\"changeLowLiquidityCheckVariables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveSecondLayerPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveSecondLayerTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationTolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaTokenLength\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mooDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permutationCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceRefValueUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetDecimalsUSD\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLength\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"virtualTokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MooOracleCurve", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d51a44d3fae010294c616388b506acda1bfaae46000000000000000000000000c4ad29ba4b3c580e6d59105fff484999997675ff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e50e2fe90745a8510491f89113959a1ef01ad400000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000001043561a882930000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d2caa748b66768ac9c53a5443225bdf1365dd4b60000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dc62a83e8ae37eb366ee07a7b8e9ca5bf396b699788738499cdcaff2f1e39cff"}