{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/exchangeV2/Delegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { ERC721 } from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport { ERC1155 } from \\\"lib/solmate/src/tokens/ERC1155.sol\\\";\\nimport { ERC20 } from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\n\\nimport \\\"./lib/Constants.sol\\\";\\nimport { AssetType, OrderType, Transfer } from \\\"./lib/Structs.sol\\\";\\n\\ncontract Delegate {\\n    error Unauthorized();\\n    error InvalidLength();\\n\\n    address private immutable _EXCHANGE;\\n\\n    constructor(address exchange) {\\n        _EXCHANGE = exchange;\\n    }\\n\\n    modifier onlyApproved() {\\n        if (msg.sender != _EXCHANGE) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    function transfer(\\n        address taker,\\n        OrderType orderType,\\n        Transfer[] calldata transfers,\\n        uint256 length\\n    ) external onlyApproved returns (bool[] memory successful) {\\n        if (transfers.length < length) {\\n            revert InvalidLength();\\n        }\\n        successful = new bool[](length);\\n\\n        for (uint256 i; i < length; ) {\\n            assembly {\\n                let calldataPointer := mload(0x40)\\n                let transfersPointer := add(transfers.offset, mul(Transfer_size, i))\\n\\n                let assetType := calldataload(add(transfersPointer, Transfer_assetType_offset))\\n                switch assetType\\n                case 0 {\\n                    // AssetType_ERC721\\n                    mstore(calldataPointer, ERC721_safeTransferFrom_selector)\\n                    switch orderType\\n                    case 0 {\\n                        // OrderType_ASK; taker is recipient\\n                        mstore(add(calldataPointer, ERC721_safeTransferFrom_to_offset), taker)\\n                        mstore(\\n                            add(calldataPointer, ERC721_safeTransferFrom_from_offset),\\n                            calldataload(add(transfersPointer, Transfer_trader_offset))\\n                        )\\n                    }\\n                    case 1 {\\n                        // OrderType_BID; taker is sender\\n                        mstore(add(calldataPointer, ERC721_safeTransferFrom_from_offset), taker)\\n                        mstore(\\n                            add(calldataPointer, ERC721_safeTransferFrom_to_offset),\\n                            calldataload(add(transfersPointer, Transfer_trader_offset))\\n                        )\\n                    }\\n                    default {\\n                        revert(0, 0)\\n                    }\\n\\n                    mstore(\\n                        add(calldataPointer, ERC721_safeTransferFrom_id_offset),\\n                        calldataload(add(transfersPointer, Transfer_id_offset))\\n                    )\\n                    let collection := calldataload(\\n                        add(transfersPointer, Transfer_collection_offset)\\n                    )\\n                    let success := call(\\n                        gas(),\\n                        collection,\\n                        0,\\n                        calldataPointer,\\n                        ERC721_safeTransferFrom_size,\\n                        0,\\n                        0\\n                    )\\n                    mstore(add(add(successful, 0x20), mul(0x20, i)), success)\\n                }\\n                case 1 {\\n                    // AssetType_ERC1155\\n                    mstore(calldataPointer, ERC1155_safeTransferFrom_selector)\\n                    switch orderType\\n                    case 0 {\\n                        // OrderType_ASK; taker is recipient\\n                        mstore(\\n                            add(calldataPointer, ERC1155_safeTransferFrom_from_offset),\\n                            calldataload(\\n                                add(\\n                                    transfersPointer,\\n                                    Transfer_trader_offset\\n                                )\\n                            )\\n                        )\\n                        mstore(add(calldataPointer, ERC1155_safeTransferFrom_to_offset), taker)\\n                    }\\n                    case 1 {\\n                        // OrderType_BID; taker is sender\\n                        mstore(\\n                            add(calldataPointer, ERC1155_safeTransferFrom_to_offset),\\n                            calldataload(\\n                                add(\\n                                    transfersPointer,\\n                                    Transfer_trader_offset\\n                                )\\n                            )\\n                        )\\n                        mstore(add(calldataPointer, ERC1155_safeTransferFrom_from_offset), taker)\\n                    }\\n                    default {\\n                        revert(0, 0)\\n                    }\\n\\n                    mstore(add(calldataPointer, ERC1155_safeTransferFrom_data_pointer_offset), 0xa0)\\n                    mstore(add(calldataPointer, ERC1155_safeTransferFrom_data_offset), 0)\\n                    mstore(\\n                        add(calldataPointer, ERC1155_safeTransferFrom_id_offset),\\n                        calldataload(\\n                            add(transfersPointer, Transfer_id_offset)\\n                        )\\n                    )\\n                    mstore(\\n                        add(calldataPointer, ERC1155_safeTransferFrom_amount_offset),\\n                        calldataload(\\n                            add(\\n                                transfersPointer,\\n                                Transfer_amount_offset\\n                            )\\n                        )\\n                    )\\n                    let collection := calldataload(\\n                        add(\\n                            transfersPointer,\\n                            Transfer_collection_offset\\n                        )\\n                    )\\n                    let success := call(\\n                        gas(),\\n                        collection,\\n                        0,\\n                        calldataPointer,\\n                        ERC1155_safeTransferFrom_size,\\n                        0,\\n                        0\\n                    )\\n                    mstore(add(add(successful, 0x20), mul(0x20, i)), success)\\n                }\\n                default {\\n                    revert(0, 0)\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV2/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nuint256 constant Bytes1_shift = 0xf8;\\nuint256 constant Bytes4_shift = 0xe0;\\nuint256 constant Bytes20_shift = 0x60;\\nuint256 constant One_word = 0x20;\\n\\nuint256 constant Memory_pointer = 0x40;\\n\\nuint256 constant AssetType_ERC721 = 0;\\nuint256 constant AssetType_ERC1155 = 1;\\n\\nuint256 constant OrderType_ASK = 0;\\nuint256 constant OrderType_BID = 1;\\n\\nuint256 constant Pool_withdrawFrom_selector = 0x9555a94200000000000000000000000000000000000000000000000000000000;\\nuint256 constant Pool_withdrawFrom_from_offset = 0x04;\\nuint256 constant Pool_withdrawFrom_to_offset = 0x24;\\nuint256 constant Pool_withdrawFrom_amount_offset = 0x44;\\nuint256 constant Pool_withdrawFrom_size = 0x64;\\n\\nuint256 constant Pool_deposit_selector = 0xf340fa0100000000000000000000000000000000000000000000000000000000;\\nuint256 constant Pool_deposit_user_offset = 0x04;\\nuint256 constant Pool_deposit_size = 0x24;\\n\\nuint256 constant ERC20_transferFrom_selector = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\\nuint256 constant ERC721_safeTransferFrom_selector = 0x42842e0e00000000000000000000000000000000000000000000000000000000;\\nuint256 constant ERC1155_safeTransferFrom_selector = 0xf242432a00000000000000000000000000000000000000000000000000000000;\\nuint256 constant ERC20_transferFrom_size = 0x64;\\nuint256 constant ERC721_safeTransferFrom_size = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_size = 0xc4;\\n\\nuint256 constant OracleSignatures_size = 0x59;\\nuint256 constant OracleSignatures_s_offset = 0x20;\\nuint256 constant OracleSignatures_v_offset = 0x40;\\nuint256 constant OracleSignatures_blockNumber_offset = 0x41;\\nuint256 constant OracleSignatures_oracle_offset = 0x45;\\n\\nuint256 constant Signatures_size = 0x41;\\nuint256 constant Signatures_s_offset = 0x20;\\nuint256 constant Signatures_v_offset = 0x40;\\n\\nuint256 constant ERC20_transferFrom_from_offset = 0x4;\\nuint256 constant ERC20_transferFrom_to_offset = 0x24;\\nuint256 constant ERC20_transferFrom_amount_offset = 0x44;\\n\\nuint256 constant ERC721_safeTransferFrom_from_offset = 0x4;\\nuint256 constant ERC721_safeTransferFrom_to_offset = 0x24;\\nuint256 constant ERC721_safeTransferFrom_id_offset = 0x44;\\n\\nuint256 constant ERC1155_safeTransferFrom_from_offset = 0x4;\\nuint256 constant ERC1155_safeTransferFrom_to_offset = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_offset = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_offset = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_pointer_offset = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_offset = 0xa4;\\n\\nuint256 constant Delegate_transfer_selector = 0xa1ccb98e00000000000000000000000000000000000000000000000000000000;\\nuint256 constant Delegate_transfer_calldata_offset = 0x1c;\\n\\nuint256 constant Order_size = 0x100;\\nuint256 constant Order_trader_offset = 0x00;\\nuint256 constant Order_collection_offset = 0x20;\\nuint256 constant Order_listingsRoot_offset = 0x40;\\nuint256 constant Order_numberOfListings_offset = 0x60;\\nuint256 constant Order_expirationTime_offset = 0x80;\\nuint256 constant Order_assetType_offset = 0xa0;\\nuint256 constant Order_makerFee_offset = 0xc0;\\nuint256 constant Order_salt_offset = 0xe0;\\n\\nuint256 constant Exchange_size = 0x80;\\nuint256 constant Exchange_askIndex_offset = 0x00;\\nuint256 constant Exchange_proof_offset = 0x20;\\nuint256 constant Exchange_maker_offset = 0x40;\\nuint256 constant Exchange_taker_offset = 0x60;\\n\\nuint256 constant BidExchange_size = 0x80;\\nuint256 constant BidExchange_askIndex_offset = 0x00;\\nuint256 constant BidExchange_proof_offset = 0x20;\\nuint256 constant BidExchange_maker_offset = 0x40;\\nuint256 constant BidExchange_taker_offset = 0x60;\\n\\nuint256 constant Listing_size = 0x80;\\nuint256 constant Listing_index_offset = 0x00;\\nuint256 constant Listing_tokenId_offset = 0x20;\\nuint256 constant Listing_amount_offset = 0x40;\\nuint256 constant Listing_price_offset = 0x60;\\n\\nuint256 constant Taker_size = 0x40;\\nuint256 constant Taker_tokenId_offset = 0x00;\\nuint256 constant Taker_amount_offset = 0x20;\\n\\nuint256 constant StateUpdate_size = 0x80;\\nuint256 constant StateUpdate_salt_offset = 0x20;\\nuint256 constant StateUpdate_leaf_offset = 0x40;\\nuint256 constant StateUpdate_value_offset = 0x60;\\n\\nuint256 constant Transfer_size = 0xa0;\\nuint256 constant Transfer_trader_offset = 0x00;\\nuint256 constant Transfer_id_offset = 0x20;\\nuint256 constant Transfer_amount_offset = 0x40;\\nuint256 constant Transfer_collection_offset = 0x60;\\nuint256 constant Transfer_assetType_offset = 0x80;\\n\\nuint256 constant ExecutionBatch_selector_offset = 0x20;\\nuint256 constant ExecutionBatch_calldata_offset = 0x40;\\nuint256 constant ExecutionBatch_base_size = 0xa0; // size of the executionBatch without the flattened dynamic elements\\nuint256 constant ExecutionBatch_taker_offset = 0x00;\\nuint256 constant ExecutionBatch_orderType_offset = 0x20;\\nuint256 constant ExecutionBatch_transfers_pointer_offset = 0x40;\\nuint256 constant ExecutionBatch_length_offset = 0x60;\\nuint256 constant ExecutionBatch_transfers_offset = 0x80;\\n\"\r\n    },\r\n    \"contracts/exchangeV2/lib/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nstruct TakeAsk {\\n    Order[] orders;\\n    Exchange[] exchanges;\\n    FeeRate takerFee;\\n    bytes signatures;\\n    address tokenRecipient;\\n}\\n\\nstruct TakeAskSingle {\\n    Order order;\\n    Exchange exchange;\\n    FeeRate takerFee;\\n    bytes signature;\\n    address tokenRecipient;\\n}\\n\\nstruct TakeBid {\\n    Order[] orders;\\n    Exchange[] exchanges;\\n    FeeRate takerFee;\\n    bytes signatures;\\n}\\n\\nstruct TakeBidSingle {\\n    Order order;\\n    Exchange exchange;\\n    FeeRate takerFee;\\n    bytes signature;\\n}\\n\\nenum AssetType {\\n    ERC721,\\n    ERC1155\\n}\\n\\nenum OrderType {\\n    ASK,\\n    BID\\n}\\n\\nstruct Exchange { // Size: 0x80\\n    uint256 index; // 0x00\\n    bytes32[] proof; // 0x20\\n    Listing listing; // 0x40\\n    Taker taker; // 0x60\\n}\\n\\nstruct Listing { // Size: 0x80\\n    uint256 index; // 0x00\\n    uint256 tokenId; // 0x20\\n    uint256 amount; // 0x40\\n    uint256 price; // 0x60\\n}\\n\\nstruct Taker { // Size: 0x40\\n    uint256 tokenId; // 0x00\\n    uint256 amount; // 0x20\\n}\\n\\nstruct Order { // Size: 0x100\\n    address trader; // 0x00\\n    address collection; // 0x20\\n    bytes32 listingsRoot; // 0x40\\n    uint256 numberOfListings; // 0x60\\n    uint256 expirationTime; // 0x80\\n    AssetType assetType; // 0xa0\\n    FeeRate makerFee; // 0xc0\\n    uint256 salt; // 0xe0\\n}\\n\\n/*\\nReference only; struct is composed manually using calldata formatting in execution\\nstruct ExecutionBatch { // Size: 0x80\\n    address taker; // 0x00\\n    OrderType orderType; // 0x20\\n    Transfer[] transfers; // 0x40\\n    uint256 length; // 0x60\\n}\\n*/\\n\\nstruct Transfer { // Size: 0xa0\\n    address trader; // 0x00\\n    uint256 id; // 0x20\\n    uint256 amount; // 0x40\\n    address collection; // 0x60\\n    AssetType assetType; // 0x80\\n}\\n\\nstruct FungibleTransfers {\\n    uint256 totalProtocolFee;\\n    uint256 totalSellerTransfer;\\n    uint256 totalTakerFee;\\n    uint256 feeRecipientId;\\n    uint256 makerId;\\n    address[] feeRecipients;\\n    address[] makers;\\n    uint256[] makerTransfers;\\n    uint256[] feeTransfers;\\n    AtomicExecution[] executions;\\n}\\n\\nstruct AtomicExecution { // Size: 0xe0\\n    uint256 makerId; // 0x00\\n    uint256 sellerAmount; // 0x20\\n    uint256 makerFeeRecipientId; // 0x40\\n    uint256 makerFeeAmount; // 0x60\\n    uint256 takerFeeAmount; // 0x80\\n    uint256 protocolFeeAmount; // 0xa0\\n    StateUpdate stateUpdate; // 0xc0\\n}\\n\\nstruct StateUpdate { // Size: 0xa0\\n    address trader; // 0x00\\n    bytes32 hash; // 0x20\\n    uint256 index; // 0x40\\n    uint256 value; // 0x60\\n    uint256 maxAmount; // 0x80\\n}\\n\\nstruct Fees { // Size: 0x40\\n    FeeRate protocolFee; // 0x00\\n    FeeRate takerFee; // 0x20\\n}\\n\\nstruct FeeRate { // Size: 0x40\\n    address recipient; // 0x00\\n    uint16 rate; // 0x20\\n}\\n\\nstruct Cancel {\\n    bytes32 hash;\\n    uint256 index;\\n    uint256 amount;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ]\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"enum AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct Transfer[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successful\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Delegate", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000b2ecfe4e4d61f8790bbb9de2d1259b9e2410cea5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}