{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RealVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol\\n\\nimport {ReentrancyGuard} from \\\"oz/utils/ReentrancyGuard.sol\\\";\\nimport {Ownable} from \\\"oz/access/Ownable.sol\\\";\\nimport {Ownable2Step} from \\\"oz/access/Ownable2Step.sol\\\";\\nimport {TransferHelper} from \\\"v3-periphery/libraries/TransferHelper.sol\\\";\\nimport {IReal} from \\\"./interfaces/IReal.sol\\\";\\nimport {IMinter} from \\\"./interfaces/IMinter.sol\\\";\\nimport {IAssetsVault} from \\\"./interfaces/IAssetsVault.sol\\\";\\nimport {IStrategyManager} from \\\"./interfaces/IStrategyManager.sol\\\";\\nimport {ShareMath} from \\\"./libraries/ShareMath.sol\\\";\\n\\n/**\\n * @title Real Ether Vault (reETH)\\n * @author Mavvverick\\n * @notice The Real Vault (reETH) is responsible for managing deposit, withdrawal, and settlement processes\\n * using ERC4626 standard. Users can deposit ETH into the Vault, where it is held securely until settlement,\\n * thereby participating in the yield generation process and receiving rewards as reETH token holders.\\n * Upon settlement, funds are deployed to the underlying strategy pool for yield generation.The Vault ensures\\n * the security of deposited assets and facilitates seamless interactions within the Real Network ecosystem.\\n * Users can interact with the Vault to deposit, withdraw, and settle RealETH tokens, contributing to the\\n * stability and growth of the platform. Additionally, the Vault's architecture provides flexibility for\\n * future yield staking /re-staking strategy and optimizations, ensuring its continued effectiveness in\\n * managing assets and supporting the Real Network infrastructure.\\n */\\ncontract RealVault is ReentrancyGuard, Ownable2Step {\\n    uint256 internal constant ONE = 1;\\n    uint256 internal constant MULTIPLIER = 10 ** 18;\\n    uint256 internal constant ONE_HUNDRED_PERCENT = 100_0000;\\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 60 * 60; // 1hour\\n    uint256 internal constant NUMBER_OF_DEAD_SHARES = 10 ** 15;\\n\\n    uint256 public minWithdrawableShares = 1_00;\\n    uint256 public rebaseTimeInterval = 24 * 60 * 60; // 1 day\\n    uint256 public rebaseTime;\\n\\n    address public immutable minter;\\n    address public immutable real;\\n    address payable public immutable assetsVault;\\n    address payable public immutable strategyManager;\\n\\n    address public proposal;\\n    address public feeRecipient;\\n\\n    uint256 public latestRoundID;\\n    uint256 public withdrawFeeRate;\\n\\n    uint256 public withdrawableAmountInPast;\\n    uint256 public withdrawingSharesInPast;\\n    uint256 public withdrawingSharesInRound;\\n    uint256 public withdrawAmountDust;\\n\\n    /// @notice On every round's close, the pricePerShare value of an real token is stored\\n    /// This is used to determine the number of shares to be returned\\n    /// to a user at the time of minting\\n    mapping(uint256 => uint256) public roundPricePerShare;\\n    mapping(uint256 => uint256) public settlementTime;\\n    mapping(address => WithdrawReceipt) public userReceipts;\\n\\n    struct WithdrawReceipt {\\n        uint256 withdrawRound;\\n        uint256 withdrawShares;\\n        uint256 withdrawableAmount;\\n    }\\n\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n    event InitiateWithdraw(address indexed account, uint256 shares, uint256 round);\\n    event CancelWithdraw(address indexed account, uint256 amount, uint256 round);\\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\\n    event WithdrawnFromStrategy(\\n        address indexed account, uint256 amount, uint256 actualAmount, uint256 totalAmount, uint256 round\\n    );\\n    event RollToNextRound(uint256 indexed round, uint256 vaultIn, uint256 vaultOut, uint256 sharePrice);\\n    event VaultMigrated(address indexed oldVault, address newVault);\\n    event StrategyAdded(address indexed strategy);\\n    event StrategyDestroyed(address indexed strategy);\\n    event StrategyCleared(address indexed strategy);\\n    event InvestmentPortfolioUpdated(address[] indexed strategies, uint256[] indexed ratios);\\n    event FeeCharged(address indexed account, uint256 amount);\\n    event SetWithdrawFeeRate(uint256 indexed oldRate, uint256 newRate);\\n    event SetFeeRecipient(address indexed oldAddr, address newAddr);\\n    event SetRebaseInterval(uint256 indexed interval);\\n    event SettleWithdrawDust(uint256 indexed dust);\\n    event MinWithdrawableSharesUpdated(uint256 indexed minShares);\\n    event ProposalUpdated(address indexed oldAddr, address newAddr);\\n\\n    error RealVault__NotReady();\\n    error RealVault__Migrated();\\n    error RealVault__InsufficientShares();\\n    error RealVault__InvalidAmount();\\n    error RealVault__ZeroAddress();\\n    error RealVault__MininmumWithdraw();\\n    error RealVault__WithdrawInstantly();\\n    error RealVault__NoRequestFound();\\n    error RealVault__NotProposal();\\n    error RealVault__ExceedBalance();\\n    error RealVault__WaitInQueue();\\n    error RealVault__MinimumWithdrawableShares();\\n    error RealVault__ExceedRequestedAmount(uint256 requestedAmount, uint256 actualAmount);\\n    error RealVault__ExceedWithdrawAmount();\\n    error RealVault__ExceedMaxFeeRate(uint256 _feeRate);\\n    error RealVault__MinimumRebaseInterval(uint256 minInterval);\\n\\n    /**\\n     * @param _intialOwner Address of the initial owner of the contract.\\n     * @param _minter Address of the minter contract.\\n     * @param _assetsVault Address of the assets vault contract.\\n     * @param _strategyManager Address of the strategy manager contract.\\n     * @param _proposal Address of the proposal contract.\\n     */\\n    constructor(\\n        address _intialOwner,\\n        address _minter,\\n        address payable _assetsVault,\\n        address payable _strategyManager,\\n        address _proposal\\n    ) payable Ownable(_intialOwner) {\\n        if (_proposal == address(0) || _assetsVault == address(0) || _strategyManager == address(0)) {\\n            revert RealVault__ZeroAddress();\\n        }\\n\\n        minter = _minter;\\n        proposal = _proposal;\\n        assetsVault = _assetsVault;\\n        strategyManager = _strategyManager;\\n\\n        real = IMinter(_minter).real();\\n        rebaseTime = block.timestamp;\\n\\n        // mint dead shares\\n        if (IReal(real).totalSupply() == 0) {\\n            TransferHelper.safeTransferETH(assetsVault, NUMBER_OF_DEAD_SHARES);\\n            IMinter(minter).mint(address(0xdead), NUMBER_OF_DEAD_SHARES);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to restrict access to only the proposal contract.\\n     */\\n    modifier onlyProposal() {\\n        if (proposal != msg.sender) revert RealVault__NotProposal();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Deposit assets into the RealVault.\\n     * @return mintAmount The amount of shares minted.\\n     */\\n    function deposit(uint256 mintAmountMin) external payable nonReentrant returns (uint256 mintAmount) {\\n        mintAmount = _depositFor(msg.sender, msg.sender, msg.value, mintAmountMin);\\n    }\\n\\n    /**\\n     * @dev Deposit assets into the RealVault on behalf of another address.\\n     * @param receiver Address to receive the minted shares.\\n     * @return mintAmount The amount of shares minted.\\n     */\\n    function depositFor(address receiver, uint256 mintAmountMin)\\n        external\\n        payable\\n        nonReentrant\\n        returns (uint256 mintAmount)\\n    {\\n        mintAmount = _depositFor(msg.sender, receiver, msg.value, mintAmountMin);\\n    }\\n\\n    /**\\n     * @dev Initiate a withdrawal request for a specified number of shares.\\n     * @param _shares Number of shares to withdraw.\\n     */\\n    function requestWithdraw(uint256 _shares) external nonReentrant {\\n        if (_shares == 0) revert RealVault__InvalidAmount();\\n        if (_shares < minWithdrawableShares) revert RealVault__MininmumWithdraw();\\n\\n        uint256 _latestRoundID = latestRoundID;\\n\\n        if (_latestRoundID == 0) revert RealVault__WithdrawInstantly();\\n\\n        IReal realToken = IReal(real);\\n        IMinter realEthMinter = IMinter(minter);\\n\\n        if (realToken.balanceOf(msg.sender) < _shares) revert RealVault__ExceedBalance();\\n        TransferHelper.safeTransferFrom(real, msg.sender, address(this), _shares);\\n\\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\\n        WithdrawReceipt memory mReceipt = userReceipts[msg.sender];\\n\\n        if (mReceipt.withdrawRound == _latestRoundID) {\\n            mReceipt.withdrawShares = mReceipt.withdrawShares + _shares;\\n        } else if (mReceipt.withdrawRound == 0) {\\n            mReceipt.withdrawShares = _shares;\\n            mReceipt.withdrawRound = _latestRoundID;\\n        } else {\\n            // Withdraw previous round share first\\n            mReceipt = _updateUserReceipt(mReceipt, realEthMinter, _shares, _latestRoundID);\\n        }\\n\\n        userReceipts[msg.sender] = mReceipt;\\n        emit InitiateWithdraw(msg.sender, _shares, _latestRoundID);\\n    }\\n\\n    /**\\n     * @dev Cancel a pending withdrawal request.\\n     * @param _shares Number of shares to cancel the withdrawal for.\\n     */\\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\\n        if (_shares == 0) revert RealVault__InvalidAmount();\\n\\n        WithdrawReceipt memory mReceipt = userReceipts[msg.sender];\\n        uint256 _latestRoundID = latestRoundID;\\n\\n        if (mReceipt.withdrawRound != _latestRoundID) revert RealVault__NoRequestFound();\\n        if (_shares > mReceipt.withdrawShares) {\\n            revert RealVault__ExceedRequestedAmount(_shares, mReceipt.withdrawShares);\\n        }\\n\\n        unchecked {\\n            mReceipt.withdrawShares -= _shares;\\n        }\\n\\n        // check minimum shares request\\n        if (mReceipt.withdrawShares != 0 && mReceipt.withdrawShares < minWithdrawableShares) {\\n            revert RealVault__MininmumWithdraw();\\n        }\\n\\n        TransferHelper.safeTransfer(real, msg.sender, _shares);\\n\\n        if (mReceipt.withdrawShares == 0) {\\n            mReceipt.withdrawRound = 0;\\n        }\\n\\n        userReceipts[msg.sender] = mReceipt;\\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\\n\\n        emit CancelWithdraw(msg.sender, _shares, _latestRoundID);\\n    }\\n\\n    /**\\n     * @dev Withdraw assets instantly or after a delay, depending on availability.\\n     * @param _amount Amount of assets to withdraw.\\n     * @param _shares Number of shares to withdraw.\\n     * @return actualWithdrawn The actual amount of assets withdrawn.\\n     */\\n    function instantWithdraw(uint256 _amount, uint256 _shares)\\n        external\\n        nonReentrant\\n        returns (uint256 actualWithdrawn)\\n    {\\n        if (_amount == 0 && _shares == 0) revert RealVault__InvalidAmount();\\n\\n        IAssetsVault aVault = IAssetsVault(assetsVault);\\n        IMinter realEthMinter = IMinter(minter);\\n\\n        uint256 _latestRoundID = latestRoundID;\\n        (uint256 idleAmount,) = getVaultAvailableAmount();\\n\\n        if (_amount != 0) {\\n            WithdrawReceipt memory mReceipt = userReceipts[msg.sender];\\n\\n            if (mReceipt.withdrawRound != _latestRoundID && mReceipt.withdrawRound != 0) {\\n                // Withdraw previous round share first\\n                mReceipt = _updateUserReceipt(mReceipt, realEthMinter, 0, 0);\\n            }\\n\\n            if (mReceipt.withdrawableAmount < _amount) revert RealVault__ExceedWithdrawAmount();\\n\\n            unchecked {\\n                mReceipt.withdrawableAmount -= _amount;\\n            }\\n\\n            userReceipts[msg.sender] = mReceipt;\\n\\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\\n            actualWithdrawn = _amount;\\n\\n            emit Withdrawn(msg.sender, _amount, _latestRoundID);\\n        }\\n\\n        if (_shares != 0) {\\n            uint256 sharePrice;\\n\\n            if (_latestRoundID == 0) {\\n                sharePrice = MULTIPLIER;\\n            } else {\\n                uint256 currSharePrice = currentSharePrice();\\n                uint256 latestSharePrice;\\n\\n                unchecked {\\n                    latestSharePrice = roundPricePerShare[_latestRoundID - ONE];\\n                }\\n                sharePrice = latestSharePrice < currSharePrice ? latestSharePrice : currSharePrice;\\n            }\\n\\n            uint256 ethAmount = ShareMath.sharesToAsset(_shares, sharePrice);\\n\\n            realEthMinter.burn(msg.sender, _shares);\\n\\n            if (ethAmount <= idleAmount) {\\n                actualWithdrawn = actualWithdrawn + ethAmount;\\n\\n                emit Withdrawn(msg.sender, ethAmount, _latestRoundID);\\n            } else {\\n                actualWithdrawn = actualWithdrawn + idleAmount;\\n\\n                unchecked {\\n                    ethAmount = ethAmount - idleAmount;\\n                }\\n\\n                IStrategyManager manager = IStrategyManager(strategyManager);\\n                // if strategy sells the LSD token on the decentralized exchange (DEX),\\n                // deducting swap fees from the requested amount.\\n                uint256 actualAmount = manager.forceWithdraw(ethAmount);\\n\\n                actualWithdrawn = actualWithdrawn + actualAmount;\\n\\n                emit WithdrawnFromStrategy(msg.sender, ethAmount, actualAmount, actualWithdrawn, _latestRoundID);\\n            }\\n        }\\n\\n        if (aVault.getBalance() < actualWithdrawn) revert RealVault__WaitInQueue();\\n\\n        uint256 withFee;\\n        if (withdrawFeeRate != 0) {\\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\\n            aVault.withdraw(feeRecipient, withFee);\\n\\n            emit FeeCharged(msg.sender, withFee);\\n        }\\n        unchecked {\\n            aVault.withdraw(msg.sender, actualWithdrawn - withFee);\\n        }\\n    }\\n\\n    /**\\n     * @dev Rebalances the strategies without incoming and outgoing amounts.\\n     */\\n    function onlyRebaseStrategies() external nonReentrant onlyProposal {\\n        IStrategyManager(strategyManager).onlyRebaseStrategies();\\n    }\\n\\n    /**\\n     * @dev Transition to the next round, managing vault balances and share prices.\\n     */\\n    function rollToNextRound() external nonReentrant {\\n        if (block.timestamp < rebaseTime + rebaseTimeInterval) revert RealVault__NotReady();\\n        rebaseTime = block.timestamp;\\n\\n        IStrategyManager manager = IStrategyManager(strategyManager);\\n        IAssetsVault aVault = IAssetsVault(assetsVault);\\n        uint256 previewSharePrice = currentSharePrice();\\n\\n        uint256 vaultBalance = aVault.getBalance();\\n        uint256 amountToWithdraw = ShareMath.sharesToAsset(withdrawingSharesInRound, previewSharePrice);\\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\\n        uint256 allPendingValue = manager.getAllStrategyPendingValue();\\n\\n        uint256 vaultIn;\\n        uint256 vaultOut;\\n\\n        if (vaultBalance > amountVaultNeed) {\\n            unchecked {\\n                vaultIn = vaultBalance - amountVaultNeed;\\n            }\\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\\n            unchecked {\\n                vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\\n            }\\n        }\\n\\n        manager.rebaseStrategies(vaultIn, vaultOut);\\n\\n        uint256 _latestRoundID = latestRoundID;\\n        uint256 newSharePrice = currentSharePrice();\\n        roundPricePerShare[_latestRoundID] = previewSharePrice < newSharePrice ? previewSharePrice : newSharePrice;\\n\\n        settlementTime[_latestRoundID] = block.timestamp;\\n        unchecked {\\n            latestRoundID = _latestRoundID + ONE;\\n        }\\n\\n        withdrawingSharesInPast = withdrawingSharesInPast + withdrawingSharesInRound;\\n        withdrawableAmountInPast =\\n            withdrawableAmountInPast + ShareMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\\n        withdrawingSharesInRound = 0;\\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\\n    }\\n\\n    /**\\n     * @dev Migrate the vault to a new contract.\\n     * @param _vault Address of the new vault.\\n     */\\n    function migrateVault(address _vault) external onlyProposal {\\n        IMinter(minter).setNewVault(_vault);\\n        IAssetsVault(assetsVault).setNewVault(_vault);\\n        IStrategyManager(strategyManager).setNewVault(_vault);\\n\\n        // migrate pending withdrawals by transferring any real token balance held by the contract\\n        // to the new implementation which should manually migrate userReceipts entries.\\n        IReal realToken = IReal(real);\\n        uint256 balance = realToken.balanceOf(address(this));\\n        if (balance > 0) TransferHelper.safeTransfer(real, _vault, balance);\\n\\n        emit VaultMigrated(address(this), _vault);\\n    }\\n\\n    /**\\n     * @dev Add a new strategy to the strategy manager.\\n     * @param _strategy Address of the new strategy.\\n     */\\n    function addStrategy(address _strategy) external onlyProposal {\\n        IStrategyManager manager = IStrategyManager(strategyManager);\\n\\n        manager.addStrategy(_strategy);\\n        emit StrategyAdded(_strategy);\\n    }\\n\\n    /**\\n     * @dev Destroy a strategy from the strategy manager.\\n     * Funds must be returned to the asset valut from the strategy before destroyin the strategy.\\n     * @param _strategy Address of the strategy to destroy.\\n     */\\n    function destroyStrategy(address _strategy) external onlyOwner {\\n        IStrategyManager manager = IStrategyManager(strategyManager);\\n\\n        manager.destroyStrategy(_strategy);\\n        emit StrategyDestroyed(_strategy);\\n    }\\n\\n    /**\\n     * @dev Clear a strategy from the vault.\\n     * Invested funds will be returned to the asset valut from the strategy\\n     * @param _strategy Address of the strategy to clear.\\n     */\\n    function clearStrategy(address _strategy) external onlyOwner {\\n        IStrategyManager manager = IStrategyManager(strategyManager);\\n\\n        manager.clearStrategy(_strategy);\\n        emit StrategyCleared(_strategy);\\n    }\\n\\n    /**\\n     * @dev Update the investment portfolio of the vault.\\n     * Set the strategy and potfolio allocation ratio in the manager.\\n     * Previous strategy ratios will set to zero before applying the new allocation ratio.\\n     * @param _strategies Array of addresses representing the new strategies.\\n     * @param _ratios Array of ratios corresponding to the strategies.\\n     */\\n    function updateInvestmentPortfolio(address[] memory _strategies, uint256[] memory _ratios) external onlyProposal {\\n        IStrategyManager manager = IStrategyManager(strategyManager);\\n\\n        manager.setStrategies(_strategies, _ratios);\\n\\n        emit InvestmentPortfolioUpdated(_strategies, _ratios);\\n    }\\n\\n    /**\\n     * @dev Update the address of the proposal contract or multisig.\\n     * @param _proposal Address of the new proposal contract or multisig.\\n     */\\n    function updateProposal(address _proposal) external onlyProposal {\\n        if (_proposal == address(0)) revert RealVault__ZeroAddress();\\n        emit ProposalUpdated(proposal, _proposal);\\n        proposal = _proposal;\\n    }\\n\\n    function settleWithdrawDust(uint256 amount) external {\\n        uint256 _withdrawAmountDust = withdrawAmountDust;\\n        if (_withdrawAmountDust < MULTIPLIER) revert RealVault__InvalidAmount();\\n        if (amount > _withdrawAmountDust) revert RealVault__ExceedBalance();\\n        withdrawableAmountInPast -= amount;\\n        withdrawAmountDust -= amount;\\n        emit SettleWithdrawDust(amount);\\n    }\\n\\n    // [INTERNAL FUNCTIONS]\\n    function _depositFor(address caller, address receiver, uint256 assets, uint256 mintAmountMin)\\n        internal\\n        returns (uint256 mintAmount)\\n    {\\n        if (assets == 0) revert RealVault__InvalidAmount();\\n\\n        mintAmount = previewDeposit(address(this).balance); // shares amount to be minted\\n        if (mintAmount < mintAmountMin) revert RealVault__InsufficientShares();\\n\\n        IAssetsVault(assetsVault).deposit{value: address(this).balance}();\\n        IMinter(minter).mint(receiver, mintAmount);\\n        emit Deposit(caller, receiver, assets, mintAmount);\\n    }\\n\\n    function _updateUserReceipt(\\n        WithdrawReceipt memory mReceipt,\\n        IMinter realEthMinter,\\n        uint256 _shares,\\n        uint256 _latestRoundID\\n    ) private returns (WithdrawReceipt memory) {\\n        uint256 pps = roundPricePerShare[mReceipt.withdrawRound];\\n        uint256 withdrawAmount = ShareMath.sharesToAsset(mReceipt.withdrawShares, pps);\\n        uint256 convertedShares = ShareMath.assetToShares(withdrawAmount, pps);\\n\\n        if (withdrawAmount > 0 && convertedShares < mReceipt.withdrawShares) {\\n            // Default is to round down (Solidity), track dust for withdrawAmount\\n            withdrawAmountDust++;\\n        }\\n\\n        realEthMinter.burn(address(this), mReceipt.withdrawShares);\\n        withdrawingSharesInPast = withdrawingSharesInPast - mReceipt.withdrawShares;\\n\\n        mReceipt.withdrawShares = _shares;\\n        mReceipt.withdrawableAmount = mReceipt.withdrawableAmount + withdrawAmount;\\n\\n        mReceipt.withdrawRound = _latestRoundID;\\n        return mReceipt;\\n    }\\n\\n    // [SETTER FUNCTIONS]\\n\\n    /**\\n     * @dev Sets the withdrawal fee rate.\\n     * @param _withdrawFeeRate The new withdrawal fee rate.\\n     * Requirements:\\n     * - The new fee rate must not exceed the maximum fee rate.\\n     */\\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\\n        if (_withdrawFeeRate > MAXMIUM_FEE_RATE) revert RealVault__ExceedMaxFeeRate(_withdrawFeeRate);\\n\\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\\n\\n        withdrawFeeRate = _withdrawFeeRate;\\n    }\\n\\n    /**\\n     * @dev Sets the fee recipient address.\\n     * @param _feeRecipient The new fee recipient address.\\n     * Requirements:\\n     * - The new fee recipient address must not be the zero address.\\n     */\\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\\n        if (_feeRecipient == address(0)) revert RealVault__ZeroAddress();\\n\\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\\n\\n        feeRecipient = _feeRecipient;\\n    }\\n\\n    /**\\n     * @dev Sets the rebase interval.\\n     * @param _interval The new rebase interval.\\n     * Requirements:\\n     * - The new interval must not be less than the minimum rebase interval.\\n     */\\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\\n        if (_interval < MINIMUM_REBASE_INTERVAL) revert RealVault__MinimumRebaseInterval(MINIMUM_REBASE_INTERVAL);\\n        rebaseTimeInterval = _interval;\\n        emit SetRebaseInterval(rebaseTimeInterval);\\n    }\\n\\n    /**\\n     * @dev Sets the minimum withdrawable shares.\\n     * @param _minWithdrawableShares The new minimum withdrawable shares.\\n     * Requirements:\\n     * - The new minimum must not be less than the 100 wei.\\n     */\\n    function setMinWithdrawableShares(uint256 _minWithdrawableShares) external onlyOwner {\\n        if (_minWithdrawableShares < 1_00) revert RealVault__MinimumWithdrawableShares();\\n        minWithdrawableShares = _minWithdrawableShares;\\n        emit MinWithdrawableSharesUpdated(_minWithdrawableShares);\\n    }\\n\\n    // [VIEW FUNCTIONS]\\n\\n    /**\\n     * @dev Calculates the number of shares corresponding to a given asset amount.\\n     * @param assets The amount of assets to calculate shares for.\\n     * @return The number of shares.\\n     */\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        uint256 sharePrice;\\n        if (latestRoundID == 0) {\\n            sharePrice = MULTIPLIER;\\n        } else {\\n            uint256 currSharePrice = currentSharePrice();\\n            uint256 latestSharePrice;\\n            unchecked {\\n                latestSharePrice = roundPricePerShare[latestRoundID - ONE];\\n            }\\n            sharePrice = latestSharePrice > currSharePrice ? latestSharePrice : currSharePrice;\\n        }\\n\\n        return ShareMath.assetToShares(assets, sharePrice);\\n    }\\n\\n    /**\\n     * @dev Retrieves the current share price.\\n     * Send a certain amount of shares to the blackhole address when the protocol accepts\\n     * deposits for the first time. https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706\\n     * @return price current share price.\\n     */\\n    function currentSharePrice() public view returns (uint256 price) {\\n        IReal realToken = IReal(real);\\n        uint256 totalReal = realToken.totalSupply();\\n        if (latestRoundID == 0) {\\n            return MULTIPLIER;\\n        }\\n\\n        uint256 etherAmount = IAssetsVault(assetsVault).getBalance()\\n            + IStrategyManager(strategyManager).getAllStrategiesValue() - withdrawableAmountInPast;\\n        uint256 activeShare = totalReal - withdrawingSharesInPast;\\n        return (etherAmount * MULTIPLIER) / activeShare;\\n    }\\n\\n    /**\\n     * @dev Retrieves the available amount in the vault.\\n     * @return idleAmount idle amount amount in the vault.\\n     * @return investedAmount invested amount in the vault.\\n     */\\n    function getVaultAvailableAmount() public view returns (uint256 idleAmount, uint256 investedAmount) {\\n        IAssetsVault vault = IAssetsVault(assetsVault);\\n\\n        if (vault.getBalance() > withdrawableAmountInPast) {\\n            unchecked {\\n                idleAmount = vault.getBalance() - withdrawableAmountInPast;\\n            }\\n        }\\n\\n        investedAmount = IStrategyManager(strategyManager).getTotalInvestedValue();\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/v3-periphery/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IReal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\nimport {IERC20} from \\\"oz/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Real Interface\\n * @dev Interface for a token contract representing real-world assets.\\n */\\ninterface IReal is IERC20 {\\n    /**\\n     * @dev Mints tokens and assigns them to the specified address.\\n     * @param _to The address to which the minted tokens will be assigned.\\n     * @param _amount The amount of tokens to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external;\\n\\n    /**\\n     * @dev Burns tokens from the specified address.\\n     * @param _from The address from which tokens will be burned.\\n     * @param _amount The amount of tokens to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\n/**\\n * @title Minter Interface\\n * @dev Interface for a contract responsible for minting and burning tokens.\\n */\\ninterface IMinter {\\n    /**\\n     * @dev Sets a new vault address.\\n     * @param _vault The address of the new vault.\\n     */\\n    function setNewVault(address _vault) external;\\n\\n    /**\\n     * @dev Mints tokens and assigns them to the specified address.\\n     * @param _to The address to which the minted tokens will be assigned.\\n     * @param _amount The amount of tokens to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external;\\n\\n    /**\\n     * @dev Burns tokens from the specified address.\\n     * @param _from The address from which tokens will be burned.\\n     * @param _amount The amount of tokens to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external;\\n\\n    /**\\n     * @dev Gets the address of the real token.\\n     * @return The address of the real token.\\n     */\\n    function real() external view returns (address);\\n\\n    /**\\n     * @dev Gets the address of the real token vault.\\n     * @return The address of the real token vault.\\n     */\\n    function vault() external view returns (address);\\n\\n    /**\\n     * @dev Gets the price of the token.\\n     * @return price The price of the token.\\n     */\\n    function getTokenPrice() external view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAssetsVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\n/**\\n * @title AssetsVault Interface\\n * @dev Interface for managing assets within a vault contract.\\n */\\ninterface IAssetsVault {\\n    /**\\n     * @dev Deposits funds into the vault.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @dev Withdraws funds from the vault.\\n     * @param to The address to which the withdrawn funds will be transferred.\\n     * @param amount The amount of funds to withdraw.\\n     */\\n    function withdraw(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Sets a new vault address.\\n     * @param _vault The address of the new vault.\\n     */\\n    function setNewVault(address _vault) external;\\n\\n    /**\\n     * @dev Gets the balance of the vault.\\n     * @return balanceAmount The balance of the vault.\\n     */\\n    function getBalance() external view returns (uint256 balanceAmount);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\n/**\\n * @title StrategyManager Interface\\n * @dev Interface for a contract managing multiple eth investment strategies.\\n */\\ninterface IStrategyManager {\\n    /**\\n     * @dev Sets a new vault address.\\n     * @param _vault The address of the new vault.\\n     */\\n    function setNewVault(address _vault) external;\\n\\n    /**\\n     * @dev Adds a new strategy to be managed.\\n     * @param _strategy The address of the strategy to add.\\n     */\\n    function addStrategy(address _strategy) external;\\n\\n    /**\\n     * @dev Destroys a strategy, removing it from management.\\n     * @param _strategy The address of the strategy to destroy.\\n     */\\n    function destroyStrategy(address _strategy) external;\\n\\n    /**\\n     * @dev Clears a strategy, potentially withdrawing its funds and resetting parameters.\\n     * @param _strategy The address of the strategy to clear.\\n     */\\n    function clearStrategy(address _strategy) external;\\n\\n    /**\\n     * @dev Rebalances the strategies based on incoming and outgoing amounts.\\n     * @param amountIn The amount of funds to be rebalanced into the strategies.\\n     * @param amountOut The amount of funds to be rebalanced out of the strategies.\\n     */\\n    function rebaseStrategies(uint256 amountIn, uint256 amountOut) external;\\n\\n    /**\\n     * @dev Rebalances the strategies without incoming and outgoing amounts.\\n     */\\n    function onlyRebaseStrategies() external;\\n\\n    /**\\n     * @dev Forces a withdrawal of a specified amount of ETH from the strategies.\\n     * @param ethAmount The amount of ETH to withdraw.\\n     * @return actualAmount The actual amount of ETH withdrawn.\\n     */\\n    function forceWithdraw(uint256 ethAmount) external returns (uint256 actualAmount);\\n\\n    /**\\n     * @dev Sets the strategies and their corresponding ratios.\\n     * @param _strategies The addresses of the strategies to set.\\n     * @param _ratios The corresponding ratios for each strategy.\\n     */\\n    function setStrategies(address[] memory _strategies, uint256[] memory _ratios) external;\\n\\n    /**\\n     * @dev Retrieves the address of the assets vault managed by the strategy manager.\\n     * @return vault The address of the assets vault.\\n     */\\n    function assetsVault() external view returns (address vault);\\n\\n    /**\\n     * @dev Retrieves the total value managed by all strategies.\\n     * @return amount The total value managed by all strategies.\\n     */\\n    function getAllStrategiesValue() external view returns (uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the total valid value managed by all strategies.\\n     * @return amount The total valid value managed by all strategies.\\n     */\\n    function getTotalInvestedValue() external view returns (uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the total pending value managed by all strategies.\\n     * @return amount The total pending value managed by all strategies.\\n     */\\n    function getAllStrategyPendingValue() external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/libraries/ShareMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.21;\\n\\nimport {FullMath} from \\\"v3-core-0.8/libraries/FullMath.sol\\\";\\n\\nlibrary ShareMath {\\n    uint256 internal constant DECIMAL = 18;\\n    uint256 internal constant DECIMAL_OFFSET = 10 ** DECIMAL;\\n    uint256 internal constant PLACEHOLDER_UINT = 1;\\n\\n    /**\\n     * @notice Converts an amount of tokens to shares.\\n     * @param assetAmount The amount of tokens to convert.\\n     * @param assetPerShare The price per share.\\n     * @return The equivalent amount of shares.\\n     *\\n     * Note: All rounding errors should be rounded down in the interest of the protocol's safety.\\n     * Token transfers, including deposit and withdraw operations, may require a rounding, leading to potential\\n     * transferring at most one GWEI less than expected aggregated over a long period of time.\\n     */\\n    function assetToShares(uint256 assetAmount, uint256 assetPerShare) internal pure returns (uint256) {\\n        require(assetPerShare > PLACEHOLDER_UINT, \\\"ShareMath Lib: Invalid assetPerShare\\\");\\n        return FullMath.mulDiv(assetAmount, DECIMAL_OFFSET, assetPerShare);\\n    }\\n\\n    /**\\n     * @notice Converts an amount of shares to tokens.\\n     * @param shares The amount of shares to convert.\\n     * @param assetPerShare The price per share.\\n     * @return The equivalent amount of tokens.\\n     */\\n    function sharesToAsset(uint256 shares, uint256 assetPerShare) internal pure returns (uint256) {\\n        require(assetPerShare > PLACEHOLDER_UINT, \\\"ShareMath Lib: Invalid assetPerShare\\\");\\n        return FullMath.mulDiv(shares, assetPerShare, DECIMAL_OFFSET);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/v3-core-0.8/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"src/=src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"oz/=lib/openzeppelin-contracts/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"v3-core-0.8/=lib/v3-core-0.8/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v3-core/=lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_intialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_assetsVault\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_strategyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proposal\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__ExceedBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"name\":\"RealVault__ExceedMaxFeeRate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"name\":\"RealVault__ExceedRequestedAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__ExceedWithdrawAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__InsufficientShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__Migrated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minInterval\",\"type\":\"uint256\"}],\"name\":\"RealVault__MinimumRebaseInterval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__MinimumWithdrawableShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__MininmumWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__NoRequestFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__NotProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__NotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__WaitInQueue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__WithdrawInstantly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RealVault__ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"CancelWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"InitiateWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"ratios\",\"type\":\"uint256[]\"}],\"name\":\"InvestmentPortfolioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"}],\"name\":\"MinWithdrawableSharesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"ProposalUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"}],\"name\":\"RollToNextRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"SetFeeRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"SetRebaseInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dust\",\"type\":\"uint256\"}],\"name\":\"SettleWithdrawDust\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"VaultMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"WithdrawnFromStrategy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsVault\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"cancelWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"clearStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmountMin\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintAmountMin\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"destroyStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultAvailableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"idleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"instantWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"migrateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWithdrawableShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyRebaseStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"real\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseTimeInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollToNextRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundPricePerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWithdrawableShares\",\"type\":\"uint256\"}],\"name\":\"setMinWithdrawableShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"setRebaseInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeRate\",\"type\":\"uint256\"}],\"name\":\"setWithdrawFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"settleWithdrawDust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlementTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyManager\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ratios\",\"type\":\"uint256[]\"}],\"name\":\"updateInvestmentPortfolio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"updateProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReceipts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAmountDust\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawableAmountInPast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawingSharesInPast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawingSharesInRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RealVault", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eb658c4ea908ac4daf9c309d8f883d6ad758b3a3000000000000000000000000655756824385f8903ac8cfda17b656cc26f7c7da000000000000000000000000f985e2c73d74beff3c8c16efc4fa5ab4cfb622940000000000000000000000005cba18d504d4158dc1a18c5dc6bb2a30b230ddd8000000000000000000000000eb658c4ea908ac4daf9c309d8f883d6ad758b3a3", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}