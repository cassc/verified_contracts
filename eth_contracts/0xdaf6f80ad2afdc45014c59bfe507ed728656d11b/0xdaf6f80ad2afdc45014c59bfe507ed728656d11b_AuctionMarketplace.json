{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AuctionMarketplace.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @title Auction\\n * @author @brougkr\\n * @notice A Smart Contract To Facilitate Ascending Rebate Auctions (With Ascending Rebate Reserve Floor) For Multiple NFTs (Or Whatever Else You Want To Sell) \\n */\\npragma solidity 0.8.19;\\nimport { DelegateCashEnabled } from \\\"./DelegateCashEnabled.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\ncontract AuctionMarketplace is DelegateCashEnabled, ReentrancyGuard, Ownable\\n{\\n    struct Bid\\n    {\\n        uint _OGBidIndex; // [0] -> Original Bid Index\\n        uint _Priority;   // [1] -> Priority Of Bid (Merkle Rank)\\n        uint _Allocation; // [2] -> Allocation For Provided Priority Tier\\n        uint _ETHValue;   // [3] -> ETH Value Of Bid\\n        uint _Timestamp;  // [4] -> Unix Timestamp Of Bid Confirmation\\n        address _Bidder;  // [5] -> Wallet Address Of Bidder\\n        address _Vault;   // [6] -> Wallet Address Of Vault (optional `delegate.cash` support)\\n        bool _Rebated;    // [7] -> If Bidder Rebated ETH From Bid\\n        bool _Winner;     // [8] -> If Bidder Is A Winner (Top Placing) In The Auction\\n        bool _NFTSent;    // [9] -> If Bidder Has Received Their NFT\\n    }\\n\\n    struct Params\\n    {\\n        string _Name;                // [0] -> Name Of Auction\\n        bool _SettlementEnabled;     // [1] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)\\n        bool _UserSettlementEnabled; // [2] -> If Self-Service User Settlement Is Enabled (Bidders Can Settle Their Own Bids ETH & NFTs)\\n        uint _LeaderboardSize;       // [3] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)\\n        uint _UnixStartTime;         // [4] -> Unix Start Time Of Auction\\n        uint _UnixEndTime;           // [5] -> Unix End Time Of Auction\\n        uint _MinBIPSIncrease;       // [6] -> Minimum BIPS (%) Increase On Each Subsequent Bid After Configured LeaderboardSize \\n        uint _SecondsExtension;      // [7] -> # Of Second(s) Of Extension For Auction (Input In Seconds)\\n        uint _SecondsThreshold;      // [8] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension\\n        uint _InitialMinimumBid;     // [9] -> Initial Minimum Bid\\n        uint _ProjectIDMintPass;     // [10] -> The Factory MintPass ProjectID\\n        uint _MintPackAmount;        // [11] -> The Amount Of Mint Passes To Disperse Per Bid\\n        address _NFT;                // [12] -> Address Of NFT Contract\\n        address _Operator;           // [13] -> Wallet Holding NFTs To Disperse\\n    }\\n\\n    struct State\\n    {\\n        bool _Active;           // [0] -> _Active\\n        bool _NFTsDispersed;    // [1] -> _NFTsDispersed\\n        uint _LastMinBid;       // [2] -> _LastMinBid\\n        uint _GlobalUniqueBids; // [3] -> _GlobalUniqueBids\\n    }\\n\\n    struct AllAuctionParams\\n    {\\n        string _Name;            // [0] -> Name Of Auction\\n        bool _Active;            // [1] -> If Sale Is Active\\n        bool _NFTsDispersed;     // [2] -> If NFTs Have Been Dispersed\\n        bool _SettlementEnabled; // [3] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)\\n        uint _LeaderboardSize;   // [4] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)\\n        uint _UnixStartTime;     // [5] -> Unix Start Time Of Auction\\n        uint _UnixEndTime;       // [6] -> Unix End Time Of Auction\\n        uint _MinBIPSIncrease;   // [7] -> Minimum BIPS (%) Increase On Each Subsequent Bid After 50 Unique Bids \\n        uint _SecondsExtension;  // [8] -> # Of Seconds(s) Of Extension For Auction (Input In # Of Seconds)\\n        uint _SecondsThreshold;  // [9] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension\\n        uint _LastMinBid;        // [10] -> Value Of The Last Minimum Bid\\n        uint _GlobalUniqueBids;  // [11] -> # Of Global Unique Bids\\n        uint _ProjectIDMintPass; // [12] -> The Factory MintPass ProjectID\\n        uint _MintPackAmount;    // [13] -> The Amount Of Mint Passes To Disperse Per Bid\\n        address _NFT;            // [14] -> Address Of NFT Contract\\n    }\\n\\n    /*-----------------------------\\n     * STATE VARIABLES & MAPPINGS *\\n    ------------------------------*/\\n\\n    mapping(uint=>Params) public AuctionParams;\\n    mapping(uint=>State) public SaleState;\\n    mapping(uint=>mapping(uint=>Bid)) public Bids;\\n    mapping(uint=>mapping(uint=>uint)) public Leaderboard;\\n    mapping(uint=>mapping(address=>uint[])) public UserBidIndexes;\\n    mapping(address=>bool) public Admin;\\n    mapping(uint=>mapping(uint=>bool)) public NFTTokenIDHasBeenSent;\\n    mapping(uint=>uint[]) public Discounts;\\n    mapping(uint=>bytes32[]) public MerkleRootsEligibility;\\n    mapping(uint=>bytes32[]) public MerkleRootsAmounts;\\n    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level\\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE;\\n    uint public _GLOBAL_UNIQUE_SALES;\\n\\n    /*---------\\n     * EVENTS *\\n    ----------*/\\n\\n    /**\\n     * @dev Emitted When A New Bid Is Submitted\\n     */\\n    event NewBidComplete(uint BidIndex, address Bidder, uint MessageValue, uint Unixtimestamp, address Vault);\\n\\n    /**\\n     * @dev Emitted When A Bid Is Topped Up\\n     */\\n    event BidToppedUp(uint BidIndex, uint ETHForBid, uint Unixtimestamp, address Bidder);\\n\\n    /**\\n     * @dev Emitted When A Bid Reclaim Fails\\n     */\\n    event BidReclaimFailed(uint BidIndex);\\n\\n    /**\\n     * @dev Emitted When A Bid Reclaim Succeeds\\n     */\\n    event BidReclaimSuccess(uint BidIndex);\\n\\n    /**\\n     * @dev Emitted When A Bidder's ETH Is Rebated (The Bid They Are Trying To Top Up Was Frontran)\\n     */\\n    event BidTopupRefunded(uint Rebate);\\n\\n    /**\\n     * @dev Emitted When The Auction End Time Is Extended\\n     */\\n    event AuctionExtended();\\n\\n    /**\\n     * @dev Emitted When A Bid Is Refunded (Kicked Back To Losing Bidder)\\n     */\\n    event BidRefunded(uint BidIndex);\\n\\n    /*--------------\\n     * CONSTRUCTOR *\\n    ---------------*/\\n\\n    constructor() \\n    {\\n        Admin[msg.sender] = true; // sets owner as admin\\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;\\n        Admin[0x90D98d5A1fD21B7cEa4D5c18341607ed1a8345c0] = true;\\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true;\\n        SaleState[0]._Active = true; // activates auction\\n        SaleState[0]._LastMinBid = 1 ether; // starts auction specified ETH value\\n        AuctionParams[0]._Name = 'Buenos Aires Artist Mint Packs'; // sets auction name\\n        AuctionParams[0]._SettlementEnabled = true; // enables rebate last price\\n        // AuctionParams[0]._UserSettlementEnabled = false; // enables self-service user auction settlement\\n        AuctionParams[0]._MintPackAmount = 10; // sets mint pass transfer amount\\n        AuctionParams[0]._LeaderboardSize = 25; // (max # of bids on leaderboard)\\n        AuctionParams[0]._UnixStartTime = block.timestamp; // sets auction start time\\n        AuctionParams[0]._UnixEndTime = block.timestamp + 694200 seconds; // sets auction end time\\n        AuctionParams[0]._MinBIPSIncrease = 105; // 5% Increase On Each Subsequent Bid After 50 Unique Bids\\n        AuctionParams[0]._SecondsExtension = 300 seconds; // # Of Seconds Of Extension\\n        AuctionParams[0]._SecondsThreshold = 300 seconds; // # Of Seconds Within Auction End Time Where Auction Extension Is Enabled\\n        AuctionParams[0]._Operator = msg.sender; // sets operator\\n        MerkleRootsEligibility[0].push(0xbb9d32f908b1b7ec4241468d3ec82305ac46bddc361b4da9a500625a5bed5986); // Merkle Root Priority Eligibility Full Set\\n        MerkleRootsEligibility[0].push(0xbb9d32f908b1b7ec4241468d3ec82305ac46bddc361b4da9a500625a5bed5986); // Merkle Root Priority Eligibility Citizen\\n        MerkleRootsAmounts[0].push(0xbb9d32f908b1b7ec4241468d3ec82305ac46bddc361b4da9a500625a5bed5986); // Merkle Root Priority Allocation Full Set\\n        MerkleRootsAmounts[0].push(0xbb9d32f908b1b7ec4241468d3ec82305ac46bddc361b4da9a500625a5bed5986); // Merkle Root Priority Allocation Citizen\\n        Discounts[0].push(80); // 20% Discount\\n        Discounts[0].push(90); // 10% Discount\\n    }\\n\\n    /*-----------------\\n     * USER FUNCTIONS *\\n    ------------------*/\\n    \\n    /**\\n     * @dev Submits A New Bid To The Auction\\n     * @param SaleIndex The Sale Index To Target\\n     * @param MaxAmount The Maximum Merkle Priority Allocation Amount | note: Input 0 If Not Applicable\\n     * @param Vault Optional delegate.xyz Integration | note: Input 0x0000000000000000000000000000000000000000 If No Delegate\\n     * @param ProofEligibility The Merkle Proof For The Bidder's Priority | note: Input [0x0000000000000000000000000000000000000000000000000000000000000000] If No Merkle Proof\\n     * @param ProofAmount The Merkle Proof For The Bidder's Priority Allocation | note: Input [0x0000000000000000000000000000000000000000000000000000000000000000] If No Merkle Proof\\n     */\\n    function NewBid ( uint SaleIndex, uint MaxAmount, address Vault, bytes32[] calldata ProofEligibility, bytes32[] calldata ProofAmount ) external payable nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(SaleState[SaleIndex]._Active, \\\"Auction: Auction Has Ended\\\"); // Requires The Auction Is Active\\n        require(block.timestamp >= AuctionParams[SaleIndex]._UnixStartTime, \\\"Auction: Auction Has Not Started\\\"); // Requires The Auction Has Started\\n        require(block.timestamp < AuctionParams[SaleIndex]._UnixEndTime, \\\"Auction: Auction Has Concluded\\\"); // Requires The Auction Has Not Ended\\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } // `delegate.cash` Integration\\n        __FinalizeNewBid(SaleIndex, msg.value); // Auto-Calculates The Required Reserve Price For The Bid (+5%)\\n        __CheckAndSeedAuctionEndTime(SaleIndex); // Checks If Auction End Time Should Be Extended And Extends If Necessary\\n        uint Priority = _ValidateMerkleProofs(SaleIndex, MaxAmount, Recipient, ProofEligibility, ProofAmount); // Validates Merkle Proof And Returns Merkle Priority\\n        uint CurrentBidIndex = SaleState[SaleIndex]._GlobalUniqueBids; // Current Bid Index\\n        Bids[SaleIndex][CurrentBidIndex] = Bid (\\n            CurrentBidIndex, // [0] -> Original Bid Index\\n            Priority,        // [1] -> Priority Of Bid (Merkle Rank)\\n            MaxAmount,       // [2] -> Allocation For Provided Priority Tier\\n            msg.value,       // [3] -> ETH Value Of Bid\\n            block.timestamp, // [4] -> Unix Timestamp Of Bid Confirmation\\n            msg.sender,      // [5] -> Wallet Address Of Bidder\\n            Recipient,       // [6] -> Wallet Address Of Vault (optional `delegate.cash` support)\\n            false,           // [7] -> If Bidder Rebated ETH From Bid\\n            false,           // [8] -> If Bidder Is A Winner (Top Placing) In The Auction\\n            false            // [9] -> If Bidder Has Received Their NFT\\n        ); // Registers New Bid\\n        UserBidIndexes[SaleIndex][msg.sender].push(CurrentBidIndex); // Appends Bid Index To User's Bid Indexes\\n        SaleState[SaleIndex]._GlobalUniqueBids = CurrentBidIndex + 1; // Increments Global Unique Bids\\n        emit NewBidComplete(CurrentBidIndex, msg.sender, msg.value, block.timestamp, Recipient); // Emits Bid Event\\n    }\\n\\n    /**\\n     * @dev Tops Up Bid(s) With Additional ETH\\n     * @param SaleIndex The Sale Index To Target\\n     * @param BidIndexes[] The Bid Indexes To Top Up\\n     * @param Amounts[] The Amounts (In WEI) To Top Up The Corresponding Bid Indexes By\\n     */\\n    function IncreaseBid ( uint SaleIndex, uint[] calldata BidIndexes, uint[] calldata Amounts ) external payable nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(SaleState[SaleIndex]._Active, \\\"Auction: Auction Has Ended\\\"); // Requires The Auction Is Active\\n        require(block.timestamp >= AuctionParams[SaleIndex]._UnixStartTime, \\\"Auction: Auction Has Not Started\\\"); // Requires The Auction Has Started\\n        require(block.timestamp < AuctionParams[SaleIndex]._UnixEndTime, \\\"Auction: Auction Has Concluded\\\"); // Requires The Auction Has Not Ended\\n        require(BidIndexes.length == Amounts.length, \\\"Auction: BidIndexes And Amounts Array Length Mismatch\\\"); // Requires BidIndexes And Amounts Length Match\\n        require(BidIndexes.length > 0, \\\"Auction: User Has Input No Bids To Top Up\\\"); // Requires User Has Bids To Top Up\\n        if(!AuctionParams[SaleIndex]._SettlementEnabled) { __CheckAndSeedAuctionEndTime(SaleIndex); } // Checks If Auction End Time Should Be Extended And Extends If Necessary\\n        Bid memory _Bid;\\n        uint Total;\\n        uint BidValue;\\n        for(uint x; x < BidIndexes.length; x++)\\n        { \\n            _Bid = Bids[SaleIndex][BidIndexes[x]];\\n            BidValue = _Bid._ETHValue;\\n            if(!_Bid._Rebated && !_Bid._Winner)\\n            {\\n                require(msg.sender == _Bid._Bidder, \\\"Auction: `msg.sender` Is Not The Bidder Of Desired Bid Index\\\");\\n                require(BidValue + Amounts[x] >= (BidValue * AuctionParams[SaleIndex]._MinBIPSIncrease) / 100, \\\"Auction: Bid Amount Topup Requires >= 5% Increase\\\");\\n                Bids[SaleIndex][BidIndexes[x]]._ETHValue += Amounts[x];\\n                Bids[SaleIndex][BidIndexes[x]]._Timestamp = block.timestamp;\\n                Total += Amounts[x];\\n                emit BidToppedUp(BidIndexes[x], Amounts[x], block.timestamp, msg.sender);\\n            }\\n        }\\n        require(msg.value >= Total, \\\"Auction: Invalid ETH Values\\\");\\n        uint Rebate = msg.value - Total; // Rebates Excess ETH (If Total > msg.value This Will Revert)\\n        if(Rebate > 0)\\n        {\\n            (bool Success, ) = msg.sender.call { value: Rebate }(\\\"\\\");\\n            require(Success, \\\"Auction: Failed To Rebate Excess ETH To Bidder, Resubmit Transaction\\\");\\n            emit BidTopupRefunded(Rebate);\\n        }\\n    }\\n\\n    /**\\n     * @dev Rebates ETH From Bid(s) If Bidder Is Not A Winner & Disperses NFTs If Winner\\n     * @param SaleIndex The Sale Index To Finalize\\n     */\\n    function UserSettleAuction ( uint SaleIndex ) external nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Have Been Dispersed\\\");\\n        require(AuctionParams[SaleIndex]._UserSettlementEnabled, \\\"Auction: User Settlement Is Not Enabled\\\");\\n        require(UserBidIndexes[SaleIndex][msg.sender].length > 0, \\\"Auction: User Has No Bids To Settle\\\");\\n        require(block.timestamp > AuctionParams[SaleIndex]._UnixEndTime, \\\"Auction: Cannot Finalize, Auction Is Still Active\\\");\\n        address Bidder = msg.sender;\\n        __UserDisperseETH(SaleIndex, Bidder);\\n        __UserDisperseNFT(SaleIndex, Bidder);\\n    }\\n\\n    /*------------------\\n     * ADMIN FUNCTIONS *\\n    -------------------*/\\n\\n    /**\\n     * @dev Starts Auction\\n     * @param AuctionInfo The Struct Of Auction Info \\n     * @param RootsEligibility The Merkle Roots For Priority Eligibility\\n     * @param RootsAmounts The Merkle Roots For Priority Allocation \\n     * @param DiscountAmounts The Discount Amounts For The Auction ([80,90] = 20% Discount, 10% Discount)\\n     */\\n    function __StartAuction (\\n        Params memory AuctionInfo, \\n        bytes32[] calldata RootsEligibility, \\n        bytes32[] calldata RootsAmounts,\\n        uint[] calldata DiscountAmounts\\n    ) external onlyAdmin returns (uint SaleIndex) { \\n        require(AuctionInfo._UnixStartTime > block.timestamp, \\\"Auction: Start Time Must Be In The Future\\\");\\n        require(RootsEligibility.length == RootsAmounts.length && RootsAmounts.length == DiscountAmounts.length, \\\"Auction: Array Lengths Must Match\\\");\\n        SaleIndex = _GLOBAL_UNIQUE_SALES;\\n        AuctionParams[SaleIndex] = AuctionInfo; \\n        SaleState[SaleIndex]._LastMinBid = AuctionParams[SaleIndex]._InitialMinimumBid;\\n        Discounts[SaleIndex] = DiscountAmounts;\\n        MerkleRootsEligibility[SaleIndex] = RootsEligibility;\\n        MerkleRootsAmounts[SaleIndex] = RootsAmounts;\\n        _GLOBAL_UNIQUE_SALES = SaleIndex + 1;\\n        for(uint x; x < DiscountAmounts.length; x++) { require(DiscountAmounts[x] <= 100, \\\"Invalid Discount Amount\\\"); }\\n        return SaleIndex;\\n    }\\n\\n    /**\\n     * @dev Changes The Sale Roots\\n     * @param SaleIndex The Sale Index To Change\\n     * @param RootsEligibility The New Merkle Roots For Priority Eligibility\\n     * @param RootsAmounts The New Merkle Roots For Max Priority Allocation\\n     */\\n    function ___ChangeRoots(uint SaleIndex, bytes32[] calldata RootsEligibility, bytes32[] calldata RootsAmounts) external onlyAdmin \\n    { \\n        MerkleRootsEligibility[SaleIndex] = RootsEligibility; \\n        MerkleRootsAmounts[SaleIndex] = RootsAmounts;\\n    }\\n\\n    /**\\n     * @dev Changes The Sale Discounts\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewDiscountAmounts The New Discount Amounts To Change\\n     */\\n    function ___ChangeDiscountAmounts(uint SaleIndex, uint[] calldata NewDiscountAmounts) external onlyAdmin { Discounts[SaleIndex] = NewDiscountAmounts; }\\n\\n    /**\\n     * @dev Changes The MintPass ProjectID\\n     * @param SaleIndex The Sale Index To Change\\n     * @param MintPassProjectID The New MintPass ProjectID To Change\\n     */\\n    function ___ChangeMintPassProjectID(uint SaleIndex, uint MintPassProjectID) external onlyAdmin { AuctionParams[SaleIndex]._ProjectIDMintPass = MintPassProjectID;}\\n\\n    /**\\n     * @dev Changes The Auction Global Pause State At `SaleIndex`\\n     * @param SaleIndex The Sale Index To Change\\n     */\\n    function ___ChangeActiveState(uint SaleIndex) external onlyAdmin { SaleState[SaleIndex]._Active = !SaleState[SaleIndex]._Active; }\\n\\n    /**\\n     * @dev Changes Min Bid\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewMinBid The New Minimum Bid \\n     */\\n    function ___ChangeMinBid(uint SaleIndex, uint NewMinBid) external onlyAdmin { SaleState[SaleIndex]._LastMinBid = NewMinBid; }\\n    \\n    /**\\n     * @dev Changes If The Lowest Valid Leaderboard Bid Is What Everyone Pays\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewState The New State (Boolean) (True = Everyone Pays Lowest Leaderboard Bid, False = Everyone Pays Their Bid ETH Value) \\n     */\\n    function ___ChangeSettlementEnabled(uint SaleIndex, bool NewState) external onlyAdmin { AuctionParams[SaleIndex]._SettlementEnabled = NewState; }\\n    \\n    /**\\n     * @dev Changes The Bid Threshold (Controls The Leaderboard Size)\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewLeaderboardSize The New Leaderboard Size\\n     */\\n    function ___ChangeLeaderboardSize(uint SaleIndex, uint NewLeaderboardSize) external onlyAdmin { AuctionParams[SaleIndex]._LeaderboardSize = NewLeaderboardSize; }\\n\\n    /**\\n     * @dev Changes The Unix Start Time\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewUnixStartTime The New Unix Start Time\\n     */\\n    function ___ChangeUnixStartTime(uint SaleIndex, uint NewUnixStartTime) external onlyAdmin { AuctionParams[SaleIndex]._UnixStartTime = NewUnixStartTime; }\\n\\n    /**\\n     * @dev Changes The Unix End Time\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewUnixEndTime The New Unix End Time\\n     */\\n    function ___ChangeUnixEndTime(uint SaleIndex, uint NewUnixEndTime) external onlyAdmin { AuctionParams[SaleIndex]._UnixEndTime = NewUnixEndTime; }\\n\\n    /**\\n     * @dev Changes The Minimum BIPs Increase\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewMinBIPSIncrease The New Minimum BIPs Increase (In BIPS) (105 = 5% Increase, 150 = 50% Increase etc...)\\n     */\\n    function ___ChangeMinBIPSIncrease(uint SaleIndex, uint NewMinBIPSIncrease) external onlyAdmin { AuctionParams[SaleIndex]._MinBIPSIncrease = NewMinBIPSIncrease; }\\n\\n    /**\\n     * @dev Changes The # Of Seconds The Auction Is Extended By If Auction End Time Is Within `AuctionParams[SaleIndex]._SecondsThreshold`\\n     * @param SaleIndex The Sale Index To Change\\n     * @param Seconds The New # Of Seconds To Extend Auction By\\n     */\\n    function ___ChangeSecondsExtension(uint SaleIndex, uint Seconds) external onlyAdmin { AuctionParams[SaleIndex]._SecondsExtension = Seconds; }\\n\\n    /**\\n     * @dev Changes The # Of Seconsd Within Auction End Time To Be Eligible For Auction Extension\\n     * @param SaleIndex The Sale Index To Change\\n     * @param Seconds The New # Of Seconds Within Auction End Time To Be Eligible For Auction Extension\\n     */\\n    function ___ChangeSecondsThreshold(uint SaleIndex, uint Seconds) external onlyAdmin { AuctionParams[SaleIndex]._SecondsThreshold = Seconds; }\\n\\n    /**\\n     * @dev Changes The Current NFT Address\\n     * @param SaleIndex The Sale Index To Change\\n     * @param NewAddress The New NFT Address\\n     */\\n    function ___ChangeNFTAddress(uint SaleIndex, address NewAddress) external onlyAdmin { AuctionParams[SaleIndex]._NFT = NewAddress; }\\n\\n    /**\\n     * @dev Changes The Current Operator Address (Address That Holds NFTs To Disperse)\\n     * @param SaleIndex The Sale Index To Change\\n     * @param Operator The New Operator Address (Address Holding NFTs To Disperse)\\n     */\\n    function ___ChangeOperator(uint SaleIndex, address Operator) external onlyAdmin { AuctionParams[SaleIndex]._Operator = Operator; }\\n\\n    /**\\n     * @dev Rebate All Unclaimed Bids & Sends Remaining ETH To Multisig\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ___InitiateRebateAndProceeds(uint SaleIndex) external onlyAdmin \\n    { \\n        SaleState[SaleIndex]._Active = false; // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n    }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (When TokenID Is Ambiguous)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ___ProcessETHAndNFTsTokenIDsAmbiguous(uint SaleIndex) external onlyAdmin\\n    {\\n        SaleState[SaleIndex]._Active = false;     // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex);       // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n        __DisperseNFTsByFCFSAmbiguous(SaleIndex); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)\\n    }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (Ascending Ranking) (When TokenID Matters)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ___ProcessETHAndNFTsTokenIDsDistinct(uint SaleIndex) external onlyAdmin\\n    {\\n        SaleState[SaleIndex]._Active = false;     // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex);       // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n        __DisperseNFTsByAscendingRank(SaleIndex); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)\\n    }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Specific TokenIDs (No Ranking)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ___ProcessETHAndNFTsTokenIDsSpecificUnranked(uint SaleIndex, uint[] calldata TokenIDs) external onlyAdmin\\n    {\\n        SaleState[SaleIndex]._Active = false;                // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex);                  // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n        __DisperseNFTsByUniqueTokenIDs(SaleIndex, TokenIDs); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)\\n    }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Specific TokenIDs (Ascending Ranking)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ___ProcessETHAndNFTsTokenIDsSpecificRanked(uint SaleIndex, uint[] calldata TokenIDs) external onlyAdmin\\n    {\\n        SaleState[SaleIndex]._Active = false;                         // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex);                           // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n        __DisperseNFTsByUniqueTokenIDsAscending(SaleIndex, TokenIDs); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)\\n    }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Mint Pack Amounts (Ascending Ranking)\\n     */\\n    function ___ProcessETHAndNFTsMintPacksRanked(uint SaleIndex) external onlyAdmin\\n    {\\n        SaleState[SaleIndex]._Active = false; // Ends Auction\\n        __AdminInitiateProceeds(SaleIndex);   // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)\\n        __DisperseNFTsMintPacks(SaleIndex);   // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)\\n    }\\n\\n    /*------------------\\n     * OWNER FUNCTIONS *\\n    -------------------*/\\n\\n    /**\\n     * @dev Adds An Admin\\n     * @param Wallet The Wallet To Add As An Admin\\n     */\\n    function ____AuthorizeAddress(address Wallet) external onlyOwner { Admin[Wallet] = true; }\\n\\n    /**\\n     * @dev Removes An Admin\\n     * @param Wallet The Wallet To Remove As An Admin\\n     */\\n    function ____DeuthorizeAddress(address Wallet) external onlyOwner { Admin[Wallet] = false; }\\n\\n    /**\\n     * @dev Initiates Withdrawl Proceeds For The Leaderboard\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function ____InitiateOnlyProceeds(uint SaleIndex) external onlyOwner { __AdminInitiateProceeds(SaleIndex); }\\n\\n    /**\\n     * @dev Withdraws All Ether From The Contract   \\n     * @notice This Is A Safety Function To Prevent Ether Locking, Only Use In An Emergency\\n     */\\n    function ____WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws Ether From Contract To Address With An Amount\\n     * @param Recipient The Recipient Of The Ether\\n     * @param Amount The Amount Of Ether To Withdraw (In WEI)\\n     * @notice This Is A Safety Function To Prevent Ether Locking, Only Use In An Emergency\\n     */\\n    function ____WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /*---------------------\\n     * INTERNAL FUNCTIONS *\\n    ----------------------*/\\n\\n    /**\\n     * @dev Calculates The Minimum Valid Bid And Seeds The Leaderboard\\n     * @param SaleIndex The Sale Index To Calculate The Minimum Valid Bid For\\n     * @param MsgValue The Message Value (In WEI) To Calculate The Minimum Valid Bid For\\n     */\\n    function __FinalizeNewBid(uint SaleIndex, uint MsgValue) internal\\n    {\\n        (uint MinBid, uint LeaderboardIndex) = _ViewMinimumValidBidAndIndex(SaleIndex);\\n        require(MsgValue >= MinBid, \\\"Auction: Bid Amount Must Be >= Current Leaderboard Floor * 1.05\\\"); // Requires Min Bid\\n        bool Valid = (SaleState[SaleIndex]._GlobalUniqueBids >= AuctionParams[SaleIndex]._LeaderboardSize);\\n        if(Valid) \\n        { \\n            __KickbackETH(SaleIndex, LeaderboardIndex); // Rebate ETH To Previous Bidder\\n            SaleState[SaleIndex]._LastMinBid = MinBid; // Stores Minimum Bid\\n        }\\n        Leaderboard[SaleIndex][LeaderboardIndex] = SaleState[SaleIndex]._GlobalUniqueBids; // Kicks Old Bid Index Out Of Leaderboard\\n    }\\n\\n    /**\\n     * @dev Kicks Losing Bidder's ETH Back To Them\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     * @param LeaderboardIndex The Leaderboard Index To Kickback ETH To\\n     */\\n    function __KickbackETH(uint SaleIndex, uint LeaderboardIndex) internal \\n    {\\n        if(!Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._Rebated)\\n        {\\n            Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._Rebated = true;\\n            (bool Success,) = Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._Bidder.call \\n            { value: Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._ETHValue }(\\\"\\\");\\n            require(Success, \\\"Auction: Kickback Failed\\\");\\n            emit BidRefunded(Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._OGBidIndex);\\n        } \\n    }\\n\\n    /**\\n     * @dev Finalizes ETH From User's Pending Bid(s)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     * @param Bidder The Bidder To Disperse ETH To\\n     */\\n    function __UserDisperseETH(uint SaleIndex, address Bidder) internal\\n    {\\n        uint[] memory _UserBidIndexes = UserBidIndexes[SaleIndex][Bidder];\\n        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);\\n        uint TotalRebate;\\n        uint TotalPaid;\\n        uint CurrentRebate;\\n        uint CurrentPaid;\\n        uint Discount;\\n        for(uint x; x < UserBidIndexes[SaleIndex][Bidder].length; x++) \\n        { \\n            if (\\n                !Bids[SaleIndex][_UserBidIndexes[x]]._Winner // Bid Is Not Winner\\n                && \\n                !Bids[SaleIndex][_UserBidIndexes[x]]._Rebated // Bid Has Not Been Rebated\\n                && \\n                Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue >= LLB // Bid Is Valid ETH Value\\n            )\\n            {\\n                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._Winner = true; \\n                if(Bids[SaleIndex][_UserBidIndexes[x]]._Priority != 69420) { Discount = Discounts[SaleIndex][Bids[SaleIndex][_UserBidIndexes[x]]._Priority]; }\\n                else { Discount = 100; }    \\n                if(AuctionParams[SaleIndex]._SettlementEnabled)\\n                {\\n                    Bids[SaleIndex][_UserBidIndexes[x]]._Rebated = true;\\n                    CurrentRebate = ((Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue - LLB) * Discount) / 100;\\n                    CurrentPaid = Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue - CurrentRebate;\\n                    TotalRebate += CurrentRebate;\\n                }\\n                else { CurrentPaid = Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue; }\\n                TotalPaid += (CurrentPaid * Discount) / 100;\\n            }\\n        }\\n        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call { value: TotalPaid }(\\\"\\\");\\n        require(MultisigWithdraw, \\\"Auction: Multisig Withdraw Failed\\\");\\n        if(TotalRebate > 0)\\n        {\\n            (bool UserWithdraw, ) = Bidder.call { value: TotalRebate }(\\\"\\\");\\n            require(UserWithdraw, \\\"Auction: User Withdraw Failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     * @param Bidder The Bidder To Disperse NFTs To\\n     */\\n    function __UserDisperseNFT(uint SaleIndex, address Bidder) internal\\n    {\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        for(uint x; x < UserBidIndexes[SaleIndex][Bidder].length; x++) \\n        { \\n            if(\\n                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._Winner \\n                && \\n                !Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._NFTSent\\n            )\\n            {\\n                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._NFTSent = true;\\n                _NFT._MintToFactory(Bidder, 1); \\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Initiates Proceeds From The Leaderboard\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function __AdminInitiateProceeds(uint SaleIndex) internal\\n    {\\n        uint TotalProceeds;\\n        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);\\n        uint RebateAmount;\\n        uint Discount;\\n        uint Priority;\\n        uint ETHValue;\\n        for(uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++)\\n        {\\n            if (\\n                !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Rebated \\n                && \\n                !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner \\n                && \\n                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue >= LLB\\n            ) {\\n                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner = true;\\n                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Rebated = true;\\n                Priority = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Priority;\\n                ETHValue = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue;\\n                if(Priority == 69420) { Discount = 100; } // No Merkle Priority\\n                else { Discount = Discounts[SaleIndex][Priority]; } // Merkle Priority\\n                if(AuctionParams[SaleIndex]._SettlementEnabled) { RebateAmount = ETHValue - ((LLB * Discount) / 100); }\\n                else { RebateAmount = ETHValue - ((ETHValue * Discount) / 100); }\\n                if(RebateAmount > 0)\\n                {\\n                    (bool Rebate, ) = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Bidder.call { value: RebateAmount }(\\\"\\\");                    \\n                    require(Rebate, \\\"Auction: Failed To Rebate ETH To Bidder, Use Failsafe Withdraw\\\");\\n                }\\n                TotalProceeds += (ETHValue - RebateAmount);\\n            }\\n        }\\n        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call { value: TotalProceeds }(\\\"\\\");\\n        require(MultisigWithdraw, \\\"Auction: Admin Failed To Withdraw ETH To Multisig, Use Failsafe Withdraw\\\");\\n    }\\n\\n    /**\\n     * @dev Validates The Auction End Time & Extends If Necessary\\n     * @param SaleIndex The Sale Index To Check\\n     */\\n    function __CheckAndSeedAuctionEndTime(uint SaleIndex) internal \\n    {\\n        // Extends Auction If Rebate Last Price (Settlement Price) Is Not Enabled (For Sales Where Leaderboard Placement Matters)\\n        if((AuctionParams[SaleIndex]._UnixEndTime - block.timestamp) < AuctionParams[SaleIndex]._SecondsThreshold) // If Bid Placed In Last 5 Minutes\\n        { \\n            AuctionParams[SaleIndex]._UnixEndTime = block.timestamp + AuctionParams[SaleIndex]._SecondsExtension; // Extends Auction By The # Of Configured Seconds \\n            emit AuctionExtended();\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs With Unique TokenIDs\\n     * @param TokenIDs Array Of TokenIDs To Be Dispersed\\n     */\\n    function __DisperseNFTsByUniqueTokenIDs(uint SaleIndex, uint[] calldata TokenIDs) internal\\n    {\\n        require(!SaleState[SaleIndex]._Active, \\\"Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First\\\");\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Already Dispersed\\\");\\n        require(TokenIDs.length == AuctionParams[SaleIndex]._LeaderboardSize, \\\"Auction: TokenIDs Array Length Must Match Leaderboard Size\\\");\\n        address _Op = AuctionParams[SaleIndex]._Operator;\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        for(uint x; x < TokenIDs.length; x++)\\n        {\\n            require(!NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]], \\\"Auction: TokenID Already Sent\\\");\\n            NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]] = true;\\n            _NFT.transferFrom(_Op, Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Bidder, TokenIDs[x]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs With Unique TokenIDs\\n     * @param TokenIDs Array Of TokenIDs To Be Dispersed\\n     */\\n    function __DisperseNFTsByUniqueTokenIDsAscending(uint SaleIndex, uint[] calldata TokenIDs) internal\\n    {\\n        require(!SaleState[SaleIndex]._Active, \\\"Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First\\\");\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Already Dispersed\\\");\\n        require(TokenIDs.length == AuctionParams[SaleIndex]._LeaderboardSize, \\\"Auction: TokenIDs Array Length Must Match Leaderboard Size\\\");\\n        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);\\n        address _Op = AuctionParams[SaleIndex]._Operator;\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        for(uint x; x < TokenIDs.length; x++)\\n        {\\n            require(!NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]], \\\"Auction: TokenID Already Sent\\\");\\n            NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]] = true;\\n            _NFT.transferFrom(_Op, Bids[SaleIndex][_Ind[x]]._Bidder, TokenIDs[x]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (Use When TokenID Is Ambiguous)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function __DisperseNFTsByFCFSAmbiguous(uint SaleIndex) internal\\n    {\\n        require(!SaleState[SaleIndex]._Active, \\\"Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First\\\");\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Already Dispersed\\\");\\n        SaleState[SaleIndex]._NFTsDispersed = true;\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        for(uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) \\n        { \\n            if(Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner && !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._NFTSent)\\n            {\\n                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._NFTSent = true;\\n                _NFT._MintToFactory(Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Bidder, 1); \\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs By Ascending Ranking Of The Leaderboard (Use When TokenID Matters)\\n     * @param SaleIndex The Sale Index To Trigger Disbursement\\n     */\\n    function __DisperseNFTsByAscendingRank(uint SaleIndex) internal\\n    {\\n        require(SaleState[SaleIndex]._Active == false, \\\"Auction: Auction Is Still Active, Must Disperse Funds First\\\");\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Already Dispersed\\\");\\n        SaleState[SaleIndex]._NFTsDispersed = true;\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);\\n        for(uint x; x < _Ind.length; x++)\\n        { \\n            if(Bids[SaleIndex][_Ind[x]]._Winner && !Bids[SaleIndex][_Ind[x]]._NFTSent)\\n            {\\n                Bids[SaleIndex][_Ind[x]]._NFTSent = true;\\n                _NFT._MintToFactory(Bids[SaleIndex][_Ind[x]]._Bidder, 1); \\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Disperses NFTs To The Top Bidders On The Leaderboard (With Mint Pack Amounts) (With Ranking Enabled)\\n     */\\n    function __DisperseNFTsMintPacks(uint SaleIndex) internal\\n    {\\n        require(!SaleState[SaleIndex]._Active, \\\"Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First\\\");\\n        require(!SaleState[SaleIndex]._NFTsDispersed, \\\"Auction: NFTs Already Dispersed\\\");\\n        require(AuctionParams[SaleIndex]._MintPackAmount > 1, \\\"Auction: Mint Pack Amount Must Be > 1\\\");\\n        SaleState[SaleIndex]._NFTsDispersed = true;\\n        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);\\n        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);\\n        uint _MintPackAmount = AuctionParams[SaleIndex]._MintPackAmount;\\n        for(uint x; x < _Ind.length; x++)\\n        {\\n            if(Bids[SaleIndex][_Ind[x]]._Winner && !Bids[SaleIndex][_Ind[x]]._NFTSent)\\n            {\\n                Bids[SaleIndex][_Ind[x]]._NFTSent = true;\\n                _NFT._MintToFactory(Bids[SaleIndex][_Ind[x]]._Bidder, _MintPackAmount); \\n            }\\n        }\\n    }\\n\\n    /*------------------------\\n     * PUBLIC VIEW FUNCTIONS *\\n    -------------------------*/\\n\\n    /**\\n     * @dev Returns All Necessary Leaderboard Components\\n     * @param SaleIndex The Sale Index To View\\n     * @param Wallet The Wallet Address Of The Bidder ('0x0000000000000000000000000000000000000000') If No Wallet\\n     */\\n    function ViewFrontend ( uint SaleIndex, address Wallet ) public view returns (\\n        uint _LLB, \\n        uint _MVB, \\n        AllAuctionParams memory _AuctionParams, \\n        Bid[] memory _RankedLeaderboard,\\n        Bid[] memory _MasterBids,\\n        uint[] memory _UserBidIndexes\\n    ) {\\n        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);\\n        _MasterBids = _ViewBidsUnique(SaleIndex);\\n        _RankedLeaderboard = _ViewLeaderboardRanked(SaleIndex);\\n        uint MVB = LLB * (AuctionParams[SaleIndex]._MinBIPSIncrease) / 100;\\n        if(SaleState[SaleIndex]._GlobalUniqueBids < AuctionParams[SaleIndex]._LeaderboardSize) \\n        { (LLB, MVB) = (SaleState[SaleIndex]._LastMinBid, SaleState[SaleIndex]._LastMinBid); }\\n        return (\\n            LLB,\\n            MVB,\\n            ViewAuctionParams(SaleIndex),\\n            ViewLeaderboardRanked(SaleIndex),\\n            _MasterBids,\\n            UserBidIndexes[SaleIndex][Wallet]\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns All Bid Values In The Leaderboard\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewLeaderboardBids(uint SaleIndex) public view returns (uint[] memory)\\n    {\\n        uint[] memory _Indexes = ViewLeaderboardIndexes(SaleIndex);\\n        uint[] memory _BidValues = new uint[](AuctionParams[SaleIndex]._LeaderboardSize);\\n        for(uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) { _BidValues[x] = Bids[SaleIndex][_Indexes[x]]._ETHValue; }\\n        return _BidValues;\\n    }\\n\\n    /**\\n     * @dev Returns A Bid Array Of Ranked Top Bids\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewLeaderboardRanked(uint SaleIndex) public view returns(Bid[] memory) { return _ViewLeaderboardRanked(SaleIndex); }\\n\\n    /**\\n     * @dev Returns All Bid Indexes In The Leaderboard\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewLeaderboardIndexes(uint SaleIndex) public view returns (uint[] memory)\\n    {\\n        uint[] memory _LeaderboardIndexes = new uint[](AuctionParams[SaleIndex]._LeaderboardSize);\\n        for(uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) { _LeaderboardIndexes[x] = Leaderboard[SaleIndex][x]; }\\n        return _LeaderboardIndexes;\\n    }\\n\\n    /**\\n     * @dev Returns The Minimum Valid Bid \\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewMinimumValidBid(uint SaleIndex) public view returns (uint ValidBid) \\n    { \\n        (ValidBid,) = _ViewMinimumValidBidAndIndex(SaleIndex);\\n        return ValidBid;\\n    }\\n\\n    /**\\n     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewBidsUnique(uint SaleIndex) public view returns ( Bid[] memory )\\n    {\\n        Bid[] memory _Bids = new Bid[](SaleState[SaleIndex]._GlobalUniqueBids);\\n        for(uint x; x < SaleState[SaleIndex]._GlobalUniqueBids; x++) { _Bids[x] = Bids[SaleIndex][x]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes\\n     * @param SaleIndex The Sale Index To View\\n     * @param Indexes The Indexes To Return\\n     */\\n    function ViewBidsAtIndexes(uint SaleIndex, uint[] calldata Indexes) public view returns(Bid[] memory) \\n    {\\n        Bid[] memory _Bids = new Bid[](Indexes.length);\\n        for(uint x; x < Indexes.length; x++) { _Bids[x] = Bids[SaleIndex][Indexes[x]]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns A `Bid` Struct Array Of All Unique Bids In The Auction Submitted By `Wallet`\\n     * @param SaleIndex The Sale Index To View\\n     * @param Wallet The Wallet Address To View\\n     */\\n    function ViewWalletBids(uint SaleIndex, address Wallet) public view returns(Bid[] memory)\\n    {\\n        uint[] memory _Indexes = UserBidIndexes[SaleIndex][Wallet];\\n        Bid[] memory _Bids = new Bid[](_Indexes.length);\\n        for(uint x; x < _Indexes.length; x++) { _Bids[x] = Bids[SaleIndex][_Indexes[x]]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of `Wallet` Submitted Bid Indexes\\n     * @param SaleIndex The Sale Index To View\\n     * @param Wallet The Wallet Address To View\\n     */\\n    function ViewWalletBidIndexes(uint SaleIndex, address Wallet) public view returns(uint[] memory) { return UserBidIndexes[SaleIndex][Wallet]; }\\n\\n    /**\\n     * @dev Returns All Of The Current Auction Parameters\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewAuctionParams(uint SaleIndex) public view returns (AllAuctionParams memory)\\n    {\\n        return AllAuctionParams (\\n            AuctionParams[SaleIndex]._Name,\\n            SaleState[SaleIndex]._Active,\\n            SaleState[SaleIndex]._NFTsDispersed,\\n            AuctionParams[SaleIndex]._SettlementEnabled,\\n            AuctionParams[SaleIndex]._LeaderboardSize,\\n            AuctionParams[SaleIndex]._UnixStartTime,\\n            AuctionParams[SaleIndex]._UnixEndTime,\\n            AuctionParams[SaleIndex]._MinBIPSIncrease,\\n            AuctionParams[SaleIndex]._SecondsExtension,\\n            AuctionParams[SaleIndex]._SecondsThreshold,\\n            SaleState[SaleIndex]._LastMinBid,\\n            SaleState[SaleIndex]._GlobalUniqueBids,\\n            AuctionParams[SaleIndex]._ProjectIDMintPass,\\n            AuctionParams[SaleIndex]._MintPackAmount,\\n            AuctionParams[SaleIndex]._NFT\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns Merkle Roots For A Specific Sale\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function ViewRoots(uint SaleIndex) public view returns (bytes32[] memory) { return MerkleRootsEligibility[SaleIndex]; }\\n\\n    /*--------------------------\\n     * INTERNAL VIEW FUNCTIONS *\\n    ---------------------------*/\\n\\n    /**\\n     * @dev Validates Merkle Proof And Returns Merkle Priority\\n     * @param SaleIndex The Sale Index To View\\n     * @param MaxAmount The Maximum Allocation For Merkle Priority\\n     * @param Bidder The Bidder To Validate\\n     * @param ProofEligibility The Merkle Proof To Validate For Priority Eligibilty Tier\\n     * @param ProofAmount The Merkle Proof To Validate For Maximum Merkle Amount\\n     */\\n    function _ValidateMerkleProofs (\\n        uint SaleIndex, \\n        uint MaxAmount, \\n        address Bidder, \\n        bytes32[] calldata ProofEligibility, \\n        bytes32[] calldata ProofAmount\\n    ) internal view returns (uint) {\\n        bytes32 Leaf = keccak256(abi.encodePacked(Bidder));\\n        for(uint Priority; Priority < MerkleRootsEligibility[SaleIndex].length; Priority++) \\n        { \\n            if(MerkleProof.verify(ProofEligibility, MerkleRootsEligibility[SaleIndex][Priority], Leaf))\\n            {\\n                require (\\n                    MerkleProof.verify (\\n                        ProofAmount, \\n                        MerkleRootsAmounts[SaleIndex][Priority], \\n                        keccak256(abi.encodePacked(Bidder, MaxAmount))\\n                    ), \\n                    \\\"Auction: Invalid Merkle Amount\\\"\\n                );\\n                return ( Priority ); // Returns Valid Priority\\n            } \\n        }\\n        return ( 69420 ); // Returns Default Out Of Bounds Priority\\n    }\\n\\n    /**\\n     * @dev Returns The Leaderboard Index Of The Smallest Bid In The Leaderboard \\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function _ViewMinimumValidLeaderboardIndex(uint SaleIndex) internal view returns (uint)\\n    {\\n        uint CurrentMinBid = type(uint).max;\\n        uint LeaderboardIndexToReplace;\\n        uint ETHValue;\\n        if(SaleState[SaleIndex]._GlobalUniqueBids < AuctionParams[SaleIndex]._LeaderboardSize) { return SaleState[SaleIndex]._GlobalUniqueBids; }\\n        for(uint IndexLeaderboard; IndexLeaderboard < AuctionParams[SaleIndex]._LeaderboardSize; IndexLeaderboard++)\\n        {\\n            ETHValue = Bids[SaleIndex][Leaderboard[SaleIndex][IndexLeaderboard]]._ETHValue;\\n            if(ETHValue <= CurrentMinBid)\\n            { \\n                CurrentMinBid = ETHValue;\\n                LeaderboardIndexToReplace = IndexLeaderboard; \\n            }\\n        }\\n        return LeaderboardIndexToReplace;\\n    }\\n\\n    /**\\n     * @dev Returns The Lowest Bid In The Leaderboard\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function _ViewLowestLeaderboardBid(uint SaleIndex) internal view returns (uint LLB)\\n    {\\n        LLB = type(uint).max;\\n        for(uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++)\\n        {\\n            if(Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue < LLB) { LLB = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue; }\\n        }\\n        return LLB;\\n    }\\n\\n    /**\\n     * @dev Returns The Minimum Valid Bid Which Is The Current Lowest Bid In The Leaderboard * 1.05\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function _ViewMinimumValidBidAndIndex(uint SaleIndex) internal view returns (uint, uint) \\n    {\\n        uint LeaderboardIndex = _ViewMinimumValidLeaderboardIndex(SaleIndex);\\n        return (        \\n            SaleState[SaleIndex]._GlobalUniqueBids < AuctionParams[SaleIndex]._LeaderboardSize \\n            ? // If Unique Bids Less Than LeaderboardSize Return NewMinimumBid & Eligible LeaderboardIndex\\n            (SaleState[SaleIndex]._LastMinBid, LeaderboardIndex) \\n            : // Else Return NewMinimumBid & Eligible LeaderboardIndex\\n            ((Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._ETHValue * AuctionParams[SaleIndex]._MinBIPSIncrease) / 100, LeaderboardIndex) \\n        );\\n    }\\n\\n    /**\\n     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction\\n     * @param SaleIndex The Sale Index To View\\n     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids\\n     */\\n    function _ViewBidsUnique(uint SaleIndex) internal view returns(Bid[] memory)\\n    {\\n        uint GlobalUniqueBids = SaleState[SaleIndex]._GlobalUniqueBids;\\n        Bid[] memory _Bids = new Bid[](GlobalUniqueBids);\\n        for(uint x; x < GlobalUniqueBids; x++) { _Bids[x] = Bids[SaleIndex][x]; }\\n        return _Bids;\\n    }\\n    \\n    /**\\n     * @dev Returns A Bid Array Of Ranked Top Bids\\n     * @param SaleIndex The Sale Index To View\\n     */\\n    function _ViewLeaderboardRanked(uint SaleIndex) internal view returns(Bid[] memory)\\n    {\\n        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);\\n        Bid[] memory _Leaderboard = new Bid[](_Ind.length);\\n        for(uint x; x < _Ind.length; x++) { _Leaderboard[x] = Bids[SaleIndex][_Ind[x]]; }\\n        return _Leaderboard;\\n    }\\n\\n    /**\\n     * @dev Returns A Sorted List Of ETH Bids @ '[n][0]' & The Indexes Of The Original Bids @ '[n][1]' & The Timestamps @ '[n][2]'\\n     * @param SaleIndex The Sale Index To View\\n     * note: This Will Give Priority To Earlier Bid Indexes & Timestamps\\n     * note: insertion sort O(n^2) seemed like best approach because english auction bids increase as auction progresses, otherwise quicksort prob better O(nlogn)\\n     * note: because block gas limit is 30M, this will `out-of-gas` dependant on how much sorting needs done if you have a more eloquent way of doing this hmu\\n     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes\\n     */\\n    function _ViewSortedLeaderboardBidIndexes(uint SaleIndex) internal view returns (uint[] memory)\\n    {\\n        uint Size;\\n        if(SaleState[SaleIndex]._GlobalUniqueBids < AuctionParams[SaleIndex]._LeaderboardSize) { Size = SaleState[SaleIndex]._GlobalUniqueBids; }\\n        else { Size = AuctionParams[SaleIndex]._LeaderboardSize; }\\n        uint[][] memory BidsAndIndexes = new uint[][](Size);\\n        for(uint x; x < BidsAndIndexes.length; x++) \\n        {\\n            BidsAndIndexes[x] = new uint[](3);                      // Init Sub-Array\\n            BidsAndIndexes[x][0] = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue;  // Assign [x][0] -> ETHValue\\n            BidsAndIndexes[x][1] = Leaderboard[SaleIndex][x];                  // Assign [x][1] -> Original Index\\n            BidsAndIndexes[x][2] = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Timestamp; // Assign [x][2] -> Timestamp\\n        }\\n        for(uint i; i < BidsAndIndexes.length; i++)\\n        {\\n            uint ETHValue = BidsAndIndexes[i][0];   // Preserve ETHValue\\n            uint OGBidIndex = BidsAndIndexes[i][1]; // Preserve OGBidIndex\\n            uint Timestamp = BidsAndIndexes[i][2];  // Preserve Timestamp\\n            uint j = i;\\n            while(j > 0 && BidsAndIndexes[j-1][0] >= ETHValue)\\n            {\\n                if(\\n                    BidsAndIndexes[j-1][0] == ETHValue && BidsAndIndexes[j-1][1] > OGBidIndex // Preserve Lower Original Index\\n                    ||\\n                    BidsAndIndexes[j-1][0] == ETHValue && BidsAndIndexes[j-1][2] > Timestamp  // Preserve Lower Timestamp\\n                ) { break; } \\n                BidsAndIndexes[j][0] = BidsAndIndexes[j-1][0]; // Move Larger Element To The Right\\n                BidsAndIndexes[j][1] = BidsAndIndexes[j-1][1]; // Move OG Index\\n                BidsAndIndexes[j][2] = BidsAndIndexes[j-1][2]; // Move Timestamp\\n                j--;\\n            }\\n            BidsAndIndexes[j][0] = ETHValue;   // Insert ETHValue In Correct Location\\n            BidsAndIndexes[j][1] = OGBidIndex; // Insert OGBidIndex In Correct Location\\n            BidsAndIndexes[j][2] = Timestamp;  // Insert Timestamp In Correct Location\\n        } \\n        uint[] memory SortedBidIndexes = new uint[](Size);\\n        for(uint y; y < BidsAndIndexes.length; y++) { SortedBidIndexes[Size - 1 - y] = BidsAndIndexes[y][1]; }\\n        return SortedBidIndexes;\\n    }\\n\\n    /**\\n     * @dev onlyAdmin Modifier\\n     */\\n    modifier onlyAdmin\\n    {\\n        require(Admin[msg.sender], \\\"Auction: onlyAdmin: Caller Is Not Admin\\\");\\n        _;\\n    }\\n}\\n\\n/**\\n * @dev Interface For ERC721 Contracts\\n */\\ninterface IERC721 \\n{ \\n    /**\\n     * @dev Mints A NFT From Custom Smart Contract Directly\\n     */\\n    function _MintToFactory(address Recipient, uint Amount) external; \\n\\n    /**\\n     * @dev Transfers An Already Minted NFT\\n     */\\n    function transferFrom(address from, address to, uint tokenID) external;\\n}\"\r\n    },\r\n    \"contracts/DelegateCashEnabled.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @title DelegateCashEnabled\\n * @author @brougkr\\n * @notice For Easily Integrating `delegate.cash`\\n */\\npragma solidity 0.8.19;\\nabstract contract DelegateCashEnabled\\n{\\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;\\n    IDelegation public constant DelegateCash = IDelegation(_DN);\\n}\\n\\ninterface IDelegation\\n{\\n    /**\\n     * @dev Returns If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AuctionExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BidIndex\",\"type\":\"uint256\"}],\"name\":\"BidReclaimFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BidIndex\",\"type\":\"uint256\"}],\"name\":\"BidReclaimSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BidIndex\",\"type\":\"uint256\"}],\"name\":\"BidRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BidIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ETHForBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Unixtimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Bidder\",\"type\":\"address\"}],\"name\":\"BidToppedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Rebate\",\"type\":\"uint256\"}],\"name\":\"BidTopupRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BidIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MessageValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Unixtimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Vault\",\"type\":\"address\"}],\"name\":\"NewBidComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AuctionParams\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_Name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_SettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_UserSettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_LeaderboardSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MinBIPSIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_InitialMinimumBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectIDMintPass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPackAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Bids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DelegateCash\",\"outputs\":[{\"internalType\":\"contract IDelegation\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Discounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"BidIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Amounts\",\"type\":\"uint256[]\"}],\"name\":\"IncreaseBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Leaderboard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MerkleRootsAmounts\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MerkleRootsEligibility\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NFTTokenIDHasBeenSent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Vault\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"ProofEligibility\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ProofAmount\",\"type\":\"bytes32[]\"}],\"name\":\"NewBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PriorityPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SaleState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_Active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTsDispersed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_LastMinBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalUniqueBids\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UserBidIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"UserSettleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewAuctionParams\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"_Name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_Active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTsDispersed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_SettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_LeaderboardSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MinBIPSIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_LastMinBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalUniqueBids\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectIDMintPass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPackAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"internalType\":\"struct AuctionMarketplace.AllAuctionParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"Indexes\",\"type\":\"uint256[]\"}],\"name\":\"ViewBidsAtIndexes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewBidsUnique\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"ViewFrontend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_LLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MVB\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"_Name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_Active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTsDispersed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_SettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_LeaderboardSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MinBIPSIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_LastMinBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalUniqueBids\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectIDMintPass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPackAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"internalType\":\"struct AuctionMarketplace.AllAuctionParams\",\"name\":\"_AuctionParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"_RankedLeaderboard\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"_MasterBids\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_UserBidIndexes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewLeaderboardBids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewLeaderboardIndexes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewLeaderboardRanked\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewMinimumValidBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ValidBid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"ViewRoots\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"ViewWalletBidIndexes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"ViewWalletBids\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_OGBidIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ETHValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Rebated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_Winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_NFTSent\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionMarketplace.Bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GLOBAL_UNIQUE_SALES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"_Name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_SettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_UserSettlementEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_LeaderboardSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_UnixEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MinBIPSIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SecondsThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_InitialMinimumBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectIDMintPass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPackAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"}],\"internalType\":\"struct AuctionMarketplace.Params\",\"name\":\"AuctionInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"RootsEligibility\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"RootsAmounts\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"DiscountAmounts\",\"type\":\"uint256[]\"}],\"name\":\"__StartAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"___ChangeActiveState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"NewDiscountAmounts\",\"type\":\"uint256[]\"}],\"name\":\"___ChangeDiscountAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewLeaderboardSize\",\"type\":\"uint256\"}],\"name\":\"___ChangeLeaderboardSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewMinBIPSIncrease\",\"type\":\"uint256\"}],\"name\":\"___ChangeMinBIPSIncrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewMinBid\",\"type\":\"uint256\"}],\"name\":\"___ChangeMinBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MintPassProjectID\",\"type\":\"uint256\"}],\"name\":\"___ChangeMintPassProjectID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"NewAddress\",\"type\":\"address\"}],\"name\":\"___ChangeNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Operator\",\"type\":\"address\"}],\"name\":\"___ChangeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"RootsEligibility\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"RootsAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"___ChangeRoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Seconds\",\"type\":\"uint256\"}],\"name\":\"___ChangeSecondsExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Seconds\",\"type\":\"uint256\"}],\"name\":\"___ChangeSecondsThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"NewState\",\"type\":\"bool\"}],\"name\":\"___ChangeSettlementEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewUnixEndTime\",\"type\":\"uint256\"}],\"name\":\"___ChangeUnixEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewUnixStartTime\",\"type\":\"uint256\"}],\"name\":\"___ChangeUnixStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"___InitiateRebateAndProceeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"___ProcessETHAndNFTsMintPacksRanked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"___ProcessETHAndNFTsTokenIDsAmbiguous\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"___ProcessETHAndNFTsTokenIDsDistinct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"TokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"___ProcessETHAndNFTsTokenIDsSpecificRanked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"TokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"___ProcessETHAndNFTsTokenIDsSpecificUnranked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"____AuthorizeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"____DeuthorizeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"____InitiateOnlyProceeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"____WithdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"Recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"____WithdrawEtherToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AuctionMarketplace", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}