{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Authorizers/Authorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.25;\\n\\n/**\\n * @dev Required interface of an Authorizer compliant contract for the SCI IRegistry.sol.\\n * @custom:security-contact security@sci.domains\\n */\\ninterface Authorizer {\\n    /**\\n     * @dev Validates if an address is authorized to register a domain.\\n     * @param sender The address trying to register the domain.\\n     * @param domainHash The name hash of the domain.\\n     * @return a bool indicating whether the sender is authorizer or not.\\n     */\\n    function isAuthorized(address sender, bytes32 domainHash) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Ens/INameHash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.25;\\n\\n/**\\n * @dev External interface of NameHash declared to support EIP-137 namehash algorithm for domains.\\n * @custom:security-contact security@sci.domains\\n */\\ninterface INameHash {\\n    /**\\n     * @dev Transforms a domain into a domain hash using the namehash algorithm specified in the EIP-137\\n     * @param domain a string representation of a domain (example.com)\\n     * @return a bytes32 representation of the namehash algorithm applied to the domain.\\n     * For example.com it will return 0xf59ba973941fd531b0702df2592a8480fd9f28516c50a93626e652a8ce263832.\\n     */\\n    function getDomainHash(string memory domain) external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/Registry/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.25;\\n\\nimport {Authorizer} from '../Authorizers/Authorizer.sol';\\nimport {Verifier} from '../Verifiers/Verifier.sol';\\n\\n/**\\n * @custom:security-contact security@sci.domains\\n */\\ninterface IRegistry {\\n    /**\\n     * @dev Emitted when a new `domain` with the `domainHash` is\\n     * registered by the `owner` using the authorizer with id `authorizerId`.\\n     */\\n    event DomainRegistered(\\n        uint256 indexed authorizerId,\\n        address indexed owner,\\n        bytes32 indexed domainHash,\\n        string domain\\n    );\\n\\n    /**\\n     * @dev Emitted when the `owner` of the `domainHash` adds a `verifier`.\\n     *\\n     * NOTE: This will also be emitted when the verifier is changed.\\n     */\\n    event VerifierSet(address indexed owner, bytes32 domainHash, Verifier indexed verifier);\\n\\n    /**\\n     * @dev Emitted when the owner of a `domainHash` is set.\\n     *\\n     */\\n    event OwnerSet(address indexed msgSender, bytes32 domainHash, address indexed owner);\\n\\n    /**\\n     * @dev Emitted when the `msgSender` adds and `authorizer` with id `authorizerId`.\\n     *\\n     * NOTE: This will also be emitted when the authorizer is changed for an existing id.\\n     */\\n    event AuthorizerSet(uint256 indexed authorizerId, Authorizer authorizer, address msgSender);\\n\\n    /**\\n     * @dev Thrown when the `account` is not authorized to register the domain with namehash `domainHash`.\\n     */\\n    error AccountIsNotAuthorizeToRegisterDomain(address account, bytes32 domainHash);\\n\\n    /**\\n     * @dev Returns the owner, the verifier, lastOwnerSetTime and lastVerifierSetTime\\n     * for a given domainHash.\\n     * @param domainHash The name hash of the domain\\n     */\\n    function domainHashToRecord(\\n        bytes32 domainHash\\n    )\\n        external\\n        view\\n        returns (\\n            address owner,\\n            Verifier verifier,\\n            uint256 lastOwnerSetTime,\\n            uint256 lastVerifierSetTime\\n        );\\n\\n    /**\\n     * @dev Register a domain.\\n     *\\n     * @param authorizerId The id of the authorizer being used.\\n     * @param owner The owner of the domain.\\n     * @param domain The domain being registered (example.com).\\n     * @param isWildcard If you are registering a wildcard to set a verifier for all subdomains.\\n     *\\n     * NOTE: If wildcard is true then it registers the name hash of `*.domain`.\\n     *\\n     * Requirements:\\n     *\\n     * - the owner must be authorized by the authorizer.\\n     *\\n     * May emit a {DomainRegistered} event.\\n     */\\n    function registerDomain(\\n        uint256 authorizerId,\\n        address owner,\\n        string memory domain,\\n        bool isWildcard\\n    ) external;\\n\\n    /**\\n     * @dev Same as registerDomain but it also adds a verifier.\\n     *\\n     * @param authorizerId The id of the authorizer being used.\\n     * @param domain The domain being registered (example.com).\\n     * @param isWildcard if you are registering a wildcard to set a verifier for all subdomains.\\n     * @param verifier the verifier that is being set for the domain.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be authorized by the authorizer.\\n     *\\n     * May emit a {DomainRegistered} and a {VerifierAdded} events.\\n     */\\n    function registerDomainWithVerifier(\\n        uint256 authorizerId,\\n        string memory domain,\\n        bool isWildcard,\\n        Verifier verifier\\n    ) external;\\n\\n    /**\\n     * @dev Returns true if the account is the owner of the domainHash.\\n     */\\n    function isDomainOwner(bytes32 domainHash, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the owner of the domainHash.\\n     * @param domainHash The name hash of the domain\\n     * @return the address of the owner or the ZERO_ADDRESS if the domain is not registered\\n     */\\n    function domainOwner(bytes32 domainHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the verifier of the domainHash.\\n     * @param domainHash The name hash of the domain\\n     * @return the address of the verifier or the ZERO_ADDRESS if the domain or\\n     * the verifier are not registered\\n     */\\n    function domainVerifier(bytes32 domainHash) external view returns (Verifier);\\n\\n    /**\\n     * @dev Returns the timestamp of the block where the verifier was set.\\n     * @param domainHash The name hash of the domain\\n     * @return the timestamp of the block where the verifier was set or\\n     * 0 if it wasn't\\n     */\\n    function domainVerifierSetTime(bytes32 domainHash) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a verifier to the domain hash.\\n     * @param domainHash The name hash of the domain\\n     * @param verifier The address of the verifier contract\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner of the domain.\\n     *\\n     * May emit a {VerifierAdded} event.\\n     *\\n     * NOTE: If you want to remove a verifier you can set it to the ZERO_ADDRESS\\n     */\\n    function setVerifier(bytes32 domainHash, Verifier verifier) external;\\n\\n    /**\\n     * @dev Sets an authorizer with id `authorizerId`.\\n     * @param authorizerId The id of the authorizer\\n     * @param authorizer The address of the authorizer contract\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the ADD_AUTHORIZER_ROLE role.\\n     *\\n     * May emit a {AuthorizerAdded} event.\\n     *\\n     * NOTE: If you want to remove an authorizer you can set it to the ZERO_ADDRESS\\n     */\\n    function setAuthorizer(uint256 authorizerId, Authorizer authorizer) external;\\n}\\n\"\r\n    },\r\n    \"contracts/SCI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.25;\\n\\nimport {Verifier} from './Verifiers/Verifier.sol';\\nimport {IRegistry} from './Registry/IRegistry.sol';\\nimport {INameHash} from './Ens/INameHash.sol';\\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\n/**\\n * @custom:security-contact security@sci.domains\\n */\\ncontract SCI is Initializable {\\n    IRegistry public registry;\\n    INameHash public nameHashUtils;\\n\\n    function initialize(address registryAddress, address nameHashAddress) external initializer {\\n        registry = IRegistry(registryAddress);\\n        nameHashUtils = INameHash(nameHashAddress);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the domainHash.\\n     * @param domainHash The name hash of the domain.\\n     * @return the address of the owner or the ZERO_ADDRESS if the domain is not registered.\\n     */\\n    function domainOwner(bytes32 domainHash) public view returns (address) {\\n        return registry.domainOwner(domainHash);\\n    }\\n\\n    /**\\n     * @dev Returns if the `contractAddress` deployed in the chain with id `chainId` is verified.\\n     * to interact with the domain with name hash `domainHash`.\\n     * @param domainHash The name hash of the domain the contract is interacting with\\n     * @param contractAddress The address of the contract is being verified.\\n     * @param chainId The id of the chain the contract is deployed in.\\n     * @return a bool indicating whether the contract is verified or not.\\n     *\\n     * NOTE: If there is no verifier set then it returns false.\\n     */\\n    function isVerifiedForDomainHash(\\n        bytes32 domainHash,\\n        address contractAddress,\\n        uint256 chainId\\n    ) public view returns (bool) {\\n        (, Verifier verifier, , ) = registry.domainHashToRecord(domainHash);\\n\\n        if (address(verifier) == address(0)) {\\n            return false;\\n        }\\n\\n        return verifier.isVerified(domainHash, contractAddress, chainId);\\n    }\\n\\n    /**\\n     * @dev Same as isVerifiedForDomainHash but for multiple domains.\\n     * This is useful to check for subdomains and wildcard verification.\\n     * For example: subdomain.example.com and *.example.com.\\n     *\\n     * @param domainHashes An array of domain hashes.\\n     * @param contractAddress The address of the contract is being verified.\\n     * @param chainId The id of the chain the contract is deployed in.\\n     * @return an array of bool indicating whether the contract address is\\n     * verified for each domain hash or not.\\n     *\\n     * NOTE: If there is no verifier set then it returns false for that `domainHash`.\\n     */\\n    function isVerifiedForMultipleDomainHashes(\\n        bytes32[] memory domainHashes,\\n        address contractAddress,\\n        uint256 chainId\\n    ) external view returns (bool[] memory) {\\n        bool[] memory domainsVerification = new bool[](domainHashes.length);\\n        uint256 domainHashesLength = domainHashes.length;\\n        for (uint256 i; i < domainHashesLength; ) {\\n            domainsVerification[i] = isVerifiedForDomainHash(\\n                domainHashes[i],\\n                contractAddress,\\n                chainId\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return domainsVerification;\\n    }\\n\\n    /**\\n     * @dev Same as isVerifiedForMultipleDomainHashes but receives the domains\\n     * and apply the name hash algorithm to them\\n     *\\n     * @param domains An array of domains.\\n     * @param contractAddress The address of the contract is being verified.\\n     * @param chainId The id of the chain the contract is deployed in.\\n     * @return an array of bool indicating whether the contract address is verified for each domain or not.\\n\\n     * NOTE: If there is no verifier set then it returns false for that `domain`.\\n     */\\n    function isVerifiedForMultipleDomains(\\n        string[] memory domains,\\n        address contractAddress,\\n        uint256 chainId\\n    ) external view returns (bool[] memory) {\\n        bool[] memory domainsVerification = new bool[](domains.length);\\n        uint256 domainsLength = domains.length;\\n        for (uint256 i; i < domainsLength; ) {\\n            domainsVerification[i] = isVerifiedForDomainHash(\\n                nameHashUtils.getDomainHash(domains[i]),\\n                contractAddress,\\n                chainId\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return domainsVerification;\\n    }\\n\\n    /**\\n    * @dev Same as isVerifiedForDomainHash but receives the domain and apply the name hash algorithm to them\\n     *\\n     * @param domain the domain the contract is interacting with.\\n     * @param contractAddress The address of the contract is being verified.\\n     * @param chainId The id of the chain the contract is deployed in.\\n     * @return a bool indicating whether the contract address is verified for the domain or not.\\n\\n     * NOTE: If there is no verifier set then it returns false.\\n     */\\n    function isVerifiedForDomain(\\n        string memory domain,\\n        address contractAddress,\\n        uint256 chainId\\n    ) public view returns (bool) {\\n        return\\n            isVerifiedForDomainHash(nameHashUtils.getDomainHash(domain), contractAddress, chainId);\\n    }\\n\\n    /**\\n     * @dev Returns info from the domain\\n     *\\n     * @param domain The domain you want to get information from\\n     */\\n    function domainToRecord(\\n        string calldata domain\\n    )\\n        external\\n        view\\n        returns (\\n            address owner,\\n            Verifier verifier,\\n            uint256 lastOwnerSetTime,\\n            uint256 lastVerifierSetTime\\n        )\\n    {\\n        return registry.domainHashToRecord(nameHashUtils.getDomainHash(domain));\\n    }\\n\\n    /**\\n     * @dev Returns info from the domain\\n     *\\n     * @param domainHash The name hash of the domain\\n     */\\n    function domainHashToRecord(\\n        bytes32 domainHash\\n    )\\n        external\\n        view\\n        returns (\\n            address owner,\\n            Verifier verifier,\\n            uint256 lastOwnerSetTime,\\n            uint256 lastVerifierSetTime\\n        )\\n    {\\n        return registry.domainHashToRecord(domainHash);\\n    }\\n\\n    // This is a temporary function until we change to the new SCI\\n    function setRegistry() public {\\n        registry = IRegistry(0x5f613920dc691b6177F2123eD2D27F00a3B5748b);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Verifiers/Verifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.25;\\n\\n/**\\n * @dev Required interface of a Verifier compliant contract for the SCI IRegistry.sol.\\n * @custom:security-contact security@sci.domains\\n */\\ninterface Verifier {\\n    /**\\n     * @dev Verifies if a contract in a specific chain is authorized\\n     * to interact within a domain.\\n     * @param domainHash The domain's name hash.\\n     * @param contractAddress The address of the contract trying to be verified.\\n     * @param chainId The chain where the contract is deployed.\\n     * @return a bool indicating whether the sender is authorizer or not.\\n     */\\n    function isVerified(\\n        bytes32 domainHash,\\n        address contractAddress,\\n        uint256 chainId\\n    ) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"domainHashToRecord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract Verifier\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastOwnerSetTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastVerifierSetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"domainOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"domainToRecord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract Verifier\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastOwnerSetTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastVerifierSetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nameHashAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"isVerifiedForDomain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"isVerifiedForDomainHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"domainHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"isVerifiedForMultipleDomainHashes\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"domains\",\"type\":\"string[]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"isVerifiedForMultipleDomains\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameHashUtils\",\"outputs\":[{\"internalType\":\"contract INameHash\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SCI", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}