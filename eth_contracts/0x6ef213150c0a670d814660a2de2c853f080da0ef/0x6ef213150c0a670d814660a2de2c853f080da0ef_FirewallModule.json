{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/gnosis-safe/FirewallModule.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.19;\\n\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface GnosisSafe {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n}\\n\\ncontract FirewallModule {\\n\\n    mapping (address => bool) public approvedDeployers;\\n    mapping (address => bool) public approvedFirewalls;\\n\\n    bytes4 private constant APPROVE_SELECTOR = bytes4(keccak256(\\\"setPolicyStatus(address,bool)\\\"));\\n\\n    address public gnosisSafe;\\n\\n    constructor(\\n        address _gnosisSafe,\\n        address[] memory _approvedFirewalls\\n    ) {\\n        gnosisSafe = _gnosisSafe;\\n        for (uint i = 0; i < _approvedFirewalls.length; i++) {\\n            approvedFirewalls[_approvedFirewalls[i]] = true;\\n        }\\n    }\\n\\n    function approvePolicy(address policy, address firewall) external {\\n        require(approvedDeployers[msg.sender], \\\"FirewallModule: not approved deployer\\\");\\n        require(approvedFirewalls[firewall], \\\"FirewallModule: not approved firewall\\\");\\n        bytes memory data = abi.encodeWithSelector(APPROVE_SELECTOR, policy, true);\\n        require(GnosisSafe(gnosisSafe).execTransactionFromModule(firewall, 0, data, Enum.Operation.Call), \\\"Could not execute\\\");\\n    }\\n\\n    function setDeployersStatus(address[] calldata deployers, bool status) external {\\n        require(msg.sender == gnosisSafe, \\\"FirewallModule: only safe\\\");\\n        for (uint i = 0; i < deployers.length; i++) {\\n            approvedDeployers[deployers[i]] = status;\\n        }\\n    }\\n\\n    function setFirewallsStatus(address[] calldata firewalls, bool status) external {\\n        require(msg.sender == gnosisSafe, \\\"FirewallModule: only safe\\\");\\n        for (uint i = 0; i < firewalls.length; i++) {\\n            approvedFirewalls[firewalls[i]] = status;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gnosisSafe\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_approvedFirewalls\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"firewall\",\"type\":\"address\"}],\"name\":\"approvePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedDeployers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedFirewalls\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gnosisSafe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"deployers\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setDeployersStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"firewalls\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setFirewallsStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FirewallModule", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000f32812a40f703e73cb05dd9615dc79e703b5137700000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d7d8cf4f1e83cad3ea00be022ef61188b2369ee7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}