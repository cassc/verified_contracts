{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC897Proxy.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @dev Interface of EIP-897 delegate proxy. \\r\\ninterface IERC897Proxy {\\r\\n  /// @dev Checking the proxy type is the way to check whether a contract is a proxy at all.\\r\\n  function proxyType() external pure returns (uint256 proxyTypeId);\\r\\n\\r\\n  /// @dev The returned code address is the address the proxy would delegate calls to at that moment in time.\\r\\n  function implementation() external view returns (address codeAddr);\\r\\n}\"\r\n    },\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\r\\nimport \\\"./interface/IERC897Proxy.sol\\\";\\r\\n\\r\\ncontract HSKProxy is Proxy, IERC897Proxy {\\r\\n    bytes32 internal constant IMPLEMENTATION_SLOT = keccak256(\\\"hsk.proxy.implementation\\\");\\r\\n\\r\\n    bytes32 internal constant STATUS_SLOT = keccak256(\\\"hsk.proxy.status\\\");\\r\\n\\r\\n    bytes32 internal constant OWNER_SLOT = keccak256(\\\"hsk.proxy.owner\\\");\\r\\n\\r\\n    bytes32 internal constant UPGRADER_SLOT_TAG = keccak256(\\\"hsk.proxy.upgraderTag\\\");\\r\\n\\r\\n    bytes32 internal constant PAUSER_SLOT_TAG = keccak256(\\\"hsk.proxy.pauserTag\\\");\\r\\n\\r\\n    /// @dev Emitted when the administration has been transferred.\\r\\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev Emitted when the upgrader is updated.\\r\\n    event SetUpgrader(address indexed account, bool enable);\\r\\n\\r\\n    /// @dev Emitted when the pauser is updated.\\r\\n    event SetPauser(address indexed account, bool enable);\\r\\n\\r\\n    /// @dev Emitted when the implementation is upgraded.\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    /// @dev Proxy status is updated.\\r\\n    event StatusUpdated(bool status);\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == _owner(), \\\"Proxy: is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier canUpgrade() {\\r\\n        require(msg.sender == _owner() || _isUpgrader(msg.sender), \\\"Proxy: is not owner or upgrader\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier canPause() {\\r\\n        require(msg.sender == _owner() || _isPauser(msg.sender), \\\"Proxy: is not owner or pauser\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _impl, address _implOwner, address _proxyOwner) {\\r\\n        _upgradeToAndCall(_impl, abi.encodeWithSelector(bytes4(keccak256(\\\"init(address)\\\")), _implOwner));\\r\\n        _setOwner(_proxyOwner);\\r\\n        _setStatus(true);\\r\\n    }\\r\\n\\r\\n    function _implementation() internal view override returns (address impl) {\\r\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            impl := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeFallback() internal view override {\\r\\n        require(_status(), \\\"Proxy: proxy is not active\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the implementation address of the proxy.\\r\\n    /// @param _impl Address of the new implementation.\\r\\n    function _setImplementation(address _impl) internal {\\r\\n        require(_impl.code.length > 0, \\\"Proxy: not a contract address\\\");\\r\\n\\r\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(slot, _impl)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Upgrades the proxy to a new implementation.\\r\\n    * @param newImplementation Address of the new implementation.\\r\\n    */\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    /// @dev Upgrade the implementation of the proxy and call a function on the new implementation.\\r\\n    /// @param _impl Address of the new implementation.\\r\\n    /// @param data Data to send as msg.data in the low level call.\\r\\n    function _upgradeToAndCall(address _impl, bytes memory data) internal {\\r\\n        _upgradeTo(_impl);\\r\\n        if (data.length > 0) {\\r\\n            // solhint-disable-next-line avoid-low-level-calls\\r\\n            (bool ok, ) = _impl.delegatecall(data);\\r\\n            require(ok, \\\"Proxy: delegateCall failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Return proxy status\\r\\n    function _status() internal view returns (bool active) {\\r\\n        bytes32 slot = STATUS_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            active := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Set proxy status\\r\\n    function _setStatus(bool active) internal {\\r\\n        bytes32 slot = STATUS_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(slot, active)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Return the owner slot.\\r\\n    function _owner() internal view returns (address account) {\\r\\n        bytes32 slot = OWNER_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            account := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Return the upgrader slot.\\r\\n    function _isUpgrader(address account) internal view returns (bool enable) {\\r\\n        bytes32 slot = keccak256(abi.encodePacked(UPGRADER_SLOT_TAG, account));\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            enable := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Return the pauser slot.\\r\\n    function _isPauser(address account) internal view returns (bool enable) {\\r\\n        bytes32 slot = keccak256(abi.encodePacked(PAUSER_SLOT_TAG, account));\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            enable := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Set new owner\\r\\n    function _setOwner(address account) internal {\\r\\n        require(account != address(0), \\\"Proxy: account can not be zero\\\");\\r\\n\\r\\n        bytes32 slot = OWNER_SLOT;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(slot, account)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setUpgrader(address account, bool enable) internal {\\r\\n        require(account != address(0), \\\"Proxy: account can not be zero\\\");\\r\\n\\r\\n        bytes32 slot = keccak256(abi.encodePacked(UPGRADER_SLOT_TAG, account));\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(slot, enable)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setPauser(address account, bool enable) internal {\\r\\n        require(account != address(0), \\\"Proxy: account can not be zero\\\");\\r\\n\\r\\n        bytes32 slot = keccak256(abi.encodePacked(PAUSER_SLOT_TAG, account));\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(slot, enable)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Perform implementation upgrade\\r\\n    function upgradeTo(address _impl) external canUpgrade {\\r\\n        _upgradeTo(_impl);\\r\\n    }\\r\\n\\r\\n    /// @dev Perform implementation upgrade with additional setup call.\\r\\n    function upgradeToAndCall(address _impl, bytes memory data) external payable canUpgrade {\\r\\n        _upgradeToAndCall(_impl, data);\\r\\n    }\\r\\n\\r\\n    /// @dev Get proxy status.\\r\\n    function status() external view returns (bool) {\\r\\n        return _status();\\r\\n    }\\r\\n\\r\\n    /// @dev Pause or unpause proxy.\\r\\n    function setStatus(bool active) external canPause {\\r\\n        _setStatus(active);\\r\\n        emit StatusUpdated(active);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the current owner.\\r\\n    function proxyOwner() external view returns (address) {\\r\\n        return _owner();\\r\\n    }\\r\\n\\r\\n    /// @dev eturns if the current account is upgrader.\\r\\n    function isUpgrader(address account) external view returns (bool) {\\r\\n        return _isUpgrader(account);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if the current account is pauser.\\r\\n    function isPauser(address account) external view returns (bool) {\\r\\n        return _isPauser(account);\\r\\n    }\\r\\n\\r\\n    /// @dev Changes the owner of the proxy.\\r\\n    function changeOwner(address _newOwner) external onlyOwner {\\r\\n        address _oldOwner = _owner();\\r\\n        _setOwner(_newOwner);\\r\\n        emit OwnerChanged(_oldOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Set upgrader.\\r\\n    function setUpgrader(address account, bool enable) external onlyOwner {\\r\\n        _setUpgrader(account, enable);\\r\\n        emit SetUpgrader(account, enable);\\r\\n    }\\r\\n\\r\\n    /// @dev Set pauser.\\r\\n    function setPauser(address account, bool enable) external onlyOwner {\\r\\n        _setPauser(account, enable);\\r\\n        emit SetPauser(account, enable);\\r\\n    }\\r\\n\\r\\n    ///////////////////////// ERC897Proxy methods ////////////////////////\\r\\n    \\r\\n    /// @dev See in IERC897Proxy.\\r\\n    function implementation() external view override returns (address) {\\r\\n        return _implementation();\\r\\n    }\\r\\n\\r\\n    /// @dev See in IERC897Proxy.\\r\\n    function proxyType() external pure override returns (uint256) {\\r\\n        // upgradable\\r\\n        return 2;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetPauser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetUpgrader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"StatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isUpgrader\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setUpgrader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HSKProxy", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000075492153f5af575ee405935ed57388c5d80247bd00000000000000000000000049ff8a4b5f4eda7911f83a0c4c725985f586900a00000000000000000000000049ff8a4b5f4eda7911f83a0c4c725985f586900a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x75492153f5af575ee405935ed57388c5d80247bd", "SwarmSource": ""}