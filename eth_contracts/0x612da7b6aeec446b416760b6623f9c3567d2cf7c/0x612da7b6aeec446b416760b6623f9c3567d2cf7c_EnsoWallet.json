{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@ensofinance/weiroll/contracts/CommandBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary CommandBuilder {\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n    uint256 constant IDX_DYNAMIC_START = 0xfd;\\n    uint256 constant IDX_DYNAMIC_END = 0xfc;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 idx; // The current command index\\n        uint256 offsetIdx; // The index of the current offset\\n\\n        uint256 count; // Number of bytes in whole ABI encoded message\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        uint256 offset; // Pointer to the first free byte for variable length data inside dynamic types\\n\\n        uint256[] memory offsets = new uint256[](10); // Optionally store the length of all dynamic types (a command cannot fit more than 10 dynamic types)\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        uint256 indicesLength; // Number of indices\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) {\\n                indicesLength = i;\\n                break;\\n            }\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    unchecked {\\n                        free += 32;\\n                        count += stateData.length;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_START) {\\n                    offset = 1; // Semantically overloading the offset to work as a boolean\\n                } else if (idx == IDX_DYNAMIC_END) {\\n                    unchecked {\\n                        offsets[offsetIdx] = offset - 1; // Remove 1 that was set at the start of the dynamic type, to get correct offset length\\n                    }\\n                    offset = 0;\\n                    // Increase count and free for dynamic type pointer\\n                    unchecked {\\n                        offsetIdx++;\\n                        free += 32;\\n                        count += 32;\\n                    }\\n                } else {\\n                    // Add the size of the value, rounded up to the next word boundary, plus space for pointer and length\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    require(\\n                        argLen % 32 == 0,\\n                        \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n                    );\\n                    unchecked {\\n                        count += argLen + 32;\\n                    }\\n                    if (offset != 0) {\\n                        // Increase offset size\\n                        unchecked {\\n                            offset += 32;\\n                        }\\n                    } else {\\n                        // Progress next free slot\\n                        unchecked {\\n                            free += 32;\\n                        }\\n                    }\\n                }\\n            } else {\\n                require(\\n                    state[idx & IDX_VALUE_MASK].length == 32,\\n                    \\\"Static state variables must be 32 bytes\\\"\\n                );\\n                unchecked {\\n                    count += 32;\\n                }\\n                if (offset != 0) {\\n                    unchecked {\\n                        offset += 32;\\n                    }\\n                } else {\\n                    unchecked {\\n                        free += 32;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        offsetIdx = 0;\\n        for (uint256 i; i < indicesLength; ) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    unchecked {\\n                        free += stateData.length - 32;\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    unchecked {\\n                        offset = free + offsets[offsetIdx];\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_END) {\\n                    offset = 0;\\n                    unchecked {\\n                        offsetIdx++;\\n                    }\\n                } else {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n\\n                    if (offset != 0) {\\n                        // Part of dynamic type; put a pointer in the first free slot and write the data to the offset free slot\\n                        uint256 pointer = offsets[offsetIdx];\\n                        assembly {\\n                            mstore(add(add(ret, 36), free), pointer)\\n                        }\\n                        unchecked {\\n                            free += 32;\\n                        }\\n                        memcpy(\\n                            state[idx & IDX_VALUE_MASK],\\n                            0,\\n                            ret,\\n                            offset + 4,\\n                            argLen\\n                        );\\n                        unchecked {\\n                            offsets[offsetIdx] += argLen;\\n                            offset += argLen;\\n                        }\\n                    } else {\\n                        // Put a pointer in the current slot and write the data to first free slot\\n                        assembly {\\n                            mstore(add(add(ret, 36), count), free)\\n                        }\\n                        memcpy(\\n                            state[idx & IDX_VALUE_MASK],\\n                            0,\\n                            ret,\\n                            free + 4,\\n                            argLen\\n                        );\\n                        unchecked {\\n                            free += argLen;\\n                            count += 32;\\n                        }\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                if (offset != 0) {\\n                    // Part of dynamic type; write to first free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n                    }\\n                    unchecked {\\n                        free += 32;\\n                    }\\n                } else {\\n                    // Write the data to current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\\n                    }\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argPtr;\\n                assembly {\\n                    argPtr := mload(add(output, 32))\\n                }\\n                require(\\n                    argPtr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint256(uint8(index));\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcIdx,\\n        bytes memory dest,\\n        uint256 destIdx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcIdx),\\n                    len,\\n                    add(add(dest, 32), destIdx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensofinance/weiroll/contracts/VM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_DATA = 0x20;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n\\n    uint256 constant SHORT_COMMAND_FILL =\\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n        internal\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outData;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\\n            command = commands[i];\\n            flags = uint256(uint8(bytes1(command << 32)));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                i = _uncheckedIncrement(i);\\n                indices = commands[i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outData) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices\\n                        )\\n                        : state[\\n                            uint8(bytes1(indices)) &\\n                            CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 callEth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    callEth := mload(add(v, 0x20))\\n                }\\n                (success, outData) = address(uint160(uint256(command))).call{ // target\\n                    value: callEth\\n                }(\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices << 8 // skip value input\\n                        )\\n                        : state[\\n                            uint8(\\n                                bytes1(indices << 8) // first byte after value input\\n                            ) & CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outData.length > 0) {\\n                    assembly {\\n                        outData := add(outData, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: flags & FLAG_EXTENDED_COMMAND == 0\\n                        ? i\\n                        : i - 1,\\n                    target: address(uint160(uint256(command))),\\n                    message: outData.length > 0 ? string(outData) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outData);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outData);\\n            }\\n        }\\n        return state;\\n    }\\n\\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            ++i;\\n        }\\n        return i;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EnsoWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract EnsoWallet is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"command_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"caller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EnsoWallet", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}