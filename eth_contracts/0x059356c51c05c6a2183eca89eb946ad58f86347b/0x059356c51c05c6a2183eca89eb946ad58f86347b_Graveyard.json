{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\n/**                                       \r\n                   %%(((       #%(                                               \r\n                    %%%(((((   #%%((    %((     %                                \r\n                     ((%(((((((//(%(((((/#%(((//((                               \r\n                       (((((((((((((//(((//((/((((/////                          \r\n                         (((/(((((*(((/////*((//////////                         \r\n                          ,.////////.../////./////./(%(/                         \r\n                          %%%%%%%%%%%%&&&&&&&%%%%%%%%%%%                         \r\n                     &&&((%%%%(&@@@@((&&&&&&&(&@@@@((%%%(((&&                    \r\n                     %%(%(%%%(@@@@@@@@(%%%%%(@@@@@@@@(%%((%(%                    \r\n                       %,,%%%,@@@@@@@@,%%%%%,@@@@@@@@,%%*,,%                     \r\n                        (,%%%((*,,,,/((%%%%%((*,,,,/((%%*,(                      \r\n                            %%%%%%%%%%%%%%%%%%%%%%%%%%%                          \r\n                             ((((%%(&@,@,,,,@,/(%%((((                           \r\n                              %%%%%,,,./////*,,,%%%%%                            \r\n                              %%%%%%%%%%%%%///%%%%%%%                            \r\n                                       ,,,,,                                     \r\n                                       (((((                                     \r\n                               (####../,%%%,/*#####                              \r\n                             /#####////.///./////####/                           \r\n                          ///////.///////////////.//////                         \r\n                         ((( ,///./////////////// ///*,(                         \r\n                        %(     ,,///////////////       (%%                       \r\n                       %%        //.//////////          #%%                      \r\n                    %%%%         ,/,..///,,/,*            %%%                    \r\n                  &&&&&%         (((((,/,**(((            %&&&&&                 \r\n                %%(%%*,%%      ////((((*(((((####       #%%,%%%(%                \r\n                %%(%%   %         ( ##     ( (          #%  %%%(%                \r\n                   ,%%%          %((       ((%             %%*,                  \r\n                             %%((*%         %*((%%                               \r\n                            @@@//((         ((//@@@                              \r\n                          &@@@@@@@@@       @@@@@@@@@@                     \r\n\r\n\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8,\u00f8\u00a4\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8,\u00f8\u00a4\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8\r\n                Website: https://rekt.kids/\r\n                Twitter: https://twitter.com/RektKidsOnEth\r\n                Telegram: https://t.me/RektBeyondRecoveryPortal\r\n\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8,\u00f8\u00a4\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8,\u00f8\u00a4\u00b0\u00ba\u00a4\u00f8,\u00b8\u00b8,\u00f8\u00a4\u00ba\u00b0`\u00b0\u00ba\u00a4\u00f8,\u00b8\r\n**/\r\n\r\npragma solidity ^0.8.4;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721A {\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n    error ApprovalQueryForNonexistentToken();\r\n    error BalanceQueryForZeroAddress();\r\n    error BalanceMustBeBelowMaxWallet();\r\n    error MintToZeroAddress();\r\n    error MintZeroQuantity();\r\n    error OwnerQueryForNonexistentToken();\r\n    error TransferCallerNotOwnerNorApproved();\r\n    error TransferFromIncorrectOwner();\r\n    error TransferToNonERC721ReceiverImplementer();\r\n    error TransferToZeroAddress();\r\n    error URIQueryForNonexistentToken();\r\n    error MintERC2309QuantityExceedsLimit();\r\n    error OwnershipNotInitializedForExtraData();\r\n    error InvalidQueryRange();\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    struct TokenOwnership {\r\n        address addr;\r\n        uint64 startTimestamp;\r\n        bool burned;\r\n        uint24 extraData;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\r\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n    function approve(address to, uint256 tokenId) external payable;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract ERC721A is IERC721A {\r\n    struct TokenApprovalRef {\r\n        address value;\r\n    }\r\n\r\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\r\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\r\n    uint256 private constant _BITPOS_AUX = 192;\r\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\r\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\r\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\r\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\r\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\r\n\r\n\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n\r\n    uint256 private _currentIndex;\r\n    uint256 private _burnCounter;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n    mapping(address => uint256) private _packedAddressData;\r\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    function _totalBurned() internal view virtual returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);\r\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\r\n    }\r\n\r\n    function _setAux(address owner, uint64 aux) internal virtual {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        assembly {\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 ||\r\n            interfaceId == 0x80ac58cd ||\r\n            interfaceId == 0x5b5e139f;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return '';\r\n    }\r\n\r\n    function explicitOwnershipOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (TokenOwnership memory ownership)\r\n    {\r\n        unchecked {\r\n            if (tokenId >= _startTokenId()) {\r\n                if (tokenId < _nextTokenId()) {\r\n                    while (!_ownershipIsInitialized(tokenId)) --tokenId;\r\n                    return _ownershipAt(tokenId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) private view returns (uint256[] memory) {\r\n        unchecked {\r\n            if (start >= stop) _revert(InvalidQueryRange.selector);\r\n            if (start < _startTokenId()) {\r\n                start = _startTokenId();\r\n            }\r\n            uint256 stopLimit = _nextTokenId();\r\n            if (stop >= stopLimit) {\r\n                stop = stopLimit;\r\n            }\r\n            uint256[] memory tokenIds;\r\n            uint256 tokenIdsMaxLength = balanceOf(owner);\r\n            bool startLtStop = start < stop;\r\n            assembly {\r\n                tokenIdsMaxLength := mul(tokenIdsMaxLength, startLtStop)\r\n            }\r\n            if (tokenIdsMaxLength != 0) {\r\n                if (stop - start <= tokenIdsMaxLength) {\r\n                    tokenIdsMaxLength = stop - start;\r\n                }\r\n                assembly {\r\n                    tokenIds := mload(0x40)\r\n                    mstore(0x40, add(tokenIds, shl(5, add(tokenIdsMaxLength, 1))))\r\n                }\r\n                TokenOwnership memory ownership = explicitOwnershipOf(start);\r\n                address currOwnershipAddr;\r\n                if (!ownership.burned) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                uint256 tokenIdsIdx;\r\n                do {\r\n                    ownership = _ownershipAt(start);\r\n                    assembly {\r\n                        switch mload(add(ownership, 0x40))\r\n                        case 0 {\r\n                            if mload(ownership) {\r\n                                currOwnershipAddr := mload(ownership)\r\n                            }\r\n                            if iszero(shl(96, xor(currOwnershipAddr, owner))) {\r\n                                tokenIdsIdx := add(tokenIdsIdx, 1)\r\n                                mstore(add(tokenIds, shl(5, tokenIdsIdx)), start)\r\n                            }\r\n                        }\r\n                        default {\r\n                            currOwnershipAddr := 0\r\n                        }\r\n                        start := add(start, 1)\r\n                    }\r\n                } while (!(start == stop || tokenIdsIdx == tokenIdsMaxLength));\r\n                assembly {\r\n                    mstore(tokenIds, tokenIdsIdx)\r\n                }\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\r\n        uint256 start = _startTokenId();\r\n        uint256 stop = _nextTokenId();\r\n        uint256[] memory tokenIds;\r\n        if (start != stop) tokenIds = _tokensOfOwnerIn(owner, start, stop);\r\n        return tokenIds;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {\r\n        return _packedOwnerships[index] != 0;\r\n    }\r\n\r\n    function _initializeOwnershipAt(uint256 index) internal virtual {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\r\n        if (_startTokenId() <= tokenId) {\r\n            packed = _packedOwnerships[tokenId];\r\n            if (packed == 0) {\r\n                if (tokenId >= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);\r\n                for (;;) {\r\n                    unchecked {\r\n                        packed = _packedOwnerships[--tokenId];\r\n                    }\r\n                    if (packed == 0) continue;\r\n                    if (packed & _BITMASK_BURNED == 0) return packed;\r\n                    _revert(OwnerQueryForNonexistentToken.selector);\r\n                }\r\n            }\r\n            if (packed & _BITMASK_BURNED == 0) return packed;\r\n        }\r\n        _revert(OwnerQueryForNonexistentToken.selector);\r\n    }\r\n\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & _BITMASK_BURNED != 0;\r\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\r\n    }\r\n\r\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\r\n        assembly {\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\r\n        }\r\n    }\r\n\r\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\r\n        assembly {\r\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\r\n        }\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public payable virtual override {\r\n        _approve(to, tokenId, true);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);\r\n\r\n        return _tokenApprovals[tokenId].value;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool result) {\r\n        if (_startTokenId() <= tokenId) {\r\n            if (tokenId < _currentIndex) {\r\n                uint256 packed;\r\n                while ((packed = _packedOwnerships[tokenId]) == 0) --tokenId;\r\n                result = packed & _BITMASK_BURNED == 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _isSenderApprovedOrOwner(\r\n        address approvedAddress,\r\n        address owner,\r\n        address msgSender\r\n    ) private pure returns (bool result) {\r\n        assembly {\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\r\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\r\n        }\r\n    }\r\n\r\n    function _getApprovedSlotAndAddress(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256 approvedAddressSlot, address approvedAddress)\r\n    {\r\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\r\n        assembly {\r\n            approvedAddressSlot := tokenApproval.slot\r\n            approvedAddress := sload(approvedAddressSlot)\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS));\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        assembly {\r\n            if approvedAddress {\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from];\r\n            ++_packedAddressData[to];\r\n\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\r\n        assembly {\r\n            log4(\r\n                0,\r\n                0,\r\n                _TRANSFER_EVENT_SIGNATURE,\r\n                from,\r\n                toMasked,\r\n                tokenId\r\n            )\r\n        }\r\n        if (toMasked == 0) _revert(TransferToZeroAddress.selector);\r\n\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public payable virtual override {\r\n        transferFrom(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\r\n            }\r\n    }\r\n\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\r\n            }\r\n            assembly {\r\n                revert(add(32, reason), mload(reason))\r\n            }\r\n        }\r\n    }\r\n\r\n    function _mint(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        unchecked {\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\r\n\r\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\r\n\r\n            uint256 end = startTokenId + quantity;\r\n            uint256 tokenId = startTokenId;\r\n\r\n            do {\r\n                assembly {\r\n                    log4(\r\n                        0, \r\n                        0,\r\n                        _TRANSFER_EVENT_SIGNATURE,\r\n                        0,\r\n                        toMasked,\r\n                        tokenId \r\n                    )\r\n                }\r\n            } while (++tokenId != end);\r\n\r\n            _currentIndex = end;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) _revert(MintToZeroAddress.selector);\r\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\r\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        unchecked {\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\r\n\r\n            _currentIndex = startTokenId + quantity;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, quantity);\r\n\r\n        unchecked {\r\n            if (to.code.length != 0) {\r\n                uint256 end = _currentIndex;\r\n                uint256 index = end - quantity;\r\n                do {\r\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\r\n                        _revert(TransferToNonERC721ReceiverImplementer.selector);\r\n                    }\r\n                } while (index < end);\r\n                if (_currentIndex != end) _revert(bytes4(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _approve(to, tokenId, false);\r\n    }\r\n\r\n    function _approve(\r\n        address to,\r\n        uint256 tokenId,\r\n        bool approvalCheck\r\n    ) internal virtual {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        if (approvalCheck && _msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                _revert(ApprovalCallerNotOwnerNorApproved.selector);\r\n            }\r\n\r\n        _tokenApprovals[tokenId].value = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (approvalCheck) {\r\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n                if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        assembly {\r\n            if approvedAddress {\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                from,\r\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\r\n            );\r\n\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\r\n        uint256 packed = _packedOwnerships[index];\r\n        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);\r\n        uint256 extraDataCasted;\r\n        assembly {\r\n            extraDataCasted := extraData\r\n        }\r\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\r\n        _packedOwnerships[index] = packed;\r\n    }\r\n\r\n    function _extraData(\r\n        address from,\r\n        address to,\r\n        uint24 previousExtraData\r\n    ) internal view virtual returns (uint24) {}\r\n\r\n    function _nextExtraData(\r\n        address from,\r\n        address to,\r\n        uint256 prevOwnershipPacked\r\n    ) private view returns (uint256) {\r\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\r\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\r\n    }\r\n\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\r\n        assembly {\r\n            let m := add(mload(0x40), 0xa0)\r\n            mstore(0x40, m)\r\n            str := sub(m, 0x20)\r\n            mstore(str, 0)\r\n\r\n            let end := str\r\n\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            str := sub(str, 0x20)\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    function _revert(bytes4 errorSelector) internal pure {\r\n        assembly {\r\n            mstore(0x00, errorSelector)\r\n            revert(0x00, 0x04)\r\n        }\r\n    }\r\n}\r\n\r\ncontract Graveyard is ReentrancyGuard, Context, ERC721A, ERC721A__IERC721Receiver {\r\n\r\n    address operator;\r\n    mapping(IERC721A => uint256[]) IDs;\r\n    mapping(address => uint256) TokenAmount;\r\n\r\n    uint256 unburyAt = 1 days;\r\n\r\n    bool public paused;\r\n\r\n    // Tombstone Types\r\n    mapping(uint256 => string) public Tombstones;\r\n    mapping(uint256 => uint) public TombstonesType;\r\n\r\n    // Zombie Types\r\n    mapping(uint256 => string) public Zombies;\r\n    mapping(uint256 => uint) public ZombiesType;\r\n\r\n    mapping(address => uint256) public burials;\r\n\r\n    mapping(address => uint256) public OwnerToID;\r\n    mapping(uint256 => address) public IDToOwner;\r\n\r\n    bool public zombieRequired = true;\r\n\r\n    // Tokens Burried At\r\n    mapping(address => mapping(address => uint256)) public buriedAmount;\r\n    mapping(uint256 => uint256) public buriedTokenAt;\r\n    mapping(address => address[]) tokensBuried;\r\n\r\n    bool public fullSend = true;\r\n\r\n    // Upgrade\r\n    uint256 public upgradeFee = 0.05 ether;\r\n\r\n    string site = 'https://rekt.kids';\r\n\r\n    struct ZombiesMD {\r\n        string Carl;\r\n        string Morbelle;\r\n        string Mortimer;\r\n        string Rottus;\r\n        string Griselda;\r\n    }\r\n\r\n    ZombiesMD public ZombieMD = ZombiesMD({\r\n        Carl: string(abi.encodePacked(site, \"/characters/Carl.json\")),\r\n        Morbelle: string(abi.encodePacked(site, \"/characters/Morbelle.json\")),\r\n        Mortimer: string(abi.encodePacked(site, \"/characters/Mortimer.json\")),\r\n        Rottus: string(abi.encodePacked(site, \"/characters/Rottus.json\")),\r\n        Griselda: string(abi.encodePacked(site, \"/characters/Griselda.json\"))\r\n    });\r\n    \r\n    ZombiesMD public TombstonesMD = ZombiesMD({\r\n        Carl: string(abi.encodePacked(site, \"/characters/CarlTombstone.json\")),\r\n        Morbelle: string(abi.encodePacked(site, \"/characters/MorbelleTombstone.json\")),\r\n        Mortimer: string(abi.encodePacked(site, \"/characters/MortimerTombstone.json\")),\r\n        Rottus: string(abi.encodePacked(site, \"/characters/RottusTombstone.json\")),\r\n        Griselda: string(abi.encodePacked(site, \"/characters/Griselda.json\"))\r\n    });\r\n\r\n    modifier onlyOwner() {\r\n        require(_msgSender() == operator);\r\n        _;\r\n    }\r\n\r\n    constructor() ERC721A('Degen Graveyard', 'Rekt Zombies') {\r\n        operator = _msgSender();\r\n        Zombies[1] = string(abi.encodePacked(site, \"/characters/Carl.json\"));\r\n        Zombies[2] = string(abi.encodePacked(site, \"/characters/Morbelle.json\"));\r\n        Zombies[3] = string(abi.encodePacked(site, \"/characters/Mortimer.json\"));\r\n        Zombies[4] = string(abi.encodePacked(site, \"/characters/Rottus.json\"));\r\n        Zombies[5] = string(abi.encodePacked(site, \"/characters/Griselda.json\"));\r\n        \r\n        Tombstones[1] = string(abi.encodePacked(site, \"/characters/CarlTombstone.json\"));\r\n        Tombstones[2] = string(abi.encodePacked(site, \"/characters/MorbelleTombstone.json\"));\r\n        Tombstones[3] = string(abi.encodePacked(site, \"/characters/MortimerTombstone.json\"));\r\n        Tombstones[4] = string(abi.encodePacked(site, \"/characters/RottusTombstone.json\"));\r\n        Tombstones[5] = string(abi.encodePacked(site, \"/characters/Griselda.json\"));\r\n    }\r\n\r\n    function setZombies(uint zombieType, string memory _url) external onlyOwner {\r\n        Zombies[zombieType] = _url;\r\n    }\r\n    \r\n    function setTombstone(uint tombType, string memory _url) external onlyOwner {\r\n        Tombstones[tombType] = _url;\r\n    }\r\n\r\n    function UnburyERC20(IERC20 token) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(operator, balance);\r\n        TokenAmount[address(token)] -= balance;\r\n    }\r\n\r\n    function UnburyERC721(IERC721A token) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        for(uint i; i < balance; i++){\r\n            token.safeTransferFrom(address(this), operator, IDs[token][i]);\r\n            IDs[token][i] = 0;\r\n            TokenAmount[address(token)]--;\r\n        }\r\n    }\r\n\r\n    function BuryNFT721(IERC721A token, uint256[] memory tokenID) external nonReentrant {\r\n        address _token = address(token);\r\n        for(uint i; i < tokenID.length; i++){\r\n            require(token.ownerOf(tokenID[i]) == _msgSender());\r\n            token.safeTransferFrom(_msgSender(), address(this), tokenID[i]);\r\n            IDs[token][TokenAmount[_token]] = tokenID[i];\r\n        }\r\n        \r\n        if(balanceOf(msg.sender) > 0) {} else {\r\n            TokenAmount[_token] += tokenID.length;\r\n            _safeMint(msg.sender, 1);\r\n        }\r\n\r\n        OwnerToID[msg.sender] = totalSupply() - 1;\r\n        tokensBuried[msg.sender].push(_token);\r\n        buriedTokenAt[totalSupply() - 1] = block.timestamp;\r\n        burials[msg.sender]++;\r\n        buriedAmount[_token][msg.sender] = tokenID.length;\r\n    }\r\n\r\n    function _afterTokenTransfers(\r\n    address from,\r\n    address to,\r\n    uint256 startTokenId,\r\n    uint256 quantity\r\n    ) internal virtual override {\r\n        super._afterTokenTransfers(from, to, startTokenId, quantity);\r\n        uint256 _burials = burials[from];\r\n        burials[to] += _burials;\r\n        burials[from] -= _burials;\r\n    }\r\n\r\n    function BuryERC20(IERC20 token, uint256 amount) external nonReentrant {\r\n        address _token = address(token);\r\n        uint256 _amount = amount;\r\n        require(_amount > 0, \"Amount cannot be zero.\");\r\n\r\n        if(fullSend) require(token.balanceOf(_msgSender()) <= amount, \"You must send all of your tokens.\");\r\n\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n\r\n        if(balanceOf(msg.sender) > 0) {\r\n\r\n        } else {\r\n            TokenAmount[_token] += _amount;\r\n            _safeMint(msg.sender, 1);\r\n        }\r\n\r\n        OwnerToID[msg.sender] = totalSupply() - 1;\r\n        tokensBuried[msg.sender].push(_token);\r\n        buriedTokenAt[totalSupply() - 1] = block.timestamp + unburyAt;\r\n        burials[msg.sender]++;\r\n        buriedAmount[_token][msg.sender] = _amount;\r\n    }\r\n\r\n    function BuryERC20s(IERC20[] memory token, uint256[] memory amount) external nonReentrant {\r\n\r\n        for(uint i; i < token.length; i++){\r\n            \r\n            address _token = address(token[i]);\r\n            uint256 _amount = amount[i];\r\n            require(_amount > 0, \"Amount cannot be zero.\");\r\n            require(buriedAmount[_token][msg.sender] == 0, \"Must be a unique token. You've buried this before.\");\r\n            if(fullSend) require(token[i].balanceOf(_msgSender()) <= _amount, \"You must send all of your tokens.\");\r\n            token[i].transferFrom(msg.sender, address(this), _amount);\r\n     \r\n            tokensBuried[msg.sender].push(_token);\r\n            buriedAmount[_token][msg.sender] = _amount;\r\n            TokenAmount[_token] += _amount;\r\n        }\r\n\r\n        if(balanceOf(msg.sender) > 0) {\r\n\r\n        } else {\r\n\r\n            _safeMint(msg.sender, token.length);\r\n        }\r\n\r\n        OwnerToID[msg.sender] = totalSupply() - 1;\r\n\r\n        buriedTokenAt[totalSupply() - 1] = block.timestamp + unburyAt;\r\n        burials[msg.sender]++;\r\n\r\n    }\r\n\r\n    function getTier(uint256 number) public pure returns(uint256 tier) {\r\n        if(number >= 10) return tier = 5;\r\n        if(number >= 8) return tier = 4;\r\n        if(number >= 4) return tier = 3;\r\n        if(number >= 2) return tier = 2;\r\n        if(number == 1) return tier = 1;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        if(buriedTokenAt[tokenId] >= block.timestamp){\r\n            return Tombstones[getTier(burials[ownerOf(tokenId)])];\r\n        }else{\r\n            return Zombies[getTier(burials[ownerOf(tokenId)])];\r\n        }\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 burials;\r\n        string zombie;\r\n        address[] tokens;\r\n    }\r\n    \r\n    function getBurials(address account) external view returns (UserInfo memory _burials) {\r\n        _burials = UserInfo({\r\n            burials: burials[account],\r\n            zombie: Zombies[getTier(burials[account])],\r\n            tokens: tokensBuried[account]\r\n        });\r\n    }\r\n\r\n    function upgrade() external payable nonReentrant {\r\n        if(zombieRequired) require(burials[msg.sender] > 0, \"Must have buried a zombie.\");\r\n        require(msg.value >= upgradeFee, \"Insufficient ETH Sent\");\r\n        burials[msg.sender] += 10;\r\n    }\r\n\r\n    function setSite(string memory _site) external onlyOwner {\r\n        site = _site;\r\n    }\r\n\r\n    function setPaused(bool _paused) external onlyOwner {\r\n        require(paused != _paused, \"Already done.\");\r\n        paused = _paused;\r\n    }\r\n\r\n    function setZombieMD(uint256 _type, string calldata metadata) external onlyOwner {\r\n        Zombies[_type] = string(abi.encodePacked(site, metadata));\r\n    }\r\n\r\n    function onERC721Received(address, address, uint256, bytes memory) public override virtual returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function tokenRequirement(bool _send) external onlyOwner {\r\n        fullSend = _send;\r\n    }\r\n\r\n    function zombieRequirement(bool _requireZombie) external onlyOwner {\r\n        zombieRequired = _requireZombie;\r\n    }\r\n\r\n    function WithdrawETH() external onlyOwner {\r\n        uint256 amountEth = address(this).balance;\r\n        payable(_msgSender()).transfer(amountEth);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceMustBeBelowMaxWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuryERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"token\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"BuryERC20s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721A\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenID\",\"type\":\"uint256[]\"}],\"name\":\"BuryNFT721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IDToOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnerToID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Tombstones\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TombstonesMD\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Carl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Morbelle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Mortimer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Rottus\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Griselda\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TombstonesType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"UnburyERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721A\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"UnburyERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZombieMD\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Carl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Morbelle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Mortimer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Rottus\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Griselda\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Zombies\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ZombiesType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burials\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buriedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buriedTokenAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"explicitOwnershipOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership\",\"name\":\"ownership\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fullSend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBurials\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"burials\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"zombie\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct Graveyard.UserInfo\",\"name\":\"_burials\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"getTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tier\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_site\",\"type\":\"string\"}],\"name\":\"setSite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tombType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setTombstone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"setZombieMD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zombieType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setZombies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_send\",\"type\":\"bool\"}],\"name\":\"tokenRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zombieRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_requireZombie\",\"type\":\"bool\"}],\"name\":\"zombieRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Graveyard", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4429d5fac7ff1b649a58f20f9c0b9abd0dec8d5436f02679b5bafc2d1744fa1b"}