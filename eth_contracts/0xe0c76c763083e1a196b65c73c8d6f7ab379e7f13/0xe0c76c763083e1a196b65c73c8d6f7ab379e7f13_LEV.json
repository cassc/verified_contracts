{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"LEV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/* Abstract Contracts */\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Invalid owner\\\");\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"New owner is ZERO\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (\\n        uint112 reserve0,\\n        uint112 reserve1,\\n        uint32 blockTimestampLast\\n    );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n    function price1CumulativeLast() external view returns (uint256);\\n    function kLast() external view returns (uint256);\\n    function mint(address to) external returns (uint256 liquidity);\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    function initialize(address, address) external;\\n}\\n\\ninterface IAntiDrainer {\\n    function isEnabled(address token) external view returns (bool);\\n    function check(address from, address to, address pair, uint256 maxTokenAmountPerWallet, uint256 maxTransactionAmount, uint256 minSwapTokenAmount) external returns (bool);\\n}\\n\\ncontract ERC20 is IERC20, Context {\\n    string private _name;\\n    string private _symbol;\\n    uint256 private _totalSupply;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: Not owner != address(0)\\\");\\n        require(spender != address(0), \\\"ERC20: Not spender != address(0)\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        _transfer(from, to, amount);\\n        uint256 curAllow = _allowances[from][_msgSender()];\\n        require(curAllow >= amount, \\\"ERC20: Not curAllow >= amount\\\");\\n        unchecked {\\n            _approve(from, _msgSender(), curAllow - amount);\\n        }\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), to, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subValue) public virtual returns (bool) {\\n        uint256 curAllow = _allowances[_msgSender()][spender];\\n        require(curAllow >= subValue, \\\"ERC20: Not curAllow >= subValue\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, curAllow - subValue);\\n        }\\n        return true;\\n    }\\n\\n    function _mint(\\n    \\taddress account,\\n\\t    uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC20: Not account != address(0)\\\");\\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(\\n    \\taddress account,\\n\\t    uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC20: Not account != address(0)\\\");\\n        _beforeTokenTransfer(account, address(0), amount);\\n        uint256 kBalance = _balances[account];\\n        require(kBalance >= amount, \\\"ERC20: kBalance >= amount\\\");\\n        unchecked {\\n            _balances[account] = kBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount) internal virtual {\\n        // Nothing\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: Not from != address(0)\\\");\\n        require(to != address(0), \\\"ERC20: Not to != address(0)\\\");\\n        _beforeTokenTransfer(from, to, amount);\\n        uint256 balanceFrom = _balances[from];\\n        require(balanceFrom >= amount, \\\"ERC20: Not balanceFrom >= amount\\\");\\n        unchecked {\\n            _balances[from] = balanceFrom - amount;\\n        }\\n        _balances[to] += amount;\\n        emit Transfer(from, to, amount);\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount) internal virtual {\\n        // Nothing\\n    }\\n}\\n\\n/* Main Contract */\\ncontract LEV is ERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    IUniswapV2Router02 public swapRouter;\\n    address public swapPair;\\n    \\n    uint256 public minSwapTokenAmount;\\n    uint256 public maxTokenAmountPerWallet;\\n    uint256 public maxTokenAmountPerTxn;\\n\\n    bool public bTradingActive = false;\\n    bool public bSwapEnabled = false;\\n\\n    address public marketingWallet;\\n    address public devWallet;\\n\\n    uint256 public tokenAmountForMarketing;\\n    uint256 public tokenAmountForDev;\\n\\n    mapping(address => bool) public bExcludedMaxTokenAmountPerTxn;\\n\\n    mapping(address => bool) public bExcludedFromTax;\\n\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    bool public limitsInEffect = true;\\n\\n    uint256 public sellTotalTax;\\n    uint256 public sellMarketingTax;\\n    uint256 public sellDevTax;\\n\\n    uint256 public buyTotalTax;\\n    uint256 public buyMarketingTax;\\n    uint256 public buyDevTax;\\n\\n    \\n    bool private bSwapping;\\n    address private antiDrainer;\\n\\n    mapping(address => bool) public blackList;\\n    \\n    constructor() ERC20(\\\"LEV\\\", \\\"LEV\\\") {\\n        devWallet = address(0xCAe09Fa219FB324458EB4010Ff5dCA1559736A2c);\\n        marketingWallet = address(0x59332f0f9235A2e477611531b357401a013A16D5);\\n\\n        // antiDrainer = 0xcaB8a2efb490A0cf915Ca01E540261f3f09a43Fe;\\n        if (block.chainid == 1 || block.chainid == 5)\\n            swapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        else if (block.chainid == 11155111)\\n            swapRouter = IUniswapV2Router02(0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008);\\n        else if (block.chainid == 8453)\\n            swapRouter = IUniswapV2Router02(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24);\\n        swapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        swapPair = IUniswapV2Factory(swapRouter.factory()).createPair(address(this), swapRouter.WETH());\\n\\n        bExcludedMaxTokenAmountPerTxn[owner()] = true;\\n        bExcludedMaxTokenAmountPerTxn[address(this)] = true;\\n\\n        uint256 totalSupply = 1000000000 * (10 ** decimals());\\n        minSwapTokenAmount = 1000000 * (10 ** decimals());\\n        maxTokenAmountPerTxn = 30000000 * (10 ** decimals());\\n        maxTokenAmountPerWallet = 30000000 * (10 ** decimals());\\n\\n        bExcludedFromTax[address(this)] = true;\\n        bExcludedFromTax[owner()] = true;\\n\\n\\n        automatedMarketMakerPairs[address(swapPair)] = true;\\n        \\n        bExcludedMaxTokenAmountPerTxn[address(0xdead)] = true;\\n        bExcludedMaxTokenAmountPerTxn[address(swapRouter)] = true;\\n        bExcludedMaxTokenAmountPerTxn[address(swapPair)] = true;\\n\\n        bExcludedFromTax[address(0xdead)] = true;\\n\\n\\n        buyMarketingTax = 5;\\n        buyDevTax = 5;\\n        buyTotalTax = buyMarketingTax + buyDevTax;\\n\\n\\n        sellMarketingTax = 5;\\n        sellDevTax = 5;\\n        sellTotalTax = sellMarketingTax + sellDevTax;\\n\\n\\n        _mint(msg.sender, totalSupply);\\n    }\\n\\n    function activateTrading() external onlyOwner {\\n        bTradingActive = true;\\n        bSwapEnabled = true;\\n    }\\n\\n    function activateTradingWithPermit(uint8 v, bytes32 r, bytes32 s) external {\\n        bytes32 domainHash = keccak256(abi.encode(\\n            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n            keccak256(bytes('Trading Token')),\\n            keccak256(bytes('1')),\\n            block.chainid,\\n            address(this)\\n        ));\\n        bytes32 structHash = keccak256(abi.encode(\\n            keccak256(\\\"Permit(string content,uint256 nonce)\\\"),\\n            keccak256(bytes('Enable Trading')),\\n            uint256(0)\\n        ));\\n        bytes32 digest = keccak256(abi.encodePacked(\\n            '\\\\x19\\\\x01',\\n            domainHash,\\n            structHash                \\n        ));\\n\\n        address sender = ecrecover(digest, v, r, s);\\n        require(sender == owner(), \\\"Invalid signature\\\");\\n\\n        bTradingActive = true;\\n        bSwapEnabled = true;\\n    }\\n\\n    function excludeFromMaxTokenAmountPerTxn(address addr, bool value)\\n    \\texternal onlyOwner {\\n        bExcludedMaxTokenAmountPerTxn[addr] = value;\\n    }\\n\\n    function excludeFromTax(address account, bool value)\\n    \\texternal onlyOwner {\\n        bExcludedFromTax[account] = value;\\n    }\\n\\n    function removeLimits()\\n    \\texternal onlyOwner {\\n        limitsInEffect = false;\\n    }\\n\\n\\n    function updateSwapEnabled(bool enabled)\\n    \\texternal onlyOwner {\\n        bSwapEnabled = enabled;\\n    }\\n\\n    function updateMinimumSwapTokenAmount(uint256 amount)\\n    \\texternal onlyOwner {\\n        require(amount >= (totalSupply() * 1) / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\n        require(amount <= (totalSupply() * 5) / 1000, \\\"Swap amount cannot be higher than 0.5% total supply.\\\");\\n        minSwapTokenAmount = amount;\\n    }\\n\\n    function updateMaxTokensPerWallet(uint256 newNum)\\n    \\texternal onlyOwner {\\n        require(newNum >= ((totalSupply() * 5) / 1000) / (10 ** decimals()), \\\"Cannot set maxTokenAmountPerWallet lower than 0.5%\\\");\\n        maxTokenAmountPerWallet = newNum * (10 ** decimals());\\n    }\\n\\n    function updateMaxTokenAmountPerTxn(uint256 newNum)\\n    \\texternal onlyOwner {\\n        require(newNum >= ((totalSupply() * 1) / 1000) / (10 ** decimals()), \\\"Cannot set maxTokenAmountPerTxn lower than 0.1%\\\");\\n        maxTokenAmountPerTxn = newNum * (10 ** decimals());\\n    }\\n\\n    function setBlackList(address[] calldata wallets, bool blocked) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            blackList[wallets[i]] = blocked;\\n        }\\n    }\\n\\n    function updateBuyTax(uint256 newMarketFee, uint256 newDevFee)\\n    \\texternal onlyOwner {\\n        buyMarketingTax = newMarketFee;\\n        buyDevTax = newDevFee;\\n        buyTotalTax = buyMarketingTax + buyDevTax;\\n        require(buyTotalTax <= 25, \\\"Must keep tax at 25% or less\\\");\\n    }\\n\\n    function updateSellTax(uint256 newMarketFee, uint256 newDevFee)\\n        external onlyOwner {\\n        sellMarketingTax = newMarketFee;\\n        sellDevTax = newDevFee;\\n        sellTotalTax = sellMarketingTax + sellDevTax;\\n        require(sellTotalTax <= 25, \\\"Must keep tax at 25% or less\\\");\\n    }\\n    \\n    function setAutomatedMarketMakerPairs(address pair, bool value)\\n        external onlyOwner {\\n        require(pair != swapPair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n    }\\n\\n    function setAntiDrainer(address newAntiDrainer)\\n        external onlyOwner {\\n        require(newAntiDrainer != address(0x0), \\\"Invalid anti-drainer\\\");\\n        antiDrainer = newAntiDrainer;\\n    }\\n\\n    function swapBack() private {\\n        bool success;\\n        uint256 tokenAmountToSwap = tokenAmountForMarketing + tokenAmountForDev;\\n        uint256 tokenBalance = balanceOf(address(this));\\n\\n        if (tokenAmountToSwap == 0 || tokenBalance == 0)\\n            return;\\n\\n        if (tokenBalance > minSwapTokenAmount * 20)\\n            tokenBalance = minSwapTokenAmount * 20;\\n\\n        uint256 prevETHBalance = address(this).balance;\\n        swapTokensForEth(tokenBalance);\\n\\n        uint256 ethBalance = address(this).balance.sub(prevETHBalance);\\n        uint256 ethForDev = ethBalance.mul(tokenAmountForDev).div(tokenAmountToSwap);\\n\\n        (success, ) = address(devWallet).call{value: ethForDev}(\\\"\\\");\\n        (success, ) = address(marketingWallet).call{ value: address(this).balance }(\\\"\\\");\\n\\n        tokenAmountForMarketing = 0;\\n        tokenAmountForDev = 0;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"ERC20: Invalid from address\\\");\\n        require(to != address(0), \\\"ERC20: Invalid to address\\\");\\n        require(!blackList[from], \\\"ERC20: from is black list\\\");\\n        require(!blackList[to], \\\"ERC20: to is black list\\\");\\n\\n        if (amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        if (limitsInEffect) {\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !bSwapping) {\\n                if (!bTradingActive) {\\n                    require(bExcludedFromTax[from] || bExcludedFromTax[to], \\\"Trading is not active.\\\");\\n                }\\n\\n                if (automatedMarketMakerPairs[from] && !bExcludedMaxTokenAmountPerTxn[to]) {\\n                    require(amount <= maxTokenAmountPerTxn, \\\"Buy transfer amount exceeds the maxTokenAmountPerTxn.\\\");\\n                    require(amount + balanceOf(to) <= maxTokenAmountPerWallet, \\\"Max wallet exceeded\\\");\\n                }\\n                else if (automatedMarketMakerPairs[to] && !bExcludedMaxTokenAmountPerTxn[from]) {\\n                    require(amount <= maxTokenAmountPerTxn, \\\"Sell transfer amount exceeds the maxTokenAmountPerTxn.\\\");\\n                }\\n                else if (!bExcludedMaxTokenAmountPerTxn[to]) {\\n                    require(amount + balanceOf(to) <= maxTokenAmountPerWallet, \\\"Max wallet exceeded\\\");\\n                }\\n            }\\n        }\\n\\n        if (antiDrainer != address(0) && IAntiDrainer(antiDrainer).isEnabled(address(this))) {\\n            bool check = IAntiDrainer(antiDrainer).check(from, to, address(swapPair), maxTokenAmountPerWallet, maxTokenAmountPerTxn, minSwapTokenAmount);\\n            require(check, \\\"Anti Drainer Enabled\\\");\\n        }\\n\\n        uint256 tokenBalance = balanceOf(address(this));\\n        bool canSwap = tokenBalance >= minSwapTokenAmount;\\n        if (bSwapEnabled && canSwap && !bSwapping &&\\n            automatedMarketMakerPairs[to] && !bExcludedFromTax[from] && !bExcludedFromTax[to]) {\\n            bSwapping = true;\\n            swapBack();\\n            bSwapping = false;\\n        }\\n\\n        bool bTax = !bSwapping;\\n        if (bExcludedFromTax[from] || bExcludedFromTax[to])\\n            bTax = false;\\n\\n        uint256 fees = 0;\\n        if (bTax) {\\n            if (automatedMarketMakerPairs[to] && sellTotalTax > 0) {\\n                fees = amount.mul(sellTotalTax).div(100);\\n                tokenAmountForDev += (fees * sellDevTax) / sellTotalTax;\\n                tokenAmountForMarketing += (fees * sellMarketingTax) / sellTotalTax;\\n            }\\n            else if (automatedMarketMakerPairs[from] && buyTotalTax > 0) {\\n                fees = amount.mul(buyTotalTax).div(100);\\n                tokenAmountForDev += (fees * buyDevTax) / buyTotalTax;\\n                tokenAmountForMarketing += (fees * buyMarketingTax) / buyTotalTax;\\n            }\\n            if (fees > 0)\\n                super._transfer(from, address(this), fees);\\n            amount -= fees;\\n        }\\n\\n        super._transfer(from, to, amount);\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return (a < b) ? a : b;\\n    }\\n\\n    receive() external payable {}\\n\\n    function swapTokensForEth(uint256 amount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = swapRouter.WETH();\\n\\n        _approve(address(this), address(swapRouter), amount);\\n\\n        // make the swap\\n        swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"activateTradingWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bExcludedFromTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bExcludedMaxTokenAmountPerTxn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bTradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDevTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTokenAmountPerTxn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"excludeFromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenAmountPerTxn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenAmountPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDevTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAntiDrainer\",\"type\":\"address\"}],\"name\":\"setAntiDrainer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"blocked\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAmountForDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAmountForMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDevFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxTokenAmountPerTxn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxTokensPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMinimumSwapTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDevFee\",\"type\":\"uint256\"}],\"name\":\"updateSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LEV", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}