{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CcipTokenTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Client} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\\\";\\nimport {IRouterClient} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\\\";\\nimport {IERC20} from \\\"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\\\";\\nimport {AddressArrayUtils} from \\\"./AddressArrayUtils.sol\\\";\\n\\ncontract CCIPTokenTransfer {\\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\\n    error NothingToWithdraw();\\n    error FailedToWithdrawEth(address owner, address target, uint256 value);\\n    error DestinationChainNotWhitelisted(uint64 destinationChainSelector);\\n\\n    event ChainWhitelisted(uint64 indexed destinationChainSelector);\\n    event TokensTransferred(\\n        bytes32 indexed messageId,\\n        uint64 indexed destinationChainSelector,\\n        address receiver,\\n        address token,\\n        uint256 tokenAmount,\\n        address feeToken,\\n        uint256 fees\\n    );\\n    event OwnerUpdated(address indexed newOwner);\\n\\n    // Mapping to track allowed destination chains\\n    mapping(uint64 => bool) public whitelistedChains;\\n\\n    // Instance of CCIP Router\\n    IRouterClient public router;\\n    // LINK fee token\\n    IERC20 public LINK;\\n\\n    // The address with administrative privileges over this contract\\n    address public owner;\\n\\n    /// @dev Modifier that checks if the chain with the given destinationChainSelector is whitelisted\\n    /// @param _destinationChainSelector The selector of the destination chain\\n    modifier onlyWhitelistedChain(uint64 _destinationChainSelector) {\\n        if (!whitelistedChains[_destinationChainSelector]) {\\n            revert DestinationChainNotWhitelisted(_destinationChainSelector);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks whether the msg.sender is owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Constructor initializes the contract with the router address\\n    /// @param _router The address of the router contract\\n    /// @param _link The address of the link contract\\n    constructor(address _router, address _link, address _owner) {\\n        router = IRouterClient(_router);\\n        LINK = IERC20(_link);\\n        owner = _owner;\\n    }\\n\\n    function _previewFee(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _token,\\n        uint256 _amount,\\n        address _feeToken\\n    ) internal view returns (uint256) {\\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(_receiver, _token, _amount, _feeToken);\\n        return router.getFee(_destinationChainSelector, evm2AnyMessage);\\n    }\\n\\n    function _maxApproveLink() internal {\\n        if (LINK.allowance(owner, address(router)) == 0) {\\n            LINK.approve(address(router), type(uint256).max);\\n        }\\n    }\\n\\n    function _maxApproveToken(address _token) internal {\\n        if (IERC20(_token).allowance(owner, address(router)) == 0) {\\n            IERC20(_token).approve(address(router), type(uint256).max);\\n        }\\n    }\\n\\n    /// @notice Find all tokens from input address array that are supported on destination chain\\n    /// @param _chainSelector The identifier for destination blockchain\\n    /// @param _tokens array of token addresses\\n    /// @return filteredTokens Address array of tokens that are supported\\n    function filterSupportedTokens(uint64 _chainSelector, address[] memory _tokens)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory supportedTokens = router.getSupportedTokens(_chainSelector);\\n        return AddressArrayUtils.intersect(supportedTokens, _tokens);\\n    }\\n\\n    /// @notice Test whether a specific token is valid on destination chain\\n    /// @param _chainSelector The identifier for destination blockchain\\n    /// @param _token token address\\n    /// @return isSupported Boolean indicating whether token is supported\\n    function tokenIsValid(uint64 _chainSelector, address _token) external view returns (bool isSupported) {\\n        address[] memory tokenArray = new address[](1);\\n        tokenArray[0] = _token;\\n        address[] memory supportedTokens = filterSupportedTokens(_chainSelector, tokenArray);\\n        return supportedTokens.length == 1;\\n    }\\n\\n    /// @notice Estimate fee transfer tokens to destination chain paying LINK as gas\\n    /// @param _destinationChainSelector The identifier for destination blockchain\\n    /// @param _receiver The address of the recipient on destination blockchai\\n    /// @param _token token address\\n    /// @param _amount token amount\\n    /// @return fee Amount of LINK token to provide as fee\\n    function previewFeeLINK(uint64 _destinationChainSelector, address _receiver, address _token, uint256 _amount)\\n        external\\n        view\\n        returns (uint256 fee)\\n    {\\n        return _previewFee(_destinationChainSelector, _receiver, _token, _amount, address(LINK));\\n    }\\n\\n    /// @notice Estimate fee transfer tokens to destination chain paying in native gas\\n    /// @param _destinationChainSelector The identifier for destination blockchain\\n    /// @param _receiver The address of the recipient on destination blockchai\\n    /// @param _token token address\\n    /// @param _amount token amount\\n    /// @return fee Amount of native token to provide as fee\\n    function previewFeeNative(uint64 _destinationChainSelector, address _receiver, address _token, uint256 _amount)\\n        external\\n        view\\n        returns (uint256 fee)\\n    {\\n        return _previewFee(_destinationChainSelector, _receiver, _token, _amount, address(0));\\n    }\\n\\n    /// @notice Transfer tokens to receiver on the destination chain\\n    /// @notice pay in LINK\\n    /// @notice the token must be in the list of supported tokens\\n    /// @notice This function can only be called by the owner\\n    /// @dev Assumes your contract has sufficient LINK tokens to pay for the fees\\n    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain\\n    /// @param _receiver The address of the recipient on the destination blockchain\\n    /// @param _token token address\\n    /// @param _amount token amount\\n    /// @return messageId The ID of the message that was sent\\n    function transferTokensPayLINK(uint64 _destinationChainSelector, address _receiver, address _token, uint256 _amount)\\n        external\\n        onlyWhitelistedChain(_destinationChainSelector)\\n        returns (bytes32 messageId)\\n    {\\n        // Create EVM2AnyMessage with information for sending cross-chain message\\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(_receiver, _token, _amount, address(LINK));\\n\\n        // Get the required fee\\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\\n\\n        // Approve the Router to transfer LINK tokens on contract's behalf\\n        _maxApproveLink();\\n        // Approve the Router to spend tokens on contract's behalf\\n        _maxApproveToken(_token);\\n\\n        // Pull funds to transfer and gas fee from user to contract\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n        LINK.transferFrom(msg.sender, address(this), fees);\\n\\n        // Send the message through the router\\n        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\\n        emit TokensTransferred(messageId, _destinationChainSelector, _receiver, _token, _amount, address(LINK), fees);\\n        return messageId;\\n    }\\n\\n    /// @notice Transfer tokens to receiver on the destination chain\\n    /// @notice Pay in native gas such as ETH on Ethereum or MATIC on Polgon\\n    /// @notice the token must be in the list of supported tokens\\n    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or MATIC on Polygon\\n    /// @param _destinationChainSelector The identifier for destination blockchain\\n    /// @param _receiver The address of the recipient on destination blockchain\\n    /// @param _token token address\\n    /// @param _amount token amount\\n    /// @return messageId The ID of the message that was sent\\n    function transferTokensPayNative(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _token,\\n        uint256 _amount\\n    ) external payable onlyWhitelistedChain(_destinationChainSelector) returns (bytes32 messageId) {\\n        // Create EVM2AnyMessage with information for sending cross-chain message\\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(_receiver, _token, _amount, address(0));\\n\\n        // Get the required fee\\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\\n        if (fees > address(this).balance) {\\n            revert NotEnoughBalance(address(this).balance, fees);\\n        }\\n\\n        // approve the Router to spend token on contract's behalf\\n        _maxApproveToken(_token);\\n\\n        // Pull funds to transfer from user to contract\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n\\n        // Send the message through the router\\n        messageId = router.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\\n        emit TokensTransferred(messageId, _destinationChainSelector, _receiver, _token, _amount, address(0), fees);\\n        return messageId;\\n    }\\n\\n    /// @notice Construct a CCIP message\\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer\\n    /// @param _receiver The address of the receiver\\n    /// @param _token The token to be transferred\\n    /// @param _amount The amount of the token to be transferred\\n    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas\\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message\\n    function _buildCCIPMessage(address _receiver, address _token, uint256 _amount, address _feeTokenAddress)\\n        internal\\n        pure\\n        returns (Client.EVM2AnyMessage memory)\\n    {\\n        // Set the token amounts\\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\\n        tokenAmounts[0] = Client.EVMTokenAmount({token: _token, amount: _amount});\\n\\n        return Client.EVM2AnyMessage({\\n            receiver: abi.encode(_receiver), // ABI-encoded receiver address\\n            data: \\\"\\\", // No data\\n            tokenAmounts: tokenAmounts, // The amount and type of token being transferred\\n            extraArgs: Client._argsToBytes(\\n                // Additional arguments, setting gas limit to 0 as we are not sending any data and non-strict sequencing mode\\n                Client.EVMExtraArgsV1({gasLimit: 0, strict: false})\\n                ),\\n            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\\n            feeToken: _feeTokenAddress\\n        });\\n    }\\n\\n    /// @notice Fallback function to allow the contract to receive Ether\\n    /// It is automatically called when Ether is transferred to the contract without any data\\n    receive() external payable {}\\n\\n    /// @dev Updates the whitelist status of a destination chain for transactions\\n    /// @notice This function can only be called by the owner\\n    /// @param _destinationChainSelector The selector of the destination chain to be updated\\n    /// @param allowed The whitelist status to be set for the destination chain\\n    function whitelistDestinationChain(uint64 _destinationChainSelector, bool allowed) external onlyOwner {\\n        whitelistedChains[_destinationChainSelector] = allowed;\\n    }\\n\\n    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract\\n    /// @notice This function can only be called by the owner\\n    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails\\n    /// @param _beneficiary The address to which the Ether should be transferred\\n    function withdraw(address _beneficiary) public onlyOwner {\\n        // Retrieve the balance of this contract\\n        uint256 amount = address(this).balance;\\n\\n        // Revert if there is nothing to withdraw\\n        if (amount == 0) revert NothingToWithdraw();\\n\\n        // Attempt to send the funds, capturing the success status and discarding any return data\\n        (bool sent,) = _beneficiary.call{value: amount}(\\\"\\\");\\n\\n        // Revert if the send failed, with information about the attempted transfer\\n        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);\\n    }\\n\\n    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token\\n    /// @notice This function can only be called by the owner\\n    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw\\n    /// @param _beneficiary The address to which the tokens will be sent\\n    /// @param _token The contract address of the ERC20 token to be withdrawn\\n    function withdrawToken(address _beneficiary, address _token) public onlyOwner {\\n        // Retrieve the balance of this contract\\n        uint256 amount = IERC20(_token).balanceOf(address(this));\\n\\n        // Revert if there is nothing to withdraw\\n        if (amount == 0) revert NothingToWithdraw();\\n\\n        IERC20(_token).transfer(_beneficiary, amount);\\n    }\\n\\n    /// @notice Updates the owner address of this contract.\\n    /// @notice This function can only be called by the owner\\n    function setOwner(address newOwner) public onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    /// @notice Sets router allowance to 0 to disable transferring tokens out of contract\\n    /// @notice This function can only be called by the owner\\n    /// @param _token The contract address of the ERC20 token to disable\\n    function revokeRouterAllowance(address _token) external onlyOwner {\\n        LINK.approve(address(router), 0);\\n        IERC20(_token).approve(address(router), 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // extraArgs will evolve to support new features\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\\n    bool strict; // See strict sequencing details below.\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param chainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\\n\\n  /// @notice Gets a list of all supported tokens which can be sent or received\\n  /// to/from a given chain id.\\n  /// @param chainSelector The chainSelector.\\n  /// @return tokens The addresses of all tokens that are supported.\\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\\n\\n  /// @param destinationChainSelector The destination chainSelector\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return fee returns guaranteed execution fee for the specified message\\n  /// delivery to destination chain\\n  /// @dev returns 0 fee on invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain\\n  /// @param destinationChainSelector The destination chain ID\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return messageId The message ID\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\\n  /// the overpayment with no refund.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\"\r\n    },\r\n    \"src/AddressArrayUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/// @notice A stripped down version of the utils from https://github.com/cryptofinlabs/cryptofin-solidity/\\nlibrary AddressArrayUtils {\\n    /**\\n     * Finds the index of the first occurrence of the given element.\\n     * @param A The input array to search\\n     * @param a The value to find\\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\\n     */\\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\\n        uint256 length = A.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (A[i] == a) {\\n                return (i, true);\\n            }\\n        }\\n        return (0, false);\\n    }\\n\\n    /**\\n     * Returns true if the value is present in the list. Uses indexOf internally.\\n     * @param A The input array to search\\n     * @param a The value to find\\n     * @return Returns isIn for the first occurrence starting from index 0\\n     */\\n    function contains(address[] memory A, address a) internal pure returns (bool) {\\n        (, bool isIn) = indexOf(A, a);\\n        return isIn;\\n    }\\n\\n    /**\\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\\n     * @param A The first array\\n     * @param B The second array\\n     * @return The intersection of the two arrays\\n     */\\n    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\\n        uint256 length = A.length;\\n        bool[] memory includeMap = new bool[](length);\\n        uint256 newLength = 0;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (contains(B, A[i])) {\\n                includeMap[i] = true;\\n                newLength++;\\n            }\\n        }\\n        address[] memory newAddresses = new address[](newLength);\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (includeMap[i]) {\\n                newAddresses[j] = A[i];\\n                j++;\\n            }\\n        }\\n        return newAddresses;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\r\n      \"@chainlink/contracts-ccip/=node_modules/@chainlink/contracts-ccip/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"dss-interfaces/=lib/dss-test/lib/dss-interfaces/src/\",\r\n      \"dss-test/=lib/dss-test/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"}],\"name\":\"DestinationChainNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedToWithdrawEth\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calculatedFees\",\"type\":\"uint256\"}],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"}],\"name\":\"ChainWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"TokensTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"filterSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"previewFeeLINK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"previewFeeNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"revokeRouterAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouterClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"tokenIsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokensPayLINK\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokensPayNative\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"whitelistDestinationChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"whitelistedChains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CCIPTokenTransfer", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e561d5e02207fb5eb32cca20a699e0d8919a1476000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000027e843260c71443b4cc8cb6bf226c3f77b9695af", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}