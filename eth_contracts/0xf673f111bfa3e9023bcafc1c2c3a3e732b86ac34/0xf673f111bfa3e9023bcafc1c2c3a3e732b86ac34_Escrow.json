{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Escrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity = 0.8.12;\\n\\n// Inheritance\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./LimitedSetup.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\ncontract Escrow is Ownable, LimitedSetup {\\n\\n    /* The escrow token. */\\n    address public token;\\n\\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\\n     * These are the times at which each given quantity of WSD vests. */\\n    mapping(address => uint[2][]) public vestingSchedules;\\n\\n    /* An account's total vested balance to save recomputing this for fee extraction purposes. */\\n    mapping(address => uint) public totalVestedAccountBalance;\\n    mapping(address => uint) public accountVestedBalance;\\n    mapping(address => uint[]) public accountVestingDates;\\n\\n    /* The total remaining vested balance, for verifying the actual balance of this contract against. */\\n    uint public totalVestedBalance;\\n    uint public constant TIME_INDEX = 0;\\n    uint public constant QUANTITY_INDEX = 1;\\n\\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules. */\\n    uint public constant MAX_VESTING_ENTRIES = 140;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address _token) LimitedSetup(8 weeks) {\\n        token = _token;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice A simple alias to totalVestedAccountBalance: provides ERC20 balance integration.\\n     */\\n    function balanceOf(address account) public view returns (uint) {\\n        return totalVestedAccountBalance[account];\\n    }\\n\\n    /**\\n     * @notice The number of vesting dates in an account's schedule.\\n     */\\n    function numVestingEntries(address account) public view returns (uint) {\\n        return vestingSchedules[account].length;\\n    }\\n\\n    /**\\n     * @notice Get a particular schedule entry for an account.\\n     * @return A pair of uints: (timestamp, quantity).\\n     */\\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\\n        return vestingSchedules[account][index];\\n    }\\n\\n    /**\\n     * @notice Get the time at which a given schedule entry will vest.\\n     */\\n    function getVestingTime(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Get the quantity of WSD associated with a given schedule entry.\\n     */\\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\\n     */\\n    function getNextVestingIndex(address account) public view returns (uint) {\\n        uint len = numVestingEntries(account);\\n        for (uint i = 0; i < len; i++) {\\n            if (getVestingTime(account, i) != 0) {\\n                return i;\\n            }\\n        }\\n        return len;\\n    }\\n\\n    function getVestingDates(address account) public view returns (uint256[] memory) {\\n        uint len = numVestingEntries(account);\\n        uint256[] memory dates = new uint256[](len);\\n\\n        for (uint i = 0; i < len; i++) {\\n            dates[i] = accountVestingDates[account][i];\\n        }\\n\\n        return dates;\\n    }\\n\\n    /**\\n     * @notice Obtain the next schedule entry that will vest for a given user.\\n     * @return A pair of uints: (timestamp, quantity). */\\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\\n        uint index = getNextVestingIndex(account);\\n        if (index == numVestingEntries(account)) {\\n            return [uint(0), 0];\\n        }\\n        return getVestingScheduleEntry(account, index);\\n    }\\n\\n    /**\\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingTime(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingQuantity(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Destroy the vesting information associated with an account.\\n     */\\n    function purgeAccount(address account) external onlyOwner onlyDuringSetup {\\n        delete vestingSchedules[account];\\n        totalVestedBalance = totalVestedBalance - totalVestedAccountBalance[account];\\n        delete totalVestedAccountBalance[account];\\n    }\\n\\n    /**\\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\\n     * @dev A call to this should be accompanied by either enough balance already available\\n     * in this contract, or a corresponding call to.endow(), to ensure that when\\n     * the funds are withdrawn, there is enough balance, as well as correctly calculating\\n     * the fees.\\n     * This may only be called by the owner during the contract's setup period.\\n     * Note; although this function could technically be used to produce unbounded\\n     * arrays, it's only in the foundation's command to add to these lists.\\n     * @param account The account to append a new vesting entry to.\\n     * @param time The absolute unix timestamp after which the vested quantity may be withdrawn.\\n     * @param quantity The quantity of WSD that will vest.\\n     */\\n    function appendVestingEntry(\\n        address account,\\n        uint time,\\n        uint quantity\\n    ) public onlyOwner onlyDuringSetup {\\n        /* No empty or already-passed vesting entries allowed. */\\n        require(block.timestamp < time, \\\"Time must be in the future\\\");\\n        require(quantity != 0, \\\"Quantity cannot be zero\\\");\\n\\n        /* There must be enough balance in the contract to provide for the vesting entry. */\\n        totalVestedBalance = totalVestedBalance + quantity;\\n        require(\\n            totalVestedBalance <= IERC20(token).balanceOf(address(this)),\\n            \\\"Must be enough balance in the contract to provide for the vesting entry\\\"\\n        );\\n\\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\\n        uint scheduleLength = vestingSchedules[account].length;\\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \\\"Vesting schedule is too long\\\");\\n        accountVestedBalance[account] = accountVestedBalance[account] + quantity;\\n        accountVestingDates[account].push(time);\\n\\n        if (scheduleLength == 0) {\\n            totalVestedAccountBalance[account] = quantity;\\n        } else {\\n            /* Disallow adding new vesting earlier than the last one.\\n             * Since entries are only appended, this means that no vesting date can be repeated. */\\n            require(\\n                getVestingTime(account, numVestingEntries(account) - 1) < time,\\n                \\\"Cannot add new vested entries earlier than the last one\\\"\\n            );\\n            totalVestedAccountBalance[account] = totalVestedAccountBalance[account] + quantity;\\n        }\\n\\n        vestingSchedules[account].push([time, quantity]);\\n    }\\n\\n    /**\\n     * @notice Construct a vesting schedule to release a quantities of WSD with array of accounts\\n     * over a series of intervals.\\n     * @dev Assumes that the quantities are nonzero\\n     * and that the sequence of timestamps is strictly increasing.\\n     * This may only be called by the owner during the contract's setup period.\\n     */\\n    function addVestingSchedules(\\n        address[] calldata accounts,\\n        uint[] calldata times,\\n        uint[] calldata quantities\\n    ) external onlyOwner onlyDuringSetup {\\n        require(accounts.length == times.length, 'invalid length time');\\n        require(accounts.length == quantities.length, 'invalid length quantities');\\n\\n        for(uint i = 0; i < accounts.length; i++) {\\n            appendVestingEntry(accounts[i], times[i], quantities[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Construct a vesting schedule to release a quantities of WSD\\n     * over a series of intervals.\\n     * @dev Assumes that the quantities are nonzero\\n     * and that the sequence of timestamps is strictly increasing.\\n     * This may only be called by the owner during the contract's setup period.\\n     */\\n    function addVestingSchedule(\\n        address account,\\n        uint[] calldata times,\\n        uint[] calldata quantities\\n    ) external onlyOwner onlyDuringSetup {\\n        for (uint i = 0; i < times.length; i++) {\\n            appendVestingEntry(account, times[i], quantities[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Allow a user to withdraw any WSD in their schedule that have vested.\\n     */\\n    function vest() external {\\n        uint numEntries = numVestingEntries(msg.sender);\\n        uint total;\\n        for (uint i = 0; i < numEntries; i++) {\\n            uint time = getVestingTime(msg.sender, i);\\n            /* The list is sorted; when we reach the first future time, bail out. */\\n            if (time > block.timestamp) {\\n                break;\\n            }\\n            uint qty = getVestingQuantity(msg.sender, i);\\n            if (qty > 0) {\\n                vestingSchedules[msg.sender][i] = [0, 0];\\n                total = total + qty;\\n            }\\n        }\\n\\n        if (total != 0) {\\n            totalVestedBalance = totalVestedBalance - total;\\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender] - total;\\n            require(IERC20(token).transfer(msg.sender, total));\\n            emit Vested(msg.sender, block.timestamp, total);\\n        }\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Vested(address indexed beneficiary, uint time, uint value);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.12;\\n\\ninterface IERC20 {\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/LimitedSetup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.12;\\n\\ncontract LimitedSetup {\\n    uint public setupExpiryTime;\\n\\n    /**\\n     * @dev LimitedSetup Constructor.\\n     * @param setupDuration The time the setup period will last for.\\n     */\\n    constructor(uint setupDuration) {\\n        setupExpiryTime = block.timestamp + setupDuration;\\n    }\\n\\n    modifier onlyDuringSetup {\\n        require(block.timestamp < setupExpiryTime, \\\"Can only perform this action during setup\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.12;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_VESTING_ENTRIES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUANTITY_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountVestedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountVestingDates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"addVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"addVestingSchedules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"appendVestingEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNextVestingEntry\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNextVestingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNextVestingQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNextVestingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getVestingDates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVestingQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVestingScheduleEntry\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVestingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"numVestingEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"purgeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setupExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalVestedAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVestedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingSchedules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Escrow", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000423d7c27d1dde7eb4aae02dae6b651c7225e6f9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}