{"SourceCode": "// File: https://github.com/Vectorized/solady/blob/main/src/auth/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n///\r\n/// @dev Note:\r\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\r\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\r\n///\r\n/// While the ownable portion follows\r\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\r\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\r\nabstract contract Ownable {\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                       CUSTOM ERRORS                        */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev The caller is not authorized to call the function.\r\n\terror Unauthorized();\r\n\r\n\t/// @dev The `newOwner` cannot be the zero address.\r\n\terror NewOwnerIsZeroAddress();\r\n\r\n\t/// @dev The `pendingOwner` does not have a valid handover request.\r\n\terror NoHandoverRequest();\r\n\r\n\t/// @dev Cannot double-initialize.\r\n\terror AlreadyInitialized();\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                           EVENTS                           */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n\t/// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n\t/// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n\t/// despite it not being as lightweight as a single argument event.\r\n\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n\t/// @dev An ownership handover to `pendingOwner` has been requested.\r\n\tevent OwnershipHandoverRequested(address indexed pendingOwner);\r\n\r\n\t/// @dev The ownership handover to `pendingOwner` has been canceled.\r\n\tevent OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n\t/// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n\tuint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n\t\t0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n\t/// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\r\n\tuint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\r\n\t\t0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\r\n\r\n\t/// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\r\n\tuint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\r\n\t\t0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                          STORAGE                           */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev The owner slot is given by:\r\n\t/// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\r\n\t/// It is intentionally chosen to be a high value\r\n\t/// to avoid collision with lower slots.\r\n\t/// The choice of manual storage layout is to enable compatibility\r\n\t/// with both regular and upgradeable contracts.\r\n\tbytes32 internal constant _OWNER_SLOT =\r\n\t\t0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\r\n\r\n\t/// The ownership handover slot of `newOwner` is given by:\r\n\t/// ```\r\n\t///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\r\n\t///     let handoverSlot := keccak256(0x00, 0x20)\r\n\t/// ```\r\n\t/// It stores the expiry timestamp of the two-step ownership handover.\r\n\tuint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                     INTERNAL FUNCTIONS                     */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\r\n\tfunction _guardInitializeOwner() internal pure virtual returns (bool guard) {}\r\n\r\n\t/// @dev Initializes the owner directly without authorization guard.\r\n\t/// This function must be called upon initialization,\r\n\t/// regardless of whether the contract is upgradeable or not.\r\n\t/// This is to enable generalization to both regular and upgradeable contracts,\r\n\t/// and to save gas in case the initial owner is not the caller.\r\n\t/// For performance reasons, this function will not check if there\r\n\t/// is an existing owner.\r\n\tfunction _initializeOwner(address newOwner) internal virtual {\r\n\t\tif (_guardInitializeOwner()) {\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tlet ownerSlot := _OWNER_SLOT\r\n\t\t\t\tif sload(ownerSlot) {\r\n\t\t\t\t\tmstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\r\n\t\t\t\t\trevert(0x1c, 0x04)\r\n\t\t\t\t}\r\n\t\t\t\t// Clean the upper 96 bits.\r\n\t\t\t\tnewOwner := shr(96, shl(96, newOwner))\r\n\t\t\t\t// Store the new value.\r\n\t\t\t\tsstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\r\n\t\t\t\t// Emit the {OwnershipTransferred} event.\r\n\t\t\t\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\t// Clean the upper 96 bits.\r\n\t\t\t\tnewOwner := shr(96, shl(96, newOwner))\r\n\t\t\t\t// Store the new value.\r\n\t\t\t\tsstore(_OWNER_SLOT, newOwner)\r\n\t\t\t\t// Emit the {OwnershipTransferred} event.\r\n\t\t\t\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Sets the owner directly without authorization guard.\r\n\tfunction _setOwner(address newOwner) internal virtual {\r\n\t\tif (_guardInitializeOwner()) {\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tlet ownerSlot := _OWNER_SLOT\r\n\t\t\t\t// Clean the upper 96 bits.\r\n\t\t\t\tnewOwner := shr(96, shl(96, newOwner))\r\n\t\t\t\t// Emit the {OwnershipTransferred} event.\r\n\t\t\t\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n\t\t\t\t// Store the new value.\r\n\t\t\t\tsstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tlet ownerSlot := _OWNER_SLOT\r\n\t\t\t\t// Clean the upper 96 bits.\r\n\t\t\t\tnewOwner := shr(96, shl(96, newOwner))\r\n\t\t\t\t// Emit the {OwnershipTransferred} event.\r\n\t\t\t\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n\t\t\t\t// Store the new value.\r\n\t\t\t\tsstore(ownerSlot, newOwner)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Throws if the sender is not the owner.\r\n\tfunction _checkOwner() internal view virtual {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// If the caller is not the stored owner, revert.\r\n\t\t\tif iszero(eq(caller(), sload(_OWNER_SLOT))) {\r\n\t\t\t\tmstore(0x00, 0x82b42900) // `Unauthorized()`.\r\n\t\t\t\trevert(0x1c, 0x04)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns how long a two-step ownership handover is valid for in seconds.\r\n\t/// Override to return a different value if needed.\r\n\t/// Made internal to conserve bytecode. Wrap it in a public function if needed.\r\n\tfunction _ownershipHandoverValidFor() internal view virtual returns (uint64) {\r\n\t\treturn 48 * 3600;\r\n\t}\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                  PUBLIC UPDATE FUNCTIONS                   */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n\tfunction transferOwnership(address newOwner) public payable virtual onlyOwner {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tif iszero(shl(96, newOwner)) {\r\n\t\t\t\tmstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\r\n\t\t\t\trevert(0x1c, 0x04)\r\n\t\t\t}\r\n\t\t}\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\t/// @dev Allows the owner to renounce their ownership.\r\n\tfunction renounceOwnership() public payable virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/// @dev Request a two-step ownership handover to the caller.\r\n\t/// The request will automatically expire in 48 hours (172800 seconds) by default.\r\n\tfunction requestOwnershipHandover() public payable virtual {\r\n\t\tunchecked {\r\n\t\t\tuint256 expires = block.timestamp + _ownershipHandoverValidFor();\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\t// Compute and set the handover slot to `expires`.\r\n\t\t\t\tmstore(0x0c, _HANDOVER_SLOT_SEED)\r\n\t\t\t\tmstore(0x00, caller())\r\n\t\t\t\tsstore(keccak256(0x0c, 0x20), expires)\r\n\t\t\t\t// Emit the {OwnershipHandoverRequested} event.\r\n\t\t\t\tlog2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Cancels the two-step ownership handover to the caller, if any.\r\n\tfunction cancelOwnershipHandover() public payable virtual {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// Compute and set the handover slot to 0.\r\n\t\t\tmstore(0x0c, _HANDOVER_SLOT_SEED)\r\n\t\t\tmstore(0x00, caller())\r\n\t\t\tsstore(keccak256(0x0c, 0x20), 0)\r\n\t\t\t// Emit the {OwnershipHandoverCanceled} event.\r\n\t\t\tlog2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\r\n\t/// Reverts if there is no existing ownership handover requested by `pendingOwner`.\r\n\tfunction completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// Compute and set the handover slot to 0.\r\n\t\t\tmstore(0x0c, _HANDOVER_SLOT_SEED)\r\n\t\t\tmstore(0x00, pendingOwner)\r\n\t\t\tlet handoverSlot := keccak256(0x0c, 0x20)\r\n\t\t\t// If the handover does not exist, or has expired.\r\n\t\t\tif gt(timestamp(), sload(handoverSlot)) {\r\n\t\t\t\tmstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\r\n\t\t\t\trevert(0x1c, 0x04)\r\n\t\t\t}\r\n\t\t\t// Set the handover slot to 0.\r\n\t\t\tsstore(handoverSlot, 0)\r\n\t\t}\r\n\t\t_setOwner(pendingOwner);\r\n\t}\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                   PUBLIC READ FUNCTIONS                    */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev Returns the owner of the contract.\r\n\tfunction owner() public view virtual returns (address result) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tresult := sload(_OWNER_SLOT)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\r\n\tfunction ownershipHandoverExpiresAt(address pendingOwner)\r\n\t\tpublic\r\n\t\tview\r\n\t\tvirtual\r\n\t\treturns (uint256 result)\r\n\t{\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// Compute the handover slot.\r\n\t\t\tmstore(0x0c, _HANDOVER_SLOT_SEED)\r\n\t\t\tmstore(0x00, pendingOwner)\r\n\t\t\t// Load the handover slot.\r\n\t\t\tresult := sload(keccak256(0x0c, 0x20))\r\n\t\t}\r\n\t}\r\n\r\n\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n\t/*                         MODIFIERS                          */\r\n\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n\t/// @dev Marks a function as only callable by the owner.\r\n\tmodifier onlyOwner() virtual {\r\n\t\t_checkOwner();\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n// File: https://github.com/Vectorized/dn404/blob/main/src/DN404Mirror.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title DN404Mirror\r\n/// @notice DN404Mirror provides an interface for interacting with the\r\n/// NFT tokens in a DN404 implementation.\r\n///\r\n/// @author vectorized.eth (@optimizoor)\r\n/// @author Quit (@0xQuit)\r\n/// @author Michael Amadi (@AmadiMichaels)\r\n/// @author cygaar (@0xCygaar)\r\n/// @author Thomas (@0xjustadev)\r\n/// @author Harrison (@PopPunkOnChain)\r\n///\r\n/// @dev Note:\r\n/// - The ERC721 data is stored in the base DN404 contract.\r\ncontract DN404Mirror is Ownable {\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                           EVENTS                           */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Emitted when token `id` is transferred from `from` to `to`.\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n\t/// @dev Emitted when `owner` enables `account` to manage the `id` token.\r\n\tevent Approval(address indexed owner, address indexed account, uint256 indexed id);\r\n\r\n\t/// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\r\n\r\n\t/// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n\tuint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n\t\t0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n\t/// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n\tuint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n\t\t0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n\t/// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\r\n\tuint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\r\n\t\t0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                        CUSTOM ERRORS                       */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Thrown when a call for an NFT function did not originate\r\n\t/// from the base DN404 contract.\r\n\terror SenderNotBase();\r\n\r\n\t/// @dev Thrown when a call for an NFT function did not originate from the deployer.\r\n\terror SenderNotDeployer();\r\n\r\n\t/// @dev Thrown when transferring an NFT to a contract address that\r\n\t/// does not implement ERC721Receiver.\r\n\terror TransferToNonERC721ReceiverImplementer();\r\n\r\n\t/// @dev Thrown when linking to the DN404 base contract and the\r\n\t/// DN404 supportsInterface check fails or the call reverts.\r\n\terror CannotLink();\r\n\r\n\t/// @dev Thrown when a linkMirrorContract call is received and the\r\n\t/// NFT mirror contract has already been linked to a DN404 base contract.\r\n\terror AlreadyLinked();\r\n\r\n\t/// @dev Thrown when retrieving the base DN404 address when a link has not\r\n\t/// been established.\r\n\terror NotLinked();\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                          STORAGE                           */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Struct contain the NFT mirror contract storage.\r\n\tstruct DN404NFTStorage {\r\n\t\taddress baseERC20;\r\n\t\taddress deployer;\r\n\t}\r\n\r\n\t/// @dev Returns a storage pointer for DN404NFTStorage.\r\n\tfunction _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// `uint72(bytes9(keccak256(\"DN404_MIRROR_STORAGE\")))`.\r\n\t\t\t$.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\r\n\t\t}\r\n\t}\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                        CONSTRUCTOR                         */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\tconstructor(address deployer) {\r\n\t\t// For non-proxies, we will store the deployer so that only the deployer can\r\n\t\t// link the base contract.\r\n\t\t_getDN404NFTStorage().deployer = deployer;\r\n\t\t_initializeOwner(deployer);\r\n\t}\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                     ERC721 OPERATIONS                      */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Returns the token collection name from the base DN404 contract.\r\n\tfunction name() public view virtual returns (string memory result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tresult := mload(0x40)\r\n\t\t\tmstore(0x00, 0x06fdde03) // `name()`.\r\n\t\t\tif iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\r\n\t\t\t\treturndatacopy(result, 0x00, returndatasize())\r\n\t\t\t\trevert(result, returndatasize())\r\n\t\t\t}\r\n\t\t\treturndatacopy(0x00, 0x00, 0x20)\r\n\t\t\treturndatacopy(result, mload(0x00), 0x20)\r\n\t\t\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n\t\t\tmstore(0x40, add(add(result, 0x20), mload(result)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the token collection symbol from the base DN404 contract.\r\n\tfunction symbol() public view virtual returns (string memory result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tresult := mload(0x40)\r\n\t\t\tmstore(0x00, 0x95d89b41) // `symbol()`.\r\n\t\t\tif iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\r\n\t\t\t\treturndatacopy(result, 0x00, returndatasize())\r\n\t\t\t\trevert(result, returndatasize())\r\n\t\t\t}\r\n\t\t\treturndatacopy(0x00, 0x00, 0x20)\r\n\t\t\treturndatacopy(result, mload(0x00), 0x20)\r\n\t\t\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n\t\t\tmstore(0x40, add(add(result, 0x20), mload(result)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\r\n\t/// the base DN404 contract.\r\n\tfunction tokenURI(uint256 id) public view virtual returns (string memory result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tresult := mload(0x40)\r\n\t\t\tmstore(0x20, id)\r\n\t\t\tmstore(0x00, 0xc87b56dd) // `tokenURI()`.\r\n\t\t\tif iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\r\n\t\t\t\treturndatacopy(result, 0x00, returndatasize())\r\n\t\t\t\trevert(result, returndatasize())\r\n\t\t\t}\r\n\t\t\treturndatacopy(0x00, 0x00, 0x20)\r\n\t\t\treturndatacopy(result, mload(0x00), 0x20)\r\n\t\t\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n\t\t\tmstore(0x40, add(add(result, 0x20), mload(result)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the total NFT supply from the base DN404 contract.\r\n\tfunction totalSupply() public view virtual returns (uint256 result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\r\n\t\t\tif iszero(\r\n\t\t\t\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(mload(0x40), 0x00, returndatasize())\r\n\t\t\t\trevert(mload(0x40), returndatasize())\r\n\t\t\t}\r\n\t\t\tresult := mload(0x00)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - `owner` must not be the zero address.\r\n\tfunction balanceOf(address owner) public view virtual returns (uint256 result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x20, shr(96, shl(96, owner)))\r\n\t\t\tmstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\r\n\t\t\tif iszero(\r\n\t\t\t\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(mload(0x40), 0x00, returndatasize())\r\n\t\t\t\trevert(mload(0x40), returndatasize())\r\n\t\t\t}\r\n\t\t\tresult := mload(0x00)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the owner of token `id` from the base DN404 contract.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - Token `id` must exist.\r\n\tfunction ownerOf(uint256 id) public view virtual returns (address result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\r\n\t\t\tmstore(0x20, id)\r\n\t\t\tif iszero(\r\n\t\t\t\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(mload(0x40), 0x00, returndatasize())\r\n\t\t\t\trevert(mload(0x40), returndatasize())\r\n\t\t\t}\r\n\t\t\tresult := shr(96, mload(0x0c))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Sets `spender` as the approved account to manage token `id` in\r\n\t/// the base DN404 contract.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - Token `id` must exist.\r\n\t/// - The caller must be the owner of the token,\r\n\t///   or an approved operator for the token owner.\r\n\t///\r\n\t/// Emits an {Approval} event.\r\n\tfunction approve(address spender, uint256 id) public virtual {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tspender := shr(96, shl(96, spender))\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\r\n\t\t\tmstore(0x20, spender)\r\n\t\t\tmstore(0x40, id)\r\n\t\t\tmstore(0x60, caller())\r\n\t\t\tif iszero(\r\n\t\t\t\tand(\r\n\t\t\t\t\tgt(returndatasize(), 0x1f),\r\n\t\t\t\t\tcall(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(m, 0x00, returndatasize())\r\n\t\t\t\trevert(m, returndatasize())\r\n\t\t\t}\r\n\t\t\tmstore(0x40, m) // Restore the free memory pointer.\r\n\t\t\tmstore(0x60, 0) // Restore the zero pointer.\r\n\t\t\t// Emit the {Approval} event.\r\n\t\t\tlog4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns the account approved to manage token `id` from\r\n\t/// the base DN404 contract.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - Token `id` must exist.\r\n\tfunction getApproved(uint256 id) public view virtual returns (address result) {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, 0x081812fc) // `getApproved(uint256)`.\r\n\t\t\tmstore(0x20, id)\r\n\t\t\tif iszero(\r\n\t\t\t\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(mload(0x40), 0x00, returndatasize())\r\n\t\t\t\trevert(mload(0x40), returndatasize())\r\n\t\t\t}\r\n\t\t\tresult := shr(96, mload(0x0c))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Sets whether `operator` is approved to manage the tokens of the caller in\r\n\t/// the base DN404 contract.\r\n\t///\r\n\t/// Emits an {ApprovalForAll} event.\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\toperator := shr(96, shl(96, operator))\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\r\n\t\t\tmstore(0x20, operator)\r\n\t\t\tmstore(0x40, iszero(iszero(approved)))\r\n\t\t\tmstore(0x60, caller())\r\n\t\t\tif iszero(\r\n\t\t\t\tand(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(m, 0x00, returndatasize())\r\n\t\t\t\trevert(m, returndatasize())\r\n\t\t\t}\r\n\t\t\t// Emit the {ApprovalForAll} event.\r\n\t\t\tlog3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\r\n\t\t\tmstore(0x40, m) // Restore the free memory pointer.\r\n\t\t\tmstore(0x60, 0) // Restore the zero pointer.\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\r\n\t/// the base DN404 contract.\r\n\tfunction isApprovedForAll(address owner, address operator)\r\n\t\tpublic\r\n\t\tview\r\n\t\tvirtual\r\n\t\treturns (bool result)\r\n\t{\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(0x40, operator)\r\n\t\t\tmstore(0x2c, shl(96, owner))\r\n\t\t\tmstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\r\n\t\t\tif iszero(\r\n\t\t\t\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(m, 0x00, returndatasize())\r\n\t\t\t\trevert(m, returndatasize())\r\n\t\t\t}\r\n\t\t\tmstore(0x40, m) // Restore the free memory pointer.\r\n\t\t\tresult := iszero(iszero(mload(0x00)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Transfers token `id` from `from` to `to`.\r\n\t///\r\n\t/// Requirements:\r\n\t///\r\n\t/// - Token `id` must exist.\r\n\t/// - `from` must be the owner of the token.\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - The caller must be the owner of the token, or be approved to manage the token.\r\n\t///\r\n\t/// Emits a {Transfer} event.\r\n\tfunction transferFrom(address from, address to, uint256 id) public virtual {\r\n\t\taddress base = baseERC20();\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tfrom := shr(96, shl(96, from))\r\n\t\t\tto := shr(96, shl(96, to))\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\r\n\t\t\tmstore(add(m, 0x20), from)\r\n\t\t\tmstore(add(m, 0x40), to)\r\n\t\t\tmstore(add(m, 0x60), id)\r\n\t\t\tmstore(add(m, 0x80), caller())\r\n\t\t\tif iszero(\r\n\t\t\t\tand(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\r\n\t\t\t) {\r\n\t\t\t\treturndatacopy(m, 0x00, returndatasize())\r\n\t\t\t\trevert(m, returndatasize())\r\n\t\t\t}\r\n\t\t\t// Emit the {Transfer} event.\r\n\t\t\tlog4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\r\n\tfunction safeTransferFrom(address from, address to, uint256 id) public payable virtual {\r\n\t\ttransferFrom(from, to, id);\r\n\r\n\t\tif (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\r\n\t}\r\n\r\n\t/// @dev Transfers token `id` from `from` to `to`.\r\n\t///\r\n\t/// Requirements:\r\n\t///\r\n\t/// - Token `id` must exist.\r\n\t/// - `from` must be the owner of the token.\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - The caller must be the owner of the token, or be approved to manage the token.\r\n\t/// - If `to` refers to a smart contract, it must implement\r\n\t///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t///\r\n\t/// Emits a {Transfer} event.\r\n\tfunction safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\r\n\t\tpublic\r\n\t\tvirtual\r\n\t{\r\n\t\ttransferFrom(from, to, id);\r\n\r\n\t\tif (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n\t}\r\n\r\n\t/// @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n\t/// See: https://eips.ethereum.org/EIPS/eip-165\r\n\t/// This function call must use less than 30000 gas.\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tlet s := shr(224, interfaceId)\r\n\t\t\t// ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\r\n\t\t\tresult := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\r\n\t\t}\r\n\t}\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                     MIRROR OPERATIONS                      */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Returns the address of the base DN404 contract.\r\n\tfunction baseERC20() public view virtual returns (address base) {\r\n\t\tbase = _getDN404NFTStorage().baseERC20;\r\n\t\tif (base == address(0)) revert NotLinked();\r\n\t}\r\n\r\n\t/// @dev Fallback modifier to execute calls from the base DN404 contract.\r\n\tmodifier dn404NFTFallback() virtual {\r\n\t\tDN404NFTStorage storage $ = _getDN404NFTStorage();\r\n\r\n\t\tuint256 fnSelector = _calldataload(0x00) >> 224;\r\n\r\n\t\t// `logTransfer(uint256[])`.\r\n\t\tif (fnSelector == 0x263c69d6) {\r\n\t\t\tif (msg.sender != $.baseERC20) revert SenderNotBase();\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\t// When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\r\n\t\t\t\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\r\n\t\t\t\tlet o := add(0x24, calldataload(0x04)) // Packed logs offset.\r\n\t\t\t\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\r\n\t\t\t\tlet end := add(o, shl(5, calldataload(sub(o, 0x20))))\r\n\t\t\t\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\r\n\r\n\t\t\t\tfor {} iszero(eq(o, end)) { o := add(0x20, o) } {\r\n\t\t\t\t\tlet d := calldataload(o) // Entry in the packed logs.\r\n\t\t\t\t\tlet a := shr(96, d) // The address.\r\n\t\t\t\t\tlet b := and(1, d) // Whether it is a burn.\r\n\t\t\t\t\tlog4(\r\n\t\t\t\t\t\tcodesize(),\r\n\t\t\t\t\t\t0x00,\r\n\t\t\t\t\t\t_TRANSFER_EVENT_SIGNATURE,\r\n\t\t\t\t\t\tmul(a, b),\r\n\t\t\t\t\t\tmul(a, iszero(b)),\r\n\t\t\t\t\t\tshr(168, shl(160, d))\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\tmstore(0x00, 0x01)\r\n\t\t\t\treturn(0x00, 0x20)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// `linkMirrorContract(address)`.\r\n\t\tif (fnSelector == 0x0f4599e5) {\r\n\t\t\tif ($.deployer != address(0)) {\r\n\t\t\t\tif (address(uint160(_calldataload(0x04))) != $.deployer) {\r\n\t\t\t\t\trevert SenderNotDeployer();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ($.baseERC20 != address(0)) revert AlreadyLinked();\r\n\t\t\t$.baseERC20 = msg.sender;\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tmstore(0x00, 0x01)\r\n\t\t\t\treturn(0x00, 0x20)\r\n\t\t\t}\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @dev Fallback function for calls from base DN404 contract.\r\n\tfallback() external payable virtual dn404NFTFallback {}\r\n\r\n\treceive() external payable virtual {}\r\n\r\n\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n\t/*                      PRIVATE HELPERS                       */\r\n\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n\t/// @dev Returns the calldata value at `offset`.\r\n\tfunction _calldataload(uint256 offset) private pure returns (uint256 value) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tvalue := calldataload(offset)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Returns if `a` has bytecode of non-zero length.\r\n\tfunction _hasCode(address a) private view returns (bool result) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tresult := extcodesize(a) // Can handle dirty upper bits.\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\r\n\t/// Reverts if the target does not support the function correctly.\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\r\n\t\tprivate\r\n\t{\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\t// Prepare the calldata.\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tlet onERC721ReceivedSelector := 0x150b7a02\r\n\t\t\tmstore(m, onERC721ReceivedSelector)\r\n\t\t\tmstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\r\n\t\t\tmstore(add(m, 0x40), shr(96, shl(96, from)))\r\n\t\t\tmstore(add(m, 0x60), id)\r\n\t\t\tmstore(add(m, 0x80), 0x80)\r\n\t\t\tlet n := mload(data)\r\n\t\t\tmstore(add(m, 0xa0), n)\r\n\t\t\tif n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\r\n\t\t\t// Revert if the call reverts.\r\n\t\t\tif iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\r\n\t\t\t\tif returndatasize() {\r\n\t\t\t\t\t// Bubble up the revert if the call reverts.\r\n\t\t\t\t\treturndatacopy(m, 0x00, returndatasize())\r\n\t\t\t\t\trevert(m, returndatasize())\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Load the returndata and compare it.\r\n\t\t\tif iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\r\n\t\t\t\tmstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\r\n\t\t\t\trevert(0x1c, 0x04)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotLink\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotBase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DN404Mirror", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a851fb68e478d305395319a509790ccc4e0778c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://782cb316a513ee25aa1d81cce13060f186e99f89ddc377c78224dcd386e2bfbd"}