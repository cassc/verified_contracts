{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/infrastructure/IKresusRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IModuleRegistry\\n * @notice Interface for the registry of authorised modules.\\n */\\ninterface IKresusRegistry {\\n    /**\\n     * @notice Registers a new module. New modules which are registered can be authorized for each {ProxyVault}.\\n     * @param _module The module address which has to be registered.\\n     * @param _name The name of the module.\\n     */\\n    function registerModule(address _module, string calldata _name) external;\\n\\n    /**\\n     * @notice Deregisters a module.\\n     * @param _module The module address.\\n     */\\n    function deregisterModule(address _module) external;\\n\\n    /**\\n     * @notice Registers contract addresses with their selectors.\\n     * @param _contracts Contract addresses to be whitelisted.\\n     * @param _selectors List of corresponding method ids to be whitelisted.\\n     */\\n    function registerContract(address[] memory _contracts, bytes4[] memory _selectors) external;\\n    \\n    /**\\n     * @notice Deregisters contract addresses with their selectors.\\n     * @param _contracts Contract addresses to be whitelisted.\\n     * @param _selectors List of corresponding method ids to be whitelisted.\\n     */\\n    function deregisterContract(address[] memory _contracts, bytes4[] memory _selectors) external;\\n\\n    /**\\n     * @notice Function to set the time delay for remove guardian operation.\\n     * @param _td New time delay for removing guardian.\\n     */\\n    function setRemoveGuardianTd(uint256 _td) external;\\n\\n    /**\\n     * @notice Function to set the time delay for unlock operation.\\n     * @param _td New time delay for unlocking a vault.\\n     */\\n    function setUnlockTd(uint256 _td) external;\\n\\n    /**\\n     * @notice Gets the name of a module from its address.\\n     * @param _module The module address.\\n     * @return The name of the module.\\n     */\\n    function moduleInfo(address _module) external view returns (string memory);\\n\\n    /**\\n     * @notice Checks if a module is registered.\\n     * @param _module The module address.\\n     * @return True if the module is registered, else false.\\n     */\\n    function isRegisteredModule(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if given modules are registered.\\n     * @param _modules The module addresses.\\n     * @return True if modules are registered, else false.\\n     */\\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if given list of contracts addresses and corresponsing method ids are whitelisted.\\n     * @param _contracts List of contract addresses.\\n     * @param _sigs List of corresponding method ids.\\n     * @return True if all the contract addresses and method ids are whitelisted, else false.\\n     */\\n    function isRegisteredCalls(address[] memory _contracts, bytes4[] memory _sigs) external view returns (bool);\\n\\n    /**\\n     * @notice Function to get the time delay for unlock.\\n     * @return Time delay for unlocking a vault.\\n     */\\n    function getUnlockTd() external view returns(uint256); \\n\\n\\n    /**\\n     * @notice Function to get the time delay for remove guardian.\\n     * @return Time delay for remove guardian.\\n     */\\n    function getRemoveGuardianTd() external view returns(uint256); \\n}\"\r\n    },\r\n    \"contracts/modules/common/BaseModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../vault/IVault.sol\\\";\\nimport \\\"../..//storage/IStorage.sol\\\";\\nimport \\\"./IModule.sol\\\";\\nimport {IKresusRegistry} from \\\"../../infrastructure/IKresusRegistry.sol\\\";\\n\\n/**\\n * @title BaseModule\\n * @notice Base Module contract that contains methods common to all Modules.\\n */\\nabstract contract BaseModule is IModule {\\n\\n    // different types of signatures\\n    enum Signature {\\n        Owner,\\n        KBG,\\n        HG,\\n        KBGAndKWG,\\n        KWG\\n    }\\n\\n    // Zero address\\n    address constant internal ZERO_ADDRESS = address(0);\\n\\n    // The guardians storage\\n    IStorage internal immutable _storage;\\n\\n    // Kresus Registry address\\n    IKresusRegistry internal immutable kresusRegistry;\\n\\n    /**\\n     * @notice Throws if the sender is not the module itself.\\n     */\\n    modifier onlySelf() {\\n        require(_isSelf(msg.sender), \\\"BM: must be module\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if the sender is not the target vault of the call.\\n     */\\n    modifier onlyVault(address _vault) {\\n        require(\\n            msg.sender == _vault,\\n            \\\"BM: caller must be vault\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @param _storageAddr deployed instance of storage contract.\\n     * @param _kresusRegistry deployed instance of kresus registry contract.\\n     */\\n    constructor(\\n        IStorage _storageAddr,\\n        IKresusRegistry _kresusRegistry\\n    ) {\\n        _storage = _storageAddr;\\n        kresusRegistry = _kresusRegistry;\\n    }\\n\\n    /**\\n     * @notice Helper method to check if an address is the module itself.\\n     * @param _addr - The target address.\\n     * @return True if locked, else false.\\n     */\\n    function _isSelf(address _addr) internal view returns (bool) {\\n        return _addr == address(this);\\n    }\\n\\n    /**\\n     * @notice Helper method to check if an address is the owner of a target vault.\\n     * @param _vault The target vault.\\n     * @param _addr The address.\\n     * @return True if `_addr` is the owner of `_vault`, else false.\\n     */\\n    function _isOwner(address _vault, address _addr) internal view returns (bool) {\\n        return IVault(_vault).owner() == _addr;\\n    }\\n\\n    /**\\n     * @notice Helper method to invoke a vault.\\n     * @param _vault - The target vault.\\n     * @param _to - The target address for the transaction.\\n     * @param _value - The value of the transaction.\\n     * @param _data - The data of the transaction.\\n     * @return _res result of low level call from vault.\\n     */\\n    function invokeVault(\\n        address _vault,\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data\\n    ) \\n        internal\\n        returns\\n        (bytes memory _res)\\n    {\\n        bool success;\\n        (success, _res) = _vault.call(\\n            abi.encodeWithSignature(\\n                \\\"invoke(address,uint256,bytes)\\\",\\n                _to,\\n                _value,\\n                _data\\n            )\\n        );\\n        if (success && _res.length > 0) {\\n            (_res) = abi.decode(_res, (bytes));\\n        } else if (_res.length > 0) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        } else if (!success) {\\n            revert(\\\"BM: vault invoke reverted\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a vault. Cannot execute when vault is locked (or under recovery)\\t\\n     * @param _vault The target vault.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _vault, address _module, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Inits a Module for a vault by e.g. setting some vault specific parameters in storage.\\n     * @param _vault The target vault.\\n     * @param _initData - Data to be initialised specific to a module when it is authorized.\\n     */\\n    function init(address _vault, bytes calldata _initData) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     * @return _isSupported True if `_methodId` is supported, else false.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"contracts/modules/common/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Utils\\n * @notice Common utility methods used by modules.\\n */\\nlibrary Utils {\\n\\n    /**\\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\\n    * @param _signedHash The signed hash\\n    * @param _signatures The concatenated signatures.\\n    * @param _index The index of the signature to recover.\\n    * @return the signer public address.\\n    */\\n    function recoverSigner(\\n        bytes32 _signedHash,\\n        bytes memory _signatures,\\n        uint256 _index\\n    )\\n        internal\\n        pure\\n        returns(address)\\n    {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\\n        }\\n        require(v == 27 || v == 28, \\\"U: bad v value in signature\\\");\\n\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"U: Invalid s value\\\");\\n        }\\n\\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"U: ecrecover returned 0\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /**\\n    * @notice Helper method to parse data and extract the method signature.\\n    * @param _data The calldata.\\n    * @return prefix The methodID for the calldata.\\n    */\\n    function functionPrefix(\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns(bytes4 prefix)\\n    {\\n        require(_data.length >= 4, \\\"U: Invalid functionPrefix\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            prefix := mload(add(_data, 0x20))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/KresusModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"./KresusRelayer.sol\\\";\\nimport \\\"./SecurityManager.sol\\\";\\nimport \\\"./TransactionManager.sol\\\";\\nimport {IKresusRegistry} from \\\"../infrastructure/IKresusRegistry.sol\\\";\\n\\n/**\\n * @title KresusModule\\n * @notice Single module for Kresus vault which consists of:\\n * - Kresus Relayer\\n * - Security Manager\\n * - Transaction Manager\\n * Consists of fundamental functionalities:\\n * - Get required signatures.\\n * - Validate signatures.\\n * - Adding and authorizing new modules.\\n */\\ncontract KresusModule is BaseModule, KresusRelayer, SecurityManager, TransactionManager {\\n\\n    // address of kresus guardian responsible for enable/disable, lock/unlock vault and executeBequeathal.\\n    address public immutable kresusGuardian;\\n\\n    /**\\n     * @param _storageAddr deployed instance of storage contract\\n     * @param _kresusRegistry deployed instance of Kresus registry\\n     * @param _kresusGuardian default guardian of kresus for recovery and unblocking\\n     */\\n    constructor (\\n        IStorage _storageAddr,\\n        IKresusRegistry _kresusRegistry,\\n        address _kresusGuardian\\n    )\\n        BaseModule(_storageAddr, _kresusRegistry)\\n    {\\n        require(_kresusGuardian != ZERO_ADDRESS, \\\"KM: Invalid address\\\");\\n        kresusGuardian = _kresusGuardian;\\n    }\\n\\n    /**\\n     * @inheritdoc IModule\\n     */\\n    function init(\\n        address _vault,\\n        bytes calldata _initData\\n    )\\n        external\\n        override\\n        onlyVault(_vault)\\n    {\\n        (address newKbg, uint256 newTimeDelay) = abi.decode(_initData, (address, uint256));\\n        require(IVault(_vault).owner() != newKbg, \\\"KM: Invalid KBG\\\");\\n        IVault(_vault).enableStaticCall(address(this));\\n        _storage.setTimeDelay(_vault, newTimeDelay);\\n        _storage.setKbg(_vault, newKbg);\\n    }\\n\\n    /**\\n     * @inheritdoc IModule\\n     */\\n    function addModule(\\n        address _vault,\\n        address _module,\\n        bytes memory _initData\\n    )\\n        external\\n        onlySelf()\\n    {\\n        require(kresusRegistry.isRegisteredModule(_module), \\\"KM: module is not registered\\\");\\n        IVault(_vault).authoriseModule(_module, true, _initData);\\n    }\\n    \\n    /**\\n     * @inheritdoc KresusRelayer\\n     */\\n    function getRequiredSignatures(\\n        address _vault,\\n        bytes calldata _data\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256, Signature)\\n    {\\n        bytes4 methodId = Utils.functionPrefix(_data);\\n\\n        if(_storage.isLocked(_vault)) {\\n            require(\\n                methodId == SecurityManager.unlock.selector ||\\n                methodId == SecurityManager.executeBequeathal.selector ||\\n                methodId == SecurityManager.disable.selector,\\n                \\\"KM: method not allowed\\\"\\n            );\\n            if(methodId == SecurityManager.unlock.selector) {\\n                return (kresusRegistry.getUnlockTd(), Signature.KBGAndKWG);\\n            }\\n        }\\n\\n        if(_storage.isDisabled(_vault)) {\\n            require(\\n                methodId == SecurityManager.executeBequeathal.selector ||\\n                methodId == TransactionManager.multiCall.selector ||\\n                methodId == TransactionManager.multiCallToWhitelistedAddresses.selector ||\\n                methodId == SecurityManager.enable.selector,\\n                \\\"KM: method not allowed\\\"\\n            );\\n        }\\n\\n        if (methodId == TransactionManager.multiCall.selector) {\\n            bool hasHumanGuardian = _storage.hasHumanGuardian(_vault);\\n            return hasHumanGuardian ? \\n                (_storage.getTimeDelay(_vault), Signature.HG) :\\n                (_storage.getTimeDelay(_vault), Signature.KBG);\\n        }\\n        if(methodId == TransactionManager.multiCallToWhitelistedAddresses.selector) {\\n            bool hasHumanGuardian = _storage.hasHumanGuardian(_vault);\\n            return hasHumanGuardian ? (0, Signature.HG) : (0, Signature.KBG);\\n        }\\n        if(methodId == SecurityManager.lock.selector) {\\n            return (0, Signature.KWG);\\n        }\\n        if(\\n            methodId == SecurityManager.setHumanGuardian.selector ||\\n            methodId == SecurityManager.transferOwnership.selector ||\\n            methodId == SecurityManager.setTimeDelay.selector\\n        ) {\\n            return (_storage.getTimeDelay(_vault), Signature.KBG);\\n        }\\n        if(\\n            methodId == SecurityManager.removeHumanGuardian.selector ||\\n            methodId == SecurityManager.removeTrustee.selector\\n        ) {\\n            return (kresusRegistry.getRemoveGuardianTd(), Signature.KBG);\\n        }\\n        if(\\n            methodId == SecurityManager.addHumanGuardian.selector ||\\n            methodId == SecurityManager.addTrustee.selector ||\\n            methodId == KresusModule.addModule.selector\\n        ) {\\n            return (0, Signature.KBG);\\n        }\\n        if(\\n            methodId == SecurityManager.enable.selector ||\\n            methodId == SecurityManager.disable.selector ||\\n            methodId == SecurityManager.executeBequeathal.selector\\n        ) {\\n            return (0, Signature.KWG);\\n        }\\n        revert(\\\"KM: unknown method\\\");\\n    }\\n\\n    /**\\n     * @notice Function to get the signature requirement to cancel operations of a vault.\\n     * Operations which are queued can be cancelled by using the requirement provided by this method.\\n     * @param _data _data The calldata for the required transaction.\\n     * @return Signature The required signature from {Signature} enum.\\n     */\\n    function getCancelRequiredSignatures(\\n        bytes calldata _data\\n    )\\n        public\\n        pure\\n        override\\n        returns(Signature)\\n    {\\n        bytes4 methodId = Utils.functionPrefix(_data);\\n        if(\\n            methodId == SecurityManager.setHumanGuardian.selector ||\\n            methodId == SecurityManager.removeHumanGuardian.selector ||\\n            methodId == SecurityManager.setTimeDelay.selector ||\\n            methodId == SecurityManager.transferOwnership.selector ||\\n            methodId == SecurityManager.removeTrustee.selector ||\\n            methodId == TransactionManager.multiCall.selector ||\\n            methodId == SecurityManager.unlock.selector\\n        ) {\\n            return Signature.Owner;\\n        }\\n        revert(\\\"KM: unknown method\\\");\\n    }\\n\\n    /**\\n     * @notice Validates the signatures provided with a relayed transaction.\\n     * @param _vault The target vault.\\n     * @param _signHash The signed hash representing the relayed transaction.\\n     * @param _signatures The signatures as a concatenated bytes array.\\n     * @param _option An Signature enum indicating whether the owner is required, optional or disallowed.\\n     * @return A boolean indicating whether the signatures are valid.\\n     */\\n    function validateSignatures(\\n        address _vault,\\n        bytes32 _signHash,\\n        bytes memory _signatures,\\n        Signature _option\\n    ) \\n        public \\n        view\\n        override\\n        returns (bool)\\n    {\\n        if(_signatures.length < 65) {\\n            return false;\\n        }\\n\\n        address signer0 = Utils.recoverSigner(_signHash, _signatures, 0);\\n\\n        if(_option == Signature.Owner) {\\n            return signer0 == IVault(_vault).owner();\\n        }\\n        if(_option == Signature.HG) {\\n            return _storage.isHumanGuardian(_vault, signer0);\\n        }\\n        if(_option == Signature.KBG || _option == Signature.KBGAndKWG) {\\n            if(_signatures.length > 65) {\\n                address signer1 = Utils.recoverSigner(_signHash, _signatures, 1);\\n                return _storage.isKbg(_vault, signer0) && signer1 == kresusGuardian;\\n            }\\n            return _storage.isKbg(_vault, signer0);\\n        }\\n        return signer0 == kresusGuardian;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/KresusRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./common/BaseModule.sol\\\";\\n/**\\n * @title KresusRelayer\\n * @notice Abstract Module to execute transactions signed by ETH-less accounts and sent by a relayer.\\n */\\nabstract contract KresusRelayer is BaseModule {\\n\\n    struct RelayerConfig {\\n        uint256 nonce;\\n        mapping(bytes32 => uint256) queuedTransactions;\\n        mapping(bytes32 => uint256) arrayIndex;\\n        bytes32[] queue;\\n    }\\n\\n    // Used to avoid stack too deep error\\n    struct StackExtension {\\n        Signature signatureRequirement;\\n        bytes32 signHash;\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    uint256 internal constant BLOCKBOUND = 10000;\\n\\n    mapping (address => RelayerConfig) internal relayer;\\n\\n\\n    event TransactionExecuted(address indexed vault, bool indexed success, bytes returnData, bytes32 signedHash);\\n    event TransactionQueued(address indexed vault, uint256 executionTime, bytes32 signedHash);\\n    event ActionCancelled(address indexed vault, bytes32 signedHash);\\n    event AllActionsCancelled(address indexed vault);\\n    \\n    /**\\n     * @notice Executes a relayed transaction.\\n     * @param _vault The target vault.\\n     * @param _data The data for the relayed transaction\\n     * @param _nonce The nonce used to prevent replay attacks.\\n     * @param _signatures The signatures as a concatenated byte array.\\n     * @return true if executed or queued successfully, else returns false.\\n     */\\n    function execute(\\n        address _vault,\\n        bytes calldata _data,\\n        uint256 _nonce,\\n        bytes calldata _signatures\\n    )\\n        external\\n        returns (bool)\\n    {\\n        require(verifyData(_vault, _data), \\\"KR: Target of _data != _vault\\\");\\n\\n        StackExtension memory stack;\\n        uint256 td;\\n        (td, stack.signatureRequirement) = getRequiredSignatures(_vault, _data);\\n\\n        stack.signHash = getSignHash(\\n            _vault,\\n            0,\\n            _data,\\n            _nonce\\n        );\\n\\n        // Execute a queued tx\\n        if (isActionQueued(_vault, stack.signHash)){\\n            require(\\n                relayer[_vault].queuedTransactions[stack.signHash] < block.timestamp,\\n                \\\"KR: Time not expired\\\"\\n            );\\n            if(relayer[_vault].queue.length > 0) {\\n                removeQueue(_vault, stack.signHash);\\n            }\\n            (stack.success, stack.returnData) = address(this).call(_data);\\n            require(stack.success, \\\"KR: Internal call failed\\\");\\n            emit TransactionExecuted(_vault, stack.success, stack.returnData, stack.signHash);\\n            return stack.success;\\n        }\\n        \\n        require(validateSignatures(\\n                _vault, \\n                stack.signHash,\\n                _signatures, \\n                stack.signatureRequirement\\n            ),\\n            \\\"KR: Invalid Signatures\\\"\\n        );\\n\\n        require(checkAndUpdateUniqueness(_vault, _nonce), \\\"KR: Duplicate request\\\");\\n\\n        // Queue the Tx\\n        if(td > 0) {\\n            uint256 executionTime = block.timestamp + td;\\n            relayer[_vault].queuedTransactions[stack.signHash] = executionTime;\\n            relayer[_vault].queue.push(stack.signHash);\\n            relayer[_vault].arrayIndex[stack.signHash] = relayer[_vault].queue.length-1;\\n            emit TransactionQueued(_vault, executionTime, stack.signHash);\\n            return true;\\n        }\\n        // Execute the tx directly without queuing\\n        else {\\n            (stack.success, stack.returnData) = address(this).call(_data);\\n            require(stack.success, \\\"KR: Internal call failed\\\");\\n            emit TransactionExecuted(_vault, stack.success, stack.returnData, stack.signHash);\\n            return stack.success;\\n        }\\n    }  \\n\\n    /**\\n     * @notice Cancels a transaction which was queued.\\n     * @param _vault The target vault.\\n     * @param _data The data for the relayed transaction.\\n     * @param _nonce The nonce used to prevent replay attacks.\\n     * @param _signature The signature needed to validate cancel.\\n     */\\n    function cancel(\\n        address _vault,\\n        bytes calldata _data,\\n        uint256 _nonce,\\n        bytes memory _signature\\n    ) \\n        external \\n    {\\n        bytes32 _actionHash = getSignHash(_vault, 0, _data, _nonce);\\n        bytes32 _cancelHash = getSignHash(_vault, 0, \\\"0x\\\", _nonce);\\n        require(isActionQueued(_vault, _actionHash), \\\"KR: Invalid hash\\\");\\n        Signature _sig = getCancelRequiredSignatures(_data);\\n        require(\\n            validateSignatures(\\n                _vault,\\n                _cancelHash,\\n                _signature,\\n                _sig\\n            ), \\\"KR: Invalid Signatures\\\"\\n        );\\n        removeQueue(_vault, _actionHash);\\n        emit ActionCancelled(_vault, _actionHash);\\n    }\\n\\n    /**\\n     * @notice To cancel all the queued operations for a `_vault` address.\\n     * @param _vault The target vault.\\n     */\\n    function cancelAll(\\n        address _vault\\n    )\\n        external\\n        onlySelf\\n    {\\n        uint256 len = relayer[_vault].queue.length;\\n        for(uint256 i=0;i<len;i++) {\\n            bytes32 _actionHash = relayer[_vault].queue[i];\\n            relayer[_vault].queuedTransactions[_actionHash] = 0;\\n            relayer[_vault].arrayIndex[_actionHash] = 0;\\n        }\\n        delete relayer[_vault].queue;\\n        emit AllActionsCancelled(_vault);\\n    }\\n\\n    /**\\n     * @notice Gets the current nonce for a vault.\\n     * @param _vault The target vault.\\n     * @return nonce gets the last used nonce of the vault.\\n     */\\n    function getNonce(address _vault) external view returns (uint256 nonce) {\\n        return relayer[_vault].nonce;\\n    }\\n\\n    /**\\n     * @notice Gets time delay and the valid signature requirement that must be provided to execute a\\n     * specific relayed transaction.\\n     * @param _vault The target vault.\\n     * @param _data The data of the relayed transaction.\\n     * @return Time delay to execute the transaction and its signature requirement.\\n     */\\n    function getRequiredSignatures(\\n        address _vault,\\n        bytes calldata _data\\n    ) public view virtual returns (uint256, Signature);\\n\\n    /**\\n     * @notice Checks validity of a signature depending on status of the vault.\\n     * @param _vault The target vault.\\n     * @param _actionHash Signed hash of the request.\\n     * @param _data The data of the relayed transaction.\\n     * @param _option Type of signature.\\n     * @return True if it is a valid signature, else false.\\n     */\\n    function validateSignatures(\\n        address _vault,\\n        bytes32 _actionHash,\\n        bytes memory _data,\\n        Signature _option\\n    ) public view virtual returns(bool);\\n\\n    /**\\n     * @notice Gets the required signature requirement to cancel the request which is queued.\\n     * @param _data The data of the relayed transaction.\\n     * @return The required signature from {Signature} enum.\\n     */ \\n    function getCancelRequiredSignatures(\\n        bytes calldata _data\\n    ) public pure virtual returns(Signature);\\n\\n    /**\\n     * @notice Generates the signed hash of a relayed transaction according to ERC1077.\\n     * (see https://eips.ethereum.org/EIPS/eip-1077).\\n     * @param _from The starting address for the relayed transaction (should be the relayer module)\\n     * @param _value The value for the relayed transaction.\\n     * @param _data The data for the relayed transaction which includes the vault address.\\n     * @param _nonce The nonce used to prevent replay attacks.\\n     */\\n    function getSignHash(\\n        address _from,\\n        uint256 _value,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encodePacked(\\n                    bytes1(0x19),\\n                    bytes1(0),\\n                    _from,\\n                    _value,\\n                    _data,\\n                    block.chainid,\\n                    _nonce\\n                ))\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Checks if the relayed transaction is unique. If yes `_nonce` is updated for `_vault`.\\n     * @param _vault The target vault.\\n     * @param _nonce The nonce.\\n     * @return True if the transaction is unique else false.\\n     */\\n    function checkAndUpdateUniqueness(\\n        address _vault,\\n        uint256 _nonce\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        // use the incremental nonce\\n        if (_nonce <= relayer[_vault].nonce) {\\n            return false;\\n        }\\n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\\n        if (nonceBlock > block.number + BLOCKBOUND) {\\n            return false;\\n        }\\n        relayer[_vault].nonce = _nonce;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Checks that the vault address provided as the first parameter of `_data` matches `_vault`\\n     * @return False if the addresses are different, else true.\\n     */\\n    function verifyData(\\n        address _vault,\\n        bytes calldata _data\\n    )\\n        internal\\n        pure\\n        returns(bool)\\n    {\\n        require(_data.length >= 36, \\\"KR: Invalid dataVault\\\");\\n        require(_vault != ZERO_ADDRESS, \\\"KR: Invalid vault\\\");\\n        address dataVault = abi.decode(_data[4:], (address));\\n        return dataVault == _vault;\\n    }\\n\\n    /**\\n     * @notice Check whether a given action is queued.\\n     * @param _vault The target vault.\\n     * @param _actionHash  Hash of the action to be checked. \\n     * @return True if the underlying action of `_actionHash` is queued, else false.\\n     */\\n    function isActionQueued(\\n        address _vault,\\n        bytes32 _actionHash\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return (relayer[_vault].queuedTransactions[_actionHash] > 0);\\n    }\\n\\n    /**\\n     * @notice Returns execution time for a given queued action.\\n     * @param _vault The target vault.\\n     * @param _actionHash Hash of the action to be checked.\\n     * @return Execution time for a given queued action, returns zero if `_actionHash` is not queued.\\n     */\\n    function queuedActionExecutionTime(\\n        address _vault,\\n        bytes32 _actionHash\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return relayer[_vault].queuedTransactions[_actionHash];\\n    }\\n    \\n    /**\\n     * @notice Removes an element at index from the array queue of a user\\n     * @param _vault The target vault.\\n     * @param  _actionHash  Hash of the action to be checked.\\n     * @return false if the index is invalid.\\n     */\\n    function removeQueue(\\n        address _vault,\\n        bytes32 _actionHash\\n    )\\n        internal\\n        returns(bool)\\n    {\\n        RelayerConfig storage _relayer = relayer[_vault];\\n        _relayer.queuedTransactions[_actionHash] = 0;\\n\\n        uint256 index = _relayer.arrayIndex[_actionHash];\\n        uint256 len = _relayer.queue.length;\\n        if(index != len - 1) {\\n            bytes32 lastHash = _relayer.queue[len - 1];\\n            _relayer.arrayIndex[lastHash] = index;\\n            _relayer.arrayIndex[_actionHash] = 0;\\n            _relayer.queue[index] = lastHash;\\n        }\\n        _relayer.queue.pop();\\n        \\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/SecurityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/**\\n * @title SecurityManager\\n * @notice Abstract module implementing the key security features of the vault which involves:\\n * - Managing guardians, trustee and ownership.\\n * - Managing time delay.\\n * - Managing status of a vault (lock/unlock, enable/disable).\\n */\\nabstract contract SecurityManager is BaseModule {\\n\\n    event Bequeathed(address indexed vault, address indexed newOwner, address newKbg);\\n    event TransferedOwnership(address indexed vault, address newOwner, address newKbg);\\n    event Locked(address indexed vault);\\n    event Unlocked(address indexed vault);\\n    event HumanGuardianChanged(address indexed vault, address indexed guardian);\\n    event TrusteeChanged(address indexed vault, address indexed trustee);\\n    event TimeDelayChanged(address indexed vault, uint256 newTimeDelay);\\n    event Enabled(address indexed vault);\\n    event Disabled(address indexed vault);\\n\\n    /**\\n     * @notice Function to lock `_vault`. Cancels all the queued operations.\\n     * @param _vault The target vault.\\n     */\\n    function lock(\\n        address _vault\\n    )\\n        external \\n        onlySelf() \\n    {\\n        _storage.lock(_vault);\\n        (bool success, ) = address(this).call(\\n            abi.encodeWithSignature(\\\"cancelAll(address)\\\", _vault)\\n        );\\n        require(success, \\\"SM: cancel all operation failed\\\");\\n        emit Locked(_vault);\\n    }\\n\\n    /**\\n     * @notice Function to update the time delay for `_vault`\\n     * @param _vault The target vault.\\n     * @param _newTimeDelay The new time delay to update in seconds.\\n     */\\n    function setTimeDelay(\\n        address _vault,\\n        uint256 _newTimeDelay\\n    )\\n        external\\n        onlySelf()\\n    {\\n        _storage.setTimeDelay(_vault, _newTimeDelay);\\n        emit TimeDelayChanged(_vault, _newTimeDelay);\\n    }\\n\\n    /**\\n     * @notice Function to unlock a locked `_vault`.\\n     * @param _vault The target vault.\\n     */\\n    function unlock(\\n        address _vault\\n    ) \\n        external\\n        onlySelf()\\n    {\\n        _storage.unlock(_vault);\\n        emit Unlocked(_vault);\\n    }\\n\\n\\n    /**\\n     * @notice Function to changes the human group public address for `_vault`.\\n     * Replaces the human group address with `_guardian`.\\n     * @param _vault The target vault.\\n     * @param _guardian The guardian to add.\\n     */\\n    function setHumanGuardian(\\n        address _vault,\\n        address _guardian\\n    )\\n        external\\n        onlySelf()\\n    {\\n        require(_guardian != IVault(_vault).owner(), \\\"SM: Invalid guardian\\\");\\n        _storage.setHumanGuardian(_vault, _guardian);\\n        emit HumanGuardianChanged(_vault, _guardian);\\n    }\\n\\n    /**\\n     * @notice Function to remove human guardians for `_vault`.\\n     * @param _vault The target vault.\\n     */\\n    function removeHumanGuardian(\\n        address _vault\\n    )\\n        external\\n        onlySelf()\\n    {\\n        _storage.setHumanGuardian(_vault, ZERO_ADDRESS);\\n        emit HumanGuardianChanged(_vault, ZERO_ADDRESS);\\n    }\\n\\n    /**\\n     * @notice Function to add a human guardian for `_vault`.\\n     * Replaces the human group address with `_guardian`.\\n     * @param _vault The target vault.\\n     * @param _guardian Address of the new guardian.\\n     */\\n    function addHumanGuardian(\\n        address _vault,\\n        address _guardian\\n    )\\n        external\\n        onlySelf()\\n    {\\n        require(\\n            _storage.getHumanGuardian(_vault) == ZERO_ADDRESS,\\n            \\\"SM: Cannot add guardian\\\"\\n        );\\n        _storage.setHumanGuardian(_vault, _guardian);\\n        emit HumanGuardianChanged(_vault, _guardian);\\n    }\\n\\n    /**\\n     * @notice Function to add trustee for `_vault`.\\n     * @param _vault The target vault.\\n     * @param _newTrustee Address of the new trustee.\\n     */\\n    function addTrustee(\\n        address _vault,\\n        address _newTrustee\\n    ) \\n        external\\n        onlySelf()\\n    {\\n        require(\\n            _storage.getTrustee(_vault) == ZERO_ADDRESS && _newTrustee != ZERO_ADDRESS,\\n            \\\"SM: Cannot add trustee\\\"\\n        );\\n        _storage.setTrustee(_vault, _newTrustee);\\n        emit TrusteeChanged(_vault, _newTrustee);\\n    }\\n\\n    /**\\n     * @notice Function to remove trustee for `_vault`.\\n     * @param _vault The target vault.\\n     */\\n    function removeTrustee(\\n        address _vault\\n    )\\n        external\\n        onlySelf()\\n    {\\n        _storage.setTrustee(_vault, ZERO_ADDRESS);\\n        emit TrusteeChanged(_vault, ZERO_ADDRESS);\\n    }\\n\\n    /**\\n     * @notice Function to set the current trustee address as the new owner for `_vault`. \\n     * After change in owner sets the current trustee address to zero address.\\n     * @param _vault The target vault.\\n     * @param _newKbg The new KBG address.\\n     */\\n    function executeBequeathal(\\n        address _vault,\\n        address _newKbg\\n    )\\n        external\\n        onlySelf()\\n    {\\n        address trustee = _storage.getTrustee(_vault);\\n        resetVault(_vault, trustee, _newKbg);\\n        emit Bequeathed(_vault, trustee, _newKbg);\\n    }\\n\\n    /**\\n     * @notice Function to enable `_vault`.\\n     * @param _vault The target vault.\\n     */\\n    function enable(\\n        address _vault\\n    )\\n        external\\n        onlySelf()\\n    {\\n        _storage.enable(_vault);\\n        emit Enabled(_vault);\\n    }\\n\\n    /**\\n     * @notice Function to disable `_vault`.\\n     * @param _vault The target vault.\\n     */\\n    function disable(\\n        address _vault\\n    )\\n        external\\n        onlySelf()\\n    {\\n        _storage.disable(_vault);\\n        emit Disabled(_vault);\\n    }\\n\\n    /**\\n     * @notice Function to transfer ownership to `_newOwner` and changes the kbg address to `_newKbg` for `_vault`.\\n     * @param _vault The target vault.\\n     * @param _newKbg The new kbg address.\\n     * @param _newOwner The new owner address.\\n     */\\n    function transferOwnership(\\n        address _vault,\\n        address _newOwner,\\n        address _newKbg\\n    )\\n        external\\n        onlySelf()\\n    {\\n        resetVault(_vault, _newOwner, _newKbg);\\n        emit TransferedOwnership(_vault, _newOwner, _newKbg);\\n    }\\n\\n    /**\\n     * @notice Changes owner, and resets vault to default state.\\n     * @param _vault The target vault.\\n     * @param _newOwner The new owner address.\\n     * @param _newKbg The new kbg address.\\n     */\\n    function resetVault(\\n        address _vault,\\n        address _newOwner,\\n        address _newKbg\\n    )\\n        internal\\n    {\\n        changeOwner(_vault, _newOwner);\\n        _storage.reset(_vault);\\n        _storage.setKbg(_vault, _newKbg);\\n    }\\n\\n    /**\\n     * @notice Changes the owner address for a vault.\\n     * @param _vault The target vault.\\n     * @param _newOwner Address of the new owner.\\n     */\\n    function changeOwner(\\n        address _vault,\\n        address _newOwner\\n    ) \\n        internal \\n    {\\n        validateNewOwner(_vault, _newOwner);\\n        IVault(_vault).setOwner(_newOwner);\\n        (bool success, ) = address(this).call(\\n            abi.encodeWithSignature(\\\"cancelAll(address)\\\", _vault)\\n        );\\n        require(success, \\\"SM: cancel all operation failed\\\");\\n    }\\n\\n    /**\\n     * @notice Checks `_newOwner` is valid to be the new owner for `_vault`.\\n     * @param _vault The target vault.\\n     * @param _newOwner The target vault.\\n     */\\n    function validateNewOwner(\\n        address _vault,\\n        address _newOwner\\n    )\\n        internal\\n        view \\n    {\\n        require(\\n            !_storage.isHumanGuardian(\\n                _vault,\\n                _newOwner\\n            ),\\n            \\\"SM: new owner cannot be guardian\\\"\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/TransactionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\n\\n/**\\n * @title TransactionManager\\n * @notice Module to execute transactions in sequence to e.g. transfer tokens (ETH, ERC20, ERC721, ERC1155)\\n * or call third-party contracts. Manages static calls made to a vault.\\n */\\nabstract contract TransactionManager is BaseModule {\\n\\n    struct Call {\\n        address to;      //the target address to which transaction to be sent\\n        uint256 value;   //native amount to be sent.\\n        bytes data;      //the data for the transaction.\\n    }\\n\\n    // Static calls\\n    bytes4 private constant ERC1271_IS_VALID_SIGNATURE = bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"));\\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_RECEIVED = bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_BATCH_RECEIVED = bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    bytes4 private constant ERC165_INTERFACE = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n\\n    /**\\n     * @notice Makes `_vault` execute a sequence of transactions\\n     * The method reverts if any of the inner transactions reverts.\\n     * @param _vault The target vault.\\n     * @param _transactions The sequence of transactions.\\n     * @return bytes array of results for  all low level calls.\\n     */\\n    function multiCall(\\n        address _vault,\\n        Call[] calldata _transactions\\n    )\\n        external \\n        onlySelf()\\n        returns (bytes[] memory)\\n    {\\n        return multiCallWithApproval(_vault, _transactions);\\n    }\\n\\n    /**\\n     * @notice Makes `_vault` execute a sequence of transactions to only whitelisted addresses.\\n     * The method reverts if there are any transactions to non whitelisted addresses.\\n     * The method reverts if any of the inner transactions reverts.\\n     * @param _vault The target vault.\\n     * @param _transactions The sequence of transactions.\\n     * @return bytes array of results for all low level calls.\\n     */\\n    function multiCallToWhitelistedAddresses(\\n        address _vault,\\n        Call[] calldata _transactions\\n    )\\n        external\\n        onlySelf()\\n        returns (bytes[] memory)\\n    {\\n        uint256 len = _transactions.length;\\n        address[] memory to = new address[](len);\\n        bytes4[] memory sigs = new bytes4[](len);\\n        for(uint256 i=0;i<len;i++) {\\n            to[i] = _transactions[i].to;\\n            sigs[i] = Utils.functionPrefix(_transactions[i].data);\\n        }\\n        require(kresusRegistry.isRegisteredCalls(to, sigs), \\\"TM: Addresses or Sigs not registered\\\");\\n        return multiCallWithApproval(_vault, _transactions);\\n    }\\n\\n    /**\\n     * @inheritdoc IModule\\n     */\\n    function supportsStaticCall(\\n        bytes4 _methodId\\n    )\\n        external\\n        pure\\n        override\\n        returns (bool _isSupported)\\n    {\\n        return _methodId == ERC1271_IS_VALID_SIGNATURE ||\\n               _methodId == ERC721_RECEIVED ||\\n               _methodId == ERC165_INTERFACE ||\\n               _methodId == ERC1155_RECEIVED ||\\n               _methodId == ERC1155_BATCH_RECEIVED;\\n    }\\n\\n    /**\\n     * @notice Returns true if this contract implements the interface defined by\\n     * `interfaceId` (see https://eips.ethereum.org/EIPS/eip-165).\\n     * @param _interfaceID Bytes4 interface id of an interface.\\n     * @return True if this contract implements the interface, else false.\\n     */\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    )\\n        external\\n        pure\\n        returns (bool)\\n    {\\n        return  _interfaceID == ERC165_INTERFACE ||\\n                _interfaceID == (ERC1155_RECEIVED ^ ERC1155_BATCH_RECEIVED) ||\\n                _interfaceID == ERC721_RECEIVED;\\n    }\\n\\n    /**\\n     * @notice Implementation of EIP 1271.\\n     * Should return whether the `_signature` provided is valid for `_msgHash`.\\n     * @param _msgHash Hash of a message signed on the behalf of `address(this)`.\\n     * @param _signature Signature byte array associated with `_msgHash`.\\n     * @return If signature is valid returns magic value {ERC1271_IS_VALID_SIGNATURE}.\\n     */\\n    function isValidSignature(\\n        bytes32 _msgHash,\\n        bytes memory _signature\\n    )\\n        external\\n        view\\n        returns (bytes4)\\n    {\\n        require(_signature.length == 65, \\\"TM: invalid signature length\\\");\\n        address signer = Utils.recoverSigner(_msgHash, _signature, 0);\\n        require(_isOwner(msg.sender, signer), \\\"TM: Invalid signer\\\");\\n        return ERC1271_IS_VALID_SIGNATURE;\\n    }\\n\\n\\n    function multiCallWithApproval(\\n        address _vault,\\n        Call[] calldata _transactions\\n    ) \\n        internal\\n        returns\\n        (bytes[] memory)\\n    {\\n        bytes[] memory results = new bytes[](_transactions.length);\\n        for(uint256 i = 0; i < _transactions.length; i++) {\\n            results[i] = invokeVault(\\n                _vault,\\n                _transactions[i].to,\\n                _transactions[i].value,\\n                _transactions[i].data\\n            );\\n        }\\n        return results;\\n    }\\n\\n\\n    fallback() external {\\n        bytes4 methodId = Utils.functionPrefix(msg.data);\\n        if(methodId == ERC721_RECEIVED || methodId == ERC1155_RECEIVED || methodId == ERC1155_BATCH_RECEIVED) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {                \\n                calldatacopy(0, 0, 0x04)\\n                return (0, 0x20)\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/storage/IStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IStorage\\n * @notice Interface for Storage\\n */\\ninterface IStorage {\\n\\n    /**\\n     * @notice Sets lock for a vault contract.\\n     * @param _vault - The target vault.\\n     */\\n    function lock(address _vault) external;\\n\\n    /**\\n     * @notice Unlocks a vault contract.\\n     * @param _vault - The target vault.\\n     */\\n    function unlock(address _vault) external;\\n\\n    /**\\n     * @notice Lets an authorised module add a guardian to a vault.\\n     * @param _vault - The target vault.\\n     * @param _guardian - The guardian to add.\\n     */\\n    function setHumanGuardian(address _vault, address _guardian) external;\\n\\n    /**\\n     * @notice Sets a new time delay for a vault contract.\\n     * @param _vault - The target vault.\\n     * @param _newTimeDelay - The new time delay.\\n     */\\n    function setTimeDelay(address _vault, uint256 _newTimeDelay) external;\\n\\n    /**\\n     * @notice Function to be used to add trustee address to bequeath vault ownership.\\n     * @param _vault - The target vault.\\n     * @param _newTrustee - New address for trustee.\\n     */\\n    function setTrustee(address _vault, address _newTrustee) external;\\n\\n    /**\\n     * @notice Function to set the kbg for a vault.\\n     * @param _vault - The target vault.\\n     * @param _kbg - Address of kbg.\\n     */\\n    function setKbg(address _vault, address _kbg) external;\\n\\n    /**\\n     * @notice Function to enable or disable a vault.\\n     * @param _vault - The target vault.\\n     */\\n    function enable(address _vault) external;\\n\\n    /**\\n     * @notice Function to disable a vault.\\n     * @param _vault - The target vault.\\n     */\\n    function disable(address _vault) external;\\n\\n    /**\\n     * @notice Function to reset the vault.\\n     * @param _vault - The target vault.\\n     */\\n    function reset(address _vault) external;\\n\\n    /**\\n     * @notice Returns boolean indicating state of the vault.\\n     * @param _vault - The target vault.\\n     * @return true if the vault is locked, else false.\\n     */\\n    function isLocked(address _vault) external view returns(bool);\\n\\n    /**\\n     * @notice Returns kbg address of the vault.\\n     * @param _vault - The target vault.\\n     * @return kbg address of the vault.\\n     */\\n    function getKbg(address _vault) external view returns(address);\\n\\n    /**\\n     * @notice Returns human guardian address of the vault.\\n     * @param _vault - The target vault.\\n     */\\n    function getHumanGuardian(address _vault) external view returns(address);\\n\\n    /**\\n     * @notice Returns the trustee address for a vault.\\n     * @param _vault - The target vault.\\n     * @return The trustee address for a vault.\\n     */\\n    function getTrustee(address _vault) external view returns(address);\\n\\n    /**\\n     * @notice Checks if an address is kbg for a vault.\\n     * @param _vault - The target vault.\\n     * @param _kbg - The account address to be checked.\\n     * @return True if `_kbg` is kbg for `_vault`, else false.\\n     */\\n    function isKbg(address _vault, address _kbg) external view returns(bool);\\n\\n    /**\\n     * @notice Checks if an address is a guardian for a vault.\\n     * @param _vault - The target vault.\\n     * @param _guardian - The account address to be checked.\\n     * @return True if `_guardian` is human guardian for `_vault`, else false.\\n     */\\n    function isHumanGuardian(address _vault, address _guardian) external view returns(bool);\\n\\n    /**\\n     * @notice Checks if an address is an trustee for a vault.\\n     * @param _vault - The target vault.\\n     * @param _trustee - The account address to be checked.\\n     * return True if `_trustee` is the trustee for `_vault`, else false.\\n     */\\n    function isTrustee(address _vault, address _trustee) external view returns(bool);\\n\\n    /**\\n     * @notice Returns if a vault is disabled.\\n     * @param _vault - The target vault.\\n     * return True if the vault is disabled, else false.\\n     */\\n    function isDisabled(address _vault) external view returns(bool);\\n\\n    /**\\n     * @notice Returns uint256 time delay in seconds for a vault\\n     * @param _vault - The target vault.\\n     * @return uint256 time delay in seconds for a vault.\\n     */\\n    function getTimeDelay(address _vault) external view returns(uint256);\\n\\n    /**\\n     * @notice Returns if a vault has human guardian.\\n     * @param _vault - The target vault.\\n     * @return True if `_vault` has human guardian, else false.\\n     */\\n    function hasHumanGuardian(address _vault) external view returns(bool);\\n}\"\r\n    },\r\n    \"contracts/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IVault\\n * @notice Interface for the {BaseVault}\\n */\\ninterface IVault {\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n     * @param _module The target module.\\n     */\\n    function enableStaticCall(address _module) external;\\n\\n    /**\\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _initData bytes32 initialization data specific to the module.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules, bytes[] calldata _initData) external;\\n\\n    /**\\n     * @notice Sets a new owner for the vault.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Returns the vault owner.\\n     * @return The vault owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint256);\\n\\n    /**\\n     * @notice Checks if a module is authorised on the vault.\\n     * @param _module The module address to check.\\n     * @return True if the module is authorised, otherwise false.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible, if static call is enabled for `_sig`, otherwise return zero address.\\n     * @param _sig The signature of the static call.\\n     * @return The module doing the redirection or zero address\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStorage\",\"name\":\"_storageAddr\",\"type\":\"address\"},{\"internalType\":\"contract IKresusRegistry\",\"name\":\"_kresusRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kresusGuardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"signedHash\",\"type\":\"bytes32\"}],\"name\":\"ActionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"AllActionsCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newKbg\",\"type\":\"address\"}],\"name\":\"Bequeathed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Disabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"HumanGuardianChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimeDelay\",\"type\":\"uint256\"}],\"name\":\"TimeDelayChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"signedHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"signedHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newKbg\",\"type\":\"address\"}],\"name\":\"TransferedOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trustee\",\"type\":\"address\"}],\"name\":\"TrusteeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"addHumanGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initData\",\"type\":\"bytes\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newTrustee\",\"type\":\"address\"}],\"name\":\"addTrustee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"cancelAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"disable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"enable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newKbg\",\"type\":\"address\"}],\"name\":\"executeBequeathal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getCancelRequiredSignatures\",\"outputs\":[{\"internalType\":\"enum BaseModule.Signature\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getRequiredSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseModule.Signature\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getSignHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initData\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_actionHash\",\"type\":\"bytes32\"}],\"name\":\"isActionQueued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kresusGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCallToWhitelistedAddresses\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_actionHash\",\"type\":\"bytes32\"}],\"name\":\"queuedActionExecutionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"removeHumanGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"removeTrustee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"setHumanGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newTimeDelay\",\"type\":\"uint256\"}],\"name\":\"setTimeDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"supportsStaticCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isSupported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newKbg\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_signHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"},{\"internalType\":\"enum BaseModule.Signature\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateSignatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "KresusModule", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000bac8780b99ae84656989be9c6a0b1470417a6dc4000000000000000000000000eece51f53dda9881ae2b5edb752ad22c8c7aebd70000000000000000000000007bf09a75da7e88977150f452135ead9c90729cbd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}