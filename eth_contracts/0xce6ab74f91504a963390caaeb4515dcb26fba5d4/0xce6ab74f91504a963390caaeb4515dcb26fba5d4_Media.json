{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys a `value` amount of tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 value) public virtual {\\n        _burn(_msgSender(), value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n     * the caller's allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `value`.\\n     */\\n    function burnFrom(address account, uint256 value) public virtual {\\n        _spendAllowance(account, _msgSender(), value);\\n        _burn(account, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\nimport {IERC1271} from \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Safe Wallet (previously Gnosis Safe).\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interface/IERC1155Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IERC1155Minter is IERC1155 {\\n    /**\\n     * @dev Sets the address of media contract as the platform that can call functions in this contract\\n     *\\n     * Requirements:\\n     *\\n     * - The origin caller of this function must be `owner` i.e. the owner or deployer of this smart contract.\\n     * - `nftPlaform` cannot be the zero address.\\n     * - `platform` must not have been initialised. This should be zero address. Therefore this function can be called only once.\\n     */\\n    function setPlatform(address nftPlatform) external;\\n\\n    /**\\n     * @dev Interface function for public variable tokenId which returns the token ID of last token minted.\\n     */\\n    function tokenId() external view returns (uint256);\\n\\n    /**\\n     * @dev Mints new tokens.\\n     *      quantity `amount` of a token ID are minted by `creator` with the token URI `tokenUri`.\\n     */\\n    function mint(\\n        address creator,\\n        uint256 amount,\\n        string calldata tokenUri,\\n        uint96 royaltyFraction\\n    ) external;\\n\\n    /**\\n     * @dev Burns already minted tokens.\\n     *\\n     * Requirements:\\n     *\\n     * - caller must have quantity of token `id` more or equal to `amount`.\\n     */\\n    function burn(uint256 id, uint256 amount) external;\\n\\n    /**\\n     * @dev approve token for transfer\\n     *\\n     * Requirements:\\n     *\\n     * - caller must be media contract\\n     */\\n    function approveToken(address from, address to, bool approved) external;\\n\\n    /**\\n     * @dev return royalty info.\\n     *\\n     * Requirements:\\n     *\\n     * - Token `id` must exist.\\n     */\\n\\n    function getRoyalty(\\n        uint256 id,\\n        uint256 salePrice\\n    ) external view returns (address, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interface/IERC721Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IERC721Minter is IERC721 {\\n    /**\\n     * @dev Sets the address of media contract as the platform that can call functions in this contract\\n     *\\n     * Requirements:\\n     *\\n     * - The origin caller of this function must be `owner` i.e. the owner or deployer of this smart contract.\\n     * - `nftPlaform` cannot be the zero address.\\n     * - `platform` must not have been initialised. This should be zero address. Therefore this function can be called only once.\\n     */\\n    function setPlatform(address nftPlatform) external;\\n\\n    /**\\n     * @dev Interface function for public variable tokenId which returns the token ID of last token minted.\\n     */\\n    function tokenId() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns if token `id` exists or not.\\n     */\\n    function exists(uint256 id) external view returns (bool);\\n\\n    /**\\n     * @dev Mints new tokens.\\n     *      A new unique token is minted by `creator` with the token URI `tokenUri`.\\n     */\\n    function mint(\\n        address creator,\\n        string calldata tokenUri,\\n        uint96 royaltyFraction\\n    ) external;\\n\\n    /**\\n     * @dev Burns already minted tokens.\\n     *\\n     * Requirements:\\n     *\\n     * - Token `id` must exist.\\n     * - The caller must be the owner of the token `id`.\\n     */\\n    function burn(uint256 id) external;\\n\\n    /**\\n     * @dev approve token for transfer.\\n     *\\n     * Requirements:\\n     *\\n     * - Token `id` must exist.\\n     * - The caller must be the media contract.\\n     */\\n\\n    function approveToken(address to, uint256 id, address auth) external;\\n\\n    /**\\n     * @dev return royalty info.\\n     *\\n     * Requirements:\\n     *\\n     * - Token `id` must exist.\\n     */\\n\\n    function getRoyalty(\\n        uint256 id,\\n        uint256 salePrice\\n    ) external view returns (address, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interface/IMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\ninterface IMarket {\\n    //Struct for maintaining collaborators of a token\\n    struct Collaborators {\\n        address[] collaborators;\\n        uint256[] percentages;\\n    }\\n\\n    //Struct for maintainig refer details\\n    struct Refer {\\n        address referee;\\n        address referal;\\n    }\\n\\n    //Struct for maintaining details of tokens on auction\\n    struct OnAuction {\\n        address seller;\\n        address tokenAddress;\\n        uint256 basePrice;\\n        uint256 quantity;\\n        uint256 lastBidPrice;\\n        uint256 startTime;\\n        uint256 endTime;\\n        address[] bidders;\\n        uint256[] bidPrices;\\n    }\\n\\n    //Struct for maintaining details of tokens on sale\\n    struct OnSale {\\n        address seller;\\n        address tokenAddress;\\n        uint256 tokenPrice;\\n        uint256 quantity;\\n    }\\n\\n    // Struct for maintaining common details of tokens on sale or auction\\n    struct SaleOrAuctionInfo {\\n        address seller;\\n        address tokenAddress;\\n        uint256 quantity;\\n    }\\n\\n    //Event emitted when a token is put for sale\\n    event ForSale(\\n        address indexed token,\\n        address erc20Address,\\n        address indexed owner,\\n        uint256 indexed id,\\n        uint256 quantity,\\n        uint256 salePrice\\n    );\\n    //Event emitted when a token is sold\\n    event Sold(\\n        address token,\\n        address indexed seller,\\n        address indexed buyer,\\n        uint256 indexed id,\\n        uint256 quantity,\\n        uint256 price,\\n        uint256 adminCommission\\n    );\\n    //Event emitted when the owner of the withdraws a token from sale\\n    event WithdrawSale(\\n        address indexed token,\\n        address indexed seller,\\n        uint256 indexed id\\n    );\\n    //Event emitted when a token is put on auction\\n    event ForAuction(\\n        address indexed token,\\n        address erc20Address,\\n        address indexed owner,\\n        uint256 indexed id,\\n        uint256 quantity,\\n        uint256 basePrice,\\n        uint256 startTime,\\n        uint256 endTime\\n    );\\n    //Event emitted when there is a bid on a token\\n    event Bid(\\n        address token,\\n        address indexed bidder,\\n        address indexed owner,\\n        uint256 indexed id,\\n        uint256 bid\\n    );\\n    //Event emitted when a bid is rejected by the token owner or withdrawn by the bidder\\n    event CancelBid(\\n        address token,\\n        address indexed bidder,\\n        address indexed owner,\\n        uint256 indexed id\\n    );\\n    //Event emitted when the token owner accepts the bid of a bidder\\n    event AcceptBid(\\n        address token,\\n        address indexed bidder,\\n        address indexed owner,\\n        uint256 indexed id,\\n        uint256 adminCommission\\n    );\\n    //Event emitted when the token owner withdraws a token on auction\\n    event WithdrawAuction(\\n        address indexed token,\\n        address indexed owner,\\n        uint256 indexed id\\n    );\\n    //Event emitted when the highest bidder claims a token on timed auction after the auction ends\\n    event Claim(\\n        address token,\\n        address indexed bidder,\\n        address indexed owner,\\n        uint256 indexed id,\\n        uint256 adminCommission\\n    );\\n    //Event emitted when a user redeems his points to their wallet\\n    event Redeem(address indexed owner, uint256 indexed pointsRedeemed);\\n\\n    event Earning(\\n        address indexed referal,\\n        address indexed referee,\\n        uint256 referalAmount,\\n        uint256 refereeAmount\\n    );\\n\\n    event Royalty(\\n        address[] receiver,\\n        uint256[] royalty,\\n        uint256 tokenId,\\n        address tokenAddress\\n    );\\n\\n    event WithdrawRoyalty(\\n        address indexed receiver,\\n        uint256 indexed royalty,\\n        uint256 indexed tokenId,\\n        address tokenAddress,\\n        address erc20TokenAddress\\n    );\\n\\n    event OmiBurn(uint256 indexed amount, address indexed burner);\\n}\\n\"\r\n    },\r\n    \"contracts/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Interface/IMarket.sol\\\";\\nimport \\\"./Interface/IERC721Minter.sol\\\";\\nimport \\\"./Interface/IERC1155Minter.sol\\\";\\nimport \\\"./OMI.sol\\\";\\n\\ncontract Market is IMarket, Ownable {\\n    struct DirectBuyParams {\\n        address tokenAddress;\\n        uint256 id;\\n        address creator;\\n        address from;\\n        address buyer;\\n        uint256 price;\\n        uint256 quantity;\\n        uint256 commission;\\n    }\\n    //Address of Media platform\\n    address private _platform;\\n    //Relayer Address\\n    address private relayer;\\n    // OMI token address\\n    address private omiAddress;\\n    //Admin Commision percentage\\n    uint256 public platformCommission; //percentage * 100\\n    // OMI burn percentage\\n    uint256 public omiBurnPercentage; //percentage * 100\\n\\n    uint256 public _omiBurn;\\n\\n    //TokenContractAddress=>OwnerAddress=>TokenId=>`onAuction`\\n    mapping(address => mapping(address => mapping(uint256 => OnAuction)))\\n        public onAuctions;\\n\\n    //TokenAddress=>OwnerAddress=>TokenId=>BidderAddress=>Boolean\\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => bool))))\\n        private _isBidder;\\n\\n    //TokenAddress=>OwnerAddress=>TokenId=>`onSale`\\n    mapping(address => mapping(address => mapping(uint256 => OnSale)))\\n        private onSales;\\n\\n    //TokenAddress=>TokenId=>`Collaborators`\\n    mapping(address => mapping(uint256 => Collaborators))\\n        private _tokenCollaborators;\\n\\n    //UserAddress=>Balance\\n    mapping(address => uint256) private _redeemablePoints;\\n\\n    // UserAddress => erc20TokenAddress => Balance\\n    mapping(address => mapping(address => uint256))\\n        private _erc20RedeemablePoints;\\n\\n    // UserAddress =>tokenAddress => Balance\\n    mapping(address => mapping(address => uint256)) public _totalRoyaltyPoints;\\n\\n    // UserAddress => nftAddress => tokenId => Balance\\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\\n        public _royaltyPoints;\\n\\n    // UserAddress => nftAddress => tokenId => Balance\\n    mapping(address => mapping(address => mapping(uint256 => uint256))) _erc20royaltyPoints;\\n\\n    constructor(\\n        address _omiAddress,\\n        address initialOwner\\n    ) Ownable(initialOwner) {\\n        omiAddress = _omiAddress;\\n    }\\n\\n    //Modifier to check only media contract can call the functions\\n    modifier onlyPlatform() {\\n        require(\\n            msg.sender == _platform,\\n            \\\"Market: can only be called from platform\\\"\\n        );\\n        _;\\n    }\\n\\n    //receive function to receive ETH to the contract\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    /**\\n     * @dev Sets the address of media contract as the platform that can call functions in this contract\\n     *\\n     * Requirements:\\n     *\\n     * - The origin caller of this function must be `owner` i.e. the owner or deployer of this smart contract.\\n     * - `nftPlaform` cannot be the zero address.\\n     * - `platform` must not have been initialised. This should be zero address. Therefore this function can be called only once.\\n     */\\n    function setPlatform(address nftPlatform) external {\\n        require(\\n            tx.origin == owner(),\\n            \\\"Market: only contract owner can set platform\\\"\\n        );\\n        require(nftPlatform != address(0), \\\"Market: invalid platform address\\\");\\n        require(\\n            _platform == address(0),\\n            \\\"Market: platform already initialised\\\"\\n        );\\n        _platform = nftPlatform;\\n    }\\n\\n    /**\\n     * @dev Puts `quantity` quantity of `id` token of contract address `tokenAddress` from `tokenOwner` on auction at a price of `price`.\\n     *\\n     *      If the `endTime` is not equal to zero then the auction is a timed auction.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must not be on auction already.\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must not be on sale already.\\n     * - If on timed auction the timestamp at which the auction starts `startTime` must be more than the current block timestamp.\\n     * - If `startTime` is zero in a timed auction it is assigned the timestamp of current block.\\n     * - If on timed auction the timestamp at which the auction ends `endTime` must be more than the `startTime`.\\n     *\\n     * Emits a {ForAuction} event.\\n     */\\n    function putOnAuction(\\n        address tokenAddress,\\n        address erc20Address,\\n        uint256 id,\\n        address tokenOwner,\\n        uint256 price,\\n        uint256 quantity,\\n        uint256 startTime,\\n        uint256 endTime\\n    ) external onlyPlatform {\\n        require(\\n            onAuctions[tokenAddress][tokenOwner][id].seller == address(0),\\n            \\\"Market: NFT already on auction\\\"\\n        );\\n        require(\\n            onSales[tokenAddress][tokenOwner][id].seller == address(0),\\n            \\\"Market: NFT already on sale\\\"\\n        );\\n        if (endTime != 0) {\\n            if (startTime != 0)\\n                require(\\n                    startTime > block.timestamp,\\n                    \\\"Market: Auction start time already passed\\\"\\n                );\\n            else startTime = block.timestamp;\\n            require(\\n                endTime > startTime,\\n                \\\"Market: Auction end time must be more than start time\\\"\\n            );\\n            onAuctions[tokenAddress][tokenOwner][id].startTime = startTime;\\n            onAuctions[tokenAddress][tokenOwner][id].endTime = endTime;\\n            onAuctions[tokenAddress][tokenOwner][id].bidders.push(address(0));\\n            onAuctions[tokenAddress][tokenOwner][id].bidPrices.push(0);\\n            onAuctions[tokenAddress][tokenOwner][id]\\n                .tokenAddress = erc20Address;\\n        }\\n        onAuctions[tokenAddress][tokenOwner][id].seller = tokenOwner;\\n        onAuctions[tokenAddress][tokenOwner][id].basePrice = price;\\n        onAuctions[tokenAddress][tokenOwner][id].quantity = quantity;\\n        onAuctions[tokenAddress][tokenOwner][id].lastBidPrice = price;\\n        onAuctions[tokenAddress][tokenOwner][id].tokenAddress = erc20Address;\\n\\n        emit ForAuction(\\n            tokenAddress,\\n            erc20Address,\\n            tokenOwner,\\n            id,\\n            quantity,\\n            price,\\n            startTime,\\n            endTime\\n        );\\n    }\\n\\n    /**\\n     * @dev a bid by `bidder` of `bidAmount` on `id` token of contract address `tokenAddress` from `tokenOwner`\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on auction.\\n     * - `bidder` must not be owner of the token.\\n     * - `bidAmount` must be more than the last bid on the token.\\n     * - If timed auction first check if the current time is more than or equal to the start time. If true, the auction has started.\\n     * - If timed auction first check if the current time is less than the end time. If false, the auction has ended.\\n     *\\n     * Emits a {Bid} event.\\n     */\\n    function bid(\\n        address tokenAddress,\\n        uint256 id,\\n        address from,\\n        address bidder,\\n        uint256 bidAmount\\n    ) external onlyPlatform {\\n        OnAuction memory auctions = onAuctions[tokenAddress][from][id];\\n        require(auctions.seller != address(0), \\\"Market: NFT not on auction\\\");\\n        require(\\n            auctions.seller != bidder,\\n            \\\"Market: Owner cannot bid on his token\\\"\\n        );\\n        if (auctions.tokenAddress != address(0)) {\\n            uint256 approveToken = IERC20(auctions.tokenAddress).allowance(\\n                bidder,\\n                address(this)\\n            );\\n            require(\\n                approveToken > auctions.lastBidPrice,\\n                \\\"Market: Bid must be more than the last bid\\\"\\n            );\\n        } else {\\n            require(\\n                bidAmount > auctions.lastBidPrice,\\n                \\\"Market: Bid must be more than the last bid\\\"\\n            );\\n        }\\n        if (auctions.endTime == 0) {\\n            if (_isBidder[tokenAddress][from][id][bidder])\\n                _updateBid(\\n                    tokenAddress,\\n                    auctions.tokenAddress,\\n                    from,\\n                    id,\\n                    bidder,\\n                    bidAmount\\n                );\\n            else {\\n                onAuctions[tokenAddress][from][id].bidders.push(bidder);\\n                onAuctions[tokenAddress][from][id].bidPrices.push(bidAmount);\\n            }\\n            _isBidder[tokenAddress][from][id][bidder] = true;\\n        } else {\\n            require(\\n                auctions.startTime <= block.timestamp,\\n                \\\"Market: Auction has not started\\\"\\n            );\\n            require(\\n                auctions.endTime > block.timestamp,\\n                \\\"Market: Auction has ended\\\"\\n            );\\n\\n            if (auctions.tokenAddress != address(0)) {\\n                _erc20RedeemablePoints[auctions.bidders[0]][\\n                    auctions.tokenAddress\\n                ] += auctions.bidPrices[0];\\n            } else {\\n                _redeemablePoints[auctions.bidders[0]] += auctions.bidPrices[0];\\n            }\\n            onAuctions[tokenAddress][from][id].bidders[0] = bidder;\\n            onAuctions[tokenAddress][from][id].bidPrices[0] = bidAmount;\\n        }\\n        onAuctions[tokenAddress][from][id].lastBidPrice = bidAmount;\\n        if (auctions.tokenAddress != address(0))\\n            IERC20(auctions.tokenAddress).transferFrom(\\n                bidder,\\n                address(this),\\n                bidAmount\\n            );\\n\\n        emit Bid(tokenAddress, bidder, from, id, bidAmount);\\n    }\\n\\n    /**\\n     * @dev a bid from `bidder` on `id` token of contract address `tokenAddress` accepted by `tokenOwner`\\n     *\\n     *      Once accepted, royalty is calculated on the final bid amount. This royalty is then divided\\n     *      among the creator and collaborators (if any) of the token.\\n     *\\n     *      After removing the royalty the remaining amount is added to the points of the `tokenOwner`\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on auction.\\n     * - It must not be on timed auction.\\n     * - `quantity` must be equal to the quantity of tokens on sale.\\n     * - `bidder` must actually have a bid on the said token.\\n     *\\n     * Emits a {AcceptBid} event.\\n     */\\n    function acceptBid(\\n        address tokenAddress,\\n        uint256 id,\\n        address creator,\\n        address tokenOwner,\\n        address bidder,\\n        uint256 quantity,\\n        uint256 commission\\n    ) external onlyPlatform {\\n        OnAuction memory auctions = onAuctions[tokenAddress][tokenOwner][id];\\n        require(auctions.seller != address(0), \\\"Market: NFT not on auction\\\");\\n        require(auctions.endTime == 0, \\\"Market: NFT is on timed auction\\\");\\n        require(\\n            auctions.quantity == quantity,\\n            \\\"Market: Quantity should be equal to total tokens on auction\\\"\\n        );\\n        require(\\n            _isBidder[tokenAddress][tokenOwner][id][bidder],\\n            \\\"Market: Bidder did not bid for this token\\\"\\n        );\\n        uint256 bidNumber;\\n        uint256 totalBids = auctions.bidders.length;\\n        uint256 _adminCommission;\\n        commission = commission > 0 ? commission : platformCommission;\\n\\n        for (bidNumber = 0; bidNumber < totalBids; bidNumber++) {\\n            if (auctions.bidders[bidNumber] == bidder) {\\n                if (creator == address(0)) {\\n                    if (auctions.tokenAddress != address(0)) {\\n                        _erc20RedeemablePoints[tokenOwner][\\n                            auctions.tokenAddress\\n                        ] += auctions.bidPrices[bidNumber];\\n                    } else {\\n                        _redeemablePoints[tokenOwner] += auctions.bidPrices[\\n                            bidNumber\\n                        ];\\n                    }\\n                } else {\\n                    (uint256 royalty, address receiver) = _royalty(\\n                        id,\\n                        auctions.bidPrices[bidNumber],\\n                        tokenAddress\\n                    );\\n\\n                    _adminCommission = _calculatePercentage(\\n                        auctions.bidPrices[bidNumber],\\n                        commission\\n                    );\\n\\n                    if (auctions.tokenAddress != address(0)) {\\n                        _erc20RedeemablePoints[tokenOwner][\\n                            auctions.tokenAddress\\n                        ] += (auctions.bidPrices[bidNumber] -\\n                            royalty -\\n                            _adminCommission);\\n\\n                        _erc20RedeemablePoints[owner()][\\n                            auctions.tokenAddress\\n                        ] += (_adminCommission);\\n                    } else {\\n                        _redeemablePoints[tokenOwner] += (auctions.bidPrices[\\n                            bidNumber\\n                        ] -\\n                            royalty -\\n                            _adminCommission);\\n\\n                        _redeemablePoints[owner()] += (_adminCommission);\\n                    }\\n\\n                    _divideRoyalty(\\n                        creator,\\n                        tokenAddress,\\n                        auctions.tokenAddress,\\n                        id,\\n                        royalty\\n                    );\\n                }\\n            } else {\\n                if (auctions.tokenAddress != address(0)) {\\n                    _erc20RedeemablePoints[auctions.bidders[bidNumber]][\\n                        auctions.tokenAddress\\n                    ] += auctions.bidPrices[bidNumber];\\n                } else {\\n                    _redeemablePoints[auctions.bidders[bidNumber]] += auctions\\n                        .bidPrices[bidNumber];\\n                }\\n\\n                _isBidder[tokenAddress][tokenOwner][id][\\n                    auctions.bidders[bidNumber]\\n                ] = false;\\n            }\\n        }\\n        delete onAuctions[tokenAddress][tokenOwner][id];\\n        emit AcceptBid(tokenAddress, bidder, tokenOwner, id, _adminCommission);\\n    }\\n\\n    /**\\n     * @dev the `bidder` on `id` token of contract address `tokenAddress` claims the token after the timed auction ends.\\n     *\\n     *      Once claimed, royalty is calculated on the final bid amount. This royalty is then divided\\n     *      among the `creator` and collaborators (if any) of the token.\\n     *\\n     *      After removing the royalty the remaining amount is added to the points of the seller `from`.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on auction.\\n     * - It must be on timed auction.\\n     * - `quantity` must be equal to the quantity of tokens on sale.\\n     * - The auction should have ended i.e. the current time must be more than the end time of the auction.\\n     * - `bidder` must be the highest bidder before the auction ended.\\n     *\\n     * Emits a {Claim} event.\\n     */\\n    function claim(DirectBuyParams memory params) external onlyPlatform {\\n        OnAuction memory auctions = onAuctions[params.tokenAddress][\\n            params.from\\n        ][params.id];\\n        SaleOrAuctionInfo memory saleInfo = SaleOrAuctionInfo({\\n            seller: auctions.seller,\\n            tokenAddress: auctions.tokenAddress,\\n            quantity: auctions.quantity\\n        });\\n        require(auctions.seller != address(0), \\\"Market: NFT not on auction\\\");\\n        require(auctions.endTime != 0, \\\"Market: NFT is not on timed auction\\\");\\n        require(\\n            auctions.endTime < block.timestamp,\\n            \\\"Market: Auction is not over\\\"\\n        );\\n        require(\\n            auctions.bidders[0] == params.buyer,\\n            \\\"Market: You are not the winning bidder\\\"\\n        );\\n        require(\\n            auctions.quantity == params.quantity,\\n            \\\"Market: Quantity should be equal to total tokens on auction\\\"\\n        );\\n        uint256 adminCommission = _handleCommissionAndRoyalty(\\n            params.id,\\n            saleInfo,\\n            params.creator,\\n            params.from,\\n            auctions.bidPrices[0],\\n            params.commission,\\n            params.tokenAddress\\n        );\\n\\n        onAuctions[params.tokenAddress][params.from][params.id]\\n            .quantity -= params.quantity;\\n        if (auctions.tokenAddress != address(0))\\n            IERC20(auctions.tokenAddress).transferFrom(\\n                params.buyer,\\n                address(this),\\n                params.id\\n            );\\n        delete onAuctions[params.tokenAddress][params.from][params.id];\\n        emit Claim(\\n            params.tokenAddress,\\n            params.buyer,\\n            params.from,\\n            params.id,\\n            adminCommission\\n        );\\n    }\\n\\n    /**\\n     * @dev the auction on `id` token of contract address `tokenAddress` by `tokenOwner` was withdrawn.\\n     *\\n     *      If timed auction then there must be no bids on the token for it to be withdrawn.\\n     *      If normal auction then all the bids on the token are added back to the points of respective\\n     *      bidders before it is withdrawn.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on auction.\\n     * - `tokenOwner` must be the auctioner.\\n     * - If timed auction there must be no bidders.\\n     *\\n     * Emits a {WithdrawAuction} event.\\n     */\\n    function withdrawAuction(\\n        address tokenAddress,\\n        uint256 id,\\n        address tokenOwner\\n    ) external onlyPlatform {\\n        OnAuction memory auctions = onAuctions[tokenAddress][tokenOwner][id];\\n        require(\\n            auctions.seller == tokenOwner,\\n            \\\"Market: You did not put the NFT on auction\\\"\\n        );\\n        if (auctions.endTime != 0)\\n            require(\\n                auctions.bidders[0] == address(0),\\n                \\\"Market: Already bid on timed auction exists\\\"\\n            );\\n        else {\\n            uint256 bidNumber;\\n            uint256 totalBids = auctions.bidders.length;\\n            for (bidNumber = 0; bidNumber < totalBids; bidNumber++) {\\n                if (auctions.tokenAddress != address(0)) {\\n                    _erc20RedeemablePoints[auctions.bidders[bidNumber]][\\n                        auctions.tokenAddress\\n                    ] += auctions.bidPrices[bidNumber];\\n                } else {\\n                    _redeemablePoints[auctions.bidders[bidNumber]] += auctions\\n                        .bidPrices[bidNumber];\\n                }\\n                _isBidder[tokenAddress][tokenOwner][id][\\n                    auctions.bidders[bidNumber]\\n                ] = false;\\n            }\\n        }\\n        delete onAuctions[tokenAddress][tokenOwner][id];\\n        emit WithdrawAuction(tokenAddress, tokenOwner, id);\\n    }\\n\\n    /**\\n     * @dev the bid of `bidder` on `id` token of contract address `tokenAddress` is removed.\\n     *\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on auction.\\n     * - It must not be on timed auction.\\n     * - `bidder` must actually have a bid on the said token.\\n     *\\n     * Emits a {CancelBid} event.\\n     */\\n    function removeBid(\\n        address tokenAddress,\\n        address from,\\n        uint256 id,\\n        address bidder\\n    ) public onlyPlatform {\\n        OnAuction memory auctions = onAuctions[tokenAddress][from][id];\\n        require(auctions.endTime == 0, \\\"Market: NFT is on timed auction\\\");\\n        require(\\n            auctions.seller == from,\\n            \\\"Market: This seller did not put this token on auction\\\"\\n        );\\n        require(\\n            _isBidder[tokenAddress][from][id][bidder],\\n            \\\"Market: No bids from bidder for this token\\\"\\n        );\\n        uint256 bidNumber;\\n        uint256 totalBids = auctions.bidders.length;\\n        for (bidNumber = 0; bidNumber < totalBids; bidNumber++) {\\n            if (auctions.bidders[bidNumber] == bidder) {\\n                if (auctions.tokenAddress != address(0)) {\\n                    _erc20RedeemablePoints[bidder][\\n                        auctions.tokenAddress\\n                    ] += auctions.bidPrices[bidNumber];\\n                } else {\\n                    _redeemablePoints[bidder] += auctions.bidPrices[bidNumber];\\n                }\\n                onAuctions[tokenAddress][from][id].bidders[bidNumber] = auctions\\n                    .bidders[totalBids - 1];\\n                onAuctions[tokenAddress][from][id].bidders.pop();\\n                onAuctions[tokenAddress][from][id].bidPrices[\\n                    bidNumber\\n                ] = auctions.bidPrices[totalBids - 1];\\n                onAuctions[tokenAddress][from][id].bidPrices.pop();\\n                _isBidder[tokenAddress][from][id][bidder] = false;\\n                break;\\n            }\\n        }\\n        emit CancelBid(tokenAddress, bidder, from, id);\\n    }\\n\\n    /**\\n     * @dev Puts `quantity` quantity of `id` token of contract address `tokenAddress` from `tokenOwner` on fixed sale at a price of `price`.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must not be on sale already.\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must not be on auction already.\\n     *\\n     * Emits a {ForSale} event.\\n     */\\n    function listOnSale(\\n        address tokenAddress,\\n        address erc20Address,\\n        uint256 id,\\n        address tokenOwner,\\n        uint256 price,\\n        uint256 quantity\\n    ) external onlyPlatform {\\n        require(\\n            onSales[tokenAddress][tokenOwner][id].seller == address(0),\\n            \\\"Market: NFT already on sale\\\"\\n        );\\n        require(\\n            onAuctions[tokenAddress][tokenOwner][id].seller == address(0),\\n            \\\"Market: NFT already on auction\\\"\\n        );\\n        onSales[tokenAddress][tokenOwner][id] = OnSale({\\n            seller: tokenOwner,\\n            tokenAddress: erc20Address,\\n            tokenPrice: price,\\n            quantity: quantity\\n        });\\n        emit ForSale(\\n            tokenAddress,\\n            erc20Address,\\n            tokenOwner,\\n            id,\\n            quantity,\\n            price\\n        );\\n    }\\n\\n    /**\\n     * @dev `buyer` pays `price` for `id` token of contract address `tokenAddress` which was put on sale by `from`.\\n     *\\n     *      `price` is the total sale price depending on the quantity of tokens to be bought.\\n     *\\n     *      Once bought, royalty is calculated on the total sale price. This royalty is then divided\\n     *      among the `creator` and collaborators (if any) of the token.\\n     *\\n     *      After removing the royalty the remaining amount is added to the points of the seller `from`.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on sale.\\n     * - `price` must be equal to the `quantity` multiplied by price of each token.\\n     * - `quantity` must be less than or equal to the quantity of token put on sale.\\n     *\\n     * Emits a {Sold} event.\\n     */\\n    function directBuy(\\n        DirectBuyParams memory params\\n    ) external onlyPlatform returns (uint256 sellPrice) {\\n        OnSale memory sale = onSales[params.tokenAddress][params.from][\\n            params.id\\n        ];\\n        SaleOrAuctionInfo memory saleInfo = SaleOrAuctionInfo({\\n            seller: sale.seller,\\n            tokenAddress: sale.tokenAddress,\\n            quantity: sale.quantity\\n        });\\n        require(sale.seller != address(0), \\\"Market: NFT not on sale\\\");\\n        require(\\n            sale.seller != params.buyer,\\n            \\\"Market: Seller can not buy own NFT\\\"\\n        );\\n        require(\\n            params.quantity <= sale.quantity,\\n            \\\"Market: Not sufficient token on sale\\\"\\n        );\\n\\n        _checkPriceAndTransfer(\\n            sale,\\n            params.buyer,\\n            params.price,\\n            params.quantity\\n        );\\n        uint256 adminCommission = _handleCommissionAndRoyalty(\\n            params.id,\\n            saleInfo,\\n            params.creator,\\n            params.from,\\n            params.price,\\n            params.commission,\\n            params.tokenAddress\\n        );\\n\\n        onSales[params.tokenAddress][params.from][params.id].quantity -= params\\n            .quantity;\\n        if (sale.tokenAddress != address(0))\\n            IERC20(sale.tokenAddress).transferFrom(\\n                params.buyer,\\n                address(this),\\n                params.price\\n            );\\n\\n        if (onSales[params.tokenAddress][params.from][params.id].quantity == 0)\\n            delete onSales[params.tokenAddress][params.from][params.id];\\n\\n        emit Sold(\\n            params.tokenAddress,\\n            params.from,\\n            params.buyer,\\n            params.id,\\n            params.quantity,\\n            params.price,\\n            adminCommission\\n        );\\n        return (params.price);\\n    }\\n\\n    function _checkPriceAndTransfer(\\n        OnSale memory sale,\\n        address buyer,\\n        uint256 price,\\n        uint256 quantity\\n    ) private view {\\n        if (sale.tokenAddress != address(0)) {\\n            uint256 approveToken = IERC20(sale.tokenAddress).allowance(\\n                buyer,\\n                address(this)\\n            );\\n            require(\\n                approveToken >= sale.tokenPrice * quantity,\\n                \\\"Market: Amount either more or less than NFT price\\\"\\n            );\\n        } else {\\n            require(\\n                price >= sale.tokenPrice * quantity,\\n                \\\"Market: Amount either more or less than NFT price\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev the sale on `id` token of contract address `tokenAddress` by `tokenOwner` was withdrawn.\\n     *\\n     * Requirements:\\n     *\\n     * - `id` token of contract address `tokenAddress` from `tokenOwner` must be on sale.\\n     * - `tokenOwner` must be the auctioner.\\n     *\\n     * Emits a {WithdrawSale} event.\\n     */\\n    function withdrawSale(\\n        address tokenAddress,\\n        uint256 id,\\n        address tokenOwner\\n    ) external {\\n        require(\\n            onSales[tokenAddress][tokenOwner][id].seller == tokenOwner,\\n            \\\"Media: You are not selling the token\\\"\\n        );\\n        delete onSales[tokenAddress][tokenOwner][id];\\n        emit WithdrawSale(tokenAddress, tokenOwner, id);\\n    }\\n\\n    /**\\n     * @dev Sets the collaborators of `tokenID` token of contract address `tokenAddress`.\\n     *      Also sets the percentage of royalty each collaborator will receive.\\n     *\\n     * Requirements:\\n     *\\n     * - The total collaborator percentage must not be more than 100%.\\n     *\\n     */\\n    function setCollaborators(\\n        address tokenAddress,\\n        uint256 tokenID,\\n        address[] calldata collaborator,\\n        uint256[] calldata percentage\\n    ) external onlyPlatform {\\n        uint256 totalPercentage;\\n        for (uint256 index = 0; index < percentage.length; index++) {\\n            totalPercentage += percentage[index];\\n        }\\n        require(\\n            totalPercentage <= 10000,\\n            \\\"Market: Percentage cannot be more than 100\\\"\\n        );\\n        Collaborators memory collaborators = Collaborators(\\n            collaborator,\\n            percentage\\n        );\\n        _tokenCollaborators[tokenAddress][tokenID] = collaborators;\\n    }\\n\\n    /**\\n     * @dev Redeems `points` to the `user` wallet.\\n     *\\n     * Requirements:\\n     *\\n     * - The redeemable points of the `user` must be more than or equal to the requested `points`.\\n     *\\n     */\\n    function redeemPoints(\\n        address user,\\n        address erc20Address,\\n        uint256 points\\n    ) external onlyPlatform {\\n        if (erc20Address != address(0)) {\\n            require(\\n                points <= _erc20RedeemablePoints[user][erc20Address],\\n                \\\"Market: Not sufficient balance to withdraw\\\"\\n            );\\n            IERC20(erc20Address).transfer(user, points);\\n            _erc20RedeemablePoints[user][erc20Address] -= points;\\n        } else {\\n            require(\\n                points <= _redeemablePoints[user],\\n                \\\"Market: Not sufficient balance to withdraw\\\"\\n            );\\n            payable(user).transfer(points);\\n            _redeemablePoints[user] -= points;\\n        }\\n        emit Redeem(user, points);\\n    }\\n\\n    /**\\n     * @dev Shows the total available redeemable points of the `user`.\\n     *\\n     */\\n    function viewPoints(\\n        address user,\\n        address erc20Address\\n    ) external view onlyPlatform returns (uint256 eth, uint256 erc20) {\\n        return (\\n            _redeemablePoints[user],\\n            _erc20RedeemablePoints[user][erc20Address]\\n        );\\n    }\\n\\n    function addPoints(address to, uint256 points) external onlyPlatform {\\n        _redeemablePoints[to] += points;\\n    }\\n\\n    function setCommission(uint256 _commission) external onlyPlatform {\\n        if (platformCommission != _commission) platformCommission = _commission;\\n    }\\n\\n    function setBurnPercentage(uint256 _burnPercentage) external onlyPlatform {\\n        if (omiBurnPercentage != _burnPercentage)\\n            omiBurnPercentage = _burnPercentage;\\n    }\\n\\n    function setRelayer(address _relayer) external onlyPlatform {\\n        require(_relayer != address(0), \\\"Market: Address zero provided\\\");\\n        require(relayer == address(0), \\\"Market: Address already set\\\");\\n        relayer = _relayer;\\n    }\\n\\n    function withdrawAllRoyalty(\\n        address erc20Address,\\n        address msgSender\\n    ) external onlyPlatform {\\n        uint256 royalty;\\n        if (erc20Address != address(0)) {\\n            royalty = _totalRoyaltyPoints[msgSender][erc20Address];\\n            require(royalty > 0, \\\"Market: Not enough royalty to withdraw\\\");\\n            _totalRoyaltyPoints[msgSender][erc20Address] = 0;\\n            IERC20(erc20Address).transfer(msgSender, royalty);\\n        } else {\\n            royalty = _totalRoyaltyPoints[msgSender][erc20Address];\\n            require(royalty > 0, \\\"Market: Not enough royalty to withdraw\\\");\\n            _totalRoyaltyPoints[msgSender][erc20Address] = 0;\\n            payable(msgSender).transfer(royalty);\\n        }\\n    }\\n\\n    function withdrawRoyalty(\\n        address erc20Address,\\n        address tokenAddress,\\n        address msgSender,\\n        uint256 tokenId\\n    ) external onlyPlatform {\\n        require(\\n            _totalRoyaltyPoints[msgSender][erc20Address] > 0,\\n            \\\"Market: Not enough royalty to withdraw\\\"\\n        );\\n        uint256 royalty;\\n        if (erc20Address != address(0)) {\\n            royalty = _erc20royaltyPoints[msgSender][tokenAddress][tokenId];\\n            require(royalty > 0, \\\"Market: Not enough royalty to withdraw\\\");\\n            _erc20royaltyPoints[msgSender][tokenAddress][tokenId] = 0;\\n            IERC20(erc20Address).transfer(msgSender, royalty);\\n        } else {\\n            royalty = _royaltyPoints[msgSender][tokenAddress][tokenId];\\n            require(royalty > 0, \\\"Market: Not enough royalty to withdraw\\\");\\n            _royaltyPoints[msgSender][tokenAddress][tokenId] = 0;\\n            payable(msgSender).transfer(royalty);\\n        }\\n        _totalRoyaltyPoints[msgSender][erc20Address] -= royalty;\\n\\n        emit WithdrawRoyalty(\\n            msgSender,\\n            royalty,\\n            tokenId,\\n            tokenAddress,\\n            erc20Address\\n        );\\n    }\\n\\n    function burnOmi(uint256 amount, address msgSender) external onlyPlatform {\\n        require(_omiBurn >= amount, \\\"Market: Not enough OMI to burn\\\");\\n        OMIToken _omi = OMIToken(omiAddress);\\n        _omiBurn -= amount;\\n        _omi.burn(amount);\\n        emit OmiBurn(amount, msgSender);\\n    }\\n\\n    //PRIVATE FUNCTIONS\\n\\n    function _updateBid(\\n        address tokenAddress,\\n        address erc20Address,\\n        address from,\\n        uint256 id,\\n        address bidder,\\n        uint256 bidAmount\\n    ) private {\\n        OnAuction memory auctions = onAuctions[tokenAddress][from][id];\\n        uint256 bidNumber;\\n        uint256 totalBids = auctions.bidders.length;\\n        for (bidNumber = 0; bidNumber < totalBids; bidNumber++) {\\n            if (auctions.bidders[bidNumber] == bidder) {\\n                if (erc20Address != address(0)) {\\n                    _erc20RedeemablePoints[bidder][erc20Address] += auctions\\n                        .bidPrices[bidNumber];\\n                } else {\\n                    _redeemablePoints[bidder] += auctions.bidPrices[bidNumber];\\n                }\\n                onAuctions[tokenAddress][from][id].bidPrices[\\n                    bidNumber\\n                ] = bidAmount;\\n            }\\n        }\\n    }\\n\\n    function _divideRoyalty(\\n        address receiver,\\n        address tokenAddress,\\n        address erc20Address,\\n        uint256 tokenId,\\n        uint256 royalty\\n    ) private onlyPlatform {\\n        uint256 totalCollaborators = _tokenCollaborators[tokenAddress][tokenId]\\n            .collaborators\\n            .length;\\n\\n        uint256 royaltySpent;\\n        uint256[] memory _collabRoyalty = new uint256[](totalCollaborators + 1);\\n        address[] memory _collab = new address[](totalCollaborators + 1);\\n\\n        address[] memory collaborators = _tokenCollaborators[tokenAddress][\\n            tokenId\\n        ].collaborators;\\n        uint256[] memory percentages = _tokenCollaborators[tokenAddress][\\n            tokenId\\n        ].percentages;\\n\\n        for (\\n            uint256 collaboratorsCounter = 0;\\n            collaboratorsCounter < totalCollaborators;\\n            collaboratorsCounter++\\n        ) {\\n            uint256 royaltyShare = (royalty *\\n                percentages[collaboratorsCounter]) / 10000;\\n            address collaborator = collaborators[collaboratorsCounter];\\n\\n            if (erc20Address != address(0)) {\\n                _erc20royaltyPoints[collaborator][tokenAddress][\\n                    tokenId\\n                ] += royaltyShare;\\n            } else {\\n                _royaltyPoints[collaborator][tokenAddress][\\n                    tokenId\\n                ] += royaltyShare;\\n            }\\n\\n            _totalRoyaltyPoints[collaborator][erc20Address] += royaltyShare;\\n            royaltySpent += royaltyShare;\\n            _collabRoyalty[collaboratorsCounter] = royaltySpent;\\n            _collab[collaboratorsCounter] = collaborator;\\n        }\\n        if (totalCollaborators == 0) {\\n            if (erc20Address != address(0)) {\\n                _erc20royaltyPoints[receiver][tokenAddress][tokenId] += royalty;\\n\\n                _collabRoyalty[0] = royalty;\\n                _collab[0] = receiver;\\n            } else {\\n                _royaltyPoints[receiver][tokenAddress][tokenId] += royalty;\\n                _collabRoyalty[0] = royalty;\\n                _collab[0] = receiver;\\n            }\\n            _totalRoyaltyPoints[receiver][erc20Address] += royalty;\\n        } else {\\n            if (erc20Address != address(0)) {\\n                _erc20royaltyPoints[receiver][tokenAddress][\\n                    tokenId\\n                ] += (royalty - royaltySpent);\\n\\n                _collabRoyalty[_collabRoyalty.length - 1] =\\n                    royalty -\\n                    royaltySpent;\\n                _collab[_collab.length - 1] = receiver;\\n                _totalRoyaltyPoints[receiver][erc20Address] += (royalty -\\n                    royaltySpent);\\n            } else {\\n                _redeemablePoints[receiver] += (royalty - royaltySpent);\\n                _collabRoyalty[_collabRoyalty.length - 1] =\\n                    royalty -\\n                    royaltySpent;\\n                _collab[_collab.length - 1] = receiver;\\n                _totalRoyaltyPoints[receiver][erc20Address] += (royalty -\\n                    royaltySpent);\\n            }\\n        }\\n        emit Royalty(_collab, _collabRoyalty, tokenId, tokenAddress);\\n    }\\n\\n    function _calculatePercentage(\\n        uint256 price,\\n        uint256 percentage\\n    ) private pure returns (uint256) {\\n        if (price == 0) return 0;\\n        return (price * percentage) / 10000;\\n    }\\n\\n    function _royalty(\\n        uint256 id,\\n        uint256 salePrice,\\n        address tokenAddress\\n    ) private view returns (uint256, address) {\\n        if (IERC721(tokenAddress).supportsInterface(0x80ac58cd)) {\\n            (address receiver, uint256 royalty) = IERC721Minter(tokenAddress)\\n                .getRoyalty(id, salePrice);\\n            return (royalty, receiver);\\n        } else if (IERC1155(tokenAddress).supportsInterface(0xd9b67a26)) {\\n            (address receiver, uint256 royalty) = IERC1155Minter(tokenAddress)\\n                .getRoyalty(id, salePrice);\\n            return (royalty, receiver);\\n        } else return (0, address(0));\\n    }\\n\\n    function _handleCommissionAndRoyalty(\\n        uint256 id,\\n        SaleOrAuctionInfo memory saleInfo,\\n        address creator,\\n        address from,\\n        uint256 price,\\n        uint256 commission,\\n        address tokenAddress\\n    ) private returns (uint256 adminCommission) {\\n        uint256 _adminCommission;\\n        (uint256 royalty, address receiver) = _royalty(id, price, tokenAddress);\\n        commission = commission > 0 ? commission : platformCommission;\\n\\n        if (creator == address(0)) {\\n            if (saleInfo.tokenAddress != address(0)) {\\n                _erc20RedeemablePoints[from][saleInfo.tokenAddress] += price;\\n            } else {\\n                _redeemablePoints[from] += price;\\n            }\\n        } else {\\n            _adminCommission = _calculatePercentage(price, commission);\\n\\n            return\\n                _handleTokenAddress(\\n                    id,\\n                    saleInfo,\\n                    receiver,\\n                    from,\\n                    price,\\n                    _adminCommission,\\n                    royalty,\\n                    tokenAddress\\n                );\\n        }\\n    }\\n\\n    function _handleTokenAddress(\\n        uint256 id,\\n        SaleOrAuctionInfo memory saleInfo,\\n        address receiver,\\n        address from,\\n        uint256 price,\\n        uint256 _adminCommission,\\n        uint256 royalty,\\n        address tokenAddress\\n    ) private returns (uint256 adminCommission) {\\n        uint256 _burnAmount;\\n        if (saleInfo.tokenAddress != address(0)) {\\n            _erc20RedeemablePoints[from][saleInfo.tokenAddress] += (price -\\n                _adminCommission -\\n                royalty);\\n            if (saleInfo.tokenAddress == omiAddress) {\\n                _burnAmount = _calculatePercentage(\\n                    _adminCommission,\\n                    omiBurnPercentage\\n                );\\n                _omiBurn += _burnAmount;\\n\\n                _erc20RedeemablePoints[owner()][\\n                    saleInfo.tokenAddress\\n                ] += (_adminCommission - _burnAmount);\\n            } else {\\n                _erc20RedeemablePoints[owner()][saleInfo.tokenAddress] += (\\n                    _adminCommission\\n                );\\n            }\\n        } else {\\n            _redeemablePoints[from] += (price - _adminCommission - royalty);\\n            _redeemablePoints[owner()] += (_adminCommission);\\n        }\\n\\n        _divideRoyalty(\\n            receiver,\\n            tokenAddress,\\n            saleInfo.tokenAddress,\\n            id,\\n            royalty\\n        );\\n        return _adminCommission - _burnAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Media.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"./Market.sol\\\";\\nimport \\\"./Interface/IERC721Minter.sol\\\";\\nimport \\\"./Interface/IERC1155Minter.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Media is Ownable {\\n    // Constants interface IDs\\n    bytes4 private constant INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    //Address of the market contract.\\n    address payable private _marketAddress;\\n    //Address of the nominated owner. This address is nominated by the current contract owner to transfer ownership to.\\n    address private _ownerNominee;\\n\\n    //URI string=>Boolean\\n    mapping(string => bool) private _uriExists;\\n\\n    constructor(address market, address initialOwner) Ownable(initialOwner) {\\n        _marketAddress = payable(market);\\n        Market(_marketAddress).setPlatform(address(this));\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Owner of the smart contract nominates another address to transfer ownership to.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller of this function must be `owner` i.e. the owner of this smart contract.\\n     * - `nominee` cannot be the zero address.\\n     */\\n    function nominateOwner(address nominee) external onlyOwner {\\n        require(nominee != address(0), \\\"Media: Zero address provided\\\");\\n        _ownerNominee = nominee;\\n    }\\n\\n    function mintToken(\\n        address tokenAddress,\\n        string memory tokenUri,\\n        uint256 supply,\\n        address[] memory collaborator,\\n        uint256[] memory percentage,\\n        uint96 royalty\\n    ) external {\\n        require(supply != 0, \\\"Media: Supply cannot be zero\\\");\\n        require(\\n            !_uriExists[tokenUri],\\n            \\\"Media: Token already exists with the given URI\\\"\\n        );\\n        require(\\n            collaborator.length == percentage.length,\\n            \\\"Media: collaborator and percentage mismatch\\\"\\n        );\\n\\n        uint256 tokenId;\\n\\n        if (IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)) {\\n            IERC1155Minter minter = IERC1155Minter(tokenAddress);\\n            minter.mint(msg.sender, supply, tokenUri, royalty);\\n            tokenId = minter.tokenId();\\n            minter.approveToken(msg.sender, address(this), true);\\n        } else if (\\n            IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)\\n        ) {\\n            require(supply == 1, \\\"Media: Only one ERC721 token can be minted\\\");\\n            IERC721Minter minter = IERC721Minter(tokenAddress);\\n            minter.mint(msg.sender, tokenUri, royalty);\\n            tokenId = minter.tokenId();\\n            minter.approveToken(address(this), tokenId, msg.sender);\\n        } else {\\n            revert(\\\"Media: Invalid NFT address\\\");\\n        }\\n\\n        Market(_marketAddress).setCollaborators(\\n            tokenAddress,\\n            tokenId,\\n            collaborator,\\n            percentage\\n        );\\n        _uriExists[tokenUri] = true;\\n    }\\n\\n    //TODO: call the approve functions for the tokens put on auction\\n    function putOnSell(\\n        address tokenAddress,\\n        address erc20Address,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 quantityOftoken\\n    ) external {\\n        require(\\n            quantityOftoken > 0,\\n            \\\"Media: Quantity must be greater than or equal to 1\\\"\\n        );\\n        if (IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)) {\\n            require(\\n                IERC721(tokenAddress).ownerOf(tokenId) == msg.sender,\\n                \\\"Media: You are not owner of this NFT\\\"\\n            );\\n            require(quantityOftoken == 1, \\\"Media: Invalid quantity provided\\\");\\n            require(\\n                IERC721(tokenAddress).getApproved(tokenId) == address(this) ||\\n                    IERC721(tokenAddress).isApprovedForAll(\\n                        msg.sender,\\n                        address(this)\\n                    ),\\n                \\\"Media: NFT not approved to sell\\\"\\n            );\\n            Market(_marketAddress).listOnSale(\\n                tokenAddress,\\n                erc20Address,\\n                tokenId,\\n                msg.sender,\\n                price,\\n                1\\n            );\\n        } else if (\\n            IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)\\n        ) {\\n            require(\\n                IERC1155(tokenAddress).balanceOf(msg.sender, tokenId) >=\\n                    quantityOftoken,\\n                \\\"Media: Not enough NFTs available to sell\\\"\\n            );\\n            require(\\n                IERC1155(tokenAddress).isApprovedForAll(\\n                    msg.sender,\\n                    address(this)\\n                ),\\n                \\\"Media: NFT not approved to sell\\\"\\n            );\\n            Market(_marketAddress).listOnSale(\\n                tokenAddress,\\n                erc20Address,\\n                tokenId,\\n                msg.sender,\\n                price,\\n                quantityOftoken\\n            );\\n        } else {\\n            revert(\\\"Media: Invalid NFT address\\\");\\n        }\\n    }\\n\\n    function directBuy(\\n        address tokenAddress,\\n        uint256 id,\\n        address from,\\n        uint256 quantity,\\n        uint256 price,\\n        uint256 commission\\n    ) external payable {\\n        address creator = owner();\\n        Market.DirectBuyParams memory params = Market.DirectBuyParams({\\n            tokenAddress: tokenAddress,\\n            id: id,\\n            creator: creator,\\n            from: from,\\n            buyer: msg.sender,\\n            price: msg.value > 0 ? msg.value : price,\\n            quantity: quantity,\\n            commission: commission\\n        });\\n        if (IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)) {\\n            require(quantity == 1, \\\"Media: Invalid quantity provided\\\");\\n\\n            Market(_marketAddress).directBuy(params);\\n            IERC721(tokenAddress).safeTransferFrom(from, msg.sender, id);\\n        } else if (\\n            IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)\\n        ) {\\n            Market(_marketAddress).directBuy(params);\\n            IERC1155(tokenAddress).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                id,\\n                quantity,\\n                \\\"\\\"\\n            );\\n        } else {\\n            revert(\\\"Media: Invalid NFT address\\\");\\n        }\\n        _marketAddress.transfer(msg.value);\\n    }\\n\\n    function bulkBuy(\\n        address[] memory tokenAddresses,\\n        uint256[] memory ids,\\n        address[] memory fromAddresses,\\n        uint256[] memory quantities,\\n        uint256[] memory prices,\\n        uint256[] memory commissions,\\n        uint256 totalPrice\\n    ) external payable {\\n        require(\\n            tokenAddresses.length == ids.length &&\\n                ids.length == fromAddresses.length &&\\n                fromAddresses.length == quantities.length &&\\n                quantities.length == prices.length &&\\n                prices.length == commissions.length,\\n            \\\"Media: Arrays must be of equal length\\\"\\n        );\\n\\n        uint256 payablePrice;\\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\\n            Market.DirectBuyParams memory params = Market.DirectBuyParams({\\n                tokenAddress: tokenAddresses[i],\\n                id: ids[i],\\n                creator: owner(),\\n                from: fromAddresses[i],\\n                buyer: msg.sender,\\n                price: msg.value > 0 ? msg.value : prices[i],\\n                quantity: 1,\\n                commission: commissions[i]\\n            });\\n            if (\\n                IERC721(tokenAddresses[i]).supportsInterface(\\n                    INTERFACE_ID_ERC721\\n                )\\n            ) {\\n                require(\\n                    quantities[i] == 1,\\n                    \\\"Media: Invalid quantity for ERC721\\\"\\n                );\\n                payablePrice += Market(_marketAddress).directBuy(params);\\n\\n                IERC721(tokenAddresses[i]).safeTransferFrom(\\n                    fromAddresses[i],\\n                    msg.sender,\\n                    ids[i]\\n                );\\n            } else if (\\n                IERC1155(tokenAddresses[i]).supportsInterface(\\n                    INTERFACE_ID_ERC1155\\n                )\\n            ) {\\n                payablePrice += Market(_marketAddress).directBuy(params);\\n                IERC1155(tokenAddresses[i]).safeTransferFrom(\\n                    fromAddresses[i],\\n                    msg.sender,\\n                    ids[i],\\n                    quantities[i],\\n                    \\\"\\\"\\n                );\\n            } else {\\n                revert(\\\"Media: Invalid NFT address\\\");\\n            }\\n        }\\n        if (totalPrice == 0) {\\n            require(msg.value >= payablePrice, \\\"Media: Insufficient funds\\\");\\n            _marketAddress.transfer(msg.value);\\n        }\\n    }\\n\\n    function withdrawSale(address tokenAddress, uint256 id) external {\\n        Market(_marketAddress).withdrawSale(tokenAddress, id, msg.sender);\\n    }\\n\\n    function putOnAuction(\\n        address tokenAddress,\\n        address erc20Address,\\n        uint256 id,\\n        uint256 price,\\n        uint256 quantity,\\n        uint256 startTime,\\n        uint256 endTime\\n    ) external {\\n        require(\\n            tokenAddress != address(0),\\n            \\\"Media: Invalid NFT address provided\\\"\\n        );\\n        if (IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)) {\\n            require(\\n                IERC721(tokenAddress).ownerOf(id) == msg.sender,\\n                \\\"Media: You are not owner of this NFT\\\"\\n            );\\n            require(quantity == 1, \\\"Media: Invalid quantity provided\\\");\\n            Market(_marketAddress).putOnAuction(\\n                tokenAddress,\\n                erc20Address,\\n                id,\\n                msg.sender,\\n                price,\\n                1,\\n                startTime,\\n                endTime\\n            );\\n        } else if (\\n            IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)\\n        ) {\\n            require(\\n                IERC1155(tokenAddress).balanceOf(msg.sender, id) >= quantity,\\n                \\\"Media: Not enough NFTs available to sell\\\"\\n            );\\n            Market(_marketAddress).putOnAuction(\\n                tokenAddress,\\n                erc20Address,\\n                id,\\n                msg.sender,\\n                price,\\n                quantity,\\n                startTime,\\n                endTime\\n            );\\n        } else {\\n            revert(\\\"Media: Invalid NFT address\\\");\\n        }\\n    }\\n\\n    function bid(\\n        address tokenAddress,\\n        uint256 id,\\n        address from,\\n        uint256 bidValue\\n    ) external payable {\\n        Market(_marketAddress).bid(\\n            tokenAddress,\\n            id,\\n            from,\\n            msg.sender,\\n            msg.value > 0 ? msg.value : bidValue\\n        );\\n\\n        _marketAddress.transfer(msg.value);\\n    }\\n\\n    function acceptBid(\\n        address tokenAddress,\\n        uint256 id,\\n        address bidder,\\n        uint256 quantity,\\n        uint256 commission\\n    ) external {\\n        address creator = owner();\\n        if (IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)) {\\n            require(\\n                IERC721(tokenAddress).ownerOf(id) == msg.sender,\\n                \\\"Media: you are not the owner of the token\\\"\\n            );\\n            require(quantity == 1, \\\"Media: Invalid quantity provided\\\");\\n\\n            Market(_marketAddress).acceptBid(\\n                tokenAddress,\\n                id,\\n                creator,\\n                msg.sender,\\n                bidder,\\n                1,\\n                commission\\n            );\\n            IERC721(tokenAddress).safeTransferFrom(msg.sender, bidder, id);\\n        } else if (\\n            IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)\\n        ) {\\n            require(\\n                IERC1155(tokenAddress).balanceOf(msg.sender, id) >= quantity,\\n                \\\"Media: Not enough NFTs available to sell\\\"\\n            );\\n\\n            Market(_marketAddress).acceptBid(\\n                tokenAddress,\\n                id,\\n                creator,\\n                msg.sender,\\n                bidder,\\n                quantity,\\n                commission\\n            );\\n            IERC1155(tokenAddress).safeTransferFrom(\\n                msg.sender,\\n                bidder,\\n                id,\\n                quantity,\\n                \\\"\\\"\\n            );\\n        } else {\\n            revert(\\\"Media: invalid token address\\\");\\n        }\\n    }\\n\\n    function claim(\\n        address tokenAddress,\\n        uint256 id,\\n        address from,\\n        uint256 quantity,\\n        uint256 commission\\n    ) external {\\n        address creator = owner();\\n        Market.DirectBuyParams memory params = Market.DirectBuyParams({\\n            tokenAddress: tokenAddress,\\n            id: id,\\n            creator: creator,\\n            from: from,\\n            buyer: msg.sender,\\n            price: 0,\\n            quantity: quantity,\\n            commission: commission\\n        });\\n        require(\\n            tokenAddress != address(0),\\n            \\\"Media: Invalid NFT address provided\\\"\\n        );\\n\\n        require(quantity > 0, \\\"Media: Invalid quantity provided\\\");\\n\\n        if (IERC721(tokenAddress).supportsInterface(INTERFACE_ID_ERC721)) {\\n            require(\\n                IERC721(tokenAddress).ownerOf(id) == from,\\n                \\\"Media: from address in not valid\\\"\\n            );\\n            require(quantity == 1, \\\"Media: Invalid quantity provided\\\");\\n\\n            Market(_marketAddress).claim(params);\\n            IERC721(tokenAddress).safeTransferFrom(from, msg.sender, id);\\n        } else if (\\n            IERC1155(tokenAddress).supportsInterface(INTERFACE_ID_ERC1155)\\n        ) {\\n            require(\\n                IERC1155(tokenAddress).balanceOf(from, id) >= quantity,\\n                \\\"Media: owner does not have sufficient NFTs\\\"\\n            );\\n\\n            Market(_marketAddress).claim(params);\\n            IERC1155(tokenAddress).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                id,\\n                quantity,\\n                \\\"\\\"\\n            );\\n        } else {\\n            revert(\\\"Media: Invalid NFT address\\\");\\n        }\\n    }\\n\\n    function rejectBid(\\n        address tokenAddress,\\n        uint256 id,\\n        address bidder\\n    ) external {\\n        Market(_marketAddress).removeBid(tokenAddress, msg.sender, id, bidder);\\n    }\\n\\n    function withdrawBid(\\n        address tokenAddress,\\n        uint256 id,\\n        address from\\n    ) external {\\n        Market(_marketAddress).removeBid(tokenAddress, from, id, msg.sender);\\n    }\\n\\n    function withdrawAuction(address tokenAddress, uint256 id) external {\\n        Market(_marketAddress).withdrawAuction(tokenAddress, id, msg.sender);\\n    }\\n\\n    function redeem(address erc20Address, uint256 points) external {\\n        Market(_marketAddress).redeemPoints(msg.sender, erc20Address, points);\\n    }\\n\\n    function setCommission(uint256 _commission) external onlyOwner {\\n        Market(_marketAddress).setCommission(_commission);\\n    }\\n\\n    function setBurnPercentage(uint256 _commission) external onlyOwner {\\n        Market(_marketAddress).setBurnPercentage(_commission);\\n    }\\n\\n    function setRelayer(address _relayer) external onlyOwner {\\n        Market(_marketAddress).setRelayer(_relayer);\\n    }\\n\\n    function viewMyPoints(\\n        address erc20Address\\n    ) external view returns (uint256, uint256) {\\n        return Market(_marketAddress).viewPoints(msg.sender, erc20Address);\\n    }\\n\\n    function withdrawRoyalty(\\n        address erc20Address,\\n        address tokenAddress,\\n        uint256 tokenId\\n    ) external {\\n        Market(_marketAddress).withdrawRoyalty(\\n            erc20Address,\\n            tokenAddress,\\n            msg.sender,\\n            tokenId\\n        );\\n    }\\n\\n    function withdrawAllRoyalty(address erc20Address) external {\\n        Market(_marketAddress).withdrawAllRoyalty(erc20Address, msg.sender);\\n    }\\n\\n    function burnOmi(uint256 amount) external {\\n        Market(_marketAddress).burnOmi(amount, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OMI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\ncontract OMIToken is ERC20, ERC20Burnable {\\n    constructor() ERC20(\\\"OMIToken\\\", \\\"OMI\\\") {}\\n\\n    function mint(address to, uint256 amount) public {\\n        _mint(to, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidValue\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"fromAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"commissions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"name\":\"bulkBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnOmi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"name\":\"directBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"collaborator\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"percentage\",\"type\":\"uint256[]\"},{\"internalType\":\"uint96\",\"name\":\"royalty\",\"type\":\"uint96\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominee\",\"type\":\"address\"}],\"name\":\"nominateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"putOnAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantityOftoken\",\"type\":\"uint256\"}],\"name\":\"putOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"rejectBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"setBurnPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"setCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"viewMyPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"withdrawAllRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"withdrawBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Media", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008fa05ccc794bb6d2e6ccae80703c7a707314f7c7000000000000000000000000dbd4c0df20c63721161868f25527f2ee368f6aac", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}