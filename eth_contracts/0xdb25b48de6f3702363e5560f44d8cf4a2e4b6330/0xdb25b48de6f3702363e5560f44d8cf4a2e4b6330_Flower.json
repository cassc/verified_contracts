{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Flower.sol\": {\r\n      \"content\": \"/** FLOWER is a collection of 100.000 NFTs living on ethereum thanks to an implementation of multiple token standards: ERC20, ERC721, 1155.\\r\\n\\r\\n    https://twitter.com/FlowerERCX\\r\\n\\r\\n    https://t.me/FlowerERCX\\r\\n\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.24;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; \\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ninterface IERC20Errors {\\r\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\r\\n    error ERC20InvalidSender(address sender);\\r\\n    error ERC20InvalidReceiver(address receiver);\\r\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\r\\n    error ERC20InvalidApprover(address approver);\\r\\n    error ERC20InvalidSpender(address spender);\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length > 0) {\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERCX {\\r\\n\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    error BalanceQueryForZeroAddress();\\r\\n\\r\\n    error MintToZeroAddress();\\r\\n\\r\\n    error MintZeroQuantity();\\r\\n\\r\\n    error BurnFromZeroAddress();\\r\\n\\r\\n    error BurnFromNonOnwerAddress();\\r\\n\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    error TransferFromIncorrectOwnerOrInvalidAmount();\\r\\n\\r\\n    error TransferToNonERC1155ReceiverImplementer();\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    error InputLengthMistmatch();\\r\\n\\r\\n    function isOwnerOf(address account, uint256 id) external view returns(bool);\\r\\n}\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n\\r\\nabstract contract ERC721Receiver {\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external virtual returns (bytes4) {\\r\\n        return ERC721Receiver.onERC721Received.selector;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC1155 is IERC165 {\\r\\n\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IERC1155MetadataURI is IERC1155 {\\r\\n\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\\r\\nabstract contract ERC165 is IERC165 {\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary LibBit {\\r\\n\\r\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\r\\n\\r\\n        assembly {\\r\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\r\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\r\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\r\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\r\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\r\\n\\r\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\r\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\r\\n\\r\\n        assembly {\\r\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\r\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\r\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\r\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\r\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\r\\n\\r\\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\r\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\r\\n\\r\\n        assembly {\\r\\n\\r\\n            let b := and(x, add(not(x), 1))\\r\\n\\r\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\\r\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\r\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\r\\n\\r\\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\\r\\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\r\\n\\r\\n        assembly {\\r\\n            let max := not(0)\\r\\n            let isMax := eq(x, max)\\r\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\r\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\r\\n            x := and(add(x, shr(4, x)), div(max, 17))\\r\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\r\\n\\r\\n        assembly {\\r\\n\\r\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\r\\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\r\\n        uint256 m1 = m0 ^ (m0 << 2);\\r\\n        uint256 m2 = m1 ^ (m1 << 1);\\r\\n        r = reverseBytes(x);\\r\\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\\r\\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\\r\\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\\r\\n    }\\r\\n\\r\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\r\\n        unchecked {\\r\\n\\r\\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == 0) >> 192);\\r\\n            uint256 m1 = m0 ^ (m0 << 32);\\r\\n            uint256 m2 = m1 ^ (m1 << 16);\\r\\n            uint256 m3 = m2 ^ (m2 << 8);\\r\\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\\r\\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\\r\\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\\r\\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\\r\\n            r = (r >> 128) | (r << 128);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\\r\\n\\r\\n        assembly {\\r\\n            z := and(x, y)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function and(bool x, bool y) internal pure returns (bool z) {\\r\\n\\r\\n        assembly {\\r\\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\\r\\n\\r\\n        assembly {\\r\\n            z := or(x, y)\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function or(bool x, bool y) internal pure returns (bool z) {\\r\\n\\r\\n        assembly {\\r\\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function rawToUint(bool b) internal pure returns (uint256 z) {\\r\\n\\r\\n        assembly {\\r\\n            z := b\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint(bool b) internal pure returns (uint256 z) {\\r\\n\\r\\n        assembly {\\r\\n            z := iszero(iszero(b))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary LibBitmap {\\r\\n\\r\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\r\\n\\r\\n    struct Bitmap {\\r\\n        mapping(uint256 => uint256) map;\\r\\n    }\\r\\n\\r\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\r\\n\\r\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\r\\n\\r\\n        assembly {\\r\\n            isSet := b\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\r\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\r\\n    }\\r\\n\\r\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\r\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\r\\n    }\\r\\n\\r\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\r\\n\\r\\n        assembly {\\r\\n            mstore(0x20, bitmap.slot)\\r\\n            mstore(0x00, shr(8, index))\\r\\n            let storageSlot := keccak256(0x00, 0x40)\\r\\n            let shift := and(index, 0xff)\\r\\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\\r\\n\\r\\n            newIsSet := and(1, shr(shift, storageValue))\\r\\n            sstore(storageSlot, storageValue)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\r\\n\\r\\n        assembly {\\r\\n            mstore(0x20, bitmap.slot)\\r\\n            mstore(0x00, shr(8, index))\\r\\n            let storageSlot := keccak256(0x00, 0x40)\\r\\n            let storageValue := sload(storageSlot)\\r\\n            let shift := and(index, 0xff)\\r\\n            sstore(\\r\\n                storageSlot,\\r\\n\\r\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\r\\n\\r\\n        assembly {\\r\\n            let max := not(0)\\r\\n            let shift := and(start, 0xff)\\r\\n            mstore(0x20, bitmap.slot)\\r\\n            mstore(0x00, shr(8, start))\\r\\n            if iszero(lt(add(shift, amount), 257)) {\\r\\n                let storageSlot := keccak256(0x00, 0x40)\\r\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\r\\n                let bucket := add(mload(0x00), 1)\\r\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\r\\n                amount := and(add(amount, shift), 0xff)\\r\\n                shift := 0\\r\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\r\\n                    mstore(0x00, bucket)\\r\\n                    sstore(keccak256(0x00, 0x40), max)\\r\\n                }\\r\\n                mstore(0x00, bucket)\\r\\n            }\\r\\n            let storageSlot := keccak256(0x00, 0x40)\\r\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\r\\n\\r\\n        assembly {\\r\\n            let shift := and(start, 0xff)\\r\\n            mstore(0x20, bitmap.slot)\\r\\n            mstore(0x00, shr(8, start))\\r\\n            if iszero(lt(add(shift, amount), 257)) {\\r\\n                let storageSlot := keccak256(0x00, 0x40)\\r\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\r\\n                let bucket := add(mload(0x00), 1)\\r\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\r\\n                amount := and(add(amount, shift), 0xff)\\r\\n                shift := 0\\r\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\r\\n                    mstore(0x00, bucket)\\r\\n                    sstore(keccak256(0x00, 0x40), 0)\\r\\n                }\\r\\n                mstore(0x00, bucket)\\r\\n            }\\r\\n            let storageSlot := keccak256(0x00, 0x40)\\r\\n            sstore(\\r\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 count)\\r\\n    {\\r\\n        unchecked {\\r\\n            uint256 bucket = start >> 8;\\r\\n            uint256 shift = start & 0xff;\\r\\n            if (!(amount + shift < 257)) {\\r\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\r\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\r\\n                amount = (amount + shift) & 0xff;\\r\\n                shift = 0;\\r\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\r\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\r\\n                }\\r\\n            }\\r\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 setBitIndex)\\r\\n    {\\r\\n        uint256 bucket;\\r\\n        uint256 bucketBits;\\r\\n\\r\\n        assembly {\\r\\n            setBitIndex := not(0)\\r\\n            bucket := shr(8, before)\\r\\n            mstore(0x00, bucket)\\r\\n            mstore(0x20, bitmap.slot)\\r\\n            let offset := and(0xff, not(before)) \\r\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\r\\n            if iszero(or(bucketBits, iszero(bucket))) {\\r\\n                for {} 1 {} {\\r\\n                    bucket := add(bucket, setBitIndex)\\r\\n                    mstore(0x00, bucket)\\r\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\r\\n                    if or(bucketBits, iszero(bucket)) { break }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (bucketBits != 0) {\\r\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\r\\n\\r\\n            assembly {\\r\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ERCX is Context, ERC165, IERC1155, IERC1155MetadataURI, IERCX, IERC20Metadata, IERC20Errors, Ownable {\\r\\n\\r\\n    using Address for address;\\r\\n    using LibBitmap for LibBitmap.Bitmap;\\r\\n\\r\\n    error InvalidQueryRange();\\r\\n\\r\\n\\r\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\r\\n\\r\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    mapping(address => LibBitmap.Bitmap) internal _owned;\\r\\n    \\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    string private _uri;\\r\\n\\r\\n    uint256 private _currentIndex;\\r\\n\\r\\n    mapping(uint256 => address) public getApproved;\\r\\n\\r\\n    mapping(address => uint256) internal _balances;\\r\\n\\r\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    uint256 public immutable totalSupply;\\r\\n\\r\\n    uint256 public immutable decimalFactor;\\r\\n    uint256 public immutable tokensPerNFT;\\r\\n\\r\\n    mapping(address => bool) public whitelist;\\r\\n\\r\\n    uint256 public easyLaunch = 1;\\r\\n\\r\\n    constructor(string memory uri_, string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalNativeSupply, uint256 _tokensPerNFT) Ownable(msg.sender) {\\r\\n        _setURI(uri_);\\r\\n        _currentIndex = _startTokenId();\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n        decimalFactor = 10 ** decimals;\\r\\n        tokensPerNFT = _tokensPerNFT * decimalFactor;\\r\\n        totalSupply = _totalNativeSupply * decimalFactor;\\r\\n        whitelist[msg.sender] = true;\\r\\n        _balances[msg.sender] = totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, totalSupply);\\r\\n    }\\r\\n\\r\\n    function setWhitelist(address target, bool state) public virtual onlyOwner {\\r\\n        whitelist[target] = state;\\r\\n    }\\r\\n\\r\\n    function _startTokenId() internal pure virtual returns (uint256) {\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    function _nextTokenId() internal view returns (uint256) {\\r\\n        return _currentIndex;\\r\\n    }\\r\\n\\r\\n    function _totalMinted() internal view returns (uint256) {\\r\\n        return _nextTokenId() - _startTokenId();\\r\\n    }\\r\\n\\r\\n    function isOwnerOf(address account, uint256 id) public view virtual override returns(bool) {\\r\\n        return _owned[account].get(id);\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC1155).interfaceId ||\\r\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\r\\n            interfaceId == type(IERCX).interfaceId ||\\r\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\r\\n            interfaceId == 0x5b5e139f || // ERC165 interface ID for ERC721Metadata.\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function uri(uint256) public view virtual override returns (string memory) {\\r\\n        return _uri;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\r\\n        return _balances[owner];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address owner, uint256 start, uint256 stop) public view virtual returns (uint256) {\\r\\n        return _owned[owner].popCount(start, stop - start);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\r\\n        if(account == address(0)) {\\r\\n            revert BalanceQueryForZeroAddress();\\r\\n        }\\r\\n        if(_owned[account].get(id)) {\\r\\n            return 1;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }   \\r\\n    }\\r\\n\\r\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        if(accounts.length != ids.length) {\\r\\n            revert InputLengthMistmatch();\\r\\n        }\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        if(from == _msgSender() || isApprovedForAll(from, _msgSender())){\\r\\n            _safeTransferFrom(from, to, id, amount, data, true);\\r\\n        } else {\\r\\n            revert TransferCallerNotOwnerNorApproved();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        if(!(from == _msgSender() || isApprovedForAll(from, _msgSender()))) {\\r\\n            revert TransferCallerNotOwnerNorApproved();\\r\\n        }\\r\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    function _safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bool check\\r\\n    ) internal virtual {\\r\\n        if(to == address(0)) {\\r\\n            revert TransferToZeroAddress();\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids);\\r\\n\\r\\n        if(amount == 1 && _owned[from].get(id)) {\\r\\n            _owned[from].unset(id);\\r\\n            _owned[to].set(id);\\r\\n            _transfer(from, to, tokensPerNFT, false);\\r\\n        } else {\\r\\n            revert TransferFromIncorrectOwnerOrInvalidAmount();\\r\\n        }\\r\\n\\r\\n        uint256 toMasked;\\r\\n        uint256 fromMasked;\\r\\n        assembly {\\r\\n            toMasked := and(to, _BITMASK_ADDRESS)\\r\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\r\\n            log4(\\r\\n                0, \\r\\n                0, \\r\\n                _TRANSFER_EVENT_SIGNATURE, \\r\\n                fromMasked, \\r\\n                toMasked, \\r\\n                amount \\r\\n            )\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids);\\r\\n\\r\\n        if(check)\\r\\n            _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    function _safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        if(ids.length != amounts.length) {\\r\\n            revert InputLengthMistmatch();\\r\\n        }\\r\\n\\r\\n        if(to == address(0)) {\\r\\n            revert TransferToZeroAddress();\\r\\n        }\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids);\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            if(amount == 1 && _owned[from].get(id)) {\\r\\n                _owned[from].unset(id);\\r\\n                _owned[to].set(id);\\r\\n            } else {\\r\\n                revert TransferFromIncorrectOwnerOrInvalidAmount();\\r\\n            }\\r\\n        }\\r\\n        _transfer(from, to, tokensPerNFT * ids.length, false);\\r\\n\\r\\n        uint256 toMasked;\\r\\n        uint256 fromMasked;\\r\\n        uint256 end = ids.length + 1;\\r\\n\\r\\n        assembly {\\r\\n\\r\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\r\\n            toMasked := and(to, _BITMASK_ADDRESS)\\r\\n\\r\\n            log4(\\r\\n                0, \\r\\n                0, \\r\\n                _TRANSFER_EVENT_SIGNATURE, \\r\\n                fromMasked, \\r\\n                toMasked, \\r\\n                mload(add(ids, 0x20)) \\r\\n            )\\r\\n\\r\\n            for {\\r\\n                let arrayId := 2\\r\\n            } iszero(eq(arrayId, end)) {\\r\\n                arrayId := add(arrayId, 1)\\r\\n            } {\\r\\n\\r\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, toMasked, mload(add(ids, mul(0x20, arrayId))))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    function _setURI(string memory newuri) internal virtual {\\r\\n        _uri = newuri;\\r\\n    }\\r\\n\\r\\n    function _mint(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        _mint(to, amount, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function _mint(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n       (uint256[] memory ids, uint256[] memory amounts) =  _mintWithoutCheck(to, amount);\\r\\n\\r\\n        uint256 end = _currentIndex;\\r\\n        _doSafeBatchTransferAcceptanceCheck(_msgSender(), address(0), to, ids, amounts, data);\\r\\n        if (_currentIndex != end) revert();\\r\\n    }\\r\\n\\r\\n    function _mintWithoutCheck(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual returns(uint256[] memory ids, uint256[] memory amounts) {\\r\\n\\r\\n        if(to == address(0)) {\\r\\n            revert MintToZeroAddress();\\r\\n        }\\r\\n        if(amount == 0) {\\r\\n            revert MintZeroQuantity();\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        ids = new uint256[](amount);\\r\\n        amounts = new uint256[](amount);\\r\\n        uint256 startTokenId = _nextTokenId();\\r\\n\\r\\n        unchecked {\\r\\n            require(type(uint256).max - amount >= startTokenId);\\r\\n            for(uint256 i = 0; i < amount; i++) {\\r\\n                ids[i] = startTokenId + i;\\r\\n                amounts[i] = 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        _beforeTokenTransfer(operator, address(0), to, ids);\\r\\n\\r\\n        _owned[to].setBatch(startTokenId, amount);\\r\\n        _currentIndex += amount;\\r\\n\\r\\n        uint256 toMasked;\\r\\n        uint256 end = startTokenId + amount;\\r\\n\\r\\n        assembly {\\r\\n            toMasked := and(to, _BITMASK_ADDRESS)\\r\\n            log4(\\r\\n                0,\\r\\n                0,\\r\\n                _TRANSFER_EVENT_SIGNATURE,\\r\\n                0,\\r\\n                toMasked,\\r\\n                startTokenId\\r\\n            )\\r\\n\\r\\n            for {\\r\\n                let tokenId := add(startTokenId, 1)\\r\\n            } iszero(eq(tokenId, end)) {\\r\\n                tokenId := add(tokenId, 1)\\r\\n            } {\\r\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, address(0), to, ids);\\r\\n\\r\\n    }\\r\\n\\r\\n    function _burn(\\r\\n        address from,\\r\\n        uint256 id\\r\\n    ) internal virtual {\\r\\n        if(from == address(0)){\\r\\n            revert BurnFromZeroAddress();\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\r\\n\\r\\n        if(!_owned[from].get(id)) {\\r\\n            revert BurnFromNonOnwerAddress();\\r\\n        }\\r\\n\\r\\n        _owned[from].unset(id);\\r\\n\\r\\n        uint256 fromMasked;\\r\\n        assembly {\\r\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\r\\n            log4(\\r\\n                0,\\r\\n                0,\\r\\n                _TRANSFER_EVENT_SIGNATURE,\\r\\n                fromMasked,\\r\\n                0,\\r\\n                id\\r\\n            )\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, address(0), id, 1);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids);\\r\\n    }\\r\\n\\r\\n    function _burnBatch(\\r\\n        address from,\\r\\n        uint256[] memory ids\\r\\n    ) internal virtual {\\r\\n        if(from == address(0)){\\r\\n            revert BurnFromZeroAddress();\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        uint256[] memory amounts = new uint256[](ids.length);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\r\\n\\r\\n        unchecked {\\r\\n            for(uint256 i = 0; i < ids.length; i++) {\\r\\n                amounts[i] = 1;\\r\\n                uint256 id = ids[i];\\r\\n                if(!_owned[from].get(id)) {\\r\\n                    revert BurnFromNonOnwerAddress();\\r\\n                }\\r\\n                _owned[from].unset(id);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 fromMasked;\\r\\n        uint256 end = ids.length + 1;\\r\\n\\r\\n        assembly {\\r\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\r\\n            log4(\\r\\n                0,\\r\\n                0,\\r\\n                _TRANSFER_EVENT_SIGNATURE,\\r\\n                fromMasked,\\r\\n                0,\\r\\n                mload(add(ids, 0x20))\\r\\n            )\\r\\n\\r\\n            for {\\r\\n                let arrayId := 2\\r\\n            } iszero(eq(arrayId, end)) {\\r\\n                arrayId := add(arrayId, 1)\\r\\n            } {\\r\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids);\\r\\n\\r\\n    }\\r\\n\\r\\n    function _burnBatch(\\r\\n        address from,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        if(from == address(0)){\\r\\n            revert BurnFromZeroAddress();\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        uint256 searchFrom = _nextTokenId();\\r\\n\\r\\n        uint256[] memory amounts = new uint256[](amount);\\r\\n        uint256[] memory ids = new uint256[](amount);\\r\\n\\r\\n        unchecked {\\r\\n            for(uint256 i = 0; i < amount; i++) {\\r\\n                amounts[i] = 1;\\r\\n                uint256 id = _owned[from].findLastSet(searchFrom);\\r\\n                ids[i] = id;\\r\\n                _owned[from].unset(id);\\r\\n                searchFrom = id;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids);\\r\\n\\r\\n        uint256 fromMasked;\\r\\n        uint256 end = amount + 1;\\r\\n\\r\\n        assembly {\\r\\n            fromMasked := and(from, _BITMASK_ADDRESS)\\r\\n            log4(\\r\\n                0,\\r\\n                0,\\r\\n                _TRANSFER_EVENT_SIGNATURE,\\r\\n                fromMasked,\\r\\n                0,\\r\\n                mload(add(ids, 0x20))\\r\\n            )\\r\\n\\r\\n            for {\\r\\n                let arrayId := 2\\r\\n            } iszero(eq(arrayId, end)) {\\r\\n                arrayId := add(arrayId, 1)\\r\\n            } {\\r\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(amount == 1)\\r\\n            emit TransferSingle(operator, from, address(0), ids[0], 1);\\r\\n        else\\r\\n            emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n        \\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids);\\r\\n\\r\\n    }\\r\\n\\r\\n    function _setApprovalForAll(\\r\\n        address owner,\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) internal virtual {\\r\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            if (IERC165(to).supportsInterface(type(IERC1155).interfaceId)) {\\r\\n                try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                    if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                        revert TransferToNonERC1155ReceiverImplementer();\\r\\n                    }\\r\\n                } catch Error(string memory reason) {\\r\\n                    revert(reason);\\r\\n                } catch {\\r\\n                    revert TransferToNonERC1155ReceiverImplementer();\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                try ERC721Receiver(to).onERC721Received(operator, from, id, data) returns (bytes4 response) {\\r\\n                    if (response != ERC721Receiver.onERC721Received.selector) {\\r\\n                        revert TransferToNonERC721ReceiverImplementer();\\r\\n                    }\\r\\n                } catch Error(string memory reason) {\\r\\n                    revert(reason);\\r\\n                } catch {\\r\\n                    revert TransferToNonERC721ReceiverImplementer();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert TransferToNonERC1155ReceiverImplementer();\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert TransferToNonERC1155ReceiverImplementer();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory array) {\\r\\n        array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\r\\n        address owner = msg.sender;\\r\\n        _transfer(owner, to, value, true);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\r\\n        address owner = msg.sender;\\r\\n        if (value < _nextTokenId() && value > 0) {\\r\\n\\r\\n            if(!isOwnerOf(owner, value)) {\\r\\n                revert ERC20InvalidSender(owner);\\r\\n            }\\r\\n\\r\\n            getApproved[value] = spender;\\r\\n\\r\\n            emit Approval(owner, spender, value);\\r\\n        } else {\\r\\n            _approve(owner, spender, value);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\r\\n        if (value < _nextTokenId()) {\\r\\n            if(!_owned[from].get(value)) {\\r\\n                revert ERC20InvalidSpender(from);\\r\\n            }    \\r\\n\\r\\n            if (\\r\\n                msg.sender != from &&\\r\\n                !isApprovedForAll(from, msg.sender) &&\\r\\n                msg.sender != getApproved[value]\\r\\n            ) {\\r\\n                revert ERC20InvalidSpender(msg.sender);\\r\\n            }\\r\\n\\r\\n            _transfer(from, to, tokensPerNFT, false);\\r\\n\\r\\n            delete getApproved[value];\\r\\n\\r\\n            _safeTransferFrom(from, to, value, 1, \\\"\\\", false);\\r\\n\\r\\n        } else {\\r\\n            _spendAllowance(from, msg.sender, value);\\r\\n            _transfer(from, to, value, true);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 value, bool mint) internal {\\r\\n        if (from == address(0)) {\\r\\n            revert ERC20InvalidSender(address(0));\\r\\n        }\\r\\n        if (to == address(0)) {\\r\\n            revert ERC20InvalidReceiver(address(0));\\r\\n        }\\r\\n        _update(from, to, value, mint);\\r\\n    }\\r\\n\\r\\n    function _update(address from, address to, uint256 value, bool mint) internal virtual {\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        uint256 toBalance = _balances[to];\\r\\n        if (fromBalance < value) {\\r\\n            revert ERC20InsufficientBalance(from, fromBalance, value);\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n\\r\\n            _balances[from] = fromBalance - value;\\r\\n\\r\\n            _balances[to] = toBalance + value;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, value);\\r\\n\\r\\n        if(mint) {\\r\\n\\r\\n            bool wlf = whitelist[from];\\r\\n            if (!wlf) {\\r\\n                uint256 tokens_to_burn = (fromBalance / tokensPerNFT) - ((fromBalance - value) / tokensPerNFT);\\r\\n                if(tokens_to_burn > 0)\\r\\n                    _burnBatch(from, tokens_to_burn);\\r\\n            }\\r\\n\\r\\n            if (!whitelist[to]) {\\r\\n                if(easyLaunch == 1 && wlf && from == owner()) {\\r\\n\\r\\n                    whitelist[to] = true;\\r\\n                    easyLaunch = 2;\\r\\n                } else {\\r\\n                    uint256 tokens_to_mint = ((toBalance + value) / tokensPerNFT) - (toBalance / tokensPerNFT);\\r\\n                    if(tokens_to_mint > 0)\\r\\n                        _mintWithoutCheck(to, tokens_to_mint);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        _approve(owner, spender, value, true);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\r\\n        if (owner == address(0)) {\\r\\n            revert ERC20InvalidApprover(address(0));\\r\\n        }\\r\\n        if (spender == address(0)) {\\r\\n            revert ERC20InvalidSpender(address(0));\\r\\n        }\\r\\n        _allowances[owner][spender] = value;\\r\\n        if (emitEvent) {\\r\\n            emit Approval(owner, spender, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            if (currentAllowance < value) {\\r\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\r\\n            }\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - value, false);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tokensOfOwnerIn(\\r\\n        address owner,\\r\\n        uint256 start,\\r\\n        uint256 stop\\r\\n    ) public view virtual returns (uint256[] memory) {\\r\\n        unchecked {\\r\\n            if (start >= stop) revert InvalidQueryRange();\\r\\n\\r\\n            if (start < _startTokenId()) {\\r\\n                start = _startTokenId();\\r\\n            }\\r\\n\\r\\n            uint256 stopLimit = _nextTokenId();\\r\\n            if (stop > stopLimit) {\\r\\n                stop = stopLimit;\\r\\n            }\\r\\n\\r\\n            uint256 tokenIdsLength;\\r\\n            if(start < stop) {\\r\\n                tokenIdsLength = balanceOf(owner, start, stop);\\r\\n            } else {\\r\\n                tokenIdsLength = 0;\\r\\n            }\\r\\n            \\r\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\r\\n\\r\\n            LibBitmap.Bitmap storage bmap = _owned[owner];\\r\\n            \\r\\n            for ((uint256 i, uint256 tokenIdsIdx) = (start, 0); tokenIdsIdx != tokenIdsLength; ++i) {\\r\\n                if(bmap.get(i) ) {\\r\\n                    tokenIds[tokenIdsIdx++] = i;\\r\\n                }\\r\\n            }\\r\\n            return tokenIds;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tokensOfOwner(address owner) public view virtual returns (uint256[] memory) {\\r\\n        if(_totalMinted() == 0) {\\r\\n            return new uint256[](0);\\r\\n        }\\r\\n        return tokensOfOwnerIn(owner, _startTokenId(), _nextTokenId());\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Flower is ERCX {\\r\\n    using Strings for uint256;\\r\\n    string public dataURI;\\r\\n    string public baseTokenURI;\\r\\n    \\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint256 private constant _totalTokens = 100000;\\r\\n    uint256 private constant _tokensPerNFT = 1;\\r\\n    string private constant _name = \\\"FLOWER\\\";\\r\\n    string private constant _ticker = \\\"FLOWER\\\";\\r\\n\\r\\n    uint256 public maxWallet;\\r\\n    bool public transferDelay = false;\\r\\n    mapping (address => uint256) private delayTimer;\\r\\n\\r\\n    constructor() ERCX(\\\"\\\", _name, _ticker, _decimals, _totalTokens, _tokensPerNFT) {\\r\\n        dataURI = \\\"https://i.ibb.co/\\\";\\r\\n        maxWallet = (_totalTokens * 10 ** _decimals) * 2 / 100;\\r\\n    }\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids\\r\\n    ) internal override {\\r\\n        if(!whitelist[to]) {\\r\\n            require(_balances[to] <= maxWallet, \\\"Transfer exceeds maximum wallet\\\");\\r\\n            if (transferDelay) {\\r\\n                require(delayTimer[tx.origin] < block.number,\\\"Only one transfer per block allowed.\\\");\\r\\n                delayTimer[tx.origin] = block.number;\\r\\n\\r\\n                require(address(to).code.length == 0 && address(tx.origin).code.length == 0, \\\"Contract trading restricted at launch\\\");\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        \\r\\n        super._afterTokenTransfer(operator, from, to, ids);\\r\\n    }\\r\\n\\r\\n    function toggleDelay() external onlyOwner {\\r\\n        transferDelay = !transferDelay;\\r\\n    }\\r\\n\\r\\n    function setMaxWallet(uint256 percent) external onlyOwner {\\r\\n        maxWallet = totalSupply * percent / 100;\\r\\n    }\\r\\n\\r\\n    function setDataURI(string memory _dataURI) public onlyOwner {\\r\\n        dataURI = _dataURI;\\r\\n    }\\r\\n\\r\\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\\r\\n        baseTokenURI = _tokenURI;\\r\\n    }\\r\\n\\r\\n    function setURI(string memory newuri) external onlyOwner {\\r\\n        _setURI(newuri);\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 id) public view returns (string memory) {\\r\\n        if(id >= _nextTokenId()) revert InputLengthMistmatch();\\r\\n\\r\\n        if (bytes(super.uri(id)).length > 0)\\r\\n            return super.uri(id);\\r\\n        if (bytes(baseTokenURI).length > 0)\\r\\n            return string(abi.encodePacked(baseTokenURI, id.toString()));\\r\\n        else {\\r\\n            uint8 seed = uint8(bytes1(keccak256(abi.encodePacked(id))));\\r\\n\\r\\n            string memory image;\\r\\n            string memory color;\\r\\n            string memory description;\\r\\n\\r\\n            if (seed <= 63) {\\r\\n                image = \\\"pxMZ1jF/Nexopetal.gif\\\";\\r\\n                color = \\\"Nexopetal\\\";\\r\\n                description = \\\"Nexopetal NFTs by Flowers 404 Collection. FLOWER is a collection of 100.000 NFTs living on ethereum thanks to an implementation of multiple token standards: ERC20, ERC721, 1155.\\\";\\r\\n            } else if (seed <= 127) {\\r\\n                image = \\\"hD4JH0T/Astraliris.gif\\\";\\r\\n                color = \\\"Astraliris\\\";\\r\\n                description = \\\"Astraliris NFTs by Flowers 404 Collection. FLOWER is a collection of 100.000 NFTs living on ethereum thanks to an implementation of multiple token standards: ERC20, ERC721, 1155.\\\";\\r\\n            } else if (seed <= 191) {\\r\\n                image = \\\"VSXR8n4/Nebulium.gif\\\";\\r\\n                color = \\\"Nebulium\\\";\\r\\n                description = \\\"Nebulium NFTs by Flowers 404 Collection. FLOWER is a collection of 100.000 NFTs living on ethereum thanks to an implementation of multiple token standards: ERC20, ERC721, 1155.\\\";\\r\\n            } else if (seed <= 255) {\\r\\n                image = \\\"CHhp2CC/Luminaflora.gif\\\";\\r\\n                color = \\\"Luminaflora\\\";\\r\\n                description = \\\"Luminaflora NFTs by Flowers 404 Collection. FLOWER is a collection of 100.000 NFTs living on ethereum thanks to an implementation of multiple token standards: ERC20, ERC721, 1155.\\\";\\r\\n            }\\r\\n\\r\\n            string memory jsonPreImage = string(abi.encodePacked('{\\\"name\\\": \\\"FLOWER #', id.toString(), '\\\",\\\"description\\\":\\\"', description, '\\\",\\\"external_url\\\":\\\"https://t.me/FlowerERCX\\\",\\\"image\\\":\\\"', dataURI, image));\\r\\n            return string(abi.encodePacked(\\\"data:application/json;utf8,\\\", jsonPreImage, '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Color\\\",\\\"value\\\":\\\"', color, '\\\"}]}'));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uri(uint256 id) public view override returns (string memory) {\\r\\n        return tokenURI(id);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromNonOnwerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InputLengthMistmatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwnerOrInvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimalFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"easyLaunch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOwnerOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataURI\",\"type\":\"string\"}],\"name\":\"setDataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newuri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Flower", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}