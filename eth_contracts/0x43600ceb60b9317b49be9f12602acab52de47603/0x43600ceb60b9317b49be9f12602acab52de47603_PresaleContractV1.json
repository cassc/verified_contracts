{"SourceCode": "// File: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Storage of the initializable contract.\r\n     *\r\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\r\n     * when using with upgradeable contracts.\r\n     *\r\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\r\n     */\r\n    struct InitializableStorage {\r\n        /**\r\n         * @dev Indicates that the contract has been initialized.\r\n         */\r\n        uint64 _initialized;\r\n        /**\r\n         * @dev Indicates that the contract is in the process of being initialized.\r\n         */\r\n        bool _initializing;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\r\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\r\n\r\n    /**\r\n     * @dev The contract is already initialized.\r\n     */\r\n    error InvalidInitialization();\r\n\r\n    /**\r\n     * @dev The contract is not initializing.\r\n     */\r\n    error NotInitializing();\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint64 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\r\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\r\n     * production.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        // Cache values to avoid duplicated sloads\r\n        bool isTopLevelCall = !$._initializing;\r\n        uint64 initialized = $._initialized;\r\n\r\n        // Allowed calls:\r\n        // - initialSetup: the contract is not in the initializing state and no previous version was\r\n        //                 initialized\r\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\r\n        //                 current contract is just being deployed\r\n        bool initialSetup = initialized == 0 && isTopLevelCall;\r\n        bool construction = initialized == 1 && address(this).code.length == 0;\r\n\r\n        if (!initialSetup && !construction) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = 1;\r\n        if (isTopLevelCall) {\r\n            $._initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            $._initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint64 version) {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing || $._initialized >= version) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = version;\r\n        $._initializing = true;\r\n        _;\r\n        $._initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        _checkInitializing();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\r\n     */\r\n    function _checkInitializing() internal view virtual {\r\n        if (!_isInitializing()) {\r\n            revert NotInitializing();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing) {\r\n            revert InvalidInitialization();\r\n        }\r\n        if ($._initialized != type(uint64).max) {\r\n            $._initialized = type(uint64).max;\r\n            emit Initialized(type(uint64).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint64) {\r\n        return _getInitializableStorage()._initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _getInitializableStorage()._initializing;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a pointer to the storage namespace.\r\n     */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\r\n        assembly {\r\n            $.slot := INITIALIZABLE_STORAGE\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    function __Pausable_init() internal onlyInitializing {\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    function __Pausable_init_unchained() internal onlyInitializing {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\r\n    struct OwnableStorage {\r\n        address _owner;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\r\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\r\n\r\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\r\n        assembly {\r\n            $.slot := OwnableStorageLocation\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\r\n        __Ownable_init_unchained(initialOwner);\r\n    }\r\n\r\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        OwnableStorage storage $ = _getOwnableStorage();\r\n        return $._owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        OwnableStorage storage $ = _getOwnableStorage();\r\n        address oldOwner = $._owner;\r\n        $._owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuardUpgradeable is Initializable {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    function __ReentrancyGuard_init() internal onlyInitializing {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: contracts/PresaleContractV1.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n//Game2Fi Crypto Coin Persale Contract Ver1.0.0\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n\r\ninterface Aggregator {\r\n  function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\ninterface StakingManager {\r\n  function depositByPresale(address _user, uint256 _amount) external;\r\n}\r\n\r\ncontract PresaleContractV1 is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable {\r\n  uint256 public totalTokensSold;\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  uint256 public claimStart;\r\n  address public saleToken;\r\n  uint256 public baseDecimals;\r\n  uint256 public maxTokensToBuy;\r\n  uint256 public currentStep;\r\n  uint256 public checkPoint;\r\n  uint256 public usdRaised;\r\n  uint256 public timeConstant;\r\n  uint256 public totalBoughtAndStaked;\r\n  uint256[][3] public rounds;\r\n  uint256[] public prevCheckpoints;\r\n  uint256[] public remainingTokensTracker;\r\n  uint256[] public percentages;\r\n  address[] public wallets;\r\n  address public paymentWallet;\r\n  address public privateSaleWallet;\r\n  address public admin;\r\n  bool public dynamicTimeFlag;\r\n  bool public whitelistClaimOnly;\r\n  bool public stakeingWhitelistStatus;\r\n\r\n  IERC20Upgradeable public USDTInterface;\r\n  Aggregator public aggregatorInterface;\r\n  mapping(address => uint256) public userDeposits;\r\n  mapping(address => bool) public hasClaimed;\r\n  mapping(address => bool) public isBlacklisted;\r\n  mapping(address => bool) public isWhitelisted;\r\n  mapping(address => bool) public wertWhitelisted;\r\n\r\n  StakingManager public stakingManagerInterface;\r\n\r\n  event SaleTimeSet(uint256 _start, uint256 _end, uint256 timestamp);\r\n  event SaleTimeUpdated(bytes32 indexed key, uint256 prevValue, uint256 newValue, uint256 timestamp);\r\n  event TokensBought(address indexed user, uint256 indexed tokensBought, address indexed purchaseToken, uint256 amountPaid, uint256 usdEq, uint256 timestamp);\r\n  event TokensAdded(address indexed token, uint256 noOfTokens, uint256 timestamp);\r\n  event TokensClaimed(address indexed user, uint256 amount, uint256 timestamp);\r\n  event ClaimStartUpdated(uint256 prevValue, uint256 newValue, uint256 timestamp);\r\n  event MaxTokensUpdated(uint256 prevValue, uint256 newValue, uint256 timestamp);\r\n  event TokensBoughtAndStaked(address indexed user, uint256 indexed tokensBought, address indexed purchaseToken, uint256 amountPaid, uint256 usdEq, uint256 timestamp);\r\n  event TokensClaimedAndStaked(address indexed user, uint256 amount, uint256 timestamp);\r\n\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() initializer {}\r\n\r\n  /**\r\n   * @dev Initializes the contract and sets key parameters\r\n   * @param _oracle Oracle contract to fetch ETH/USDT price\r\n   * @param _usdt USDT token contract address\r\n   * @param _startTime start time of the presale\r\n   * @param _endTime end time of the presale\r\n   * @param _rounds array of round details\r\n   * @param _maxTokensToBuy amount of max tokens to buy\r\n   * @param _paymentWallet address to recive payments\r\n   */\r\n  function initialize(address _oracle, address _usdt, uint256 _startTime, uint256 _endTime, uint256[][3] memory _rounds, uint256 _maxTokensToBuy, address _paymentWallet) external initializer {\r\n    require(_oracle != address(0), \"Zero aggregator address\");\r\n    require(_usdt != address(0), \"Zero USDT address\");\r\n    require(_startTime > block.timestamp && _endTime > _startTime, \"Invalid time\");\r\n    __Pausable_init_unchained();\r\n    __Ownable_init(msg.sender);\r\n    __ReentrancyGuard_init_unchained();\r\n    baseDecimals = (10 ** 18);\r\n    aggregatorInterface = Aggregator(_oracle);\r\n    USDTInterface = IERC20Upgradeable(_usdt);\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    rounds = _rounds;\r\n    maxTokensToBuy = _maxTokensToBuy;\r\n    paymentWallet = _paymentWallet;\r\n    emit SaleTimeSet(startTime, endTime, block.timestamp);\r\n  }\r\n\r\n  /**\r\n   * @dev To pause the presale\r\n   */\r\n  function pause() external onlyOwner {\r\n    _pause();\r\n  }\r\n\r\n  /**\r\n   * @dev To unpause the presale\r\n   */\r\n  function unpause() external onlyOwner {\r\n    _unpause();\r\n  }\r\n\r\n  /**\r\n   * @dev To calculate the price in USD for given amount of tokens.\r\n   * @param _amount No of tokens\r\n   */\r\n  function calculatePrice(uint256 _amount) public view returns (uint256) {\r\n    uint256 USDTAmount;\r\n    uint256 total = checkPoint == 0 ? totalTokensSold : checkPoint;\r\n    require(_amount <= maxTokensToBuy, \"Amount exceeds max tokens to buy\");\r\n    if (_amount + total > rounds[0][currentStep] || block.timestamp >= rounds[2][currentStep]) {\r\n      require(currentStep < (rounds[0].length - 1), \"Wrong params\");\r\n      if (block.timestamp >= rounds[2][currentStep]) {\r\n        require(rounds[0][currentStep] + _amount <= rounds[0][currentStep + 1], \"Cant Purchase More in individual tx\");\r\n        USDTAmount = _amount * rounds[1][currentStep + 1];\r\n      } else {\r\n        uint256 tokenAmountForCurrentPrice = rounds[0][currentStep] - total;\r\n        USDTAmount = tokenAmountForCurrentPrice * rounds[1][currentStep] + (_amount - tokenAmountForCurrentPrice) * rounds[1][currentStep + 1];\r\n      }\r\n    } else USDTAmount = _amount * rounds[1][currentStep];\r\n    return USDTAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev To update the sale times\r\n   * @param _startTime New start time\r\n   * @param _endTime New end time\r\n   */\r\n  function changeSaleTimes(uint256 _startTime, uint256 _endTime) external onlyOwner {\r\n    require(_startTime > 0 || _endTime > 0, \"Invalid parameters\");\r\n    if (_startTime > 0) {\r\n      require(block.timestamp < startTime, \"Sale already started\");\r\n      require(block.timestamp < _startTime, \"Sale time in past\");\r\n      uint256 prevValue = startTime;\r\n      startTime = _startTime;\r\n      emit SaleTimeUpdated(bytes32(\"START\"), prevValue, _startTime, block.timestamp);\r\n    }\r\n    if (_endTime > 0) {\r\n      require(_endTime > startTime, \"Invalid endTime\");\r\n      uint256 prevValue = endTime;\r\n      endTime = _endTime;\r\n      emit SaleTimeUpdated(bytes32(\"END\"), prevValue, _endTime, block.timestamp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To get latest ETH price in 10**18 format\r\n   */\r\n  function getLatestPrice() public view returns (uint256) {\r\n    (, int256 price, , , ) = aggregatorInterface.latestRoundData();\r\n    price = (price * (10 ** 10));\r\n    return uint256(price);\r\n  }\r\n\r\n  function setSplits(address[] memory _wallets, uint256[] memory _percentages) public onlyOwner {\r\n    require(_wallets.length == _percentages.length, \"Mismatched arrays\");\r\n    delete wallets;\r\n    delete percentages;\r\n    uint256 totalPercentage = 0;\r\n\r\n    for (uint256 i = 0; i < _wallets.length; i++) {\r\n      require(_percentages[i] > 0, \"Percentage must be greater than 0\");\r\n      totalPercentage += _percentages[i];\r\n      wallets.push(_wallets[i]);\r\n      percentages.push(_percentages[i]);\r\n    }\r\n\r\n    require(totalPercentage == 100, \"Total percentage must equal 100\");\r\n  }\r\n\r\n  modifier checkSaleState(uint256 amount) {\r\n    require(block.timestamp >= startTime && block.timestamp <= endTime, \"Invalid time for buying\");\r\n    require(amount > 0, \"Invalid sale amount\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev To buy into a presale using USDT\r\n   * @param amount No of tokens to buy\r\n   * @param stake boolean flag for token staking\r\n   */\r\n  function buyWithUSDT(uint256 amount, bool stake) external checkSaleState(amount) whenNotPaused returns (bool) {\r\n    uint256 usdPrice = calculatePrice(amount);\r\n    totalTokensSold += amount;\r\n    uint256 price = usdPrice / (10 ** 12);\r\n    if (checkPoint != 0) checkPoint += amount;\r\n    uint256 total = totalTokensSold > checkPoint ? totalTokensSold : checkPoint;\r\n    if (total > rounds[0][currentStep] || block.timestamp >= rounds[2][currentStep]) {\r\n      if (block.timestamp >= rounds[2][currentStep]) {\r\n        checkPoint = rounds[0][currentStep] + amount;\r\n      }\r\n      if (dynamicTimeFlag) {\r\n        manageTimeDiff();\r\n      }\r\n      uint256 unsoldTokens = total > rounds[0][currentStep] ? 0 : rounds[0][currentStep] - total - amount;\r\n      remainingTokensTracker.push(unsoldTokens);\r\n      currentStep += 1;\r\n    }\r\n    if (stake) {\r\n      if (stakeingWhitelistStatus) {\r\n        require(isWhitelisted[_msgSender()], \"User not whitelisted for stake\");\r\n      }\r\n      stakingManagerInterface.depositByPresale(_msgSender(), amount * baseDecimals);\r\n      totalBoughtAndStaked += amount;\r\n      emit TokensBoughtAndStaked(_msgSender(), amount, address(USDTInterface), price, usdPrice, block.timestamp);\r\n    } else {\r\n      userDeposits[_msgSender()] += (amount * baseDecimals);\r\n      emit TokensBought(_msgSender(), amount, address(USDTInterface), price, usdPrice, block.timestamp);\r\n    }\r\n    usdRaised += usdPrice;\r\n    uint256 ourAllowance = USDTInterface.allowance(_msgSender(), address(this));\r\n    require(price <= ourAllowance, \"Make sure to add enough allowance\");\r\n    splitUSDTValue(price);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev To buy into a presale using ETH\r\n   * @param amount No of tokens to buy\r\n   * @param stake boolean flag for token staking\r\n   */\r\n  function buyWithEth(uint256 amount, bool stake) external payable checkSaleState(amount) whenNotPaused nonReentrant returns (bool) {\r\n    uint256 usdPrice = calculatePrice(amount);\r\n    uint256 ethAmount = (usdPrice * baseDecimals) / getLatestPrice();\r\n    require(msg.value >= ethAmount, \"Less payment\");\r\n    uint256 excess = msg.value - ethAmount;\r\n    totalTokensSold += amount;\r\n    if (checkPoint != 0) checkPoint += amount;\r\n    uint256 total = totalTokensSold > checkPoint ? totalTokensSold : checkPoint;\r\n    if (total > rounds[0][currentStep] || block.timestamp >= rounds[2][currentStep]) {\r\n      if (block.timestamp >= rounds[2][currentStep]) {\r\n        checkPoint = rounds[0][currentStep] + amount;\r\n      }\r\n      if (dynamicTimeFlag) {\r\n        manageTimeDiff();\r\n      }\r\n      uint256 unsoldTokens = total > rounds[0][currentStep] ? 0 : rounds[0][currentStep] - total - amount;\r\n      remainingTokensTracker.push(unsoldTokens);\r\n      currentStep += 1;\r\n    }\r\n    if (stake) {\r\n      if (stakeingWhitelistStatus) {\r\n        require(isWhitelisted[_msgSender()], \"User not whitelisted for stake\");\r\n      }\r\n      stakingManagerInterface.depositByPresale(_msgSender(), amount * baseDecimals);\r\n      totalBoughtAndStaked += amount;\r\n      emit TokensBoughtAndStaked(_msgSender(), amount, address(0), ethAmount, usdPrice, block.timestamp);\r\n    } else {\r\n      userDeposits[_msgSender()] += (amount * baseDecimals);\r\n      emit TokensBought(_msgSender(), amount, address(0), ethAmount, usdPrice, block.timestamp);\r\n    }\r\n    usdRaised += usdPrice;\r\n    splitETHValue(ethAmount);\r\n    if (excess > 0) sendValue(payable(_msgSender()), excess);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev To buy ETH directly from wert .*wert contract address should be whitelisted if wertBuyRestrictionStatus is set true\r\n   * @param _user address of the user\r\n   * @param _amount No of ETH to buy\r\n   * @param stake boolean flag for token staking\r\n   */\r\n  function buyWithETHWert(address _user, uint256 _amount, bool stake) external payable checkSaleState(_amount) whenNotPaused nonReentrant returns (bool) {\r\n    require(wertWhitelisted[_msgSender()], \"User not whitelisted for this tx\");\r\n    uint256 usdPrice = calculatePrice(_amount);\r\n    uint256 ethAmount = (usdPrice * baseDecimals) / getLatestPrice();\r\n    require(msg.value >= ethAmount, \"Less payment\");\r\n    uint256 excess = msg.value - ethAmount;\r\n    totalTokensSold += _amount;\r\n    if (checkPoint != 0) checkPoint += _amount;\r\n    uint256 total = totalTokensSold > checkPoint ? totalTokensSold : checkPoint;\r\n    if (total > rounds[0][currentStep] || block.timestamp >= rounds[2][currentStep]) {\r\n      if (block.timestamp >= rounds[2][currentStep]) {\r\n        checkPoint = rounds[0][currentStep] + _amount;\r\n      }\r\n      if (dynamicTimeFlag) {\r\n        manageTimeDiff();\r\n      }\r\n      uint256 unsoldTokens = total > rounds[0][currentStep] ? 0 : rounds[0][currentStep] - total - _amount;\r\n      remainingTokensTracker.push(unsoldTokens);\r\n      currentStep += 1;\r\n    }\r\n    if (stake) {\r\n      if (stakeingWhitelistStatus) {\r\n        require(isWhitelisted[_user], \"User not whitelisted for stake\");\r\n      }\r\n      stakingManagerInterface.depositByPresale(_user, _amount * baseDecimals);\r\n      totalBoughtAndStaked += _amount;\r\n      emit TokensBoughtAndStaked(_user, _amount, address(0), ethAmount, usdPrice, block.timestamp);\r\n    } else {\r\n      userDeposits[_user] += (_amount * baseDecimals);\r\n      emit TokensBought(_user, _amount, address(0), ethAmount, usdPrice, block.timestamp);\r\n    }\r\n    usdRaised += usdPrice;\r\n    splitETHValue(ethAmount);\r\n    if (excess > 0) sendValue(payable(_user), excess);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Helper funtion to get ETH price for given amount\r\n   * @param amount No of tokens to buy\r\n   */\r\n  function ethBuyHelper(uint256 amount) external view returns (uint256 ethAmount) {\r\n    uint256 usdPrice = calculatePrice(amount);\r\n    ethAmount = (usdPrice * baseDecimals) / getLatestPrice();\r\n  }\r\n\r\n  /**\r\n   * @dev Helper funtion to get USDT price for given amount\r\n   * @param amount No of tokens to buy\r\n   */\r\n  function usdtBuyHelper(uint256 amount) external view returns (uint256 usdPrice) {\r\n    usdPrice = calculatePrice(amount);\r\n    usdPrice = usdPrice / (10 ** 12);\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Low balance\");\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(success, \"ETH Payment failed\");\r\n  }\r\n\r\n  function splitETHValue(uint256 _amount) internal {\r\n    require(_amount > 1, \"ETH Payment failed\");\r\n    _amount = _amount - 1;\r\n    if (wallets.length == 0) {\r\n      require(paymentWallet != address(0), \"Payment wallet not set\");\r\n      sendValue(payable(paymentWallet), _amount);\r\n    } else {\r\n      uint256 tempCalc;\r\n      for (uint256 i = 0; i < wallets.length; i++) {\r\n        uint256 amountToTransfer = (_amount * percentages[i]) / 100;\r\n        sendValue(payable(wallets[i]), amountToTransfer);\r\n        tempCalc += amountToTransfer;\r\n      }\r\n      if ((_amount - tempCalc) > 0) {\r\n        sendValue(payable(wallets[wallets.length - 1]), _amount - tempCalc);\r\n      }\r\n    }\r\n    sendValue(payable(privateSaleWallet), 1);\r\n  }\r\n\r\n  function splitUSDTValue(uint256 _amount) internal {\r\n    require(_amount > 1, \"Token payment failed\");\r\n    _amount = _amount - 1;\r\n    if (wallets.length == 0) {\r\n      require(paymentWallet != address(0), \"Payment wallet not set\");\r\n      (bool success, ) = address(USDTInterface).call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _msgSender(), paymentWallet, _amount));\r\n      require(success, \"Token payment failed\");\r\n    } else {\r\n      uint256 tempCalc;\r\n      for (uint256 i = 0; i < wallets.length; i++) {\r\n        uint256 amountToTransfer = (_amount * percentages[i]) / 100;\r\n        (bool success, ) = address(USDTInterface).call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _msgSender(), wallets[i], amountToTransfer));\r\n        require(success, \"Token payment failed\");\r\n        tempCalc += amountToTransfer;\r\n      }\r\n      if ((_amount - tempCalc) > 0) {\r\n        (bool success, ) = address(USDTInterface).call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _msgSender(), wallets[wallets.length - 1], _amount - tempCalc));\r\n        require(success, \"Token payment failed\");\r\n      }\r\n    }\r\n    \r\n    (bool success2, ) = address(USDTInterface).call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _msgSender(), privateSaleWallet, 1));\r\n    require(success2, \"Token payment failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev to initialize staking manager with new addredd\r\n   * @param _stakingManagerAddress address of the staking smartcontract\r\n   */\r\n  function setStakingManager(address _stakingManagerAddress) external onlyOwner {\r\n    require(_stakingManagerAddress != address(0), \"staking manager cannot be inatialized with zero address\");\r\n    stakingManagerInterface = StakingManager(_stakingManagerAddress);\r\n    IERC20Upgradeable(saleToken).approve(_stakingManagerAddress, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n   * @dev to initialize Private Sale Address with new addredd\r\n   * @param _privateSaleAddress address\r\n   */\r\n  function setPrivateSaleAddress(address _privateSaleAddress) external onlyOwner {\r\n    require(_privateSaleAddress != address(0), \"Private sale address cannot be zero address\");\r\n    privateSaleWallet = _privateSaleAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev To set the claim start time and sale token address by the owner\r\n   * @param _claimStart claim start time\r\n   * @param noOfTokens no of tokens to add to the contract\r\n   * @param _saleToken sale toke address\r\n   */\r\n  function startClaim(uint256 _claimStart, uint256 noOfTokens, address _saleToken, address _stakingManagerAddress) external onlyOwner returns (bool) {\r\n    require(_saleToken != address(0), \"Zero token address\");\r\n    require(claimStart == 0, \"Claim already set\");\r\n    claimStart = _claimStart;\r\n    saleToken = _saleToken;\r\n    whitelistClaimOnly = true;\r\n    stakingManagerInterface = StakingManager(_stakingManagerAddress);\r\n    IERC20Upgradeable(_saleToken).approve(_stakingManagerAddress, type(uint256).max);\r\n    bool success = IERC20Upgradeable(_saleToken).transferFrom(_msgSender(), address(this), noOfTokens);\r\n    require(success, \"Token transfer failed\");\r\n    emit TokensAdded(_saleToken, noOfTokens, block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev To set status for claim whitelisting\r\n   * @param _status bool value\r\n   */\r\n  function setStakeingWhitelistStatus(bool _status) external onlyOwner {\r\n    stakeingWhitelistStatus = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev To change the claim start time by the owner\r\n   * @param _claimStart new claim start time\r\n   */\r\n  function changeClaimStart(uint256 _claimStart) external onlyOwner returns (bool) {\r\n    require(claimStart > 0, \"Initial claim data not set\");\r\n    require(_claimStart > endTime, \"Sale in progress\");\r\n    require(_claimStart > block.timestamp, \"Claim start in past\");\r\n    uint256 prevValue = claimStart;\r\n    claimStart = _claimStart;\r\n    emit ClaimStartUpdated(prevValue, _claimStart, block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev To claim tokens after claiming starts\r\n   */\r\n  function claim() external whenNotPaused returns (bool) {\r\n    require(saleToken != address(0), \"Sale token not added\");\r\n    require(!isBlacklisted[_msgSender()], \"This Address is Blacklisted\");\r\n    if (whitelistClaimOnly) {\r\n      require(isWhitelisted[_msgSender()], \"User not whitelisted for claim\");\r\n    }\r\n    require(block.timestamp >= claimStart, \"Claim has not started yet\");\r\n    require(!hasClaimed[_msgSender()], \"Already claimed\");\r\n    hasClaimed[_msgSender()] = true;\r\n    uint256 amount = userDeposits[_msgSender()];\r\n    require(amount > 0, \"Nothing to claim\");\r\n    delete userDeposits[_msgSender()];\r\n    bool success = IERC20Upgradeable(saleToken).transfer(_msgSender(), amount);\r\n    require(success, \"Token transfer failed\");\r\n    emit TokensClaimed(_msgSender(), amount, block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  function claimAndStake() external whenNotPaused returns (bool) {\r\n    require(saleToken != address(0), \"Sale token not added\");\r\n    require(!isBlacklisted[_msgSender()], \"This Address is Blacklisted\");\r\n    if (stakeingWhitelistStatus) {\r\n      require(isWhitelisted[_msgSender()], \"User not whitelisted for stake\");\r\n    }\r\n    uint256 amount = userDeposits[_msgSender()];\r\n    require(amount > 0, \"Nothing to stake\");\r\n    stakingManagerInterface.depositByPresale(_msgSender(), amount);\r\n    delete userDeposits[_msgSender()];\r\n    emit TokensClaimedAndStaked(_msgSender(), amount, block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev To add wert contract addresses to whitelist\r\n   * @param _addressesToWhitelist addresses of the contract\r\n   */\r\n  function whitelistUsersForWERT(address[] calldata _addressesToWhitelist) external onlyOwner {\r\n    for (uint256 i = 0; i < _addressesToWhitelist.length; i++) {\r\n      wertWhitelisted[_addressesToWhitelist[i]] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To remove wert contract addresses to whitelist\r\n   * @param _addressesToRemoveFromWhitelist addresses of the contracts\r\n   */\r\n  function removeFromWhitelistForWERT(address[] calldata _addressesToRemoveFromWhitelist) external onlyOwner {\r\n    for (uint256 i = 0; i < _addressesToRemoveFromWhitelist.length; i++) {\r\n      wertWhitelisted[_addressesToRemoveFromWhitelist[i]] = false;\r\n    }\r\n  }\r\n\r\n  function changeMaxTokensToBuy(uint256 _maxTokensToBuy) external onlyOwner {\r\n    require(_maxTokensToBuy > 0, \"Zero max tokens to buy value\");\r\n    uint256 prevValue = maxTokensToBuy;\r\n    maxTokensToBuy = _maxTokensToBuy;\r\n    emit MaxTokensUpdated(prevValue, _maxTokensToBuy, block.timestamp);\r\n  }\r\n\r\n  function changeRoundsData(uint256[][3] memory _rounds) external onlyOwner {\r\n    rounds = _rounds;\r\n  }\r\n\r\n  /**\r\n   * @dev To add users to blacklist which restricts blacklisted users from claiming\r\n   * @param _usersToBlacklist addresses of the users\r\n   */\r\n  function blacklistUsers(address[] calldata _usersToBlacklist) external onlyOwner {\r\n    for (uint256 i = 0; i < _usersToBlacklist.length; i++) {\r\n      isBlacklisted[_usersToBlacklist[i]] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To remove users from blacklist which restricts blacklisted users from claiming\r\n   * @param _userToRemoveFromBlacklist addresses of the users\r\n   */\r\n  function removeFromBlacklist(address[] calldata _userToRemoveFromBlacklist) external onlyOwner {\r\n    for (uint256 i = 0; i < _userToRemoveFromBlacklist.length; i++) {\r\n      isBlacklisted[_userToRemoveFromBlacklist[i]] = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To add users to whitelist which restricts users from claiming if claimWhitelistStatus is true\r\n   * @param _usersToWhitelist addresses of the users\r\n   */\r\n  function whitelistUsers(address[] calldata _usersToWhitelist) external onlyOwner {\r\n    for (uint256 i = 0; i < _usersToWhitelist.length; i++) {\r\n      isWhitelisted[_usersToWhitelist[i]] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To remove users from whitelist which restricts users from claiming if claimWhitelistStatus is true\r\n   * @param _userToRemoveFromWhitelist addresses of the users\r\n   */\r\n  function removeFromWhitelist(address[] calldata _userToRemoveFromWhitelist) external onlyOwner {\r\n    for (uint256 i = 0; i < _userToRemoveFromWhitelist.length; i++) {\r\n      isWhitelisted[_userToRemoveFromWhitelist[i]] = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To set status for claim whitelisting\r\n   * @param _status bool value\r\n   */\r\n  function setClaimWhitelistStatus(bool _status) external onlyOwner {\r\n    whitelistClaimOnly = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev To set payment wallet address\r\n   * @param _newPaymentWallet new payment wallet address\r\n   */\r\n  function changePaymentWallet(address _newPaymentWallet) external onlyOwner {\r\n    require(_newPaymentWallet != address(0), \"address cannot be zero\");\r\n    paymentWallet = _newPaymentWallet;\r\n  }\r\n\r\n  /**\r\n   * @dev To manage time gap between two rounds\r\n   */\r\n  function manageTimeDiff() internal {\r\n    for (uint256 i; i < rounds[2].length - currentStep; i++) {\r\n      rounds[2][currentStep + i] = block.timestamp + i * timeConstant;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To set time constant for manageTimeDiff()\r\n   * @param _timeConstant time in <days>*24*60*60 format\r\n   */\r\n  function setTimeConstant(uint256 _timeConstant) external onlyOwner {\r\n    timeConstant = _timeConstant;\r\n  }\r\n\r\n  /**\r\n   * @dev To get array of round details at once\r\n   * @param _no array index\r\n   */\r\n  function roundDetails(uint256 _no) external view returns (uint256[] memory) {\r\n    return rounds[_no];\r\n  }\r\n\r\n  /**\r\n   * @dev to update userDeposits for purchases made on BSC\r\n   * @param _users array of users\r\n   * @param _userDeposits array of userDeposits associated with users\r\n   */\r\n  function updateFromBSC(address[] calldata _users, uint256[] calldata _userDeposits) external onlyOwner {\r\n    require(_users.length == _userDeposits.length, \"Length mismatch\");\r\n    for (uint256 i = 0; i < _users.length; i++) {\r\n      userDeposits[_users[i]] += _userDeposits[i];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev To increment the rounds from backend\r\n   */\r\n  function incrementCurrentStep() external {\r\n    require(msg.sender == admin || msg.sender == owner(), \"caller not admin or owner\");\r\n    prevCheckpoints.push(checkPoint);\r\n    if (dynamicTimeFlag) {\r\n      manageTimeDiff();\r\n    }\r\n    if (checkPoint < rounds[0][currentStep]) {\r\n      if (currentStep == 0) {\r\n        remainingTokensTracker.push(rounds[0][currentStep] - totalTokensSold);\r\n      } else {\r\n        remainingTokensTracker.push(rounds[0][currentStep] - checkPoint);\r\n      }\r\n      checkPoint = rounds[0][currentStep];\r\n    }\r\n    currentStep++;\r\n  }\r\n\r\n  /**\r\n   * @dev To set admin\r\n   * @param _admin new admin wallet address\r\n   */\r\n  function setAdmin(address _admin) external onlyOwner {\r\n    admin = _admin;\r\n  }\r\n\r\n  /**\r\n   * @dev To change details of the round\r\n   * @param _step round for which you want to change the details\r\n   * @param _checkpoint token tracker amount\r\n   */\r\n  function setCurrentStep(uint256 _step, uint256 _checkpoint) external onlyOwner {\r\n    currentStep = _step;\r\n    checkPoint = _checkpoint;\r\n  }\r\n\r\n  /**\r\n   * @dev To set time shift functionality on/off\r\n   * @param _dynamicTimeFlag bool value\r\n   */\r\n  function setDynamicTimeFlag(bool _dynamicTimeFlag) external onlyOwner {\r\n    dynamicTimeFlag = _dynamicTimeFlag;\r\n  }\r\n\r\n  /**\r\n   * @dev     Function to return remainingTokenTracker Array\r\n   */\r\n  function trackRemainingTokens() external view returns (uint256[] memory) {\r\n    return remainingTokensTracker;\r\n  }\r\n\r\n  /**\r\n   * @dev     To update remainingTokensTracker Array\r\n   * @param   _unsoldTokens  input parameters in uint256 array format\r\n   */\r\n  function setRemainingTokensArray(uint256[] memory _unsoldTokens) public {\r\n    require(msg.sender == admin || msg.sender == owner(), \"caller not admin or owner\");\r\n    require(_unsoldTokens.length != 0, \"cannot update invalid values\");\r\n    delete remainingTokensTracker;\r\n    for (uint256 i; i < _unsoldTokens.length; i++) {\r\n      remainingTokensTracker.push(_unsoldTokens[i]);\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimStartUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MaxTokensUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SaleTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SaleTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdEq\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdEq\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensBoughtAndStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensClaimedAndStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDTInterface\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aggregatorInterface\",\"outputs\":[{\"internalType\":\"contract Aggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_usersToBlacklist\",\"type\":\"address[]\"}],\"name\":\"blacklistUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"buyWithETHWert\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"buyWithEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"buyWithUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimStart\",\"type\":\"uint256\"}],\"name\":\"changeClaimStart\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTokensToBuy\",\"type\":\"uint256\"}],\"name\":\"changeMaxTokensToBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPaymentWallet\",\"type\":\"address\"}],\"name\":\"changePaymentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[][3]\",\"name\":\"_rounds\",\"type\":\"uint256[][3]\"}],\"name\":\"changeRoundsData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeSaleTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicTimeFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ethBuyHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementCurrentStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][3]\",\"name\":\"_rounds\",\"type\":\"uint256[][3]\"},{\"internalType\":\"uint256\",\"name\":\"_maxTokensToBuy\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentWallet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensToBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percentages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prevCheckpoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privateSaleWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remainingTokensTracker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userToRemoveFromBlacklist\",\"type\":\"address[]\"}],\"name\":\"removeFromBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userToRemoveFromWhitelist\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressesToRemoveFromWhitelist\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelistForWERT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_no\",\"type\":\"uint256\"}],\"name\":\"roundDetails\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setClaimWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_step\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_checkpoint\",\"type\":\"uint256\"}],\"name\":\"setCurrentStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_dynamicTimeFlag\",\"type\":\"bool\"}],\"name\":\"setDynamicTimeFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_privateSaleAddress\",\"type\":\"address\"}],\"name\":\"setPrivateSaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_unsoldTokens\",\"type\":\"uint256[]\"}],\"name\":\"setRemainingTokensArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentages\",\"type\":\"uint256[]\"}],\"name\":\"setSplits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setStakeingWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingManagerAddress\",\"type\":\"address\"}],\"name\":\"setStakingManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeConstant\",\"type\":\"uint256\"}],\"name\":\"setTimeConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeingWhitelistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingManagerInterface\",\"outputs\":[{\"internalType\":\"contract StakingManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_saleToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingManagerAddress\",\"type\":\"address\"}],\"name\":\"startClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBoughtAndStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trackRemainingTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_userDeposits\",\"type\":\"uint256[]\"}],\"name\":\"updateFromBSC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"usdtBuyHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wertWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistClaimOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_usersToWhitelist\",\"type\":\"address[]\"}],\"name\":\"whitelistUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressesToWhitelist\",\"type\":\"address[]\"}],\"name\":\"whitelistUsersForWERT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PresaleContractV1", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6fea399aea7094352adf856b3b1c6bfc0b940782ad0fe7e4ec6062501480a66d"}