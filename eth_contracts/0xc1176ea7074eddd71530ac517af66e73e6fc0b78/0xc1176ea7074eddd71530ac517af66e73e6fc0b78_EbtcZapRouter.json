{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/EbtcZapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport {ICdpManagerData} from \\\"@ebtc/contracts/interfaces/ICdpManagerData.sol\\\";\\r\\nimport {ICdpManager} from \\\"@ebtc/contracts/interfaces/ICdpManager.sol\\\";\\r\\nimport {IBorrowerOperations} from \\\"@ebtc/contracts/interfaces/IBorrowerOperations.sol\\\";\\r\\nimport {IPositionManagers} from \\\"@ebtc/contracts/interfaces/IPositionManagers.sol\\\";\\r\\nimport {IERC20} from \\\"@ebtc/contracts/Dependencies/IERC20.sol\\\";\\r\\nimport {SafeERC20} from \\\"@ebtc/contracts/Dependencies/SafeERC20.sol\\\";\\r\\nimport {IStETH} from \\\"./interface/IStETH.sol\\\";\\r\\nimport {IWrappedETH} from \\\"./interface/IWrappedETH.sol\\\";\\r\\nimport {IEbtcZapRouter} from \\\"./interface/IEbtcZapRouter.sol\\\";\\r\\nimport {IWstETH} from \\\"./interface/IWstETH.sol\\\";\\r\\n\\r\\ninterface IMinChangeGetter {\\r\\n    function MIN_CHANGE() external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract EbtcZapRouter is IEbtcZapRouter {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address public constant NATIVE_ETH_ADDRESS =\\r\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n    uint256 public constant LIQUIDATOR_REWARD = 2e17;\\r\\n    uint256 public constant MIN_NET_STETH_BALANCE = 2e18;\\r\\n\\r\\n    IStETH public immutable stEth;\\r\\n    IERC20 public immutable ebtc;\\r\\n    IERC20 public immutable wrappedEth;\\r\\n    IERC20 public immutable wstEth;\\r\\n    IBorrowerOperations public immutable borrowerOperations;\\r\\n    ICdpManager public immutable cdpManager;\\r\\n    address public immutable owner;\\r\\n    uint256 public immutable MIN_CHANGE;\\r\\n\\r\\n    constructor(\\r\\n        IERC20 _wstEth,\\r\\n        IERC20 _wEth,\\r\\n        IStETH _stEth,\\r\\n        IERC20 _ebtc,\\r\\n        IBorrowerOperations _borrowerOperations,\\r\\n        ICdpManager _cdpManager,\\r\\n        address _owner\\r\\n    ) {\\r\\n        wstEth = _wstEth;\\r\\n        wrappedEth = _wEth;\\r\\n        stEth = _stEth;\\r\\n        ebtc = _ebtc;\\r\\n        borrowerOperations = _borrowerOperations;\\r\\n        cdpManager = _cdpManager;\\r\\n        owner = _owner;\\r\\n\\r\\n        // Infinite Approvals @TODO: do these stay at max for each token?\\r\\n        stEth.approve(address(borrowerOperations), type(uint256).max);\\r\\n        wrappedEth.approve(address(wrappedEth), type(uint256).max);\\r\\n        wstEth.approve(address(wstEth), type(uint256).max);\\r\\n        stEth.approve(address(wstEth), type(uint256).max);\\r\\n\\r\\n        MIN_CHANGE = IMinChangeGetter(address(borrowerOperations)).MIN_CHANGE();\\r\\n    }\\r\\n\\r\\n    /// @dev This is to allow wrapped ETH related Zap\\r\\n    receive() external payable {\\r\\n        require(\\r\\n            msg.sender == address(wrappedEth),\\r\\n            \\\"EbtcZapRouter: only allow Wrapped ETH to send Ether!\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Open a CDP with stEth\\r\\n    function openCdp(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _stEthBalance,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId) {\\r\\n        uint256 _collVal = _transferInitialStETHFromCaller(_stEthBalance);\\r\\n\\r\\n        cdpId = _openCdpWithPermit(\\r\\n            _debt,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collVal,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n\\r\\n        emit ZapOperationEthVariant(\\r\\n            cdpId, \\r\\n            EthVariantZapOperationType.OpenCdp, \\r\\n            true, \\r\\n            address(stEth), \\r\\n            _stEthBalance, \\r\\n            _collVal,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Open a CDP with raw native Ether\\r\\n    /// @param _debt The total expected debt for new CDP\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _ethBalance The total stETH collateral (converted from raw Ether) amount deposited (added) for the specified Cdp\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function openCdpWithEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalance,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external payable returns (bytes32 cdpId) {\\r\\n        uint256 _collVal = _convertRawEthToStETH(_ethBalance);\\r\\n\\r\\n        cdpId = _openCdpWithPermit(\\r\\n            _debt,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collVal,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n\\r\\n        emit ZapOperationEthVariant(\\r\\n            cdpId, \\r\\n            EthVariantZapOperationType.OpenCdp, \\r\\n            true, \\r\\n            NATIVE_ETH_ADDRESS, \\r\\n            _ethBalance, \\r\\n            _collVal,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Open a CDP with Wrapped Ether\\r\\n    /// @param _debt The total expected debt for new CDP\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _wethBalance The total stETH collateral (converted from wrapped Ether) amount deposited (added) for the specified Cdp\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function openCdpWithWrappedEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wethBalance,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId) {\\r\\n        uint256 _collVal = _convertWrappedEthToStETH(_wethBalance);\\r\\n\\r\\n        cdpId = _openCdpWithPermit(\\r\\n            _debt,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collVal,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n        \\r\\n        emit ZapOperationEthVariant(\\r\\n            cdpId, \\r\\n            EthVariantZapOperationType.OpenCdp, \\r\\n            true, \\r\\n            address(wrappedEth), \\r\\n            _wethBalance, \\r\\n            _collVal,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Open a CDP with Wrapped StETH\\r\\n    /// @param _debt The total expected debt for new CDP\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _wstEthBalance The total stETH collateral (converted from wrapped stETH) amount deposited (added) for the specified Cdp\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function openCdpWithWstEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wstEthBalance,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId) {\\r\\n        uint256 _collVal = _convertWstEthToStETH(_wstEthBalance);\\r\\n\\r\\n        cdpId = _openCdpWithPermit(\\r\\n            _debt,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collVal,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n\\r\\n        emit ZapOperationEthVariant(\\r\\n            cdpId, \\r\\n            EthVariantZapOperationType.OpenCdp, \\r\\n            true, \\r\\n            address(wstEth), \\r\\n            _wstEthBalance, \\r\\n            _collVal,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Close a CDP with original collateral(stETH) returned to CDP owner\\r\\n    /// @dev Note plain collateral(stETH) is returned no matter whatever asset is zapped in\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function closeCdp(\\r\\n        bytes32 _cdpId,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external {\\r\\n        _closeCdpWithPermit(_cdpId, false, _positionManagerPermit);\\r\\n    }\\r\\n\\r\\n    /// @dev Close a CDP with wrapped version of collateral(WstETH) returned to CDP owner\\r\\n    /// @dev Note plain collateral(stETH) is returned no matter whatever asset is zapped in\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function closeCdpForWstETH(\\r\\n        bytes32 _cdpId,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external {\\r\\n        _closeCdpWithPermit(_cdpId, true, _positionManagerPermit);\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows various operations which might change both collateral (increase collateral with raw native Ether) and debt of a Cdp\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _collBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\r\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\r\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _ethBalanceIncrease The total stETH collateral (converted from raw native Ether) amount deposited (added) for the specified Cdp\\r\\n    /// @param _useWstETHForDecrease Indicator whether withdrawn collateral is original(stETH) or wrapped version(WstETH)\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function adjustCdpWithEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external payable {\\r\\n        _adjustCdpWithEth(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            _isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _ethBalanceIncrease,\\r\\n            _useWstETHForDecrease,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _adjustCdpWithEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) internal {\\r\\n        uint256 _collBalanceIncrease = _ethBalanceIncrease;\\r\\n        if (_ethBalanceIncrease > 0) {\\r\\n            _collBalanceIncrease = _convertRawEthToStETH(_ethBalanceIncrease);\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                EthVariantZapOperationType.AdjustCdp, \\r\\n                true, \\r\\n                NATIVE_ETH_ADDRESS, \\r\\n                _ethBalanceIncrease, \\r\\n                _collBalanceIncrease,\\r\\n                msg.sender\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _adjustCdpWithPermit(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            _isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collBalanceIncrease,\\r\\n            _useWstETHForDecrease,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows various operations which might change both collateral (increase collateral with wrapped Ether) and debt of a Cdp\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _collBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\r\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\r\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _wethBalanceIncrease The total stETH collateral (converted from wrapped Ether) amount deposited (added) for the specified Cdp\\r\\n    /// @param _useWstETHForDecrease Indicator whether withdrawn collateral is original(stETH) or wrapped version(WstETH)\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function adjustCdpWithWrappedEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wethBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external {\\r\\n        uint256 _collBalanceIncrease = _wethBalanceIncrease;\\r\\n        if (_wethBalanceIncrease > 0) {\\r\\n            _collBalanceIncrease = _convertWrappedEthToStETH(\\r\\n                _wethBalanceIncrease\\r\\n            );\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                EthVariantZapOperationType.AdjustCdp, \\r\\n                true, \\r\\n                address(wrappedEth), \\r\\n                _wethBalanceIncrease, \\r\\n                _collBalanceIncrease,\\r\\n                msg.sender\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _adjustCdpWithPermit(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            _isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collBalanceIncrease,\\r\\n            _useWstETHForDecrease,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows various operations which might change both collateral (increase collateral with wrapped Ether) and debt of a Cdp\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _collBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\r\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\r\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _wstEthBalanceIncrease The total stETH collateral (converted from wrapped stETH) amount deposited (added) for the specified Cdp\\r\\n    /// @param _useWstETHForDecrease Indicator whether withdrawn collateral is original(stETH) or wrapped version(WstETH)\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function adjustCdpWithWstEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wstEthBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external {\\r\\n        uint256 _collBalanceIncrease = _wstEthBalanceIncrease;\\r\\n\\r\\n        // wstETH In\\r\\n        if (_wstEthBalanceIncrease > 0) {\\r\\n            _collBalanceIncrease = _convertWstEthToStETH(\\r\\n                _wstEthBalanceIncrease\\r\\n            );\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                EthVariantZapOperationType.AdjustCdp, \\r\\n                true, \\r\\n                address(wstEth), \\r\\n                _wstEthBalanceIncrease, \\r\\n                _collBalanceIncrease,\\r\\n                msg.sender\\r\\n            );\\r\\n        } \\r\\n\\r\\n        _adjustCdpWithPermit(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            _isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collBalanceIncrease,\\r\\n            _useWstETHForDecrease,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows various operations which might change both collateral and debt of a Cdp\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _collBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\r\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\r\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _collBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp\\r\\n    /// @param _useWstETHForDecrease Indicator whether withdrawn collateral is original(stETH) or wrapped version(WstETH)\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function adjustCdp(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _collBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external {\\r\\n        if (_collBalanceIncrease > 0) {\\r\\n            uint256 _collVal = _transferInitialStETHFromCaller(_collBalanceIncrease);\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                EthVariantZapOperationType.AdjustCdp, \\r\\n                true, \\r\\n                address(stEth), \\r\\n                _collBalanceIncrease, \\r\\n                _collVal,\\r\\n                msg.sender\\r\\n            );\\r\\n        }\\r\\n        _adjustCdpWithPermit(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            _isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collBalanceIncrease,\\r\\n            _useWstETHForDecrease,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Increase the collateral for given CDP with raw native Ether\\r\\n    /// @param _cdpId The CdpId on which this operation is operated\\r\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\r\\n    /// @param _ethBalanceIncrease The total stETH collateral (converted from raw Ether) amount deposited (added) for the specified Cdp\\r\\n    /// @param _positionManagerPermit PositionPermit required for Zap approved by calling user\\r\\n    function addCollWithEth(\\r\\n        bytes32 _cdpId,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalanceIncrease,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) external payable {        \\r\\n        _adjustCdpWithEth(\\r\\n            _cdpId,\\r\\n            0,\\r\\n            0,\\r\\n            false,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _ethBalanceIncrease,\\r\\n            false,\\r\\n            _positionManagerPermit\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer an arbitrary token back to you\\r\\n    function sweepToken(address token, uint256 amount) public {\\r\\n        require(owner == msg.sender, \\\"Must be owner\\\");\\r\\n\\r\\n        if (amount > 0) {\\r\\n            IERC20(token).safeTransfer(msg.sender, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _openCdpWithPermit(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _stEthBalance,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) internal returns (bytes32 cdpId) {\\r\\n        // Check token balances of Zap before operation\\r\\n        require(\\r\\n            stEth.balanceOf(address(this)) >= _stEthBalance,\\r\\n            \\\"EbtcZapRouter: not enough collateral for open!\\\"\\r\\n        );\\r\\n\\r\\n        _requireZeroOrMinAdjustment(_debt);\\r\\n        _requireAtLeastMinNetStEthBalance(_stEthBalance - LIQUIDATOR_REWARD);\\r\\n\\r\\n        _permitPositionManagerApproval(_positionManagerPermit);\\r\\n\\r\\n        cdpId = borrowerOperations.openCdpFor(\\r\\n            _debt,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _stEthBalance,\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        ebtc.transfer(msg.sender, _debt);\\r\\n\\r\\n        // Token balances should not have changed after operation\\r\\n        // Created CDP should be owned by borrower\\r\\n    }\\r\\n\\r\\n    function _closeCdpWithPermit(\\r\\n        bytes32 _cdpId,\\r\\n        bool _useWstETH,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) internal {\\r\\n        require(\\r\\n            msg.sender == _getOwnerAddress(_cdpId),\\r\\n            \\\"EbtcZapRouter: not owner for close!\\\"\\r\\n        );\\r\\n\\r\\n        // for debt repayment\\r\\n        uint256 _debt = ICdpManagerData(address(cdpManager)).getSyncedCdpDebt(\\r\\n            _cdpId\\r\\n        );\\r\\n        ebtc.transferFrom(msg.sender, address(this), _debt);\\r\\n\\r\\n        _permitPositionManagerApproval(_positionManagerPermit);\\r\\n\\r\\n        uint256 _zapStEthBalanceBefore = stEth.balanceOf(address(this));\\r\\n        borrowerOperations.closeCdp(_cdpId);\\r\\n        uint256 _zapStEthBalanceAfter = stEth.balanceOf(address(this));\\r\\n        uint256 _stETHDiff = _zapStEthBalanceAfter - _zapStEthBalanceBefore;\\r\\n\\r\\n        _transferStEthToCaller(_cdpId, EthVariantZapOperationType.CloseCdp, _useWstETH, _stETHDiff);\\r\\n    }\\r\\n\\r\\n    function _transferStEthToCaller(\\r\\n        bytes32 _cdpId,\\r\\n        EthVariantZapOperationType _operationType,\\r\\n        bool _useWstETH,\\r\\n        uint256 _stEthVal\\r\\n    ) internal {\\r\\n        if (_useWstETH) {\\r\\n            // return wrapped version(WstETH)\\r\\n            uint256 _wstETHVal = IWstETH(address(wstEth)).wrap(_stEthVal);\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                _operationType, \\r\\n                false, \\r\\n                address(wstEth), \\r\\n                _wstETHVal, \\r\\n                _stEthVal,\\r\\n                msg.sender\\r\\n            );\\r\\n\\r\\n            wstEth.transfer(msg.sender, _wstETHVal);\\r\\n        } else {\\r\\n            // return original collateral(stETH)\\r\\n            emit ZapOperationEthVariant(\\r\\n                _cdpId, \\r\\n                _operationType, \\r\\n                false, \\r\\n                address(stEth), \\r\\n                _stEthVal, \\r\\n                _stEthVal,\\r\\n                msg.sender\\r\\n            );\\r\\n            stEth.transfer(msg.sender, _stEthVal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _adjustCdpWithPermit(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _collBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _collBalanceIncrease,\\r\\n        bool _useWstETH,\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) internal {\\r\\n        require(\\r\\n            msg.sender == _getOwnerAddress(_cdpId),\\r\\n            \\\"EbtcZapRouter: not owner for adjust!\\\"\\r\\n        );\\r\\n        require(\\r\\n            (_collBalanceDecrease > 0 && _collBalanceIncrease == 0) ||\\r\\n                (_collBalanceIncrease > 0 && _collBalanceDecrease == 0) ||\\r\\n                (_collBalanceIncrease == 0 && _collBalanceDecrease == 0),\\r\\n            \\\"EbtcZapRouter: can't add and remove collateral at the same time!\\\"\\r\\n        );\\r\\n\\r\\n        _requireNonZeroAdjustment(_collBalanceIncrease, _collBalanceDecrease, _debtChange);\\r\\n        _requireZeroOrMinAdjustment(_debtChange);\\r\\n        _requireZeroOrMinAdjustment(_collBalanceIncrease);\\r\\n        _requireZeroOrMinAdjustment(_collBalanceDecrease);\\r\\n\\r\\n        _permitPositionManagerApproval(_positionManagerPermit);\\r\\n\\r\\n        // for debt decrease\\r\\n        if (!isDebtIncrease && _debtChange > 0) {\\r\\n            ebtc.transferFrom(msg.sender, address(this), _debtChange);\\r\\n        }\\r\\n\\r\\n        uint256 _zapStEthBalanceBefore = stEth.balanceOf(address(this));\\r\\n        borrowerOperations.adjustCdpWithColl(\\r\\n            _cdpId,\\r\\n            _collBalanceDecrease,\\r\\n            _debtChange,\\r\\n            isDebtIncrease,\\r\\n            _upperHint,\\r\\n            _lowerHint,\\r\\n            _collBalanceIncrease\\r\\n        );\\r\\n        uint256 _zapStEthBalanceAfter = stEth.balanceOf(address(this));\\r\\n\\r\\n        // Send any withdrawn debt back to borrower\\r\\n        if (isDebtIncrease && _debtChange > 0) {\\r\\n            ebtc.transfer(msg.sender, _debtChange);\\r\\n        }\\r\\n\\r\\n        // Send any withdrawn collateral to back to borrower\\r\\n        if (_collBalanceDecrease > 0) {\\r\\n            _transferStEthToCaller(\\r\\n                _cdpId,\\r\\n                EthVariantZapOperationType.AdjustCdp,\\r\\n                _useWstETH,\\r\\n                _zapStEthBalanceAfter - _zapStEthBalanceBefore\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transferInitialStETHFromCaller(\\r\\n        uint256 _initialStETH\\r\\n    ) internal returns (uint256) {\\r\\n        // check before-after balances for 1-wei corner case\\r\\n        uint256 _balBefore = stEth.balanceOf(address(this));\\r\\n        stEth.transferFrom(msg.sender, address(this), _initialStETH);\\r\\n        uint256 _deposit = stEth.balanceOf(address(this)) - _balBefore;\\r\\n        return _deposit;\\r\\n    }\\r\\n\\r\\n    function _convertRawEthToStETH(\\r\\n        uint256 _initialETH\\r\\n    ) internal returns (uint256) {\\r\\n        require(\\r\\n            msg.value == _initialETH,\\r\\n            \\\"EbtcZapRouter: Incorrect ETH amount\\\"\\r\\n        );\\r\\n        return _depositRawEthIntoLido(_initialETH);\\r\\n    }\\r\\n\\r\\n    function _depositRawEthIntoLido(\\r\\n        uint256 _initialETH\\r\\n    ) internal returns (uint256) {\\r\\n        // check before-after balances for 1-wei corner case\\r\\n        uint256 _balBefore = stEth.balanceOf(address(this));\\r\\n        // TODO call submit() with a referral?\\r\\n        payable(address(stEth)).call{value: _initialETH}(\\\"\\\");\\r\\n        uint256 _deposit = stEth.balanceOf(address(this)) - _balBefore;\\r\\n        return _deposit;\\r\\n    }\\r\\n\\r\\n    function _convertWrappedEthToStETH(\\r\\n        uint256 _initialWETH\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 _wETHBalBefore = wrappedEth.balanceOf(address(this));\\r\\n        wrappedEth.transferFrom(msg.sender, address(this), _initialWETH);\\r\\n        uint256 _wETHReiceived = wrappedEth.balanceOf(address(this)) -\\r\\n            _wETHBalBefore;\\r\\n\\r\\n        uint256 _rawETHBalBefore = address(this).balance;\\r\\n        IWrappedETH(address(wrappedEth)).withdraw(_wETHReiceived);\\r\\n        uint256 _rawETHConverted = address(this).balance - _rawETHBalBefore;\\r\\n        return _depositRawEthIntoLido(_rawETHConverted);\\r\\n    }\\r\\n\\r\\n    function _convertWstEthToStETH(\\r\\n        uint256 _initialWstETH\\r\\n    ) internal returns (uint256) {\\r\\n        require(\\r\\n            wstEth.transferFrom(msg.sender, address(this), _initialWstETH),\\r\\n            \\\"EbtcZapRouter: transfer wstETH failure!\\\"\\r\\n        );\\r\\n\\r\\n        uint256 _stETHBalBefore = stEth.balanceOf(address(this));\\r\\n        IWstETH(address(wstEth)).unwrap(_initialWstETH);\\r\\n        uint256 _stETHReiceived = stEth.balanceOf(address(this)) -\\r\\n            _stETHBalBefore;\\r\\n\\r\\n        return _stETHReiceived;\\r\\n    }\\r\\n\\r\\n    function _permitPositionManagerApproval(\\r\\n        PositionManagerPermit calldata _positionManagerPermit\\r\\n    ) internal {\\r\\n        try\\r\\n            borrowerOperations.permitPositionManagerApproval(\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                IPositionManagers.PositionManagerApproval.OneTime,\\r\\n                _positionManagerPermit.deadline,\\r\\n                _positionManagerPermit.v,\\r\\n                _positionManagerPermit.r,\\r\\n                _positionManagerPermit.s\\r\\n            )\\r\\n        {} catch {\\r\\n            /// @notice adding try...catch around to mitigate potential permit front-running\\r\\n            /// see: https://www.trust-security.xyz/post/permission-denied\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getOwnerAddress(bytes32 cdpId) internal pure returns (address) {\\r\\n        uint256 _tmp = uint256(cdpId) >> 96;\\r\\n        return address(uint160(_tmp));\\r\\n    }\\r\\n\\r\\n    function _requireZeroOrMinAdjustment(uint256 _change) internal view {\\r\\n        require(\\r\\n            _change == 0 || _change >= MIN_CHANGE,\\r\\n            \\\"EbtcZapRouter: Debt or collateral change must be zero or above min\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _requireAtLeastMinNetStEthBalance(uint256 _stEthBalance) internal pure {\\r\\n        require(\\r\\n            _stEthBalance >= MIN_NET_STETH_BALANCE,\\r\\n            \\\"EbtcZapRouter: Cdp's net stEth balance must not fall below minimum\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _requireNonZeroAdjustment(\\r\\n        uint256 _stEthBalanceIncrease,\\r\\n        uint256 _stEthBalanceDecrease,\\r\\n        uint256 _debtChange\\r\\n    ) internal pure {\\r\\n        require(\\r\\n            _stEthBalanceIncrease > 0 || _stEthBalanceDecrease > 0 || _debtChange > 0,\\r\\n            \\\"EbtcZapRouter: There must be either a collateral or debt change\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/ICdpManagerData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./ICollSurplusPool.sol\\\";\\r\\nimport \\\"./IEBTCToken.sol\\\";\\r\\nimport \\\"./ISortedCdps.sol\\\";\\r\\nimport \\\"./IActivePool.sol\\\";\\r\\nimport \\\"./IRecoveryModeGracePeriod.sol\\\";\\r\\nimport \\\"../Dependencies/ICollateralTokenOracle.sol\\\";\\r\\n\\r\\n// Common interface for the Cdp Manager.\\r\\ninterface ICdpManagerData is IRecoveryModeGracePeriod {\\r\\n    // --- Events ---\\r\\n\\r\\n    event StakingRewardSplitSet(uint256 _stakingRewardSplit);\\r\\n    event RedemptionFeeFloorSet(uint256 _redemptionFeeFloor);\\r\\n    event MinuteDecayFactorSet(uint256 _minuteDecayFactor);\\r\\n    event BetaSet(uint256 _beta);\\r\\n    event RedemptionsPaused(bool _paused);\\r\\n\\r\\n    event Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _liqReward);\\r\\n    event Redemption(\\r\\n        uint256 _debtToRedeemExpected,\\r\\n        uint256 _debtToRedeemActual,\\r\\n        uint256 _collSharesSent,\\r\\n        uint256 _feeCollShares,\\r\\n        address indexed _redeemer\\r\\n    );\\r\\n    event CdpUpdated(\\r\\n        bytes32 indexed _cdpId,\\r\\n        address indexed _borrower,\\r\\n        address indexed _executor,\\r\\n        uint256 _oldDebt,\\r\\n        uint256 _oldCollShares,\\r\\n        uint256 _debt,\\r\\n        uint256 _collShares,\\r\\n        uint256 _stake,\\r\\n        CdpOperation _operation\\r\\n    );\\r\\n    event CdpLiquidated(\\r\\n        bytes32 indexed _cdpId,\\r\\n        address indexed _borrower,\\r\\n        uint _debt,\\r\\n        uint _collShares,\\r\\n        CdpOperation _operation,\\r\\n        address indexed _liquidator,\\r\\n        uint _premiumToLiquidator\\r\\n    );\\r\\n    event CdpPartiallyLiquidated(\\r\\n        bytes32 indexed _cdpId,\\r\\n        address indexed _borrower,\\r\\n        uint256 _debt,\\r\\n        uint256 _collShares,\\r\\n        CdpOperation operation,\\r\\n        address indexed _liquidator,\\r\\n        uint _premiumToLiquidator\\r\\n    );\\r\\n    event BaseRateUpdated(uint256 _baseRate);\\r\\n    event LastRedemptionTimestampUpdated(uint256 _lastFeeOpTime);\\r\\n    event TotalStakesUpdated(uint256 _newTotalStakes);\\r\\n    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\\r\\n    event SystemDebtRedistributionIndexUpdated(uint256 _systemDebtRedistributionIndex);\\r\\n    event CdpDebtRedistributionIndexUpdated(bytes32 _cdpId, uint256 _cdpDebtRedistributionIndex);\\r\\n    event CdpArrayIndexUpdated(bytes32 _cdpId, uint256 _newIndex);\\r\\n    event StEthIndexUpdated(uint256 _oldIndex, uint256 _newIndex, uint256 _updTimestamp);\\r\\n    event CollateralFeePerUnitUpdated(uint256 _oldPerUnit, uint256 _newPerUnit, uint256 _feeTaken);\\r\\n    event CdpFeeSplitApplied(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _oldPerUnitCdp,\\r\\n        uint256 _newPerUnitCdp,\\r\\n        uint256 _collReduced,\\r\\n        uint256 _collLeft\\r\\n    );\\r\\n\\r\\n    enum CdpOperation {\\r\\n        openCdp,\\r\\n        closeCdp,\\r\\n        adjustCdp,\\r\\n        syncAccounting,\\r\\n        liquidateInNormalMode,\\r\\n        liquidateInRecoveryMode,\\r\\n        redeemCollateral,\\r\\n        partiallyLiquidate,\\r\\n        failedPartialRedemption\\r\\n    }\\r\\n\\r\\n    enum Status {\\r\\n        nonExistent,\\r\\n        active,\\r\\n        closedByOwner,\\r\\n        closedByLiquidation,\\r\\n        closedByRedemption\\r\\n    }\\r\\n\\r\\n    // Store the necessary data for a cdp\\r\\n    struct Cdp {\\r\\n        uint256 debt;\\r\\n        uint256 coll;\\r\\n        uint256 stake;\\r\\n        uint128 liquidatorRewardShares;\\r\\n        Status status;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * --- Variable container structs for liquidations ---\\r\\n     *\\r\\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\\r\\n     * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\r\\n     **/\\r\\n\\r\\n    struct CdpDebtAndCollShares {\\r\\n        uint256 debt;\\r\\n        uint256 collShares;\\r\\n    }\\r\\n\\r\\n    struct LiquidationLocals {\\r\\n        bytes32 cdpId;\\r\\n        uint256 partialAmount; // used only for partial liquidation, default 0 means full liquidation\\r\\n        uint256 price;\\r\\n        uint256 ICR;\\r\\n        bytes32 upperPartialHint;\\r\\n        bytes32 lowerPartialHint;\\r\\n        bool recoveryModeAtStart;\\r\\n        uint256 TCR;\\r\\n        uint256 totalSurplusCollShares;\\r\\n        uint256 totalCollSharesToSend;\\r\\n        uint256 totalDebtToBurn;\\r\\n        uint256 totalDebtToRedistribute;\\r\\n        uint256 totalLiquidatorRewardCollShares;\\r\\n    }\\r\\n\\r\\n    struct LiquidationRecoveryModeLocals {\\r\\n        uint256 entireSystemDebt;\\r\\n        uint256 entireSystemColl;\\r\\n        uint256 totalDebtToBurn;\\r\\n        uint256 totalCollSharesToSend;\\r\\n        uint256 totalSurplusCollShares;\\r\\n        bytes32 cdpId;\\r\\n        uint256 price;\\r\\n        uint256 ICR;\\r\\n        uint256 totalDebtToRedistribute;\\r\\n        uint256 totalLiquidatorRewardCollShares;\\r\\n    }\\r\\n\\r\\n    struct LocalVariables_OuterLiquidationFunction {\\r\\n        uint256 price;\\r\\n        bool recoveryModeAtStart;\\r\\n        uint256 liquidatedDebt;\\r\\n        uint256 liquidatedColl;\\r\\n    }\\r\\n\\r\\n    struct LocalVariables_LiquidationSequence {\\r\\n        uint256 i;\\r\\n        uint256 ICR;\\r\\n        bytes32 cdpId;\\r\\n        bool backToNormalMode;\\r\\n        uint256 entireSystemDebt;\\r\\n        uint256 entireSystemColl;\\r\\n        uint256 price;\\r\\n        uint256 TCR;\\r\\n    }\\r\\n\\r\\n    struct SingleRedemptionInputs {\\r\\n        bytes32 cdpId;\\r\\n        uint256 maxEBTCamount;\\r\\n        uint256 price;\\r\\n        bytes32 upperPartialRedemptionHint;\\r\\n        bytes32 lowerPartialRedemptionHint;\\r\\n        uint256 partialRedemptionHintNICR;\\r\\n    }\\r\\n\\r\\n    struct LiquidationValues {\\r\\n        uint256 entireCdpDebt;\\r\\n        uint256 debtToBurn;\\r\\n        uint256 totalCollToSendToLiquidator;\\r\\n        uint256 debtToRedistribute;\\r\\n        uint256 collSurplus;\\r\\n        uint256 liquidatorCollSharesReward;\\r\\n    }\\r\\n\\r\\n    struct LiquidationTotals {\\r\\n        uint256 totalDebtInSequence;\\r\\n        uint256 totalDebtToBurn;\\r\\n        uint256 totalCollToSendToLiquidator;\\r\\n        uint256 totalDebtToRedistribute;\\r\\n        uint256 totalCollSurplus;\\r\\n        uint256 totalCollReward;\\r\\n    }\\r\\n\\r\\n    // --- Variable container structs for redemptions ---\\r\\n\\r\\n    struct RedemptionTotals {\\r\\n        uint256 remainingDebtToRedeem;\\r\\n        uint256 debtToRedeem;\\r\\n        uint256 collSharesDrawn;\\r\\n        uint256 totalCollSharesSurplus;\\r\\n        uint256 feeCollShares;\\r\\n        uint256 collSharesToRedeemer;\\r\\n        uint256 decayedBaseRate;\\r\\n        uint256 price;\\r\\n        uint256 systemDebtAtStart;\\r\\n        uint256 twapSystemDebtAtStart;\\r\\n        uint256 systemCollSharesAtStart;\\r\\n        uint256 tcrAtStart;\\r\\n    }\\r\\n\\r\\n    struct SingleRedemptionValues {\\r\\n        uint256 debtToRedeem;\\r\\n        uint256 collSharesDrawn;\\r\\n        uint256 collSurplus;\\r\\n        uint256 liquidatorRewardShares;\\r\\n        bool cancelledPartial;\\r\\n        bool fullRedemption;\\r\\n        uint256 newPartialNICR;\\r\\n    }\\r\\n\\r\\n    function getActiveCdpsCount() external view returns (uint256);\\r\\n\\r\\n    function totalStakes() external view returns (uint256);\\r\\n\\r\\n    function ebtcToken() external view returns (IEBTCToken);\\r\\n\\r\\n    function systemStEthFeePerUnitIndex() external view returns (uint256);\\r\\n\\r\\n    function systemStEthFeePerUnitIndexError() external view returns (uint256);\\r\\n\\r\\n    function stEthIndex() external view returns (uint256);\\r\\n\\r\\n    function calcFeeUponStakingReward(\\r\\n        uint256 _newIndex,\\r\\n        uint256 _prevIndex\\r\\n    ) external view returns (uint256, uint256, uint256);\\r\\n\\r\\n    function syncGlobalAccounting() external; // Accrues StEthFeeSplit without influencing Grace Period\\r\\n\\r\\n    function syncGlobalAccountingAndGracePeriod() external; // Accrues StEthFeeSplit and influences Grace Period\\r\\n\\r\\n    function getAccumulatedFeeSplitApplied(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _systemStEthFeePerUnitIndex\\r\\n    ) external view returns (uint256, uint256);\\r\\n\\r\\n    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getCachedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);\\r\\n\\r\\n    function getSyncedCdpDebt(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getSyncedCdpCollShares(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getSyncedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);\\r\\n\\r\\n    function getSyncedTCR(uint256 _price) external view returns (uint256);\\r\\n\\r\\n    function getSyncedSystemCollShares() external view returns (uint256);\\r\\n\\r\\n    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getPendingRedistributedDebt(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function hasPendingRedistributedDebt(bytes32 _cdpId) external view returns (bool);\\r\\n\\r\\n    function getSyncedDebtAndCollShares(\\r\\n        bytes32 _cdpId\\r\\n    ) external view returns (uint256 debt, uint256 collShares);\\r\\n\\r\\n    function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) external view returns (bool);\\r\\n\\r\\n    function totalCollateralSnapshot() external view returns (uint256);\\r\\n\\r\\n    function totalStakesSnapshot() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/ICdpManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IEbtcBase.sol\\\";\\r\\nimport \\\"./ICdpManagerData.sol\\\";\\r\\n\\r\\n// Common interface for the Cdp Manager.\\r\\ninterface ICdpManager is IEbtcBase, ICdpManagerData {\\r\\n    // --- Functions ---\\r\\n    function liquidate(bytes32 _cdpId) external;\\r\\n\\r\\n    function partiallyLiquidate(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _partialAmount,\\r\\n        bytes32 _upperPartialHint,\\r\\n        bytes32 _lowerPartialHint\\r\\n    ) external;\\r\\n\\r\\n    function batchLiquidateCdps(bytes32[] calldata _cdpArray) external;\\r\\n\\r\\n    function redeemCollateral(\\r\\n        uint256 _EBTCAmount,\\r\\n        bytes32 _firstRedemptionHint,\\r\\n        bytes32 _upperPartialRedemptionHint,\\r\\n        bytes32 _lowerPartialRedemptionHint,\\r\\n        uint256 _partialRedemptionHintNICR,\\r\\n        uint256 _maxIterations,\\r\\n        uint256 _maxFee\\r\\n    ) external;\\r\\n\\r\\n    function updateStakeAndTotalStakes(bytes32 _cdpId) external returns (uint256);\\r\\n\\r\\n    function syncAccounting(bytes32 _cdpId) external;\\r\\n\\r\\n    function closeCdp(bytes32 _cdpId, address _borrower, uint256 _debt, uint256 _coll) external;\\r\\n\\r\\n    function getRedemptionRate() external view returns (uint256);\\r\\n\\r\\n    function getRedemptionRateWithDecay() external view returns (uint256);\\r\\n\\r\\n    function getRedemptionFeeWithDecay(uint256 _stETHToRedeem) external view returns (uint256);\\r\\n\\r\\n    function getCdpStatus(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getCdpStake(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getCdpDebt(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getCdpCollShares(bytes32 _cdpId) external view returns (uint256);\\r\\n\\r\\n    function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view returns (uint);\\r\\n\\r\\n    function initializeCdp(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _debt,\\r\\n        uint256 _coll,\\r\\n        uint256 _liquidatorRewardShares,\\r\\n        address _borrower\\r\\n    ) external;\\r\\n\\r\\n    function updateCdp(\\r\\n        bytes32 _cdpId,\\r\\n        address _borrower,\\r\\n        uint256 _coll,\\r\\n        uint256 _debt,\\r\\n        uint256 _newColl,\\r\\n        uint256 _newDebt\\r\\n    ) external;\\r\\n\\r\\n    function getCachedTCR(uint256 _price) external view returns (uint256);\\r\\n\\r\\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IBorrowerOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\nimport \\\"./IPositionManagers.sol\\\";\\n\\n// Common interface for the Cdp Manager.\\ninterface IBorrowerOperations is IPositionManagers {\\n    // --- Events ---\\n\\n    event FeeRecipientAddressChanged(address indexed _feeRecipientAddress);\\n    event FlashLoanSuccess(\\n        address indexed _receiver,\\n        address indexed _token,\\n        uint256 _amount,\\n        uint256 _fee\\n    );\\n\\n    // --- Functions ---\\n\\n    function openCdp(\\n        uint256 _EBTCAmount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalance\\n    ) external returns (bytes32);\\n\\n    function openCdpFor(\\n        uint _EBTCAmount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint _collAmount,\\n        address _borrower\\n    ) external returns (bytes32);\\n\\n    function addColl(\\n        bytes32 _cdpId,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external;\\n\\n    function withdrawColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function withdrawDebt(\\n        bytes32 _cdpId,\\n        uint256 _amount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function repayDebt(\\n        bytes32 _cdpId,\\n        uint256 _amount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function closeCdp(bytes32 _cdpId) external;\\n\\n    function adjustCdp(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function adjustCdpWithColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external;\\n\\n    function claimSurplusCollShares() external;\\n\\n    function feeRecipientAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IPositionManagers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPositionManagers {\\n    enum PositionManagerApproval {\\n        None,\\n        OneTime,\\n        Persistent\\n    }\\n\\n    event PositionManagerApprovalSet(\\n        address indexed _borrower,\\n        address indexed _positionManager,\\n        PositionManagerApproval _approval\\n    );\\n\\n    function getPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager\\n    ) external view returns (PositionManagerApproval);\\n\\n    function setPositionManagerApproval(\\n        address _positionManager,\\n        PositionManagerApproval _approval\\n    ) external;\\n\\n    function revokePositionManagerApproval(address _positionManager) external;\\n\\n    function renouncePositionManagerApproval(address _borrower) external;\\n\\n    function permitPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager,\\n        PositionManagerApproval _approval,\\n        uint _deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function version() external view returns (string memory);\\n\\n    function permitTypeHash() external view returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /// @dev Calls approve while checking bool return value, handles no-return tokens\\n    function safeApprove(IERC20 token, address spender, uint256 amount) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, amount));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        require(\\n            returndata.length == 0 || abi.decode(returndata, (bool)),\\n            \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IStETH.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\n/* See contracts/COMPILERS.md */\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@ebtc/contracts/Dependencies/ICollateralToken.sol\\\";\\r\\n\\r\\n/// @notice Add submit functionality to eBTC stETH interface\\r\\ninterface IStETH is ICollateralToken {\\r\\n    function submit(address _referral) external payable returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interface/IWrappedETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\n/* See contracts/COMPILERS.md */\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Wrapped ETH (version 9)\\r\\n/// @dev check https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\\r\\ninterface IWrappedETH {\\r\\n    function withdraw(uint wad) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interface/IEbtcZapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IEbtcZapRouter {\\r\\n    struct PositionManagerPermit {\\r\\n        uint256 deadline;\\r\\n        uint8 v;\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n    }\\r\\n\\r\\n    enum EthVariantZapOperationType {\\r\\n        OpenCdp,\\r\\n        AdjustCdp,\\r\\n        CloseCdp\\r\\n    }\\r\\n\\r\\n    event ZapOperationEthVariant(\\r\\n        bytes32 indexed cdpId,\\r\\n        EthVariantZapOperationType indexed operation,\\r\\n        bool isCollateralIncrease,\\r\\n        address indexed collateralToken,\\r\\n        uint256 collateralTokenDelta,\\r\\n        uint256 stEthDelta,\\r\\n        address cdpOwner\\r\\n    );\\r\\n\\r\\n    function openCdp(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _stEthBalance,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId);\\r\\n\\r\\n    function openCdpWithEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalance,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external payable returns (bytes32 cdpId);\\r\\n\\r\\n    function openCdpWithWrappedEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wethBalance,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId);\\r\\n\\r\\n    function openCdpWithWstEth(\\r\\n        uint256 _debt,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wstEthBalance,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external returns (bytes32 cdpId);\\r\\n\\r\\n    function adjustCdp(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _stEthBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _stEthBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external;\\r\\n\\r\\n    function adjustCdpWithEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _stEthBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _ethBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external payable;\\r\\n\\r\\n    function adjustCdpWithWrappedEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _stEthBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wethBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external;\\r\\n\\r\\n    function adjustCdpWithWstEth(\\r\\n        bytes32 _cdpId,\\r\\n        uint256 _stEthBalanceDecrease,\\r\\n        uint256 _debtChange,\\r\\n        bool _isDebtIncrease,\\r\\n        bytes32 _upperHint,\\r\\n        bytes32 _lowerHint,\\r\\n        uint256 _wstEthBalanceIncrease,\\r\\n        bool _useWstETHForDecrease,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external;\\r\\n\\r\\n    function closeCdp(\\r\\n        bytes32 _cdpId,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external;\\r\\n\\r\\n    function closeCdpForWstETH(\\r\\n        bytes32 _cdpId,\\r\\n        PositionManagerPermit memory _positionManagerPermit\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interface/IWstETH.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\n/* See contracts/COMPILERS.md */\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Check https://etherscan.io/token/0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0#code\\r\\ninterface IWstETH {\\r\\n    /// @notice Exchanges wstETH to stETH\\r\\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\\r\\n\\r\\n    /// @notice Exchanges stETH to wstETH\\r\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\r\\n\\r\\n    /// @notice Get amount of wstETH for a given amount of stETH\\r\\n    function getWstETHByStETH(\\r\\n        uint256 _stETHAmount\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /// @notice Get amount of stETH for a given amount of wstETH\\r\\n    function getStETHByWstETH(\\r\\n        uint256 _stETHAmount\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/ICollSurplusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ICollSurplusPool {\\r\\n    // --- Events ---\\r\\n\\r\\n    event SurplusCollSharesAdded(\\r\\n        bytes32 indexed _cdpId,\\r\\n        address indexed _account,\\r\\n        uint256 _claimableSurplusCollShares,\\r\\n        uint256 _surplusCollSharesAddedFromCollateral,\\r\\n        uint256 _surplusCollSharesAddedFromLiquidatorReward\\r\\n    );\\r\\n    event CollSharesTransferred(address indexed _to, uint256 _amount);\\r\\n\\r\\n    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);\\r\\n\\r\\n    // --- Contract setters ---\\r\\n\\r\\n    function getTotalSurplusCollShares() external view returns (uint256);\\r\\n\\r\\n    function getSurplusCollShares(address _account) external view returns (uint256);\\r\\n\\r\\n    function increaseSurplusCollShares(\\r\\n        bytes32 _cdpId,\\r\\n        address _account,\\r\\n        uint256 _collateralShares,\\r\\n        uint256 _liquidatorRewardShares\\r\\n    ) external;\\r\\n\\r\\n    function claimSurplusCollShares(address _account) external;\\r\\n\\r\\n    function increaseTotalSurplusCollShares(uint256 _value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IEBTCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../Dependencies/IERC20.sol\\\";\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\n\\ninterface IEBTCToken is IERC20, IERC2612 {\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/ISortedCdps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n// Common interface for the SortedCdps Doubly Linked List.\\r\\ninterface ISortedCdps {\\r\\n    // --- Events ---\\r\\n\\r\\n    event NodeAdded(bytes32 _id, uint _NICR);\\r\\n    event NodeRemoved(bytes32 _id);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    function remove(bytes32 _id) external;\\r\\n\\r\\n    function batchRemove(bytes32[] memory _ids) external;\\r\\n\\r\\n    function reInsert(bytes32 _id, uint256 _newICR, bytes32 _prevId, bytes32 _nextId) external;\\r\\n\\r\\n    function contains(bytes32 _id) external view returns (bool);\\r\\n\\r\\n    function isFull() external view returns (bool);\\r\\n\\r\\n    function isEmpty() external view returns (bool);\\r\\n\\r\\n    function getSize() external view returns (uint256);\\r\\n\\r\\n    function getMaxSize() external view returns (uint256);\\r\\n\\r\\n    function getFirst() external view returns (bytes32);\\r\\n\\r\\n    function getLast() external view returns (bytes32);\\r\\n\\r\\n    function getNext(bytes32 _id) external view returns (bytes32);\\r\\n\\r\\n    function getPrev(bytes32 _id) external view returns (bytes32);\\r\\n\\r\\n    function validInsertPosition(\\r\\n        uint256 _ICR,\\r\\n        bytes32 _prevId,\\r\\n        bytes32 _nextId\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function findInsertPosition(\\r\\n        uint256 _ICR,\\r\\n        bytes32 _prevId,\\r\\n        bytes32 _nextId\\r\\n    ) external view returns (bytes32, bytes32);\\r\\n\\r\\n    function insert(\\r\\n        address owner,\\r\\n        uint256 _ICR,\\r\\n        bytes32 _prevId,\\r\\n        bytes32 _nextId\\r\\n    ) external returns (bytes32);\\r\\n\\r\\n    function getOwnerAddress(bytes32 _id) external pure returns (address);\\r\\n\\r\\n    function nonExistId() external view returns (bytes32);\\r\\n\\r\\n    function cdpCountOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function getCdpCountOf(\\r\\n        address owner,\\r\\n        bytes32 startNodeId,\\r\\n        uint maxNodes\\r\\n    ) external view returns (uint256, bytes32);\\r\\n\\r\\n    function getCdpsOf(address owner) external view returns (bytes32[] memory);\\r\\n\\r\\n    function getAllCdpsOf(\\r\\n        address owner,\\r\\n        bytes32 startNodeId,\\r\\n        uint maxNodes\\r\\n    ) external view returns (bytes32[] memory, uint256, bytes32);\\r\\n\\r\\n    function cdpOfOwnerByIndex(address owner, uint256 index) external view returns (bytes32);\\r\\n\\r\\n    function cdpOfOwnerByIdx(\\r\\n        address owner,\\r\\n        uint256 index,\\r\\n        bytes32 startNodeId,\\r\\n        uint maxNodes\\r\\n    ) external view returns (bytes32, bool);\\r\\n\\r\\n    function toCdpId(\\r\\n        address owner,\\r\\n        uint256 blockHeight,\\r\\n        uint256 nonce\\r\\n    ) external pure returns (bytes32);\\r\\n\\r\\n    function nextCdpNonce() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IActivePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IPool.sol\\\";\\r\\nimport \\\"./ITwapWeightedObserver.sol\\\";\\r\\n\\r\\ninterface IActivePool is IPool, ITwapWeightedObserver {\\r\\n    // --- Events ---\\r\\n    event ActivePoolEBTCDebtUpdated(uint256 _EBTCDebt);\\r\\n    event SystemCollSharesUpdated(uint256 _coll);\\r\\n    event FeeRecipientClaimableCollSharesIncreased(uint256 _coll, uint256 _fee);\\r\\n    event FeeRecipientClaimableCollSharesDecreased(uint256 _coll, uint256 _fee);\\r\\n    event FlashLoanSuccess(\\r\\n        address indexed _receiver,\\r\\n        address indexed _token,\\r\\n        uint256 _amount,\\r\\n        uint256 _fee\\r\\n    );\\r\\n    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function transferSystemCollShares(address _account, uint256 _amount) external;\\r\\n\\r\\n    function increaseSystemCollShares(uint256 _value) external;\\r\\n\\r\\n    function transferSystemCollSharesAndLiquidatorReward(\\r\\n        address _account,\\r\\n        uint256 _shares,\\r\\n        uint256 _liquidatorRewardShares\\r\\n    ) external;\\r\\n\\r\\n    function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external;\\r\\n\\r\\n    function claimFeeRecipientCollShares(uint256 _shares) external;\\r\\n\\r\\n    function feeRecipientAddress() external view returns (address);\\r\\n\\r\\n    function getFeeRecipientClaimableCollShares() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IRecoveryModeGracePeriod.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Interface for State Updates that can trigger RM Liquidations\\ninterface IRecoveryModeGracePeriod {\\n    event TCRNotified(uint256 TCR); /// NOTE: Mostly for debugging to ensure synch\\n\\n    // NOTE: Ts is implicit in events (it's added by GETH)\\n    event GracePeriodStart();\\n    event GracePeriodEnd();\\n    event GracePeriodDurationSet(uint256 _recoveryModeGracePeriodDuration);\\n\\n    function notifyStartGracePeriod(uint256 tcr) external;\\n\\n    function notifyEndGracePeriod(uint256 tcr) external;\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/ICollateralTokenOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * Based on the stETH:\\n *  -   https://docs.lido.fi/contracts/lido#\\n */\\ninterface ICollateralTokenOracle {\\n    // Return beacon specification data.\\n    function getBeaconSpec()\\n        external\\n        view\\n        returns (\\n            uint64 epochsPerFrame,\\n            uint64 slotsPerEpoch,\\n            uint64 secondsPerSlot,\\n            uint64 genesisTime\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IEbtcBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ninterface IEbtcBase {\\n    function priceFeed() external view returns (IPriceFeed);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/ICollateralToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * Based on the stETH:\\n *  -   https://docs.lido.fi/contracts/lido#\\n */\\ninterface ICollateralToken is IERC20 {\\n    // Returns the amount of shares that corresponds to _ethAmount protocol-controlled Ether\\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\\n\\n    // Returns the amount of Ether that corresponds to _sharesAmount token shares\\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\\n\\n    // Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);\\n\\n    // Returns the amount of shares owned by _account\\n    function sharesOf(address _account) external view returns (uint256);\\n\\n    // Returns authorized oracle address\\n    function getOracle() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n *\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     *\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\\n     * a value in the near future. The deadline argument can be set to uint256(-1) to\\n     * create Permits that effectively never expire.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function permitTypeHash() external view returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    // --- Events ---\\n\\n    event ETHBalanceUpdated(uint256 _newBalance);\\n    event EBTCBalanceUpdated(uint256 _newBalance);\\n    event CollSharesTransferred(address indexed _to, uint256 _amount);\\n\\n    // --- Functions ---\\n\\n    function getSystemCollShares() external view returns (uint256);\\n\\n    function getSystemDebt() external view returns (uint256);\\n\\n    function increaseSystemDebt(uint256 _amount) external;\\n\\n    function decreaseSystemDebt(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/ITwapWeightedObserver.sol\": {\r\n      \"content\": \"// SPDX-License Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\nimport {IBaseTwapWeightedObserver} from \\\"./IBaseTwapWeightedObserver.sol\\\";\\r\\n\\r\\ninterface ITwapWeightedObserver is IBaseTwapWeightedObserver {\\r\\n    event TwapDisabled();\\r\\n\\r\\n    function PERIOD() external view returns (uint256);\\r\\n\\r\\n    function valueToTrack() external view returns (uint128);\\r\\n\\r\\n    function timeToAccrue() external view returns (uint64);\\r\\n\\r\\n    function getLatestAccumulator() external view returns (uint128);\\r\\n\\r\\n    function observe() external returns (uint256);\\r\\n\\r\\n    function update() external;\\r\\n\\r\\n    function twapDisabled() external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IPriceFeed {\\r\\n    // --- Events ---\\r\\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\\r\\n    event PriceFeedStatusChanged(Status newStatus);\\r\\n    event FallbackCallerChanged(\\r\\n        address indexed _oldFallbackCaller,\\r\\n        address indexed _newFallbackCaller\\r\\n    );\\r\\n    event UnhealthyFallbackCaller(address indexed _fallbackCaller, uint256 timestamp);\\r\\n    event CollateralFeedSourceUpdated(address indexed stEthFeed);\\r\\n\\r\\n    // --- Structs ---\\r\\n\\r\\n    struct ChainlinkResponse {\\r\\n        uint80 roundEthBtcId;\\r\\n        uint80 roundStEthEthId;\\r\\n        uint256 answer;\\r\\n        uint256 timestampEthBtc;\\r\\n        uint256 timestampStEthEth;\\r\\n        bool success;\\r\\n    }\\r\\n\\r\\n    struct FallbackResponse {\\r\\n        uint256 answer;\\r\\n        uint256 timestamp;\\r\\n        bool success;\\r\\n    }\\r\\n\\r\\n    // --- Enum ---\\r\\n\\r\\n    enum Status {\\r\\n        chainlinkWorking,\\r\\n        usingFallbackChainlinkUntrusted,\\r\\n        bothOraclesUntrusted,\\r\\n        usingFallbackChainlinkFrozen,\\r\\n        usingChainlinkFallbackUntrusted\\r\\n    }\\r\\n\\r\\n    // --- Function ---\\r\\n    function fetchPrice() external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ebtc/packages/contracts/contracts/interfaces/IBaseTwapWeightedObserver.sol\": {\r\n      \"content\": \"// SPDX-License Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IBaseTwapWeightedObserver {\\r\\n    // NOTE: Packing manually is cheaper, but this is simpler to understand and follow\\r\\n    struct PackedData {\\r\\n        // Slot 0\\r\\n        // Seconds in a year: 3.154e+7\\r\\n        /// @dev Accumulator value recorded for TWAP Observer until last update\\r\\n        uint128 observerCumuVal; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171\\r\\n        /// @dev Accumulator for TWAP globally\\r\\n        uint128 accumulator; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171\\r\\n        // NOTE: We can further compress this slot but we will not be able to use only one (see u72 impl)\\r\\n        /// So what's the point of making the code more complex?\\r\\n\\r\\n        // Slot 1\\r\\n        /// @dev last update timestamp for TWAP Observer\\r\\n        uint64 lastObserved; // Thousands of Years, if we use relative time we can use u32 | Relative to deploy time (as immutable)\\r\\n        /// @dev last update timestamp for TWAP global track(spot) value\\r\\n        uint64 lastAccrued; // Thousands of years\\r\\n        // Expect eBTC debt to never surpass 100e27, which is 100 BILLION eBTC\\r\\n        // log_2(100e27) = 96.3359147517 | log_2(100e27 / 1e18) = 36.5412090438\\r\\n        // We could use a u64\\r\\n        /// @dev average value since last observe\\r\\n        uint128 lastObservedAverage;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ebtc/=lib/ebtc/packages/contracts/\",\r\n      \"@crytic/=lib/\",\r\n      \"ERC4626/=lib/properties/lib/ERC4626/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"ebtc/=lib/ebtc/\",\r\n      \"erc4626-tests/=lib/properties/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/properties/lib/openzeppelin-contracts/\",\r\n      \"properties/=lib/properties/contracts/\",\r\n      \"solmate/=lib/properties/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_wstEth\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_wEth\",\"type\":\"address\"},{\"internalType\":\"contract IStETH\",\"name\":\"_stEth\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_ebtc\",\"type\":\"address\"},{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"_borrowerOperations\",\"type\":\"address\"},{\"internalType\":\"contract ICdpManager\",\"name\":\"_cdpManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"enum IEbtcZapRouter.EthVariantZapOperationType\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCollateralIncrease\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralTokenDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stEthDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cdpOwner\",\"type\":\"address\"}],\"name\":\"ZapOperationEthVariant\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LIQUIDATOR_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CHANGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_NET_STETH_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalanceIncrease\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"addCollWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collBalanceIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useWstETHForDecrease\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"adjustCdp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalanceIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useWstETHForDecrease\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"adjustCdpWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_wethBalanceIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useWstETHForDecrease\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"adjustCdpWithWrappedEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_wstEthBalanceIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useWstETHForDecrease\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"adjustCdpWithWstEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cdpManager\",\"outputs\":[{\"internalType\":\"contract ICdpManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"closeCdp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"closeCdpForWstETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ebtc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"openCdp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"openCdpWithEth\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_wethBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"openCdpWithWrappedEth\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_wstEthBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEbtcZapRouter.PositionManagerPermit\",\"name\":\"_positionManagerPermit\",\"type\":\"tuple\"}],\"name\":\"openCdpWithWstEth\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stEth\",\"outputs\":[{\"internalType\":\"contract IStETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedEth\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstEth\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EbtcZapRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000661c70333aa1850ccdbae82776bb436a0fcfeefb000000000000000000000000d366e016ae0677cdce93472e603b75051e022ad0000000000000000000000000c4cbae499bb4ca41e78f52f07f5d98c375711774000000000000000000000000690c74af48be029e763e61b4adeb10e06119d3ba", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}