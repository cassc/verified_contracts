{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsCanvasIdStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title OpenAvatarGen0AssetsCanvasIdStore\\n * @dev This contracts stores a canvas ID.\\n */\\nabstract contract OpenAvatarGen0AssetsCanvasIdStore {\\n  /// @notice The canvas ID.\\n  uint8 public canvasId;\\n\\n  constructor(uint8 canvasId_) {\\n    canvasId = canvasId_;\\n  }\\n\\n  /**\\n   * @notice Get the canvas ID.\\n   * @return The canvas ID.\\n   */\\n  function getCanvasId() external view returns (uint8) {\\n    return canvasId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsCanvasStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {CanvasHeader, IOpenAvatarGen0AssetsCanvasStore} from '../interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {FuseGuard} from '../lib/FuseGuard.sol';\\nimport {KeepAlive} from '../lib/KeepAlive.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsCanvasStore\\n * @dev This contract stores canvas headers\\n * @dev This contract is used for off-chain rendering\\n */\\ncontract OpenAvatarGen0AssetsCanvasStore is IOpenAvatarGen0AssetsCanvasStore, FuseGuard, KeepAlive {\\n  /// @dev Event emitted when a canvas is added.\\n  event CanvasAdd(uint8 id);\\n\\n  /// @dev Event emitted when the fuse is burned to disable adding a new canvas.\\n  event FuseBurnedCanAddCanvas();\\n\\n  /// @dev Rvert error when canvas already exists.\\n  error CanvasAlreadyExists(uint8 id);\\n  /// @dev Revert error when canvas does not exist.\\n  error CanvasDoesNotExist(uint8 id);\\n  /// @dev Revert error when canvas size is invalid.\\n  error InvalidCanvasSize(uint8 width, uint8 height);\\n\\n  /// @dev The canvas bytes per pixel.\\n  /// @dev the only reason this is separate and named with CANVAS_ prefix is because\\n  // there is another one in PaletteStore and they conflict\\n  uint8 public constant CANVAS_BYTES_PER_PIXEL = 4; // RGBA\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The canvas ids.\\n  uint8[] public canvasIds;\\n  /// @dev The canvas headers.\\n  mapping(uint => CanvasHeader) public canvasHeaders;\\n  /// @dev Whether a canvas exists.\\n  mapping(uint => bool) public canvasExists;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for adding a new canvas.\\n  bool public fuseBurnedCanAddCanvas = false;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2; // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable adding a new canvas.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanAddCanvas() external onlyOwner {\\n    if (fuseBurnedCanAddCanvas) return;\\n    fuseBurnedCanAddCanvas = true;\\n    emit FuseBurnedCanAddCanvas();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable adding a new canvas.\\n   * @return Whether the fuse is burned to permanently disable adding a new canvas.\\n   */\\n  function isFuseBurnedCanAddCanvas() external view returns (bool) {\\n    return fuseBurnedCanAddCanvas;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Canvas\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Add a canvas to the store.\\n   * @param header The canvas header.\\n   */\\n  function addCanvas(CanvasHeader calldata header) external override onlyOwner {\\n    if (fuseBurnedCanAddCanvas) revert OperationBlockedByBurnedFuse();\\n    if (canvasExists[header.id]) revert CanvasAlreadyExists(header.id);\\n    if (header.width == 0 || header.height == 0) revert InvalidCanvasSize(header.width, header.height);\\n    canvasHeaders[header.id] = header;\\n    canvasIds.push(header.id);\\n    canvasExists[header.id] = true;\\n    emit CanvasAdd(header.id);\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The number of canvases stored in the contract.\\n   */\\n  function hasCanvas(uint8 id) external view override returns (bool) {\\n    return canvasExists[id];\\n  }\\n\\n  /**\\n   * @notice Return the canvas header.\\n   * @param id The canvas to query.\\n   * @return The canvas header.\\n   * @dev Returns all zeroes if the canvas does not exist.\\n   */\\n  function getCanvasHeader(uint8 id) external view override returns (CanvasHeader memory) {\\n    return canvasHeaders[id];\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The number of canvases stored in the contract.\\n   */\\n  function getNumCanvasIds() external view override returns (uint) {\\n    return canvasIds.length;\\n  }\\n\\n  /**\\n   * @notice Return the number of canvases stored in the contract.\\n   * @return The array of canvas ids stored in the contract.\\n   */\\n  function getCanvasIds() external view override returns (uint8[] memory) {\\n    return canvasIds;\\n  }\\n\\n  /**\\n   * @notice Return the height of the canvas.\\n   * @param id The canvas to query.\\n   * @return The height of the canvas.\\n   */\\n  function getCanvasHeight(uint8 id) public view override returns (uint8) {\\n    return canvasHeaders[id].height;\\n  }\\n\\n  /**\\n   * @notice Return the width of the canvas.\\n   * @param id The canvas to query.\\n   * @return The width of the canvas.\\n   */\\n  function getCanvasWidth(uint8 id) public view override returns (uint8) {\\n    return canvasHeaders[id].width;\\n  }\\n\\n  /**\\n   * @notice Return the number of bytes in the canvas.\\n   * @param id The canvas to query.\\n   * @return The number of bytes in the canvas.\\n   */\\n  function getCanvasNumBytes(uint8 id) public view override returns (uint) {\\n    return CANVAS_BYTES_PER_PIXEL * uint(canvasHeaders[id].width) * uint(canvasHeaders[id].height);\\n  }\\n\\n  /**\\n   * @notice Return the number of pixels in the canvas.\\n   * @param id The canvas to query.\\n   * @return The number of pixels in the canvas.\\n   */\\n  function getCanvasNumPixels(uint8 id) public view override returns (uint) {\\n    return uint(canvasHeaders[id].width) * uint(canvasHeaders[id].height);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsPaletteStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStore, UploadPaletteBatchInput, UploadPaletteInput} from '../interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {FuseGuard} from '../lib/FuseGuard.sol';\\nimport {KeepAlive} from '../lib/KeepAlive.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsPaletteStore\\n * @dev This contract stores color palettes by (code, index).\\n * @dev All palettes of a given code should be the same length.\\n */\\ncontract OpenAvatarGen0AssetsPaletteStore is IOpenAvatarGen0AssetsPaletteStore, FuseGuard, KeepAlive {\\n  /// @dev Error for invalid palette code.\\n  error InvalidPaletteCode(uint8 code);\\n  /// @dev Error for empty palette array.\\n  error EmptyPaletteArray();\\n  /// @dev Error for invalid palette index.\\n  error PaletteIndexOutOfBounds(uint8 code, uint8 index);\\n  /// @dev Error for palette already exists.\\n  error PaletteAlreadyExists(uint8 code, uint8 index);\\n  /// @dev Error for invalid palette length.\\n  error InvalidPaletteLength(uint length);\\n  /// @dev Error for invalid transparent color code.\\n  error InvalidTransparentColorCode(bytes4 code);\\n  /// @dev Event emitted when the fuse is burned to disable uploading a new palette.\\n  event FuseBurnedCanUploadPalette();\\n  /// @dev Event emitted when a palette is uploaded.\\n  event PaletteUpload(uint8 code, uint8 index);\\n\\n  /// @dev RGBA color depth.\\n  uint8 public constant DEPTH = 4;\\n  /// @dev Whether the canvas has an alpha channel.\\n  bool public constant HAS_ALPHA_CHANNEL = true;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The color palettes.\\n  /// @dev 5D array\\n  ///        bytes4 -----------> (red, green, blue, alpha) color\\n  ///        bytes4[] ---------> A color palette\\n  ///        bytes4[][] -------> A set of color palettes (for a palette code)\\n  ///        bytes4[][][] -----> All the color palette sets for all the palette codes\\n  bytes4[][][] public palettes;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for uploading a palette.\\n  bool public fuseBurnedCanUploadPalette = false;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Return whether the canvas has an alpha channel.\\n   * @return Whether the canvas has an alpha channel.\\n   */\\n  function hasAlphaChannel() external pure override returns (bool) {\\n    return HAS_ALPHA_CHANNEL;\\n  }\\n\\n  /**\\n   * @notice Return the number of bytes per pixel.\\n   * @return The number of bytes per pixel.\\n   */\\n  function getBytesPerPixel() public pure override returns (uint8) {\\n    return DEPTH;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6; // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable uploading a new palette.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanUploadPalette() external onlyOwner {\\n    if (fuseBurnedCanUploadPalette) return;\\n    fuseBurnedCanUploadPalette = true;\\n    emit FuseBurnedCanUploadPalette();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable uploading a new palette.\\n   * @return Whether the fuse is burned to permanently disable uploading a new palette.\\n   */\\n  function isFuseBurnedCanUploadPalette() external view returns (bool) {\\n    return fuseBurnedCanUploadPalette;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Palettes\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Get the number of palette codes.\\n   */\\n  function getNumPaletteCodes() external view override returns (uint) {\\n    return palettes.length;\\n  }\\n\\n  /**\\n   * @notice Get the number of palettes for the given layer and index.\\n   * @param code The palette code.\\n   */\\n  function getNumPalettes(uint8 code) external view override returns (uint) {\\n    return (code < palettes.length) ? palettes[code].length : 0;\\n  }\\n\\n  /**\\n   * @notice Get the palette for the given palette code and index.\\n   * @param code The code for which to get the palette.\\n   * @param index The index of the palette to get.\\n   * @return The palette for the given layer, pattern, index.\\n   * @dev Returns an empty array if the palette does not exist.\\n   */\\n  function getPalette(uint8 code, uint8 index) external view override returns (bytes4[] memory) {\\n    if (code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[code];\\n      if (index < codePalettes.length) {\\n        return codePalettes[index];\\n      }\\n    }\\n    // return empty array if not found\\n    return new bytes4[](0);\\n  }\\n\\n  /**\\n   * @notice Store the given palette in the contract\\n   * @param input The palette to store.\\n   */\\n  function uploadPalette(UploadPaletteInput calldata input) external override onlyOwner {\\n    // check fuse\\n    if (fuseBurnedCanUploadPalette) revert OperationBlockedByBurnedFuse();\\n\\n    // should always include transparent (will revert later if index 0 is not transparent)\\n    if (input.palette.length == 0) revert InvalidPaletteLength(input.palette.length);\\n\\n    // Base Case: palettes[code] does not exist yet\\n    if (input.code == palettes.length) {\\n      // create new array of palettes\\n      palettes.push(new bytes4[][](0));\\n    }\\n    // Append Case: palettes[code] exists\\n    if (input.code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[input.code];\\n\\n      // 3 cases:\\n      // 1. index == length, append (happy path)\\n      // 2. index < length, revert\\n      // 3. index > length, revert\\n      uint ct = codePalettes.length;\\n      if (input.index == ct) {\\n        // append\\n        // check that the first color is transparent\\n        if (input.palette[0] != 0x00000000) {\\n          revert InvalidTransparentColorCode(input.palette[0]);\\n        }\\n        // TODO: verify length of each palette matches the same as the first\\n        // palette uploaded for that code\\n        codePalettes.push(input.palette);\\n        emit PaletteUpload(input.code, input.index);\\n      } else if (input.index < ct) {\\n        // already exists\\n        revert PaletteAlreadyExists(input.code, input.index);\\n      } else {\\n        // index > ct out of bounds\\n        revert PaletteIndexOutOfBounds(input.code, input.index);\\n      }\\n    } else {\\n      // out of bounds\\n      revert InvalidPaletteCode(input.code);\\n    }\\n  }\\n\\n  /**\\n   * @notice Store the given palettes in the contract\\n   * @param input The paletted to store.\\n   */\\n  function uploadPaletteBatch(UploadPaletteBatchInput calldata input) external override onlyOwner {\\n    _uploadPaletteBatch(input);\\n  }\\n\\n  /**\\n   * @notice Store the given palettes in the contract\\n   * @param input The paletted to store.\\n   */\\n  function _uploadPaletteBatch(UploadPaletteBatchInput calldata input) internal {\\n    // check fuse\\n    if (fuseBurnedCanUploadPalette) revert OperationBlockedByBurnedFuse();\\n\\n    // should always include transparent (will revert later if index 0 is not transparent)\\n    if (input.palettes.length == 0) revert EmptyPaletteArray();\\n\\n    // Base Case: palettes[code] does not exist yet\\n    if (input.code == palettes.length) {\\n      // create new array of palettes\\n      palettes.push(new bytes4[][](0));\\n    }\\n    // Append Case: palettes[code] exists\\n    if (input.code < palettes.length) {\\n      bytes4[][] storage codePalettes = palettes[input.code];\\n\\n      // 3 cases:\\n      // 1. index == length, append (happy path)\\n      // 2. index < length, revert\\n      // 3. index > length, revert\\n      uint ct = codePalettes.length;\\n      if (input.fromIndex == ct) {\\n        // append all palettes\\n        uint len = input.palettes.length;\\n        for (uint i = 0; i < len; ) {\\n          bytes4[] calldata palette = input.palettes[i];\\n          // check that the first color is transparent\\n          if (palette[0] != 0x00000000) {\\n            revert InvalidTransparentColorCode(palette[0]);\\n          }\\n          // TODO: verify length of each palette matches?\\n          codePalettes.push(palette);\\n          emit PaletteUpload(input.code, uint8(i));\\n          unchecked {\\n            ++i;\\n          }\\n        }\\n      } else if (input.fromIndex < ct) {\\n        // already exists\\n        revert PaletteAlreadyExists(input.code, input.fromIndex);\\n      } else {\\n        // index > ct out of bounds\\n        revert PaletteIndexOutOfBounds(input.code, input.fromIndex);\\n      }\\n    } else {\\n      // out of bounds\\n      revert InvalidPaletteCode(input.code);\\n    }\\n  }\\n\\n  /**\\n   * @notice Batch upload multiple palette batches.\\n   * @param inputs The palette batches to upload.\\n   */\\n  function uploadPaletteBatches(UploadPaletteBatchInput[] calldata inputs) external override onlyOwner {\\n    uint len = inputs.length;\\n    for (uint i = 0; i < len; ) {\\n      _uploadPaletteBatch(inputs[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsPatternStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsPatternStore, OptionalPatternHeader, PatternHeader, PatternBlob, UploadPatternInput} from '../interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\nimport {OpenAvatarGen0AssetsCanvasStore} from './OpenAvatarGen0AssetsCanvasStore.sol';\\nimport {OpenAvatarGen0AssetsPaletteStore} from './OpenAvatarGen0AssetsPaletteStore.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsPatternStore\\n * @dev This contract stores assets via:\\n * - canvas\\n * - layer\\n * - pattern\\n * and for palettes, by:\\n * - palette code\\n * - palette\\n */\\ncontract OpenAvatarGen0AssetsPatternStore is\\n  IOpenAvatarGen0AssetsPatternStore,\\n  OpenAvatarGen0AssetsCanvasStore,\\n  OpenAvatarGen0AssetsPaletteStore\\n{\\n  /// @dev Event emitted when the fuse is burned to disable adding a new layer.\\n  event FuseBurnedCanAddLayer();\\n  /// @dev Event emitted when the fuse is burned to disable uploading a pattern.\\n  event FuseBurnedCanUploadPattern();\\n  /// @dev Event emitted when a layer is added to a canvas.\\n  event LayerAdd(uint8 canvasId, uint8 layer);\\n  /// @dev Event emitted when a pattern is uploaded.\\n  event PatternUpload(uint8 canvasId, uint8 layer, uint8 pattern);\\n\\n  /// @dev Revert error when layer already exists.\\n  error LayerAlreadyExists(uint8 canvasId, uint8 layer);\\n  /// @dev Revert error when layer index is out of bounds.\\n  error LayerIndexOutOfBounds(uint8 canvasId, uint8 layer);\\n  /// @dev Revert error when pattern has invalid length.\\n  error InvalidPatternLength(uint width, uint height, uint length);\\n  /// @dev Revert error when pattern already exists.\\n  error PatternAlreadyExists(uint8 canvasId, uint8 layer, uint8 index);\\n  /// @dev Revert error when pattern index is out of bounds.\\n  error PatternIndexOutOfBounds(uint8 canvasId, uint8 layer, uint8 index);\\n  /// @dev Revert error when palette code does not exist.\\n  error UnknownPaletteCode(uint8 code);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Each pattern has a corresponding header describing the pattern data\\n  /// @dev Every pattern is an arbitrary blob of bytes\\n  mapping(uint => PatternBlob[][]) public patterns;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for adding a new layer.\\n  bool public fuseBurnedCanAddLayer = false;\\n  /// @dev Flag to indicate if the fuse has been burned for uploading a pattern.\\n  bool public fuseBurnedCanUploadPattern = false;\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(\\n    address ownerProxy\\n  ) OpenAvatarGen0AssetsCanvasStore(ownerProxy) OpenAvatarGen0AssetsPaletteStore(ownerProxy) {}\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual override(OpenAvatarGen0AssetsCanvasStore, OpenAvatarGen0AssetsPaletteStore) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n      // pattern\\n      interfaceId == 0x32c8b38e || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreRead.\\n      interfaceId == 0xcd89a9e1 || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreWrite.\\n      interfaceId == 0xff411a6f; // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStore.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable adding a new layer.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanAddLayer() external onlyOwner {\\n    if (fuseBurnedCanAddLayer) return;\\n    fuseBurnedCanAddLayer = true;\\n    emit FuseBurnedCanAddLayer();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable adding a new layer.\\n   * @return Whether the fuse is burned to permanently disable adding a new layer.\\n   */\\n  function isFuseBurnedCanAddLayer() external view returns (bool) {\\n    return fuseBurnedCanAddLayer;\\n  }\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable uploading a new pattern.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanUploadPattern() external onlyOwner {\\n    if (fuseBurnedCanUploadPattern) return;\\n    fuseBurnedCanUploadPattern = true;\\n    emit FuseBurnedCanUploadPattern();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable uploading a new pattern.\\n   * @return Whether the fuse is burned to permanently disable uploading a new pattern.\\n   */\\n  function isFuseBurnedCanUploadPattern() external view returns (bool) {\\n    return fuseBurnedCanUploadPattern;\\n  }\\n\\n  /**************************************************************************\\n   * Helpers\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Pack four uint8 values into a single uint32.\\n   * @param a The first uint8 value.\\n   * @param b The second uint8 value.\\n   * @param c The third uint8 value.\\n   * @param d The fourth uint8 value.\\n   * @param e The fifth uint8 value.\\n   * @return The packed uint40 value.\\n   */\\n  function packUint40(uint8 a, uint8 b, uint8 c, uint8 d, uint8 e) public pure returns (uint40) {\\n    return (uint40(a) << 32) | (uint40(b) << 24) | (uint40(c) << 16) | (uint40(d) << 8) | uint40(e);\\n  }\\n\\n  /**************************************************************************\\n   * Layers\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Get the number of layers stored in the contract.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @return The number of layers stored in the contract.\\n   */\\n  function getNumLayers(uint8 canvasId) public view override returns (uint) {\\n    return patterns[canvasId].length;\\n  }\\n\\n  /**\\n   * @notice Add a new layer to the contract. The layer must not already exist. Layer indices may be skipped.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer to add.\\n   * @dev This function is only callable by the contract owner.\\n   */\\n  function addLayer(uint8 canvasId, uint8 layer) public override onlyOwner {\\n    if (fuseBurnedCanAddLayer) revert OperationBlockedByBurnedFuse();\\n    if (!canvasExists[canvasId]) revert CanvasDoesNotExist(canvasId);\\n    unchecked {\\n      // layers can be skipped when adding to reserve for later\\n      // so we need to fill in the skipped layers with empty arrays\\n      PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n      while (canvasPatterns.length < layer + 1) {\\n        canvasPatterns.push(new PatternBlob[](0));\\n      }\\n\\n      // now we have backfilled the layers, so procede with the main data\\n      PatternBlob[] storage patternsArrayForNewLayer = canvasPatterns[layer];\\n      if (patternsArrayForNewLayer.length == 0) {\\n        // transparent means no height/width/offsets\\n        // transparent layer has all zeros\\n        // transparent pattern is empty bytes\\n        patternsArrayForNewLayer.push(PatternBlob(PatternHeader(0, 0, 0, 0, 0), new bytes(0)));\\n        emit LayerAdd(canvasId, layer);\\n      } else {\\n        revert LayerAlreadyExists(canvasId, layer);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Add multiple layers to the contract. The layers must not already exist. Layer indices may be skipped.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layers_ The layers to add.\\n   * @dev This function is only callable by the contract owner.\\n   */\\n  function addLayers(uint8 canvasId, uint8[] calldata layers_) public override onlyOwner {\\n    if (!canvasExists[canvasId]) revert CanvasDoesNotExist(canvasId);\\n    uint len = layers_.length;\\n    for (uint i = 0; i < len; ) {\\n      addLayer(canvasId, layers_[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**************************************************************************\\n   * Patterns\\n   *************************************************************************/\\n\\n  /**\\n   * @notice Get the number of patterns for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the number of patterns.\\n   * @return The number of patterns for the given layer and index.\\n   */\\n  function getNumPatterns(uint8 canvasId, uint8 layer) public view override returns (uint) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      return canvasPatterns[layer].length;\\n    } else {\\n      // we have a choice to return 0 or revert\\n      // since any valid layer always has a transparent pattern, we can return 0\\n      // and callers can use that to determine if the layer exists without handling\\n      // a revert\\n      return 0;\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the pattern header for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the pattern header.\\n   * @param index The index of the pattern header to get.\\n   * @return The pattern header for the given layer and index.\\n   */\\n  function getPatternHeader(\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 index\\n  ) external view override returns (OptionalPatternHeader memory) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      PatternBlob[] storage layerPatterns = canvasPatterns[layer];\\n      if (index < layerPatterns.length) {\\n        return OptionalPatternHeader(true, layerPatterns[index].header);\\n      }\\n    }\\n    return OptionalPatternHeader(false, PatternHeader(0, 0, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @notice Get the pattern for the given layer and index.\\n   * @param canvasId The canvas for which to get the pattern data.\\n   * @param layer The layer for which to get the pattern data.\\n   * @param index The index of the pattern to get.\\n   * @return The pattern for the given layer and index.\\n   */\\n  function getPatternData(uint8 canvasId, uint8 layer, uint8 index) public view override returns (bytes memory) {\\n    PatternBlob[][] storage canvasPatterns = patterns[canvasId];\\n    if (layer < canvasPatterns.length) {\\n      PatternBlob[] storage layerPatterns = canvasPatterns[layer];\\n      if (index < layerPatterns.length) {\\n        return layerPatterns[index].data;\\n      }\\n    }\\n    return new bytes(0);\\n  }\\n\\n  /**\\n   * @notice Store the given pattern in the contract.\\n   * @param input The input.\\n   */\\n  function uploadPattern(UploadPatternInput calldata input) public override onlyOwner {\\n    if (fuseBurnedCanUploadPattern) revert OperationBlockedByBurnedFuse();\\n    if (!canvasExists[input.canvasId]) revert CanvasDoesNotExist(input.canvasId);\\n    // consistency checks\\n    if (input.data.length != uint(input.width) * uint(input.height)) {\\n      revert InvalidPatternLength(input.width, input.height, input.data.length);\\n    }\\n    if (input.paletteCode < palettes.length) {\\n      PatternBlob[][] storage canvasPatterns = patterns[input.canvasId];\\n      if (input.layer < canvasPatterns.length) {\\n        PatternBlob[] storage layerPatterns = canvasPatterns[input.layer];\\n        uint ct = layerPatterns.length;\\n\\n        // 3 cases:\\n        // 1. index == length, append (happy path)\\n        // 2. index < length, revert\\n        // 3. index > length, revert\\n        if (input.index == ct) {\\n          // append\\n          layerPatterns.push(\\n            PatternBlob(\\n              PatternHeader(input.width, input.height, input.offsetX, input.offsetY, input.paletteCode),\\n              input.data\\n            )\\n          );\\n\\n          emit PatternUpload(input.canvasId, input.layer, input.index);\\n        } else if (input.index < ct) {\\n          // already exists\\n          revert PatternAlreadyExists(input.canvasId, input.layer, input.index);\\n        } else {\\n          // out of bounds\\n          revert PatternIndexOutOfBounds(input.canvasId, input.layer, input.index);\\n        }\\n      } else {\\n        revert LayerIndexOutOfBounds(input.canvasId, input.layer);\\n      }\\n    } else {\\n      revert UnknownPaletteCode(input.paletteCode);\\n    }\\n  }\\n\\n  /**\\n   * @notice Batch upload multiple patterns.\\n   * @param inputs The uploadPattern inputs.\\n   */\\n  function uploadPatterns(UploadPatternInput[] calldata inputs) public override onlyOwner {\\n    if (fuseBurnedCanUploadPattern) revert OperationBlockedByBurnedFuse();\\n    uint len = inputs.length;\\n    for (uint i = 0; i < len; ) {\\n      uploadPattern(inputs[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n// Adapted from:\\n// https://github.com/Brechtpd/base64/blob/4d85607b18d981acff392d2e99ba654305552a97/base64.sol\\n\\n// solhint-disable no-empty-blocks\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n  string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n  bytes internal constant TABLE_DECODE =\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'00000000000000000000003e0000003f3435363738393a3b3c3d000000000000'\\n    hex'00000102030405060708090a0b0c0d0e0f101112131415161718190000000000'\\n    hex'001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000';\\n\\n  function encode(bytes memory data) internal pure returns (bytes memory) {\\n    if (data.length == 0) return '';\\n\\n    // load the table into memory\\n    string memory table = TABLE_ENCODE;\\n\\n    // multiply by 4/3 rounded up\\n    uint encodedLen = 4 * ((data.length + 2) / 3);\\n\\n    // add some extra buffer at the end required for the writing\\n    bytes memory result = new bytes(encodedLen + 32);\\n\\n    assembly {\\n      // set the actual output length\\n      mstore(result, encodedLen)\\n\\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n\\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n\\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n\\n      // run over the input, 3 bytes at a time\\n      for {\\n\\n      } lt(dataPtr, endPtr) {\\n\\n      } {\\n        // read 3 bytes\\n        dataPtr := add(dataPtr, 3)\\n        let input := mload(dataPtr)\\n\\n        // write 4 characters\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n      }\\n\\n      // padding with '='\\n      switch mod(mload(data), 3)\\n      case 1 {\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n      }\\n      case 2 {\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  function decode(string memory _data) internal pure returns (bytes memory) {\\n    bytes memory data = bytes(_data);\\n\\n    if (data.length == 0) return new bytes(0);\\n    require(data.length % 4 == 0, 'invalid base64 decoder input');\\n\\n    // load the table into memory\\n    bytes memory table = TABLE_DECODE;\\n\\n    // every 4 characters represent 3 bytes\\n    uint decodedLen = (data.length / 4) * 3;\\n\\n    // add some extra buffer at the end required for the writing\\n    bytes memory result = new bytes(decodedLen + 32);\\n\\n    assembly {\\n      // padding with '='\\n      let lastBytes := mload(add(data, mload(data)))\\n      if eq(and(lastBytes, 0xFF), 0x3d) {\\n        decodedLen := sub(decodedLen, 1)\\n        if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n          decodedLen := sub(decodedLen, 1)\\n        }\\n      }\\n\\n      // set the actual output length\\n      mstore(result, decodedLen)\\n\\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n\\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n\\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n\\n      // run over the input, 4 characters at a time\\n      for {\\n\\n      } lt(dataPtr, endPtr) {\\n\\n      } {\\n        // read 4 characters\\n        dataPtr := add(dataPtr, 4)\\n        let input := mload(dataPtr)\\n\\n        // write 3 bytes\\n        let output := add(\\n          add(\\n            shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n            shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))\\n          ),\\n          add(\\n            shl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)),\\n            and(mload(add(tablePtr, and(input, 0xFF))), 0xFF)\\n          )\\n        )\\n        mstore(resultPtr, shl(232, output))\\n        resultPtr := add(resultPtr, 3)\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/registry/ENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n  /**\\n   * @dev Returns the address that owns the specified node.\\n   * @param node The specified node.\\n   * @return address of the owner.\\n   */\\n  function owner(bytes32 node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/reverseRegistrar/IReverseRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface IReverseRegistrar {\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      calling account.\\n   * @param owner The address to set as the owner of the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claim(address owner) external returns (bytes32);\\n\\n  /**\\n   * @dev Sets the `name()` record for the reverse ENS record associated with\\n   * the calling account. First updates the resolver to the default reverse\\n   * resolver if necessary.\\n   * @param name The name to set for this address.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setName(string memory name) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/IERC634.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IERC634: Text Data Interface\\n * @dev This is the same as EIP-634 with different variable names\\n * - rename node -> dna\\n * - +calldata for key in text()\\n * - +external for text()\\n * - +memory for return value of text()\\n */\\ninterface IERC634 {\\n  /**\\n   * @notice Returns the text data associated with a DNA\\n   * @param dna A DNA to lookup text data for\\n   * @param key A key to lookup text data for\\n   * @return text The text data\\n   */\\n  function text(bytes32 dna, string calldata key) external view returns (string memory text);\\n}\\n\"\r\n    },\r\n    \"contracts/core/erc721/AOpenAvatarMintStateMachine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {FuseGuard} from '../lib/FuseGuard.sol';\\n\\n/**\\n * @title AOpenAvatarMintStateMachine\\n * @notice A contract that manages the mint state machine.\\n */\\nabstract contract AOpenAvatarMintStateMachine is FuseGuard, Ownable {\\n  /// @dev The mint states.\\n  enum MintState {\\n    PermanentlyDisabled,\\n    Disabled,\\n    OnlyOwner,\\n    PublicPendingBlockTimestamp,\\n    Public\\n  }\\n\\n  /// @dev Event emitted when the fuse is burned to disable changing the mint state.\\n  event FuseBurnedCanChangeMintState();\\n  /// @dev Event emitted when the fuse is burned to disable changing the public mint time.\\n  event FuseBurnedCanChangePublicMintTime();\\n  /// @dev Event emitted when the mint state changes.\\n  event MintStateChange(MintState state);\\n  /// @dev Event emitted when the public mint time changes.\\n  event PublicMintTimeChange(uint time);\\n\\n  /// @dev Revert error when mint is permanently disabled.\\n  error MintPermanentlyDisabled();\\n  /// @dev Revert error when public mint is not yet started.\\n  error PublicMintNotStarted();\\n  /// @dev Revert error when public mint is disabled.\\n  error MintDisabled();\\n  /// @dev Revert error when public mint is not authorized.\\n  error MintNotAuthorized();\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The current mint state.\\n  MintState public mintStatus = MintState.Disabled;\\n\\n  /// @dev The time when public minting will be enabled, if pending public mint time.\\n  uint256 public publicMintTime;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for changing the mint state.\\n  bool public fuseBurnedCanChangeMintState = false;\\n  /// @dev Flag to indicate if the fuse has been burned for changing the public mint time.\\n  bool public fuseBurnedCanChangePublicMintTime = false;\\n\\n  /**\\n   * @notice Sets whether mint is active.\\n   * @param val True to enable mint, false to disable.\\n   * @dev Only callable by owner.\\n   * @dev reverts if mint is fuse is burned\\n   * @dev no-op if mint is already set to the desired value\\n   * @dev reverts if mint is permanently disabled\\n   */\\n  function setMintState(MintState val) external onlyOwner {\\n    if (fuseBurnedCanChangeMintState) revert OperationBlockedByBurnedFuse();\\n    if (val == mintStatus) return;\\n    if (mintStatus == MintState.PermanentlyDisabled) revert MintPermanentlyDisabled();\\n    mintStatus = val;\\n    emit MintStateChange(val);\\n  }\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable changing the mint state.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanChangeMintState() external onlyOwner {\\n    if (fuseBurnedCanChangeMintState) return;\\n    fuseBurnedCanChangeMintState = true;\\n    emit FuseBurnedCanChangeMintState();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable changing the mint state.\\n   * @return Whether the fuse is burned to permanently disable changing the mint state.\\n   */\\n  function isFuseBurnedCanChangeMintState() external view returns (bool) {\\n    return fuseBurnedCanChangeMintState;\\n  }\\n\\n  /**\\n   * @notice Get the public mint time.\\n   * @return The public mint time.\\n   */\\n  function getPublicMintTime() external view returns (uint256) {\\n    return publicMintTime;\\n  }\\n\\n  /**\\n   * @notice Set the public mint time.\\n   * @param _publicMintTime The public mint time.\\n   * @dev reverts if fuse is burned\\n   */\\n  function setPublicMintTime(uint256 _publicMintTime) external onlyOwner {\\n    if (fuseBurnedCanChangePublicMintTime) revert OperationBlockedByBurnedFuse();\\n    if (publicMintTime == _publicMintTime) return;\\n    publicMintTime = _publicMintTime;\\n    emit PublicMintTimeChange(_publicMintTime);\\n  }\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable changing the public mint time.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanChangePublicMintTime() external onlyOwner {\\n    if (fuseBurnedCanChangePublicMintTime) return;\\n    fuseBurnedCanChangePublicMintTime = true;\\n    emit FuseBurnedCanChangePublicMintTime();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable changing the public mint time.\\n   * @return Whether the fuse is burned to permanently disable changing the public mint time.\\n   */\\n  function isFuseBurnedCanChangePublicMintTime() external view returns (bool) {\\n    return fuseBurnedCanChangePublicMintTime;\\n  }\\n\\n  /**\\n   * @notice Returns the current mint state.\\n   * @return The current mint state.\\n   */\\n  function getMintState() external view returns (MintState) {\\n    return mintStatus;\\n  }\\n\\n  /**\\n   * @notice Returns whether mint state is public.\\n   * @return True if mint state is public, false otherwise.\\n   */\\n  function isMintPublic() external view returns (bool) {\\n    return mintStatus == MintState.Public;\\n  }\\n\\n  /**\\n   * @notice Returns whether mint state is public pending block timestamp.\\n   * @return True if mint state is public pending block timestamp, false otherwise.\\n   */\\n  function isMintPublicPendingBlockTimestamp() external view returns (bool) {\\n    return mintStatus == MintState.PublicPendingBlockTimestamp;\\n  }\\n\\n  /**\\n   * @notice Returns whether mint state is only owner can mint.\\n   * @return True if mint state is only owner can mint, false otherwise.\\n   */\\n  function isMintOnlyOwner() external view returns (bool) {\\n    return mintStatus == MintState.OnlyOwner;\\n  }\\n\\n  /**\\n   * @notice Returns whether mint state is paused or permanently disabled.\\n   * @return True if mint state is paused or permanently disabled, false otherwise.\\n   */\\n  function isMintDisabled() external view returns (bool) {\\n    return mintStatus == MintState.Disabled || mintStatus == MintState.PermanentlyDisabled;\\n  }\\n\\n  /**\\n   * @notice Returns whether mint state is permanently disabled.\\n   * @return True if mint state is permanently disabled, false otherwise.\\n   */\\n  function isMintPermanentlyDisabled() external view returns (bool) {\\n    return mintStatus == MintState.PermanentlyDisabled;\\n  }\\n\\n  ////////////////////////// modifiers //////////////////////////\\n\\n  /**\\n   * @notice Modifier to check if mint is public.\\n   * ----------------------------------------------------------------------\\n   * |  MintState                     |  Owner  |  Non-owner  |  Result  |\\n   * ----------------------------------------------------------------------\\n   * |  PermanentlyDisabled           |   No    |     No      |  Revert  |\\n   * ----------------------------------------------------------------------\\n   * |  Disabled                      |   No    |     No      |  Revert  |\\n   * ----------------------------------------------------------------------\\n   * |  OnlyOwner                     |   Yes   |     No      |  Proceed |\\n   * ----------------------------------------------------------------------\\n   * |  PublicPendingBlockTimestamp   |   No    |     No      |  Revert  |\\n   * |  (Before Time)                 |         |             |          |\\n   * ----------------------------------------------------------------------\\n   * |  PublicPendingBlockTimestamp   |   Yes   |     Yes     |  Proceed |\\n   * |  (At/After Time)               |         |             |          |\\n   * ----------------------------------------------------------------------\\n   * |  Public                        |   Yes   |     Yes     |  Proceed |\\n   * ----------------------------------------------------------------------\\n   * @dev Reverts if mint is not authorized.\\n   */\\n  modifier onlyAuthorizedMint() {\\n    if (mintStatus == MintState.Public) {\\n      // CASE 1: mint is public\\n      _;\\n    } else if (mintStatus == MintState.PublicPendingBlockTimestamp) {\\n      // CASE 2: mint is public pending block timestamp\\n      //\\n      // in our normal scenario, this will only happen once, unless contract owner puts it back to public\\n      // pending block timestamp\\n      //\\n      // we are going to check the block timestamp to see if it is greater than or equal to the public mint time\\n      // if it is, we will update the mint state to public\\n      // otherwise, we will revert with an error\\n      //\\n      // solhint-disable-next-line not-rely-on-time\\n      if (block.timestamp < publicMintTime) {\\n        // CASE 2.1: && block timestamp is NOT greater than public mint time\\n        // => mint is not yet public so revert\\n        //\\n        // this happens if callers try to mint before the public mint time\\n        //\\n        revert PublicMintNotStarted();\\n      } else {\\n        // CASE 2.2: && block timestamp IS greater than or equal public mint time\\n        // => update the mint state to public\\n        // => mint is now public so continue\\n        //\\n        // this will only happen once, unless contract owner puts it back to public\\n        // pending block timestamp\\n        //\\n        mintStatus = MintState.Public;\\n        emit MintStateChange(MintState.Public);\\n      }\\n    } else if (mintStatus == MintState.OnlyOwner) {\\n      // CASE 3: mint is only owner\\n      //\\n      // this should be the normal scenario with a single boolean check\\n      if (owner() == _msgSender()) {\\n        // CASE 3.1: && caller is owner\\n        // => mint is only owner && caller is owner so continue\\n        _;\\n      } else {\\n        // CASE 3.2: && caller is NOT owner\\n        // => mint is only owner && caller is NOT owner so revert\\n        revert MintNotAuthorized();\\n      }\\n    } else if (mintStatus == MintState.Disabled) {\\n      revert MintDisabled();\\n    } else {\\n      revert MintPermanentlyDisabled();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/erc721/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title Treasury\\n * @dev The Treasury contract is a contract that holds funds for the protocol.\\n */\\nabstract contract Treasury is Ownable {\\n  event TreasuryWithdrawal(address indexed to, uint amount);\\n\\n  /**\\n   * @notice Withdraw funds from the contract.\\n   * @param amount The amount to withdraw.\\n   * @dev Only the owner can withdraw funds.\\n   */\\n  function withdraw(uint amount) public onlyOwner {\\n    require(amount <= address(this).balance, 'Insufficient balance');\\n    payable(msg.sender).transfer(amount);\\n    emit TreasuryWithdrawal(msg.sender, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nstruct CanvasHeader {\\n  uint8 id;\\n  uint8 width;\\n  uint8 height;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreRead\\n * @dev This interface reads canvas headers.\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreRead {\\n  function hasCanvas(uint8 id) external view returns (bool);\\n\\n  function getCanvasHeader(uint8 id) external view returns (CanvasHeader memory);\\n\\n  function getNumCanvasIds() external view returns (uint);\\n\\n  function getCanvasIds() external view returns (uint8[] memory);\\n\\n  function getCanvasHeight(uint8 id) external view returns (uint8);\\n\\n  function getCanvasWidth(uint8 id) external view returns (uint8);\\n\\n  function getCanvasNumBytes(uint8 id) external view returns (uint);\\n\\n  function getCanvasNumPixels(uint8 id) external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreWrite\\n * @dev This interface writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  function addCanvas(CanvasHeader calldata header) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStore\\n * @dev This interface reads and writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStore is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsCanvasStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreRead\\n * @dev This interface allows reading from the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function hasAlphaChannel() external view returns (bool);\\n\\n  function getBytesPerPixel() external view returns (uint8);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Palettes\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPaletteCodes() external view returns (uint);\\n\\n  function getNumPalettes(uint8 code) external view returns (uint);\\n\\n  function getPalette(uint8 code, uint8 index) external view returns (bytes4[] memory);\\n}\\n\\nstruct UploadPaletteInput {\\n  uint8 code;\\n  uint8 index;\\n  bytes4[] palette;\\n}\\n\\nstruct UploadPaletteBatchInput {\\n  uint8 code;\\n  uint8 fromIndex;\\n  bytes4[][] palettes;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreWrite\\n * @dev This interface allows writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreWrite {\\n  function uploadPalette(UploadPaletteInput calldata input) external;\\n\\n  function uploadPaletteBatch(UploadPaletteBatchInput calldata input) external;\\n\\n  function uploadPaletteBatches(UploadPaletteBatchInput[] calldata input) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStore\\n * @dev This interface allows reading from and writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStore is\\n  IOpenAvatarGen0AssetsPaletteStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './IOpenAvatarGen0AssetsPaletteStore.sol';\\n\\nstruct PatternHeader {\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n}\\n\\nstruct OptionalPatternHeader {\\n  /// @dev true if the header exists\\n  bool exists;\\n  /// @dev the pattern header\\n  /// @dev all zeroes is valid header\\n  PatternHeader header;\\n}\\n\\nstruct PatternBlob {\\n  /// @dev the pattern header\\n  PatternHeader header;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\nstruct UploadPatternInput {\\n  /// @dev the canvas id\\n  uint8 canvasId;\\n  /// @dev index of the layer within the canvas\\n  uint8 layer;\\n  /// @dev index of the pattern within the layer\\n  uint8 index;\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreRead\\n * @dev This interface reads pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreRead is IOpenAvatarGen0AssetsCanvasStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumLayers(uint8 canvasId) external view returns (uint);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPatterns(uint8 canvasId, uint8 layer) external view returns (uint);\\n\\n  function getPatternHeader(\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 index\\n  ) external view returns (OptionalPatternHeader memory);\\n\\n  function getPatternData(uint8 canvasId, uint8 layer, uint8 index) external view returns (bytes memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreWrite\\n * @dev This interface writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreWrite is IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function addLayer(uint8 canvasId, uint8 layer) external;\\n\\n  function addLayers(uint8 canvasId, uint8[] calldata layers) external;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function uploadPattern(UploadPatternInput calldata input) external;\\n\\n  function uploadPatterns(UploadPatternInput[] calldata inputs) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStore\\n * @dev This interface reads and writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStore is\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsCanvasStore\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PatternHeader} from '../assets/IOpenAvatarGen0AssetsPatternStore.sol';\\n\\nstruct LayerPatternPalette {\\n  uint8 layer;\\n  uint8 pattern;\\n  uint8 palette;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasLayerCompositor\\n * @dev This contract composes palettized patterns into a single image.\\n */\\ninterface IOpenAvatarGen0AssetsCanvasLayerCompositor {\\n  function createLayerComposition(\\n    uint8 canvasId,\\n    // is view function, so not concerned about calldata being cheaper\\n    // need memory because this function is called by other functions that\\n    // may compute layers dynamically in memory\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) external view returns (bytes memory);\\n\\n  function drawLayerComposition(\\n    bytes memory out,\\n    uint8 canvasId,\\n    // is view function, so not concerned about calldata being cheaper\\n    // need memory because this function is called by other functions that\\n    // may compute layers dynamically in memory\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) external view returns (bytes memory);\\n\\n  function drawLayer(\\n    bytes memory image,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) external view returns (bytes memory);\\n\\n  function drawMaskedLayer(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) external view returns (bytes memory);\\n\\n  function drawPattern(\\n    bytes memory image,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) external view returns (bytes memory);\\n\\n  function drawMaskedPattern(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/render/IOpenAvatarGen0CanvasRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\ninterface IOpenAvatarGen0CanvasRenderer {\\n  function drawOpenAvatar(uint8 canvasId, bytes32 dna) external view returns (bytes memory);\\n\\n  function drawOpenAvatarOverlay(bytes memory image, uint8 canvasId, bytes32 dna) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/Adler32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Adler32\\n * @notice This contract implements the Adler32 checksum algorithm.\\n */\\nlibrary Adler32 {\\n  function adler32(bytes memory self, uint offset, uint end) internal pure returns (uint32) {\\n    unchecked {\\n      uint32 a = 1;\\n      uint32 b = 0;\\n\\n      // Process each byte of the data in order\\n      for (uint i = offset; i < end; i++) {\\n        a = (a + uint32(uint8(self[i]))) % 65521;\\n        b = (b + a) % 65521;\\n      }\\n\\n      // The Adler-32 checksum is stored as a 4-byte value\\n      return (b << 16) | a;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/CRC32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title CRC32\\n * @notice This contract implements the CRC32 checksum algorithm.\\n */\\nlibrary CRC32 {\\n  // CRC32 algorithm: https://en.wikipedia.org/wiki/Cyclic_redundancy_check\\n  /**\\n   * @dev Calculates the CRC32 checksum of a chunk of data.\\n   * @param self The data to calculate the checksum of.\\n   * @param start The start index of the data.\\n   * @param end The end index of the data.\\n   * @return checksum The CRC32 checksum of the data.\\n   */\\n  function crc32(bytes memory self, uint start, uint end) internal pure returns (uint32 checksum) {\\n    // Initialize the checksum to 0xffffffff\\n    checksum = 0xffffffff;\\n\\n    // Loop through each byte of the chunk data\\n    for (uint i = start; i < end; i++) {\\n      // XOR the byte with the checksum\\n      checksum = checksum ^ uint8(self[i]);\\n      // Loop through each bit of the byte\\n      for (uint j = 0; j < 8; j++) {\\n        // If the LSB of the checksum is 1\\n        if ((checksum & 1) == 1) {\\n          // 0xEDB88320 is the CRC-32 polynomial in reversed bit order\\n          // this translates to the polynomial with equation\\n          // x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\\n          // which is the same as the one used in the PNG specification\\n          checksum = (checksum >> 1) ^ 0xedb88320;\\n        }\\n        // If the LSB of the checksum is 0\\n        else {\\n          // Shift the checksum right by 1 bit\\n          checksum = (checksum >> 1);\\n        }\\n      }\\n    }\\n\\n    // Return the inverted checksum\\n    return ~checksum;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/DNA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n *  @title DNA\\n *  @notice This library implements the DNA as defined by OpenAvatar.\\n *  @dev The DNA string is a 32-byte hex string. The DNA string is immutable.\\n *  The bytes represent the following:\\n *  ZZZZ YYYY XXXX WWWW VVVV UUUU TTTT SSSS\\n *  0000 0000 0000 0000 0000 0000 0000 0000\\n *\\n *    Bytes  |  Chars  | Description\\n *  ---------|---------|-------------\\n *   [0:1]   | [0:3]   |  body\\n *   [2:3]   | [4:7]   |  tattoos\\n *   [4:5]   | [8:11]  |  makeup\\n *   [6:7]   | [12:15] |  left eye\\n *   [8:9]   | [16:19] |  right eye\\n *   [10:11] | [20:23] |  bottomwear\\n *   [12:13] | [24:27] |  footwear\\n *   [14:15] | [28:31] |  topwear\\n *   [16:17] | [32:35] |  handwear\\n *   [18:19] | [36:39] |  outerwear\\n *   [20:21] | [40:43] |  jewelry\\n *   [22:23] | [44:47] |  facial hair\\n *   [24:25] | [48:51] |  facewear\\n *   [26:27] | [52:55] |  eyewear\\n *   [28:29] | [56:59] |  hair\\n *   [30:31] | [60:63] |  reserved\\n *\\n *  Each 2-byte section is a struct of the following:\\n *    [0] | [0:1] |  pattern\\n *    [1] | [2:3] |  palette\\n *\\n * The pattern is an index into the pattern array.\\n * The palette is an index into the palette array.\\n */\\nlibrary DNA {\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Body\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [0:1]\\n\\n  /// @notice Returns the body pattern index from the DNA.\\n  function bodyPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[0]);\\n  }\\n\\n  /// @notice Returns the body palette index from the DNA.\\n  function bodyPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[1]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Tattoos\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [2:3]\\n\\n  /// @notice Returns the tattoos pattern index from the DNA.\\n  function tattoosPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[2]);\\n  }\\n\\n  /// @notice Returns the tattoos palette index from the DNA.\\n  function tattoosPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[3]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Makeup\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [4:5]\\n\\n  /// @notice Returns the makeup pattern index from the DNA.\\n  function makeupPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[4]);\\n  }\\n\\n  /// @notice Returns the makeup palette index from the DNA.\\n  function makeupPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[5]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Left Eye\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [6:7]\\n\\n  /// @notice Returns the left eye pattern index from the DNA.\\n  function leftEyePattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[6]);\\n  }\\n\\n  /// @notice Returns the left eye palette index from the DNA.\\n  function leftEyePalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[7]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Right Eye\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [8:9]\\n\\n  /// @notice Returns the right eye pattern index from the DNA.\\n  function rightEyePattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[8]);\\n  }\\n\\n  /// @notice Returns the right eye palette index from the DNA.\\n  function rightEyePalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[9]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Bottomwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [10:11]\\n\\n  /// @notice Returns the bottomwear pattern index from the DNA.\\n  function bottomwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[10]);\\n  }\\n\\n  /// @notice Returns the bottomwear palette index from the DNA.\\n  function bottomwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[11]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Footwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [12:13]\\n\\n  /// @notice Returns the footwear pattern index from the DNA.\\n  function footwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[12]);\\n  }\\n\\n  /// @notice Returns the footwear palette index from the DNA.\\n  function footwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[13]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Topwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [14:15]\\n\\n  /// @notice Returns the topwear pattern index from the DNA.\\n  function topwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[14]);\\n  }\\n\\n  /// @notice Returns the topwear palette index from the DNA.\\n  function topwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[15]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Handwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [16:17]\\n\\n  /// @notice Returns the handwear pattern index from the DNA.\\n  function handwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[16]);\\n  }\\n\\n  /// @notice Returns the handwear palette index from the DNA.\\n  function handwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[17]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Outerwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [18:19]\\n\\n  /// @notice Returns the outerwear pattern index from the DNA.\\n  function outerwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[18]);\\n  }\\n\\n  /// @notice Returns the outerwear palette index from the DNA.\\n  function outerwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[19]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Jewelry\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [20:21]\\n\\n  /// @notice Returns the jewelry pattern index from the DNA.\\n  function jewelryPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[20]);\\n  }\\n\\n  /// @notice Returns the jewelry palette index from the DNA.\\n  function jewelryPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[21]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Facial Hair\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [22:23]\\n\\n  /// @notice Returns the facial hair pattern index from the DNA.\\n  function facialHairPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[22]);\\n  }\\n\\n  /// @notice Returns the facial hair palette index from the DNA.\\n  function facialHairPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[23]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Facewear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [24:25]\\n\\n  /// @notice Returns the facewear pattern index from the DNA.\\n  function facewearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[24]);\\n  }\\n\\n  /// @notice Returns the facewear palette index from the DNA.\\n  function facewearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[25]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Eyewear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [26:27]\\n\\n  /// @notice Returns the eyewear pattern index from the DNA.\\n  function eyewearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[26]);\\n  }\\n\\n  /// @notice Returns the eyewear palette index from the DNA.\\n  function eyewearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[27]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Hair\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [28:29]\\n\\n  /// @notice Returns the hair pattern index from the DNA.\\n  function hairPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[28]);\\n  }\\n\\n  /// @notice Returns the hair palette index from the DNA.\\n  function hairPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[29]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/ENSReverseClaimer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {ENS} from '../dependencies/ens/registry/ENS.sol';\\nimport {IReverseRegistrar} from '../dependencies/ens/reverseRegistrar/IReverseRegistrar.sol';\\n\\n/**\\n * @title ENSReverseClaimer\\n * @dev This contract is used to claim reverse ENS records.\\n */\\nabstract contract ENSReverseClaimer is Ownable {\\n  /// @dev The namehash of 'addr.reverse', the domain at which reverse records\\n  ///      are stored in ENS.\\n  bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      contract.\\n   * @param ens The ENS registry.\\n   * @param claimant The address to set as the owner of the reverse record in\\n   *                 ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claimReverseENS(ENS ens, address claimant) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).claim(claimant);\\n  }\\n\\n  /**\\n   * @dev Sets the reverse ENS record associated with the contract.\\n   * @param ens The ENS registry.\\n   * @param name The name to set as the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setReverseENS(ENS ens, string calldata name) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).setName(name);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/FuseGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title FuseGuard\\n * @dev A contract that manages fuses.\\n */\\nabstract contract FuseGuard {\\n  /// @dev Revert error when operation is blocked by burned fuse.\\n  error OperationBlockedByBurnedFuse();\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/ImageEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {Base64} from '../dependencies/Base64.sol';\\nimport {PNG} from './PNG.sol';\\n\\n/**\\n * @title ImageEncoder\\n * @dev A library for encoding images as PNG or SVG.\\n */\\ncontract ImageEncoder is PNG {\\n  /**\\n   * @notice Encodes the image as a Base64-encoded PNG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image data, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @return The encoded Base64-encoded PNG.\\n   */\\n  function encodeBase64PNG(bytes memory data, uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    bytes memory png = encodePNG(data, width, height, alpha);\\n    return Base64.encode(png);\\n  }\\n\\n  /**\\n   * @notice Encodes the image as an SVG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @param svgWidth Width of the scaled SVG, in pixels.\\n   * @param svgHeight Height of the scaled SVG, in pixels.\\n   * @return The encoded SVG.\\n   */\\n  function encodeSVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (bytes memory) {\\n    bytes memory base64PNG = encodeBase64PNG(data, width, height, alpha);\\n    string memory svgWidthStr = Strings.toString(svgWidth);\\n    string memory svgHeightStr = Strings.toString(svgHeight);\\n    return\\n      abi.encodePacked(\\n        '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 ',\\n        svgWidthStr,\\n        ' ',\\n        svgHeightStr,\\n        '\\\">\\\\n\\\\t<foreignObject width=\\\"',\\n        svgWidthStr,\\n        '\\\" height=\\\"',\\n        svgHeightStr,\\n        '\\\">\\\\n\\\\t\\\\t<img xmlns=\\\"http://www.w3.org/1999/xhtml\\\" width=\\\"',\\n        svgWidthStr,\\n        '\\\" height=\\\"',\\n        svgHeightStr,\\n        '\\\" style=\\\"image-rendering: pixelated;\\\" src=\\\"data:image/png;base64,',\\n        base64PNG,\\n        '\\\"/>\\\\n\\\\t</foreignObject>\\\\n</svg>'\\n      );\\n  }\\n\\n  /**\\n   * @notice Encodes the image as a Base64-encoded SVG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @param svgWidth Width of the scaled SVG, in pixels.\\n   * @param svgHeight Height of the scaled SVG, in pixels.\\n   * @return The encoded Base64-encoded SVG.\\n   */\\n  function encodeBase64SVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (bytes memory) {\\n    bytes memory svg = encodeSVG(data, width, height, alpha, svgWidth, svgHeight);\\n    return Base64.encode(svg);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/KeepAlive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title KeepAlive\\n * @dev KeepAlive is a contract designed to maintain its onchain presence in\\n * case of state expiration by using payable receive() and fallback() functions,\\n * while allow the owner to still withdraw funds.\\n * fallback():\\n *   - Default function that gets executed when no other function in the contract\\n *     matches the provided function signature, or when the contract receives\\n *     Ether along with data\\n *   - Can be payable or non-payable\\n *   - Must be marked external\\n * receive():\\n *   - Introduced in Solidity 0.6.0\\n *   - Special function that is executed when a contract receives Ether without\\n *     any data\\n *   - Must be payable\\n *   - Must be marked external\\n *   - Makes it easier to differentiate between intended Ether transfers and\\n *     other function calls\\n */\\ncontract KeepAlive is Ownable {\\n  /**\\n   * @notice Fallback function.\\n   * @dev fallback():\\n   *  - Default function that gets executed when no other function in the contract\\n   *    matches the provided function signature, or when the contract receives\\n   *    Ether along with data\\n   *  - Can be payable or non-payable\\n   *  - Must be marked external\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  fallback() external payable {}\\n\\n  /**\\n   * @notice Receive funds.\\n   * @dev receive():\\n   *   - Introduced in Solidity 0.6.0\\n   *   - Special function that is executed when a contract receives Ether without\\n   *     any data\\n   *   - Must be payable\\n   *   - Must be marked external\\n   *   - Makes it easier to differentiate between intended Ether transfers and\\n   *     other function calls\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  receive() external payable {}\\n\\n  /**\\n   * @notice Withdraw funds from the contract.\\n   */\\n  function withdraw(uint amount) external onlyOwner {\\n    payable(msg.sender).transfer(amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/OwnerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title OwnerProxy\\n * @dev OwnerProxy is a proxy contract that provides an onchain interface of\\n * just the Ownable functions.\\n *\\n * The main purpose of this contract is to allow for deploying to\\n * deterministic addresses via CREATE2, while still allowing for the owner\\n * address to be updated. Normally, the owner address is set at deployment\\n * time as a constructor arg, which means that the address of the contract\\n * is not known until after it is deployed. This makes it difficult to\\n * deploy contracts to a deterministic address.\\n *\\n * The OwnerProxy contract can be deployed to a preconfigured address via a\\n * CREATE2 factory, after which subsequent contracts can be written to\\n * refer to the OwnerProxy contract (at its preconfigured address) as\\n * a way to determine the owner of the address at deployment time\\n * for _subsequent_ CREATE2 deployments of _other_ contracts.\\n *\\n * Other contracts should be written to accept an OwnerProxy address as a\\n * constructor arg, and then use that OwnerProxy's owner() as the owner\\n * address for the contract being deployed.\\n *\\n *    ```\\n *    constructor(address ownerProxy) {\\n *      transferOwnership(Ownable(ownerProxy).owner());\\n *    }\\n *    ```\\n *\\n * This allows developers to mine CREATE2 addresses with static constructor\\n * args input once this OwnerProxy is deployed, while still using different\\n * owner addresses on different chains, (e.g. test or prod) by manipulating the\\n * owner() of the OwnerProxy at deployment time of future contracts that\\n * refer to it.\\n *\\n * This mechanism allows for developers to:\\n * - deploy initization code via CREATE2 to static address (can be mined)\\n * - to a developer-controlled owner address\\n * - on any EVM chain\\n * - now or in the future\\n * - while allowing the post-deployment owner address to be updated for each\\n *   deployment or chain\\n *\\n * so long as:\\n * - OwnerProxy is deployed via CREATE2 to the same address across all chains\\n * - such that it can be passed in as a deterministic constructor arg to\\n *   contracts\\n *\\n * To ensure OwnerProxy is deployed at the same address it can either be:\\n * - deployed via a CREATE2 factory with a deterministic salt\\n * - deployed via the same deployer at the same nonce across all EVM chains\\n *\\n * The standard sequence as designed is:\\n * - Determine deployer key\\n * - Deploy 0age's ImmutableCreate2Factory as nonce 0 transaction\\n *   (deterministic address)\\n * - Deploy OwnerProxy via ImmutableCreate2Factory::safeCreate2 with\\n *   deterministic salt S\\n * - Deploy contract(s) with constructor arg of OwnerProxy address\\n * - In contract constructor, transfer ownership to OwnerProxy::owner()\\n */\\ncontract OwnerProxy is Ownable {\\n  error NotMasterOwner();\\n  address public immutable masterOwner;\\n\\n  /**\\n   * @dev Construct the OwnerProxy.\\n   * @param masterOwner_ The address of the master owner.\\n   */\\n  constructor(address masterOwner_) {\\n    masterOwner = masterOwner_;\\n\\n    // test test test test test test test test test test test junk\\n    // m/44'/60'/0'/0/0\\n    transferOwnership(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\\n  }\\n\\n  /**\\n   * @dev Modifier to ensure that only the master owner can call a function.\\n   */\\n  modifier onlyMasterOwner() {\\n    if (msg.sender != masterOwner) revert NotMasterOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Transfer ownership to the master owner.\\n   */\\n  function takeOwnership() external onlyMasterOwner {\\n    _transferOwnership(masterOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/PixelBlender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title PixelBlender\\n * @dev This contract blends pixels together.\\n */\\ncontract PixelBlender {\\n  /**\\n   * @notice Blend two pixels together.\\n   * @param foreground The foreground pixel color value.\\n   * @param background The background pixel color value.\\n   * @param foregroundAlpha The alpha of the foreground pixel.\\n   * @return The blended pixel color value.\\n   */\\n  function blendPixel(uint8 foreground, uint8 background, uint8 foregroundAlpha) internal pure returns (uint8) {\\n    return uint8((uint(foreground) * uint(foregroundAlpha) + uint(background) * (255 - uint(foregroundAlpha))) / 255);\\n  }\\n\\n  /**\\n   * @notice Blend two alpha values together.\\n   * @param foregroundAlpha The foreground alpha value.\\n   * @param backgroundAlpha The background alpha value.\\n   * @return The blended alpha value.\\n   */\\n  function blendAlpha(uint8 foregroundAlpha, uint8 backgroundAlpha) internal pure returns (uint8) {\\n    if (foregroundAlpha == 255) return 255;\\n    if (backgroundAlpha == 255) return 255;\\n    return uint8(uint(foregroundAlpha) + (uint(backgroundAlpha) * (255 - uint(foregroundAlpha))) / 255);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/PNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Adler32} from './Adler32.sol';\\nimport {CRC32} from './CRC32.sol';\\n\\n/**\\n * @title PNG\\n * @dev PNG is a contract for generating PNG images from raw image data in Solidity.\\n * It includes functions for encoding and decoding PNG images, as well as for\\n * calculating Adler32 and CRC32 checksums.\\n *\\n * This contract is based on the PNG specification:\\n *\\n * http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html\\n *\\n * It supports only 8 bit images and supports RGB or RGBA color formats.\\n * It uses compression method 0, filter method 0, and interlace method 0.\\n */\\ncontract PNG {\\n  using Adler32 for bytes;\\n  using CRC32 for bytes;\\n\\n  /**\\n   * The PNG signature is a fixed eight-byte sequence:\\n   * 89 50 4e 47 0d 0a 1a 0a\\n   */\\n  bytes public constant PNG_SIGNATURE = hex'89504e470d0a1a0a';\\n\\n  /**\\n   * The IEND chunk marks the end of the PNG datastream.\\n   * It contains no data.\\n   *\\n   * The IEND chunk must appear last.\\n   * It is an error to place any data after the IEND chunk.\\n   *\\n   * The IEND chunk is always equal to 12 bytes\\n   * 00 00 00 00 49 45 4e 44 ae 42 60 82\\n   */\\n  bytes public constant IEND = hex'0000000049454e44ae426082';\\n\\n  /**\\n   * @notice Encodes a PNG image from raw image data\\n   * @param data Raw image data\\n   * @param width  The width of the image, in pixels\\n   * @param height The height of the image, in pixels\\n   * @param alpha  Whether the image has an alpha channel\\n   * @return PNG image\\n   */\\n  function encodePNG(bytes memory data, uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    unchecked {\\n      // Determine the width of each pixel\\n      uint pixelWidth = (alpha) ? 4 : 3;\\n\\n      // Check that the length of the data is correct\\n      require(data.length == pixelWidth * width * height, 'Invalid image data length');\\n\\n      // Create the IHDR chunk\\n      bytes memory chunkIHDR = encodeIHDR(width, height, alpha);\\n\\n      // Create the IDAT chunk\\n      bytes memory chunkIDAT = encodeIDAT(data, width, height, alpha);\\n\\n      // Concatenate the chunks into a single bytes array.\\n      return abi.encodePacked(PNG_SIGNATURE, chunkIHDR, chunkIDAT, IEND);\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates an IHDR chunk for a PNG image with the given width and height.\\n   * This function generates an IHDR chunk according to the PNG specification\\n   * (http://libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IHDR).\\n   *\\n   * @param width The width of the image.\\n   * @param height The height of the image.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes memory array containing the IDAT chunk data.\\n   */\\n  function encodeIHDR(uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    // Create the IHDR chunk\\n    // The IHDR chunk length is 13 bytes (0x0000000d in hex)\\n    // The IHDR type 49 48 44 52 (IHDR)\\n    //\\n    // The IHDR chunk data consists of the following fields:\\n    // 4 bytes: width\\n    // 4 bytes: height\\n    // 1 byte: bit depth (8)\\n    // 1 byte: color type (2 for RGB, 6 for RGBA)\\n    // 1 byte: compression method (0)\\n    // 1 byte: filter method (0)\\n    // 1 byte: interlace method (0)\\n    //\\n    // 4 bytes: CRC32 checksum\\n    bytes memory chunkIHDR = hex'0000000d494844520000000000000000080200000000000000';\\n    // Set the width and height of the image in the chunk data\\n    chunkIHDR[8] = bytes1(uint8(width >> 24));\\n    chunkIHDR[9] = bytes1(uint8(width >> 16));\\n    chunkIHDR[10] = bytes1(uint8(width >> 8));\\n    chunkIHDR[11] = bytes1(uint8(width));\\n    chunkIHDR[12] = bytes1(uint8(height >> 24));\\n    chunkIHDR[13] = bytes1(uint8(height >> 16));\\n    chunkIHDR[14] = bytes1(uint8(height >> 8));\\n    chunkIHDR[15] = bytes1(uint8(height));\\n\\n    // Set the color type of the image in the chunk data\\n    if (alpha) {\\n      // truecolor image with alpha channel\\n      chunkIHDR[17] = hex'06';\\n    } else {\\n      // truecolor image without alpha channel\\n      chunkIHDR[17] = hex'02';\\n    }\\n\\n    // Calculate and set the CRC32 checksum of the chunk\\n    uint32 checksum = chunkIHDR.crc32(4, 21);\\n    chunkIHDR[21] = bytes1(uint8(checksum >> 24));\\n    chunkIHDR[22] = bytes1(uint8(checksum >> 16));\\n    chunkIHDR[23] = bytes1(uint8(checksum >> 8));\\n    chunkIHDR[24] = bytes1(uint8(checksum));\\n\\n    return chunkIHDR;\\n  }\\n\\n  /**\\n   * @dev Interlaces a given bytes array of image data.\\n   * @param data The bytes array of image data.\\n   * @param width The width of the image, in pixels.\\n   * @param height The height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @return The interlaced bytes array.\\n   */\\n  function interlace(bytes memory data, uint width, uint height, bool alpha) internal pure returns (bytes memory) {\\n    unchecked {\\n      uint pixelWidth = alpha ? 4 : 3;\\n\\n      // IDAT chunk\\n      // The IDAT chunk contains the actual image data.\\n      // The layout and total size of this raw data are determined by the fields of IHDR.\\n      // The filtered data is then compressed using the method specified by the IHDR chunk.\\n\\n      // Since our image has no filtering,\\n      // the filter type byte for each scanline would be 0x00 (no filtering).\\n      // Interlacing method 0 is used, so pixels are stored sequentially from left to right,\\n      // and scanlines sequentially from top to bottom (no interlacing).\\n      uint rowWidth = pixelWidth * width;\\n      uint rowWidthPadded = rowWidth + 1;\\n      // Declare a bytes array to hold the interlaced data.\\n      bytes memory interlacedData = new bytes(rowWidthPadded * height);\\n\\n      // Loop over the scanlines.\\n      for (uint row = 0; row < height; row++) {\\n        // Calculate the starting index for the current scanline.\\n        uint startIndex = rowWidthPadded * row;\\n\\n        // Set the filter type byte for the current scanline.\\n        interlacedData[startIndex] = 0x00; // Filter type 0 (no filtering)\\n\\n        // Copy the scanline data into the interlaced data array.\\n        // No filtering is used, so the scanline data starts at index 1.\\n        for (uint j = 0; j < rowWidth; j++) {\\n          interlacedData[startIndex + 1 + j] = data[row * rowWidth + j];\\n        }\\n      }\\n      return interlacedData;\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates a zlib-compressed version of the given image data using the Deflate algorithm.\\n   * This function generates a zlib-compressed version of the given image data using the Deflate algorithm,\\n   * as specified in the PNG specification (http://www.libpng.org/pub/png/spec/1.2/PNG-Compression.html).\\n   * The resulting data is suitable for storage in an IDAT chunk of a PNG file.\\n   *\\n   * @param data The image data to be compressed.\\n   * @param width The width of the image, in pixels.\\n   * @param height The height of the image, in pixels.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes array containing the zlib-compressed image data.\\n   */\\n  function zlibCompressDeflate(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha\\n  ) internal pure returns (bytes memory) {\\n    unchecked {\\n      // Generate Deflate-compressed data\\n      bytes memory deflateCompressedData = interlace(data, width, height, alpha);\\n\\n      // Calculate Adler-32 checksum of Deflate-compressed data\\n      uint32 blockAdler32 = deflateCompressedData.adler32(0, deflateCompressedData.length);\\n\\n      // zlib block header (BFINAL = 1, BTYPE = 0)\\n      bytes memory zlibBlockHeader = hex'01';\\n\\n      // LEN is the length of the data\\n      bytes32 len = bytes32(deflateCompressedData.length);\\n\\n      // Generate zlib-compressed data\\n      bytes memory result = abi.encodePacked(\\n        // zlib header\\n        // CM = 8 (deflate), CINFO = 7 (32K window size)\\n        hex'78',\\n        // FCHECK = 0 (no check)\\n        // FDICT = 0 (no preset dictionary)\\n        // FLEVEL = 0 (fastest compression)\\n        hex'01',\\n        // block header (BFINAL = 1, BTYPE = 0)\\n        zlibBlockHeader,\\n        // LEN (2 bytes) (length of the data)\\n        len[31],\\n        len[30],\\n        // NLEN (2 bytes) (one's complement of LEN)\\n        ~len[31],\\n        ~len[30],\\n        // Deflate-compressed data\\n        deflateCompressedData,\\n        // block footer (adler32 checksum)\\n        blockAdler32\\n      );\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates an IDAT chunk for a PNG image with the given width and height.\\n   * This function generates an IDAT chunk according to the PNG specification\\n   * (http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html).\\n   *\\n   * @param data The filtered image data.\\n   * @param width The width of the image.\\n   * @param height The height of the image.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes memory array containing the IDAT chunk data.\\n   */\\n  function encodeIDAT(bytes memory data, uint width, uint height, bool alpha) internal pure returns (bytes memory) {\\n    unchecked {\\n      // The IDAT data is compressed using the deflate algorithm.\\n      bytes memory compressed = zlibCompressDeflate(data, width, height, alpha);\\n      // The compressed data stream is then stored in the IDAT chunk.\\n      bytes memory typedata = abi.encodePacked(\\n        hex'49444154', // Chunk type: \\\"IDAT\\\" in ASCII\\n        compressed\\n      );\\n\\n      // CRC calculated from the chunk type and chunk data\\n      uint32 crc = typedata.crc32(0, typedata.length);\\n\\n      // Append the CRC32 checksum to the end of the chunk\\n      return abi.encodePacked(uint32(compressed.length), typedata, crc);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/test/CRC32Test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport '../CRC32.sol';\\n\\n// This contract is used to test the CRC32 library\\ncontract CRC32Test {\\n  function crc32(bytes memory data) public pure returns (uint32) {\\n    return CRC32.crc32(data, 0, data.length);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/test/PixelBlenderTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {PixelBlender} from '../PixelBlender.sol';\\n\\ncontract PixelBlenderTest is PixelBlender {\\n  function testBlendPixel(uint8 foreground, uint8 background, uint8 foregroundAlpha) public pure returns (uint8) {\\n    return blendPixel(foreground, background, foregroundAlpha);\\n  }\\n\\n  function testBlendAlpha(uint8 foregroundAlpha, uint8 backgroundAlpha) public pure returns (uint8) {\\n    return blendAlpha(foregroundAlpha, backgroundAlpha);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/test/TestENSReverseClaimer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {ENSReverseClaimer} from '../ENSReverseClaimer.sol';\\nimport {KeepAlive} from '../KeepAlive.sol';\\n\\n/**\\n * @title TestENSReverseClaimer\\n * @dev This contract is test contract to test functionality for\\n *     ENSReverseClaimer.\\n */\\ncontract TestENSReverseClaimer is KeepAlive, ENSReverseClaimer {\\n  constructor(address owner) {\\n    transferOwnership(owner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/test/TestSVGRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {ERC721A, ERC721AQueryable, IERC721A} from 'erc721a/contracts/extensions/ERC721AQueryable.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\n\\nimport {Base64} from '../../dependencies/Base64.sol';\\nimport {ImageEncoder} from '../ImageEncoder.sol';\\n\\n/**\\n * @title TestSVGRenderer\\n * @dev This contract is used for testing how websites render SVGs differently.\\n *\\n * Every token is rendered with a different \\\"image\\\" element where the SVG has\\n * different formatting, attributes, workarounds, foreign objects, etc.\\n *\\n * This allows us to mint a bunch of tokens at once in the constructor and then\\n * test how different websites render the SVGs on a testnet.\\n */\\ncontract TestSVGRenderer is ImageEncoder, ERC721AQueryable {\\n  using Strings for uint256;\\n\\n  // SVG 1: Testing a simple SVG rendering with specific viewBox and fill color\\n  string private constant svg1 =\\n    '<svg viewBox=\\\"0 0 100 100\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\n'\\n    '    <rect width=\\\"100\\\" height=\\\"100\\\" fill=\\\"#FF0000\\\" />\\\\n'\\n    '</svg>';\\n\\n  // SVG 2: Similar to SVG 1, but with an overlapping green rectangle\\n  string private constant svg2 =\\n    '<svg viewBox=\\\"0 0 100 100\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\n'\\n    '    <rect width=\\\"100\\\" height=\\\"100\\\" fill=\\\"#FF0000\\\" />\\\\n'\\n    '    <rect width=\\\"10\\\" height=\\\"10\\\" fill=\\\"#00FF00\\\" />\\\\n'\\n    '</svg>';\\n\\n  // SVG 3: black border\\n  string private constant svg3 =\\n    '<svg viewBox=\\\"0 0 100 100\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\n'\\n    '    <rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"100\\\" height=\\\"100\\\" fill=\\\"none\\\" stroke=\\\"#FF0000\\\" />\\\\n'\\n    '</svg>';\\n\\n  // SVG 4: Testing overlapping circles with alpha transparency (Venn diagram) with border\\n  string private constant svg4 =\\n    '<svg viewBox=\\\"0 0 120 120\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\n'\\n    '    <rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"120\\\" height=\\\"120\\\" fill=\\\"none\\\" stroke=\\\"#FF0000\\\" />\\\\n'\\n    '    <circle cx=\\\"40\\\" cy=\\\"60\\\" r=\\\"30\\\" fill=\\\"rgba(255, 0, 0, 0.5)\\\" />\\\\n'\\n    '    <circle cx=\\\"80\\\" cy=\\\"60\\\" r=\\\"30\\\" fill=\\\"rgba(0, 255, 0, 0.5)\\\" />\\\\n'\\n    '    <circle cx=\\\"60\\\" cy=\\\"40\\\" r=\\\"30\\\" fill=\\\"rgba(0, 0, 255, 0.5)\\\" />\\\\n'\\n    '</svg>';\\n\\n  string private constant url =\\n    'https://raw.githubusercontent.com/stoooops/explore/master/image_rgba_32x32_cyan_checkerboard.png';\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Constructor\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  constructor() ERC721A('SVG Test', 'SVG') {\\n    // mint 100 tokens\\n    // _mintBatchTo(msg.sender, 100);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC721Metadata\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function tokenURI(uint tokenId) public view override(ERC721A, IERC721A) returns (string memory) {\\n    if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          'data:application/json;base64,',\\n          Base64.encode(\\n            abi.encodePacked(\\n              '{\\\"description\\\":\\\"TestSVGRenderer is a test contract for testing how base64-encoded SVGs are rendered on NFT marketplace websites.\\\",\\\"image\\\":\\\"',\\n              getImageURI(tokenId),\\n              '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Token ID\\\",\\\"value\\\":',\\n              tokenId.toString(),\\n              ',\\\"display_type\\\":\\\"number\\\"}]}'\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Art\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function packSVG(string memory svg) internal pure returns (bytes memory) {\\n    return abi.encodePacked('data:image/svg+xml;base64,', Base64.encode(abi.encodePacked(svg)));\\n  }\\n\\n  function packPNG(bytes memory png) internal pure returns (bytes memory) {\\n    return abi.encodePacked('data:image/png;base64,', Base64.encode(png));\\n  }\\n\\n  function getImageURI(uint tokenId) internal pure returns (bytes memory) {\\n    uint width = 32;\\n    uint height = 32;\\n    uint scaleWidth = 128;\\n    uint scaleHeight = 128;\\n    bytes memory checkerboard = fill(width, height, 0, 0, 255, 255);\\n\\n    bytes memory imageUri;\\n    if (tokenId == 1) {\\n      imageUri = packSVG(svg1);\\n    } else if (tokenId == 2) {\\n      imageUri = packSVG(svg2);\\n    } else if (tokenId == 3) {\\n      imageUri = packSVG(svg3);\\n    } else if (tokenId == 4) {\\n      imageUri = packSVG(svg4);\\n    } else if (tokenId == 5) {\\n      imageUri = packPNG(encodePNG(checkerboard, width, height, true));\\n    } else if (tokenId == 6) {\\n      imageUri = packSVG(encodePNGBase64ImageSVG(checkerboard, width, height, true, scaleWidth, scaleHeight, false));\\n    } else if (tokenId == 7) {\\n      imageUri = packSVG(encodePNGBase64ImageSVG(checkerboard, width, height, true, scaleWidth, scaleHeight, true));\\n    } else if (tokenId == 8) {\\n      imageUri = packSVG(encodePNGBase64ForeignObjectSVG(checkerboard, width, height, true, scaleWidth, scaleHeight));\\n    } else if (tokenId == 9) {\\n      imageUri = packSVG(string(encodeSVG(checkerboard, width, height, true, scaleWidth, scaleHeight)));\\n    } else if (tokenId == 10) {\\n      imageUri = packSVG(encodeImageURLForeignObjectSVG(url, scaleWidth, scaleHeight));\\n    } else {\\n      // do nothing\\n    }\\n\\n    return imageUri;\\n  }\\n\\n  function fill(\\n    uint width,\\n    uint height,\\n    uint8 red,\\n    uint8 green,\\n    uint8 blue,\\n    uint8 alpha\\n  ) internal pure returns (bytes memory) {\\n    bytes memory result = new bytes(width * height * 4);\\n    for (uint i = 0; i < height; i++) {\\n      for (uint j = 0; j < width; j++) {\\n        uint offset = (i * width + j) * 4;\\n        // color the pixel if its row number and column number add up to an even number\\n        if ((i + j) % 2 == 0) {\\n          result[offset] = bytes1(red);\\n          result[offset + 1] = bytes1(green);\\n          result[offset + 2] = bytes1(blue);\\n          result[offset + 3] = bytes1(alpha);\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  // Helper function to create SVG start tag\\n  function startSVG(uint svgWidth, uint svgHeight, bool isForeignObject) internal pure returns (bytes memory) {\\n    string memory svgWidthStr = Strings.toString(svgWidth);\\n    string memory svgHeightStr = Strings.toString(svgHeight);\\n\\n    if (isForeignObject) {\\n      return\\n        abi.encodePacked(\\n          '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 ',\\n          svgWidthStr,\\n          ' ',\\n          svgHeightStr,\\n          '\\\">\\\\n'\\n        );\\n    } else {\\n      return\\n        abi.encodePacked(\\n          '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" viewBox=\\\"0 0 ',\\n          svgWidthStr,\\n          ' ',\\n          svgHeightStr,\\n          '\\\">\\\\n'\\n        );\\n    }\\n  }\\n\\n  // Helper function to close SVG\\n  function closeSVG() internal pure returns (bytes memory) {\\n    return '</svg>';\\n  }\\n\\n  // Helper function to add a border to SVG\\n  function addBorder(uint svgWidth, uint svgHeight) internal pure returns (bytes memory) {\\n    string memory svgWidthStr = Strings.toString(svgWidth);\\n    string memory svgHeightStr = Strings.toString(svgHeight);\\n\\n    return\\n      abi.encodePacked(\\n        '\\\\t<rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"',\\n        svgWidthStr,\\n        '\\\" height=\\\"',\\n        svgHeightStr,\\n        '\\\" fill=\\\"none\\\" stroke=\\\"#FF0000\\\" />\\\\n'\\n      );\\n  }\\n\\n  function encodePNGBase64ImageSVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight,\\n    bool usePixelatedRendering\\n  ) public pure returns (string memory) {\\n    bytes memory base64PNG = encodeBase64PNG(data, width, height, alpha);\\n    bytes memory result = startSVG(svgWidth, svgHeight, false);\\n    // result = abi.encodePacked(result, addBorder(svgWidth, svgHeight));\\n\\n    string memory imageRendering = usePixelatedRendering ? ' style=\\\"image-rendering: pixelated;\\\"' : '';\\n\\n    result = abi.encodePacked(\\n      result,\\n      '\\\\t<image x=\\\"0\\\" y=\\\"0\\\" width=\\\"',\\n      Strings.toString(svgWidth),\\n      '\\\" height=\\\"',\\n      Strings.toString(svgHeight),\\n      '\\\" preserveAspectRatio=\\\"none\\\" xlink:href=\\\"data:image/png;base64,',\\n      base64PNG,\\n      '\\\"',\\n      imageRendering,\\n      '/>\\\\n',\\n      closeSVG()\\n    );\\n\\n    return string(result);\\n  }\\n\\n  function encodePNGBase64ForeignObjectSVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (string memory) {\\n    bytes memory base64PNG = encodeBase64PNG(data, width, height, alpha);\\n    bytes memory result = startSVG(svgWidth, svgHeight, true);\\n    // result = abi.encodePacked(result, addBorder(svgWidth, svgHeight));\\n    result = abi.encodePacked(\\n      result,\\n      '\\\\t<foreignObject width=\\\"',\\n      Strings.toString(svgWidth),\\n      '\\\" height=\\\"',\\n      Strings.toString(svgHeight),\\n      '\\\">\\\\n'\\n    );\\n    result = abi.encodePacked(\\n      result,\\n      '\\\\t\\\\t<img xmlns=\\\"http://www.w3.org/1999/xhtml\\\" width=\\\"',\\n      Strings.toString(svgWidth),\\n      '\\\" height=\\\"',\\n      Strings.toString(svgHeight),\\n      '\\\" style=\\\"image-rendering: pixelated;\\\" src=\\\"data:image/png;base64,',\\n      base64PNG,\\n      '\\\"/>\\\\n'\\n    );\\n    result = abi.encodePacked(result, '\\\\t</foreignObject>\\\\n', closeSVG());\\n\\n    return string(result);\\n  }\\n\\n  function encodeImageURLForeignObjectSVG(\\n    string memory imageURL,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (string memory) {\\n    bytes memory result = startSVG(svgWidth, svgHeight, true);\\n    // result = abi.encodePacked(result, addBorder(svgWidth, svgHeight));\\n\\n    result = abi.encodePacked(\\n      result,\\n      '\\\\t<foreignObject width=\\\"',\\n      Strings.toString(svgWidth),\\n      '\\\" height=\\\"',\\n      Strings.toString(svgHeight),\\n      '\\\">\\\\n\\\\t\\\\t<img xmlns=\\\"http://www.w3.org/1999/xhtml\\\" width=\\\"',\\n      Strings.toString(svgWidth),\\n      '\\\" height=\\\"',\\n      Strings.toString(svgHeight),\\n      '\\\" style=\\\"image-rendering: pixelated;\\\" src=\\\"',\\n      bytes(imageURL),\\n      '\\\"/>\\\\n\\\\t</foreignObject>\\\\n',\\n      closeSVG()\\n    );\\n\\n    return string(result);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function _mintTo(address to) internal {\\n    _safeMint(to, 1);\\n  }\\n\\n  function mint() external payable {\\n    _mintTo(msg.sender);\\n  }\\n\\n  function mintTo(address to) external payable {\\n    _mintTo(to);\\n  }\\n\\n  function _mintBatchTo(address to, uint n) internal {\\n    _safeMint(to, n);\\n  }\\n\\n  function mintBatch(uint n) external payable {\\n    _mintBatchTo(msg.sender, n);\\n  }\\n\\n  function mintBatchTo(address to, uint n) external payable {\\n    _mintBatchTo(to, n);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/render/OpenAvatarGen0AssetsCanvasLayerCompositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead} from '../interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {OptionalPatternHeader, PatternHeader} from '../interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\nimport {IOpenAvatarGen0AssetsCanvasLayerCompositor, LayerPatternPalette} from '../interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol';\\nimport {KeepAlive} from '../lib/KeepAlive.sol';\\nimport {PixelBlender} from '../lib/PixelBlender.sol';\\nimport {IOpenAvatarGen0AssetsRead} from '../../IOpenAvatarGen0Assets.sol';\\n\\n/**\\n * @title OpenAvatarGen0AssetsCanvasLayerCompositor\\n * @dev This contract composes layer patterns into a single image.\\n * @dev A pattern is a 2d byte array with a corresponding color palette.\\n * @dev The values of the pattern array are indexes into the color palette.\\n */\\ncontract OpenAvatarGen0AssetsCanvasLayerCompositor is\\n  KeepAlive,\\n  PixelBlender,\\n  IOpenAvatarGen0AssetsCanvasLayerCompositor\\n{\\n  /// @dev Error reverted when the component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Error reverted when provided address does not support the required interface.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Error reverted when the canvas bytes per pixel is not 4.\\n  error InvalidCanvasBytesPerPixel();\\n  /// @dev Error reverted when the canvas size is invalid.\\n  error InvalidCanvasSize(uint8 canvasId, uint invalidNumBytes);\\n  /// @dev Error reverted when the mask length is invalid.\\n  error InvalidMaskLength(uint maskLength, uint canvasSize);\\n\\n  /// @dev The transparent alpha value.\\n  bytes1 public constant TRANSPARENT = 0x00;\\n  /// @dev The opaque alpha value.\\n  bytes1 public constant OPAQUE = 0xff;\\n\\n  /// @dev The\\n  IOpenAvatarGen0AssetsRead public openAvatarGen0AssetsRead;\\n\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsCanvasLayerCompositor (for clients).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR = 0x2638c94b;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsRead (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ = 0x67bf31d1;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the\\n    // configured owner.\\n    // using a proxy allows for using same constructor args and thus same\\n    // bytecode for all instances of this contract.\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      interfaceId == INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface\\n   * contract.\\n   */\\n  function initialize(address openAvatarGen0Assets_) external onlyOwner {\\n    setOpenAvatarGen0Assets(openAvatarGen0Assets_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0AssetsRead) != address(0);\\n  }\\n\\n  /**\\n   * @dev Get the OpenAvatarGen0Assets address.\\n   * @return The OpenAvatarGen0Assets address.\\n   */\\n  function getOpenAvatarGen0Assets() external view returns (address) {\\n    return address(openAvatarGen0AssetsRead);\\n  }\\n\\n  /**\\n   * @notice Set the asset store.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface\\n   * contract.\\n   */\\n  function setOpenAvatarGen0Assets(address openAvatarGen0Assets_) internal {\\n    // only set once\\n    if (address(openAvatarGen0AssetsRead) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only read interface is required\\n    if (!IERC165(openAvatarGen0Assets_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ)) {\\n      revert InterfaceUnsupported(openAvatarGen0Assets_, INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ);\\n    }\\n\\n    // set\\n    openAvatarGen0AssetsRead = IOpenAvatarGen0AssetsRead(openAvatarGen0Assets_);\\n\\n    // sanity check\\n    if (openAvatarGen0AssetsRead.getBytesPerPixel() != 4) revert InvalidCanvasBytesPerPixel();\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layer Composition\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Create a layer composition.\\n   * @param canvasId The id of the canvas to use\\n   * @param layerPatternPalette The layer, pattern, and palette to use for each\\n   * layer\\n   */\\n  function createLayerComposition(\\n    uint8 canvasId,\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) external view override returns (bytes memory) {\\n    bytes memory out = new bytes(openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId));\\n    _drawLayerComposition(out, canvasId, layerPatternPalette);\\n    return out;\\n  }\\n\\n  /**\\n   * @dev Draw a layer composition onto the image\\n   * @param out The image to draw the layer composition onto\\n   * @param canvasId The id of the canvas to use\\n   * @param layerPatternPalette The layer, pattern, and palette to use for each\\n   * layer\\n   */\\n  function drawLayerComposition(\\n    bytes memory out,\\n    uint8 canvasId,\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) public view override returns (bytes memory) {\\n    _drawLayerComposition(out, canvasId, layerPatternPalette);\\n    return out;\\n  }\\n\\n  /**\\n   * @dev Draw a layer composition onto the image\\n   * @param out The image to draw the layer composition onto\\n   * @param canvasId The id of the canvas to use\\n   * @param layerPatternPalette The layer, pattern, and palette to use for each\\n   * layer\\n   */\\n  function _drawLayerComposition(\\n    bytes memory out,\\n    uint8 canvasId,\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) internal view {\\n    // sanity check so we don't out of bounds for bad input\\n    if (out.length != openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId)) {\\n      revert InvalidCanvasSize(canvasId, out.length);\\n    }\\n\\n    uint length = layerPatternPalette.length;\\n    for (uint i = 0; i < length; ) {\\n      LayerPatternPalette memory lpp = layerPatternPalette[i];\\n      _drawLayer(out, canvasId, lpp.layer, lpp.pattern, lpp.palette);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Overlay a layer on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param canvasId The id of the canvas to use\\n   * @param layer The index of the layer to overlay\\n   * @param pattern The index of the pattern to use for the layer\\n   * @param palette The index of the palette to use for the layer/pattern\\n   */\\n  function drawLayer(\\n    bytes memory image,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) public view override returns (bytes memory) {\\n    _drawLayer(image, canvasId, layer, pattern, palette);\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Overlay a layer on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param canvasId The id of the canvas to use\\n   * @param layer The index of the layer to overlay\\n   * @param pattern The index of the pattern to use for the layer\\n   * @param palette The index of the palette to use for the layer/pattern\\n   */\\n  function _drawLayer(bytes memory image, uint8 canvasId, uint8 layer, uint8 pattern, uint8 palette) internal view {\\n    OptionalPatternHeader memory optionalHeader = openAvatarGen0AssetsRead.getPatternHeader(canvasId, layer, pattern);\\n    // gracefully handle missing pattern\\n    if (optionalHeader.exists) {\\n      bytes memory patternData = openAvatarGen0AssetsRead.getPatternData(canvasId, layer, pattern);\\n      // transparent patterns will exist and have length 0\\n      if (patternData.length > 0) {\\n        bytes4[] memory paletteData = openAvatarGen0AssetsRead.getPalette(optionalHeader.header.paletteCode, palette);\\n        // gracefully handle missing palette\\n        if (paletteData.length > 0) {\\n          _drawPattern(image, canvasId, optionalHeader.header, patternData, paletteData);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Overlay a layer on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param mask The mask to apply to the pattern before overlaying it\\n   * @param canvasId The id of the canvas to use\\n   * @param layer The index of the layer to overlay\\n   * @param pattern The index of the pattern to use for the layer\\n   * @param palette The index of the palette to use for the layer/pattern\\n   */\\n  function drawMaskedLayer(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) public view override returns (bytes memory) {\\n    _drawMaskedLayer(image, mask, canvasId, layer, pattern, palette);\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Overlay a layer on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param mask The mask to apply to the pattern before overlaying it\\n   * @param canvasId The id of the canvas to use\\n   * @param layer The index of the layer to overlay\\n   * @param pattern The index of the pattern to use for the layer\\n   * @param palette The index of the palette to use for the layer/pattern\\n   */\\n  function _drawMaskedLayer(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) internal view {\\n    OptionalPatternHeader memory optionalHeader = openAvatarGen0AssetsRead.getPatternHeader(canvasId, layer, pattern);\\n    // gracefully handle missing pattern\\n    if (optionalHeader.exists) {\\n      bytes memory patternData = openAvatarGen0AssetsRead.getPatternData(canvasId, layer, pattern);\\n      // transparent patterns will exist and have length 0\\n      if (patternData.length > 0) {\\n        bytes4[] memory paletteData = openAvatarGen0AssetsRead.getPalette(optionalHeader.header.paletteCode, palette);\\n        // gracefully handle missing palette\\n        if (paletteData.length > 0) {\\n          _drawMaskedPattern(image, mask, canvasId, optionalHeader.header, patternData, paletteData);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Overlay a pattern on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param header The header of the pattern to use for the layer\\n   * @param pattern The pattern to use for the layer\\n   * @param palette The palette to use for the layer/pattern\\n   */\\n  function drawPattern(\\n    bytes memory image,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) public view returns (bytes memory) {\\n    _drawPattern(image, canvasId, header, pattern, palette);\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Overlay a pattern on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param header The header of the pattern to use for the layer\\n   * @param pattern The pattern to use for the layer\\n   * @param palette The palette to use for the layer/pattern\\n   */\\n  function _drawPattern(\\n    bytes memory image,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) internal view {\\n    _drawMaskedPattern(\\n      image,\\n      // this is wasteful\\n      new bytes(openAvatarGen0AssetsRead.getCanvasNumPixels(canvasId)),\\n      canvasId,\\n      header,\\n      pattern,\\n      palette\\n    );\\n  }\\n\\n  /**\\n   * @dev Overlay a pattern on top of the image\\n   * @param image The image to overlay the layer on top of\\n   * @param header The header of the pattern to use for the layer\\n   * @param pattern The pattern to use for the layer\\n   * @param palette The palette to use for the layer/pattern\\n   */\\n  function drawMaskedPattern(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) public view returns (bytes memory) {\\n    _drawMaskedPattern(image, mask, canvasId, header, pattern, palette);\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Overlay a pattern on top of the image, applying a mask\\n   * @param image The image to overlay the layer on top of\\n   * @param mask The mask to apply to the pattern before overlaying it\\n   * @param header The header of the pattern to use for the layer\\n   * @param pattern The pattern to use for the layer\\n   * @param palette The palette to use for the layer/pattern\\n   */\\n  function _drawMaskedPattern(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) internal view {\\n    unchecked {\\n      uint8 canvasWidth = openAvatarGen0AssetsRead.getCanvasWidth(canvasId);\\n      // loop through pixels in the image\\n      for (uint y = 0; y < header.height; ) {\\n        uint colY = y + header.offsetY;\\n        for (uint x = 0; x < header.width; ) {\\n          uint rowX = x + header.offsetX;\\n          uint imagePixel = colY * canvasWidth + rowX;\\n          if (imagePixel < mask.length && mask[imagePixel] != 0) {\\n            // skip transparent pixels\\n            ++x;\\n            continue;\\n          }\\n\\n          // calculate the offset of the pixel in the pattern\\n          // get the color index from the pattern\\n          uint8 colorIndex = uint8(pattern[y * header.width + x]);\\n          // colorIndex == 0 means transparent\\n          if (colorIndex > 0) {\\n            // get the color from the palette\\n            bytes4 rgba = palette[colorIndex];\\n\\n            // calculate the offset of the pixel in the image\\n            uint offset = 4 * imagePixel;\\n            if (rgba[3] == OPAQUE) {\\n              image[offset] = rgba[0];\\n              image[offset + 1] = rgba[1];\\n              image[offset + 2] = rgba[2];\\n              image[offset + 3] = OPAQUE;\\n\\n              // solhint-disable-next-line no-empty-blocks\\n            } else if (rgba[3] == TRANSPARENT) {\\n              // do nothing\\n            } else {\\n              // blend the pixel with the existing pixel\\n              // again there are two subcases based on whether the existing\\n              // pixel is transparent or not\\n              if (image[offset + 3] == TRANSPARENT) {\\n                // CASE 1: existing pixel is transparent\\n                // so just copy the pixel exactly\\n                // including the semi-transparent alpha value\\n                image[offset] = rgba[0];\\n                image[offset + 1] = rgba[1];\\n                image[offset + 2] = rgba[2];\\n                image[offset + 3] = rgba[3];\\n              } else {\\n                // CASE 2: existing pixel is not transparent\\n                // we need to blend\\n                image[offset] = bytes1(blendPixel(uint8(rgba[0]), uint8(image[offset]), uint8(rgba[3])));\\n                image[offset + 1] = bytes1(blendPixel(uint8(rgba[1]), uint8(image[offset + 1]), uint8(rgba[3])));\\n                image[offset + 2] = bytes1(blendPixel(uint8(rgba[2]), uint8(image[offset + 2]), uint8(rgba[3])));\\n                image[offset + 3] = bytes1(blendAlpha(uint8(rgba[3]), uint8(image[offset + 3])));\\n              }\\n            }\\n          }\\n          ++x;\\n        }\\n        ++y;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/render/OpenAvatarGen0CanvasRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IOpenAvatarGen0RendererDecorator} from '../../IOpenAvatarGen0Renderer.sol';\\nimport {OpenAvatarGen0AssetsCanvasIdStore} from '../assets/OpenAvatarGen0AssetsCanvasIdStore.sol';\\nimport {IOpenAvatarGen0AssetsCanvasLayerCompositor, LayerPatternPalette} from '../interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol';\\nimport {IOpenAvatarGen0CanvasRenderer} from '../interfaces/render/IOpenAvatarGen0CanvasRenderer.sol';\\nimport {ImageEncoder} from '../lib/ImageEncoder.sol';\\nimport {DNA} from '../lib/DNA.sol';\\nimport {OpenAvatarGen0AssetsCanvasLayerCompositor} from './OpenAvatarGen0AssetsCanvasLayerCompositor.sol';\\n\\n/**\\n * @title OpenAvatarGen0CanvasRenderer\\n * @dev This contract renders a DNA as an image in a variety of formats.\\n */\\ncontract OpenAvatarGen0CanvasRenderer is\\n  IOpenAvatarGen0CanvasRenderer,\\n  IOpenAvatarGen0RendererDecorator,\\n  ImageEncoder,\\n  OpenAvatarGen0AssetsCanvasIdStore,\\n  OpenAvatarGen0AssetsCanvasLayerCompositor\\n{\\n  using DNA for bytes32;\\n\\n  /// @dev The layer index for the body layer.\\n  uint8 public constant LAYER_INDEX_BODY = 10;\\n  /// @dev The layer index for the tattoos layer.\\n  uint8 public constant LAYER_INDEX_TATTOOS = 20;\\n  /// @dev The layer index for the makeup layer.\\n  uint8 public constant LAYER_INDEX_MAKEUP = 30;\\n  /// @dev The layer index for the left eye layer.\\n  uint8 public constant LAYER_INDEX_LEFT_EYE = 40;\\n  /// @dev The layer index for the right eye layer.\\n  uint8 public constant LAYER_INDEX_RIGHT_EYE = 50;\\n  /// @dev The layer index for the bottomwear layer.\\n  uint8 public constant LAYER_INDEX_BOTTOMWEAR = 60;\\n  /// @dev The layer index for the footwear layer.\\n  uint8 public constant LAYER_INDEX_FOOTWEAR = 70;\\n  /// @dev The layer index for the topwear layer.\\n  uint8 public constant LAYER_INDEX_TOPWEAR = 80;\\n  /// @dev The layer index for the handwear layer.\\n  uint8 public constant LAYER_INDEX_HANDWEAR = 90;\\n  /// @dev The layer index for the outerwear layer.\\n  uint8 public constant LAYER_INDEX_OUTERWEAR = 100;\\n  /// @dev The layer index for the jewelry layer.\\n  uint8 public constant LAYER_INDEX_JEWELRY = 110;\\n  /// @dev The layer index for the facial hair layer.\\n  uint8 public constant LAYER_INDEX_FACIAL_HAIR = 120;\\n  /// @dev The layer index for the facewear layer.\\n  uint8 public constant LAYER_INDEX_FACEWEAR = 130;\\n  /// @dev The layer index for the eyewear layer.\\n  uint8 public constant LAYER_INDEX_EYEWEAR = 140;\\n  /// @dev The layer index for the hair layer.\\n  uint8 public constant LAYER_INDEX_HAIR = 150;\\n\\n  /// @dev scale the base PNG to an SVG by this factor\\n  uint public constant SVG_SCALE = 10;\\n\\n  constructor(\\n    address ownerProxy,\\n    uint8 canvasId_\\n  )\\n    OpenAvatarGen0AssetsCanvasIdStore(canvasId_)\\n    OpenAvatarGen0AssetsCanvasLayerCompositor(ownerProxy)\\n  // solhint-disable-next-line no-empty-blocks\\n  {\\n\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure virtual override(OpenAvatarGen0AssetsCanvasLayerCompositor) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatarGen0AssetsCanvasLayerCompositor\\n      interfaceId == 0xb93e4881 || // ERC165 interface ID for IOpenAvatarGen0Renderer.\\n      interfaceId == 0x00a663b1 || // ERC165 interface ID for IOpenAvatarGen0RendererDecorator.\\n      interfaceId == 0x13247985 || // ERC165 interface ID for IOpenAvatarGen0CanvasRenderer.\\n      interfaceId == 0x2638c94b; // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Drawing\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function drawOpenAvatar(uint8 canvasId, bytes32 dna) external view returns (bytes memory) {\\n    return _drawOpenAvatar(canvasId, dna);\\n  }\\n\\n  function _drawOpenAvatar(uint8 canvasId, bytes32 dna) internal view returns (bytes memory) {\\n    bytes memory image = new bytes(openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId));\\n    return _drawOpenAvatarOverlay(image, canvasId, dna);\\n  }\\n\\n  function drawOpenAvatarOverlay(bytes memory image, uint8 canvasId, bytes32 dna) external view returns (bytes memory) {\\n    return _drawOpenAvatarOverlay(image, canvasId, dna);\\n  }\\n\\n  /**\\n   * @notice Compose the given DNA into a single image, on top of the given\\n   * base image.\\n   * @param image The base image.\\n   * @param canvasId The canvas ID. Between [0, 11]. Behavior for 12 or\\n   * higher undefined.\\n   * @param dna The DNA to compose.\\n   * @return The image.\\n   */\\n  function _drawOpenAvatarOverlay(\\n    bytes memory image,\\n    uint8 canvasId,\\n    bytes32 dna\\n  ) internal view returns (bytes memory) {\\n    uint expectedNumBytes = openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId);\\n    // sanity check the provided image array\\n    // must be at least as long as the expected image length\\n    if (image.length < expectedNumBytes) {\\n      revert InvalidCanvasSize(canvasId, image.length);\\n    }\\n\\n    /**\\n     * A 32 byte hex string\\n     * @dev The DNA string is a 32 byte hex string.\\n     * @dev The DNA string is immutable.\\n     * @dev The bytes represent the following:\\n     * The bytes represent the following:\\n     * ZZZZ YYYY XXXX WWWW VVVV UUUU TTTT SSSS\\n     * 0000 0000 0000 0000 0000 0000 0000 0000\\n     *\\n     *    Bytes  |  Chars  | Description\\n     *  ---------|---------|-------------\\n     *   [0:1]   | [0:3]   |  body\\n     *   [2:3]   | [4:7]   |  tattoos\\n     *   [4:5]   | [8:11]  |  makeup\\n     *   [6:7]   | [12:15] |  left eye\\n     *   [8:9]   | [16:19] |  right eye\\n     *   [10:11] | [20:23] |  bottomwear\\n     *   [12:13] | [24:27] |  footwear\\n     *   [14:15] | [28:31] |  topwear\\n     *   [16:17] | [32:35] |  handwear\\n     *   [18:19] | [36:39] |  outerwear\\n     *   [20:21] | [40:43] |  jewelry\\n     *   [22:23] | [44:47] |  facial hair\\n     *   [24:25] | [48:51] |  facewear\\n     *   [26:27] | [52:55] |  eyewear\\n     *   [28:29] | [56:59] |  hair\\n     *   [30:31] | [60:63] |  reserved\\n     *\\n     * Each 2-byte section is a struct of the following:\\n     *   [0] | [0:1] |  pattern\\n     *   [1] | [2:3] |  palette\\n     */\\n    LayerPatternPalette[] memory layers = new LayerPatternPalette[](15);\\n    layers[0] = LayerPatternPalette(LAYER_INDEX_BODY, dna.bodyPattern(), dna.bodyPalette());\\n    layers[1] = LayerPatternPalette(LAYER_INDEX_TATTOOS, dna.tattoosPattern(), dna.tattoosPalette());\\n    layers[2] = LayerPatternPalette(LAYER_INDEX_MAKEUP, dna.makeupPattern(), dna.makeupPalette());\\n    layers[3] = LayerPatternPalette(LAYER_INDEX_LEFT_EYE, dna.leftEyePattern(), dna.leftEyePalette());\\n    layers[4] = LayerPatternPalette(LAYER_INDEX_RIGHT_EYE, dna.rightEyePattern(), dna.rightEyePalette());\\n    layers[5] = LayerPatternPalette(LAYER_INDEX_BOTTOMWEAR, dna.bottomwearPattern(), dna.bottomwearPalette());\\n    layers[6] = LayerPatternPalette(LAYER_INDEX_FOOTWEAR, dna.footwearPattern(), dna.footwearPalette());\\n    layers[7] = LayerPatternPalette(LAYER_INDEX_TOPWEAR, dna.topwearPattern(), dna.topwearPalette());\\n    layers[8] = LayerPatternPalette(LAYER_INDEX_OUTERWEAR, dna.outerwearPattern(), dna.outerwearPalette());\\n    layers[9] = LayerPatternPalette(LAYER_INDEX_HANDWEAR, dna.handwearPattern(), dna.handwearPalette());\\n    layers[10] = LayerPatternPalette(LAYER_INDEX_JEWELRY, dna.jewelryPattern(), dna.jewelryPalette());\\n    layers[11] = LayerPatternPalette(LAYER_INDEX_FACIAL_HAIR, dna.facialHairPattern(), dna.facialHairPalette());\\n    layers[12] = LayerPatternPalette(LAYER_INDEX_FACEWEAR, dna.facewearPattern(), dna.facewearPalette());\\n    layers[13] = LayerPatternPalette(LAYER_INDEX_EYEWEAR, dna.eyewearPattern(), dna.eyewearPalette());\\n    layers[14] = LayerPatternPalette(LAYER_INDEX_HAIR, dna.hairPattern(), dna.hairPalette());\\n\\n    return drawLayerComposition(image, canvasId, layers);\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG URI.\\n   * @param dna The DNA to render.\\n   * @return The SVG URI.\\n   */\\n  function renderURI(bytes32 dna) public view override returns (string memory) {\\n    return string(abi.encodePacked('data:image/svg+xml;base64,', renderBase64SVG(dna)));\\n  }\\n\\n  /**\\n   * @notice Render the dna as a byte array.\\n   * @param dna The DNA to render.\\n   * @return The byte array of the image.\\n   */\\n  function renderHex(bytes32 dna) public view override returns (bytes memory) {\\n    return _drawOpenAvatar(canvasId, dna);\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a PNG.\\n   * @param dna The DNA to render.\\n   * @return The PNG image.\\n   */\\n  function renderPNG(bytes32 dna) public view override returns (bytes memory) {\\n    return\\n      encodePNG(\\n        _drawOpenAvatar(canvasId, dna),\\n        openAvatarGen0AssetsRead.getCanvasWidth(canvasId),\\n        openAvatarGen0AssetsRead.getCanvasHeight(canvasId),\\n        openAvatarGen0AssetsRead.hasAlphaChannel()\\n      );\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded PNG.\\n   * @param dna The DNA to render.\\n   * @return The PNG image.\\n   */\\n  function renderBase64PNG(bytes32 dna) public view override returns (bytes memory) {\\n    return\\n      encodeBase64PNG(\\n        _drawOpenAvatar(canvasId, dna),\\n        openAvatarGen0AssetsRead.getCanvasWidth(canvasId),\\n        openAvatarGen0AssetsRead.getCanvasHeight(canvasId),\\n        openAvatarGen0AssetsRead.hasAlphaChannel()\\n      );\\n  }\\n\\n  function renderSVG(bytes32 dna) public view override returns (bytes memory) {\\n    uint width = openAvatarGen0AssetsRead.getCanvasWidth(canvasId);\\n    uint height = openAvatarGen0AssetsRead.getCanvasHeight(canvasId);\\n    return\\n      encodeSVG(\\n        _drawOpenAvatar(canvasId, dna),\\n        width,\\n        height,\\n        openAvatarGen0AssetsRead.hasAlphaChannel(),\\n        SVG_SCALE * width,\\n        SVG_SCALE * height\\n      );\\n  }\\n\\n  function renderBase64SVG(bytes32 dna) public view override returns (bytes memory) {\\n    uint width = openAvatarGen0AssetsRead.getCanvasWidth(canvasId);\\n    uint height = openAvatarGen0AssetsRead.getCanvasHeight(canvasId);\\n    return\\n      encodeBase64SVG(\\n        _drawOpenAvatar(canvasId, dna),\\n        width,\\n        height,\\n        openAvatarGen0AssetsRead.hasAlphaChannel(),\\n        SVG_SCALE * width,\\n        SVG_SCALE * height\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/example/OpenAvatarGen0ExampleMutableCanvasRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {OpenAvatarGen0Renderer} from '../../OpenAvatarGen0Renderer.sol';\\n\\n/**\\n * @title OpenAvatarGen0ExampleMutableCanvasRenderer\\n * @dev This contract renders a DNA as an image in a variety of formats,\\n * and allows for mutating the canvas id by the contract owner.\\n */\\ncontract OpenAvatarGen0ExampleMutableCanvasRenderer is OpenAvatarGen0Renderer {\\n  error CanvasDoesNotExist(uint8 canvasId);\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0Renderer(ownerProxy) {}\\n\\n  /**\\n   * @notice Set the canvas ID.\\n   * @param newCanvasId The new canvas ID.\\n   */\\n  function setCanvasId(uint8 newCanvasId) external onlyOwner {\\n    if (!openAvatarGen0AssetsRead.hasCanvas(newCanvasId)) revert CanvasDoesNotExist(newCanvasId);\\n    canvasId = newCanvasId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/OpenAvatarGen0ProfilePictureRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {OpenAvatarGen0AssetsCanvasIdStore} from '../core/assets/OpenAvatarGen0AssetsCanvasIdStore.sol';\\nimport {IOpenAvatarGen0CanvasRenderer} from '../core/interfaces/render/IOpenAvatarGen0CanvasRenderer.sol';\\nimport {ENSReverseClaimer} from '../core/lib/ENSReverseClaimer.sol';\\nimport {ImageEncoder} from '../core/lib/ImageEncoder.sol';\\nimport {KeepAlive} from '../core/lib/KeepAlive.sol';\\nimport {IOpenAvatarGen0AssetsRead} from '../IOpenAvatarGen0Assets.sol';\\nimport {IOpenAvatarGen0Renderer} from '../IOpenAvatarGen0Renderer.sol';\\nimport {IOpenAvatarGen0TextRecords} from '../IOpenAvatarGen0TextRecords.sol';\\nimport {IOpenAvatarGen0TokenDNA} from '../IOpenAvatarGen0Token.sol';\\nimport {OpenAvatarGenerationZero} from '../OpenAvatarGenerationZero.sol';\\nimport {DNA} from '../core/lib/DNA.sol';\\nimport {IOpenAvatarGen0AssetsCanvasLayerCompositor, LayerPatternPalette} from '../core/interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol';\\n\\nstruct OpenAvatarProfilePictureSettings {\\n  /// @dev Whether or not to use a solid background color.\\n  bool overrideBackground;\\n  /// @dev The background color.\\n  bytes3 backgroundColor;\\n  /// @dev Whether or not to mask below the neck for a \\\"floating head\\\" effect.\\n  bool maskBelowTheNeck;\\n}\\n\\n/**\\n * @title OpenAvatarGen0ProfilePictureRenderer\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @notice A contract for rendering OpenAvatar Gen0 profile pictures.\\n * @dev This contract renders an Avatar against a background image.\\n *\\n * ----------------------------------------------------------------------------\\n * 'pfp' Renderer\\n * ----------------------------------------------------------------------------\\n * A Profile Picture Renderer is provided with the key \\\"pfp\\\".\\n *\\n * The 'pfp' Renderer renders the Avatar with a configurable background color\\n * determined by the 'gen0.renderer.pfp.background-color' text record, which\\n * should be a valid RGB hex color code (e.g. \\\"#ff0000\\\" for red).\\n *\\n * Further, the 'pfp' Renderer provides the option of masking the Avatar\\n * below the neck to create a \\\"floating head\\\" effect. This can be configured\\n * by setting the `gen0.renderer.pfp.mask` text record to \\\"below-the-neck\\\".\\n *\\n * The Profile Picture Renderer is a demonstration of combining the OpenAvatar\\n * building blocks together to create dynamic, owner-customizable behavior. It\\n * utilizes onchain assets, onchain rendering, and onchain text records to\\n * render a customizable Avatar pfp.\\n *\\n * This pattern is permissionless.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Background Image\\n * ----------------------------------------------------------------------------\\n * The background image is by default a white/light gray checkerboard of 8x8\\n * squares arranged in a 4x4 grid.\\n *\\n * The background image can be changed by the token owner by setting the\\n * 'gen0.renderer.pfp.background-image' text record to a valid RGB hex color\\n * code (e.g. \\\"#ff0000\\\" for red).\\n */\\ncontract OpenAvatarGen0ProfilePictureRenderer is\\n  IOpenAvatarGen0Renderer,\\n  OpenAvatarGenerationZero,\\n  OpenAvatarGen0AssetsCanvasIdStore,\\n  ImageEncoder,\\n  ENSReverseClaimer,\\n  KeepAlive\\n{\\n  using DNA for bytes32;\\n\\n  /// @dev Emitted when the fuse is burned to make the background image immutable.\\n  event FuseBurnedChangeBackgroundImage();\\n\\n  /// @dev Error when a component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Error when the fuse is already burned.\\n  error FuseBurned();\\n  /// @dev Error when the required ERC-165 interfaces are not supported.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Error when the provided canvas has an invalid number of bytes per pixel.\\n  error InvalidCanvasBytesPerPixel();\\n  /// @dev Error when calling write-protection function on a non-owned DNA.\\n  error NotOwner(bytes32 dna);\\n\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0Renderer (for clients).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_RENDERER = 0xb93e4881;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsRead (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ = 0x67bf31d1;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsCanvasLayerCompositor (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR = 0x2638c94b;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0TokenDNA (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA = 0x2717336f;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0TextRecords ERC-634 text() (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TEXT = 0x59d1d43c;\\n\\n  /// @dev The canvas id.\\n  uint8 public constant CANVAS_ID = 0;\\n  /// @dev The pixel width of the canvas.\\n  uint8 public constant CANVAS_WIDTH = 32;\\n  /// @dev The pixel height of the canvas.\\n  uint8 public constant CANVAS_HEIGHT = 32;\\n  /// @dev The number of bytes in the canvas - 32 * 32 * 4.\\n  uint16 public constant CANVAS_NUM_BYTES = 4096;\\n\\n  /// @dev The layer index for the body layer.\\n  uint8 public constant LAYER_INDEX_BODY = 10;\\n  /// @dev The layer index for the tattoos layer.\\n  uint8 public constant LAYER_INDEX_TATTOOS = 20;\\n  /// @dev The layer index for the makeup layer.\\n  uint8 public constant LAYER_INDEX_MAKEUP = 30;\\n  /// @dev The layer index for the left eye layer.\\n  uint8 public constant LAYER_INDEX_LEFT_EYE = 40;\\n  /// @dev The layer index for the right eye layer.\\n  uint8 public constant LAYER_INDEX_RIGHT_EYE = 50;\\n  /// @dev The layer index for the bottomwear layer.\\n  uint8 public constant LAYER_INDEX_BOTTOMWEAR = 60;\\n  /// @dev The layer index for the footwear layer.\\n  uint8 public constant LAYER_INDEX_FOOTWEAR = 70;\\n  /// @dev The layer index for the topwear layer.\\n  uint8 public constant LAYER_INDEX_TOPWEAR = 80;\\n  /// @dev The layer index for the handwear layer.\\n  uint8 public constant LAYER_INDEX_HANDWEAR = 90;\\n  /// @dev The layer index for the outerwear layer.\\n  uint8 public constant LAYER_INDEX_OUTERWEAR = 100;\\n  /// @dev The layer index for the jewelry layer.\\n  uint8 public constant LAYER_INDEX_JEWELRY = 110;\\n  /// @dev The layer index for the facial hair layer.\\n  uint8 public constant LAYER_INDEX_FACIAL_HAIR = 120;\\n  /// @dev The layer index for the facewear layer.\\n  uint8 public constant LAYER_INDEX_FACEWEAR = 130;\\n  /// @dev The layer index for the eyewear layer.\\n  uint8 public constant LAYER_INDEX_EYEWEAR = 140;\\n  /// @dev The layer index for the hair layer.\\n  uint8 public constant LAYER_INDEX_HAIR = 150;\\n\\n  /// @dev Scale the SVG by this amount.\\n  uint public constant SVG_SCALE = 10;\\n\\n  /// @dev The \\\"only head\\\" mask which masks below the neck.\\n  bytes public constant BELOW_THE_NECK_MASK =\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0101010101010101010101010000000000000000010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101';\\n\\n  /// @dev The background image, an 4x4 grid of 8x8 checkerboard squares.\\n  ///      Every four lines is one row of the image.\\n  ///      The pattern switches every 8 rows, or 32 lines\\n  ///\\n  ///      This value is constant even though it isn't declared constant,\\n  ///      because declaring it as a constant makes renderURI fail\\n  ///      with out-of-gas?\\n  bytes public backgroundImage =\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff';\\n\\n  /// @dev The text key for the background color of the avatar pfp.\\n  string public constant TEXT_KEY_PFP_BACKGROUND_COLOR = 'gen0.renderer.pfp.background-color';\\n  /// @dev The text key for the mask of the avatar pfp.\\n  string public constant TEXT_KEY_PFP_MASK = 'gen0.renderer.pfp.mask';\\n  /// @dev The text value for a pfp rendering that only displays the head.\\n  string public constant TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK = 'below-the-neck';\\n  /// @dev The keccak26 hash 'below-the-neck', for use in the contract.\\n  bytes32 private constant TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK_HASH =\\n    keccak256(abi.encodePacked(TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK));\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // State variables\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev fuse can be burned to make the background image immutable\\n  bool public fuseBurnedChangeBackgroundImage = false;\\n\\n  /// @dev The OpenAvatarGen0AssetsRead dependency.\\n  IOpenAvatarGen0AssetsRead public openAvatarGen0AssetsRead;\\n  /// @dev The OpenAvatarGen0AssetsCanvasLayerCompositor dependency.\\n  IOpenAvatarGen0AssetsCanvasLayerCompositor public openAvatarGen0AssetsCanvasLayerCompositor;\\n  /// @dev The OpenAvatarDNA dependency.\\n  IOpenAvatarGen0TokenDNA public openAvatarGen0Token;\\n  /// @dev The OpenAvatarGen0TextRecords dependency.\\n  IOpenAvatarGen0TextRecords public openAvatarGen0TextRecords;\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0AssetsCanvasIdStore(CANVAS_ID) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure override(OpenAvatarGenerationZero) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // renderer\\n      interfaceId == INTERFACE_ID_OPENAVATAR_GEN0_RENDERER;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface contract.\\n   * @param openAvatarAssesCanvasLayerCompositor_ The address of the canvas layer compositor contract.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   * @param openAvatarGen0TextRecords_ The address of the text records contract.\\n   */\\n  function initialize(\\n    address openAvatarGen0Assets_,\\n    address openAvatarAssesCanvasLayerCompositor_,\\n    address openAvatarGen0Token_,\\n    address openAvatarGen0TextRecords_\\n  ) external onlyOwner {\\n    // helpers enforce only-once invariant and check ERC-165 supportsInterface()\\n    setOpenAvatarGen0Assets(openAvatarGen0Assets_);\\n    setOpenAvatarGen0AssetsCanvasLayerCompositor(openAvatarAssesCanvasLayerCompositor_);\\n    setOpenAvatarGen0Token(openAvatarGen0Token_);\\n    setOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0AssetsRead) != address(0);\\n  }\\n\\n  /**\\n   * @notice Get the asset store.\\n   * @return The address of the asset store read interface contract.\\n   */\\n  function getOpenAvatarGen0Assets() external view returns (address) {\\n    return address(openAvatarGen0AssetsRead);\\n  }\\n\\n  /**\\n   * @notice Set the asset store.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface contract.\\n   */\\n  function setOpenAvatarGen0Assets(address openAvatarGen0Assets_) internal {\\n    // only set once\\n    if (address(openAvatarGen0AssetsRead) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only read interface is required\\n    if (!IERC165(openAvatarGen0Assets_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ)) {\\n      revert InterfaceUnsupported(openAvatarGen0Assets_, INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ);\\n    }\\n\\n    // set\\n    openAvatarGen0AssetsRead = IOpenAvatarGen0AssetsRead(openAvatarGen0Assets_);\\n\\n    // sanity check\\n    if (openAvatarGen0AssetsRead.getBytesPerPixel() != 4) revert InvalidCanvasBytesPerPixel();\\n  }\\n\\n  /**\\n   * @notice Get the IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n   * @return The address of the IOpenAvatarGen0AssetsCanvasLayerCompositor interface contract.\\n   */\\n  function getOpenAvatarGen0AssetsCanvasLayerCompositor() external view returns (address) {\\n    return address(openAvatarGen0AssetsCanvasLayerCompositor);\\n  }\\n\\n  /**\\n   * @notice Set the IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n   * @param openAvatarAssesCanvasLayerCompositor_ The address of the\\n   * IOpenAvatarGen0AssetsCanvasLayerCompositor interface contract.\\n   */\\n  function setOpenAvatarGen0AssetsCanvasLayerCompositor(address openAvatarAssesCanvasLayerCompositor_) internal {\\n    // only set once\\n    if (address(openAvatarGen0AssetsCanvasLayerCompositor) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    //\\n    // we don't need use renderURI from OpenAvatarGen0Renderer, which is too high level here\\n    //\\n    // instead we use the compositor interface to manually layer assets on top of each other\\n    // allowing us to modify the image layers before encoding as a PNG/SVG\\n    if (\\n      !IERC165(openAvatarAssesCanvasLayerCompositor_).supportsInterface(\\n        INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR\\n      )\\n    ) {\\n      revert InterfaceUnsupported(\\n        openAvatarAssesCanvasLayerCompositor_,\\n        INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR\\n      );\\n    }\\n\\n    // set\\n    openAvatarGen0AssetsCanvasLayerCompositor = IOpenAvatarGen0AssetsCanvasLayerCompositor(\\n      openAvatarAssesCanvasLayerCompositor_\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the OpenAvatar token.\\n   * @return The address of the OpenAvatar token read interface contract.\\n   */\\n  function getOpenAvatarGen0Token() external view returns (address) {\\n    return address(openAvatarGen0Token);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatar token address.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   */\\n  function setOpenAvatarGen0Token(address openAvatarGen0Token_) internal {\\n    // only set once\\n    if (address(openAvatarGen0Token) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only DNA interface is required\\n    if (!IERC165(openAvatarGen0Token_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA)) {\\n      revert InterfaceUnsupported(openAvatarGen0Token_, INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA);\\n    }\\n\\n    // set\\n    openAvatarGen0Token = IOpenAvatarGen0TokenDNA(openAvatarGen0Token_);\\n  }\\n\\n  /**\\n   * @notice Get the OpenAvatarGen0TextRecords.\\n   * @return The address of the OpenAvatarGen0TextRecords.\\n   */\\n  function getOpenAvatarGen0TextRecords() external view returns (address) {\\n    return address(openAvatarGen0TextRecords);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatarGen0TextRecords address.\\n   * @param openAvatarGen0TextRecords_ The address of the OpenAvatarGen0TextRecords contract.\\n   */\\n  function setOpenAvatarGen0TextRecords(address openAvatarGen0TextRecords_) internal {\\n    // only set once\\n    if (address(openAvatarGen0TextRecords) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only text() interface is required\\n    if (!IERC165(openAvatarGen0TextRecords_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TEXT)) {\\n      revert InterfaceUnsupported(openAvatarGen0TextRecords_, INTERFACE_ID_OPENAVATAR_GEN0_TEXT);\\n    }\\n\\n    // set\\n    openAvatarGen0TextRecords = IOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Modifiers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Modifier to check that the caller is the owner of the token.\\n   */\\n  modifier onlyTokenOwner(bytes32 dna) {\\n    if (msg.sender != openAvatarGen0Token.ownerOfDNA(dna)) {\\n      revert NotOwner(dna);\\n    }\\n    _;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the fuse burned status for changing the background image.\\n   */\\n  function getFuseBurnedChangeBackgroundImage() external view returns (bool) {\\n    return fuseBurnedChangeBackgroundImage;\\n  }\\n\\n  /**\\n   * @dev Burn the fuse to prevent changing the background image.\\n   */\\n  function burnFuseChangeBackgroundImage() external onlyOwner {\\n    if (!fuseBurnedChangeBackgroundImage) {\\n      fuseBurnedChangeBackgroundImage = true;\\n      emit FuseBurnedChangeBackgroundImage();\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Background Image\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the default background image.\\n   */\\n  function getBackgroundImage() external view returns (bytes memory) {\\n    return backgroundImage;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Profile Picture Settings\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Return the background settings for the given DNA.\\n   * @param dna The DNA to set the background color for.\\n   * @return The background settings.\\n   */\\n  function getProfilePictureSettings(bytes32 dna) external view returns (OpenAvatarProfilePictureSettings memory) {\\n    string memory pfpBackground = openAvatarGen0TextRecords.text(dna, TEXT_KEY_PFP_BACKGROUND_COLOR);\\n\\n    // pfpBackground is a RGB hexstring like #AABBCC\\n    // we need to decompose into a bytes3 0xAABBCC\\n    bool overrideBackground = bytes(pfpBackground).length == 7;\\n    bytes3 backgroundColor = _hexStrToBytes3(pfpBackground);\\n\\n    // pfpMask is a string like 'below-the-neck' or ''\\n    string memory pfpMask = openAvatarGen0TextRecords.text(dna, TEXT_KEY_PFP_MASK);\\n    // security (gas) - don't compute hash if incorrect length\\n    bool validLength = bytes(pfpMask).length == 14; // 'below-the-neck' is 14 bytes\\n    bool maskBelowTheNeck = false;\\n    if (validLength) {\\n      maskBelowTheNeck = keccak256(abi.encodePacked(pfpMask)) == TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK_HASH;\\n    }\\n\\n    return OpenAvatarProfilePictureSettings(overrideBackground, backgroundColor, maskBelowTheNeck);\\n  }\\n\\n  /**\\n   * @notice Convert an RGB hextring #AABBCC to a bytes3 0xAABBCC.\\n   * @param _str The string to convert.\\n   * @return The bytes3 value\\n   * @dev if the string is not length-7 or leading # is missing, return 0x000000\\n   * @dev if a pair of characters is not a valid hex string, return 0x00 for that byte\\n   */\\n  function _hexStrToBytes3(string memory _str) internal pure returns (bytes3) {\\n    bytes memory b = bytes(_str);\\n    if (b.length != 7) return 0x000000;\\n\\n    // the first character should be '#'\\n    if (b[0] != 0x23) return 0x000000;\\n\\n    bytes3 rgb;\\n    for (uint i = 0; i < 3; i++) {\\n      rgb |= bytes3(_safeParseByte(_str, 2 * i + 1)) >> (8 * i);\\n    }\\n    return rgb;\\n  }\\n\\n  /**\\n   * @notice Safely parse a byte.\\n   * @param _str The string to parse.\\n   * @param _start The start index.\\n   * @return The parsed byte, or 0x00 if the byte is invalid.\\n   */\\n  function _safeParseByte(string memory _str, uint _start) private pure returns (bytes1) {\\n    bytes1 b1 = _safeParseHexDigit(bytes(_str)[_start]);\\n    bytes1 b2 = _safeParseHexDigit(bytes(_str)[_start + 1]);\\n    return (b1 << 4) | b2;\\n  }\\n\\n  /**\\n   * @dev Safely parse a hex digit.\\n   * @param _hex The hex digit to parse.\\n   * @return The parsed digit, or 0x00 if the digit is invalid.\\n   */\\n  function _safeParseHexDigit(bytes1 _hex) private pure returns (bytes1) {\\n    if (_hex >= '0' && _hex <= '9') {\\n      return bytes1(uint8(_hex) - 48);\\n    }\\n    if (_hex >= 'a' && _hex <= 'f') {\\n      return bytes1(uint8(_hex) - 97 + 10);\\n    }\\n    if (_hex >= 'A' && _hex <= 'F') {\\n      return bytes1(uint8(_hex) - 65 + 10);\\n    }\\n    return 0;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Rendering - external\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG URI.\\n   * @param dna The DNA to render.\\n   * @return The SVG URI.\\n   */\\n  function renderURI(bytes32 dna) external view override returns (string memory) {\\n    return string(abi.encodePacked('data:image/svg+xml;base64,', renderBase64SVG(dna)));\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG URI with the provided settings.\\n   * @param dna The DNA to render.\\n   * @param pfpSettings The background settings to use.\\n   * @return The SVG URI.\\n   */\\n  function renderURIWithSettings(\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) external view returns (string memory) {\\n    return string(abi.encodePacked('data:image/svg+xml;base64,', renderBase64SVGWithSettings(dna, pfpSettings)));\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Rendering - helpers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function createBackgroundImage(\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) internal view returns (bytes memory, uint8, uint8) {\\n    bytes memory image = new bytes(openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId));\\n\\n    uint8 width = openAvatarGen0AssetsRead.getCanvasWidth(canvasId);\\n    uint8 height = openAvatarGen0AssetsRead.getCanvasHeight(canvasId);\\n\\n    if (pfpSettings.overrideBackground) {\\n      uint numPixels = uint(width) * uint(height);\\n      // override default background with solid color\\n      for (uint i = 0; i < numPixels; ) {\\n        uint offset = i * 4;\\n        image[offset] = pfpSettings.backgroundColor[0];\\n        image[offset + 1] = pfpSettings.backgroundColor[1];\\n        image[offset + 2] = pfpSettings.backgroundColor[2];\\n        image[offset + 3] = 0xff;\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // copy default background\\n      for (uint i = 0; i < image.length; ) {\\n        image[i] = backgroundImage[i];\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    }\\n    return (image, width, height);\\n  }\\n\\n  /// @dev kind of a hack but doesn't matter. seems like a one-off so just put it here\\n  function _drawNeckLine(bytes memory image) internal pure returns (bytes memory) {\\n    // the bottom of the head is an 8-pixel line representing the chinline/neck\\n    // by default, this is will be the \\\"dark\\\" color for that body color palette,\\n    // which is not black but rather a dark skin tone color.\\n    //\\n    // but if we are drawing just the head without the body, we actually want to have\\n    // the head outlined in black because that's the boundary shape.\\n    //\\n    // so we draw 8 black pixels over top of the \\\"dark\\\" pixels\\n    //\\n    // another design considered was uploading the \\\"head\\\" pattern separately to\\n    // the assets contract, for the same canvas, but on a \\\"off\\\" layer (11?) (body=10)\\n    // which fits with the intended design of how to use the assets contract\\n    //\\n    // but\\n    //\\n    // this was a one-off for now, so we are just doing the 8 pixel difference here\\n\\n    // 8 pixels across\\n\\n    // 1st pixel\\n    image[2864] = 0x00;\\n    image[2865] = 0x00;\\n    image[2866] = 0x00;\\n    image[2867] = 0xff;\\n    // 2nd pixel\\n    image[2868] = 0x00;\\n    image[2869] = 0x00;\\n    image[2870] = 0x00;\\n    image[2871] = 0xff;\\n    // 3rd pixel\\n    image[2872] = 0x00;\\n    image[2873] = 0x00;\\n    image[2874] = 0x00;\\n    image[2875] = 0xff;\\n    // 4th pixel\\n    image[2876] = 0x00;\\n    image[2877] = 0x00;\\n    image[2878] = 0x00;\\n    image[2879] = 0xff;\\n    // 5th pixel\\n    image[2880] = 0x00;\\n    image[2881] = 0x00;\\n    image[2882] = 0x00;\\n    image[2883] = 0xff;\\n    // 6th pixel\\n    image[2884] = 0x00;\\n    image[2885] = 0x00;\\n    image[2886] = 0x00;\\n    image[2887] = 0xff;\\n    // 7th pixel\\n    image[2888] = 0x00;\\n    image[2889] = 0x00;\\n    image[2890] = 0x00;\\n    // 8th pixel\\n    image[2891] = 0xff;\\n    image[2892] = 0x00;\\n    image[2893] = 0x00;\\n    image[2894] = 0x00;\\n    image[2895] = 0xff;\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Draw the layers of the avatar.\\n   * @param image The image to draw on.\\n   * @param mask The mask to apply before drawing.\\n   * @param canvasId The canvas ID to draw on.\\n   * @param dna The DNA to use.\\n   * @param pfpSettings The background settings to use.\\n   * @return The image with the layers drawn.\\n   */\\n  function _drawLayers(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) internal view returns (bytes memory) {\\n    // body\\n    uint8 bodyPattern = dna.bodyPattern();\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_BODY,\\n      bodyPattern,\\n      dna.bodyPalette()\\n    );\\n\\n    // the neck is normally drawn on top of the body with a skin tone \\\"neck\\\"\\n    // but for this we want black border around the head not the body\\n    //\\n    // transparent bodies don't have a neck line\\n    if (pfpSettings.maskBelowTheNeck && bodyPattern != 0) {\\n      image = _drawNeckLine(image);\\n    }\\n\\n    // tattoos\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_TATTOOS,\\n      dna.tattoosPattern(),\\n      dna.tattoosPalette()\\n    );\\n    // makeup\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_MAKEUP,\\n      dna.makeupPattern(),\\n      dna.makeupPalette()\\n    );\\n    // eyes\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_LEFT_EYE,\\n      dna.leftEyePattern(),\\n      dna.leftEyePalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_RIGHT_EYE,\\n      dna.rightEyePattern(),\\n      dna.rightEyePalette()\\n    );\\n    // clothes\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_BOTTOMWEAR,\\n      dna.bottomwearPattern(),\\n      dna.bottomwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_FOOTWEAR,\\n      dna.footwearPattern(),\\n      dna.footwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_TOPWEAR,\\n      dna.topwearPattern(),\\n      dna.topwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_HANDWEAR,\\n      dna.handwearPattern(),\\n      dna.handwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_OUTERWEAR,\\n      dna.outerwearPattern(),\\n      dna.outerwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_JEWELRY,\\n      dna.jewelryPattern(),\\n      dna.jewelryPalette()\\n    );\\n    // facial hair - no mask\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawLayer(\\n      image,\\n      canvasId,\\n      LAYER_INDEX_FACIAL_HAIR,\\n      dna.facialHairPattern(),\\n      dna.facialHairPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_FACEWEAR,\\n      dna.facewearPattern(),\\n      dna.facewearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_EYEWEAR,\\n      dna.eyewearPattern(),\\n      dna.eyewearPalette()\\n    );\\n    // hair - no mask\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawLayer(\\n      image,\\n      canvasId,\\n      LAYER_INDEX_HAIR,\\n      dna.hairPattern(),\\n      dna.hairPalette()\\n    );\\n    return image;\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG.\\n   * @param dna The DNA to render.\\n   * @return The base64-encoded SVG.\\n   */\\n  function renderBase64SVG(bytes32 dna) public view returns (bytes memory) {\\n    return renderBase64SVGWithSettings(dna, this.getProfilePictureSettings(dna));\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG.\\n   * @param dna The DNA to render.\\n   * @param pfpSettings The settings to use for the profile picture.\\n   * @return The base64-encoded SVG.\\n   */\\n  function renderBase64SVGWithSettings(\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) public view returns (bytes memory) {\\n    (bytes memory image, uint8 width, uint8 height) = createBackgroundImage(pfpSettings);\\n\\n    // copy mask into memory\\n    bytes memory mask = new bytes(openAvatarGen0AssetsRead.getCanvasNumPixels(canvasId));\\n    if (pfpSettings.maskBelowTheNeck) {\\n      uint length = mask.length;\\n      for (uint i = 0; i < length; ) {\\n        mask[i] = BELOW_THE_NECK_MASK[i];\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    }\\n    image = _drawLayers(image, mask, canvasId, dna, pfpSettings);\\n    return\\n      encodeBase64SVG(\\n        image,\\n        width,\\n        height,\\n        openAvatarGen0AssetsRead.hasAlphaChannel(),\\n        SVG_SCALE * width,\\n        SVG_SCALE * height\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarSentinel\\n * @dev An interface for the OpenAvatar sentinel.\\n */\\ninterface IOpenAvatarSentinel {\\n  /// @dev Returns true\\n  function openAvatar() external view returns (bool);\\n}\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev An interface for the OpenAvatar generation.\\n */\\ninterface IOpenAvatarGeneration {\\n  /// @dev Returns the generation of the OpenAvatar\\n  function openAvatarGeneration() external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatar\\n * @dev The OpenAvatar interface.\\n */\\ninterface IOpenAvatar is IOpenAvatarSentinel, IOpenAvatarGeneration {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {IOpenAvatarGen0AssetsPatternStoreRead, IOpenAvatarGen0AssetsPatternStoreWrite, IOpenAvatarGen0AssetsPatternStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\n\\n/**\\n * @title IOpenAvatarGen0AssetsRead\\n * @dev This interface reads asset data\\n */\\ninterface IOpenAvatarGen0AssetsRead is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreRead\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsWrite\\n * @dev This interface writes asset data\\n */\\ninterface IOpenAvatarGen0AssetsWrite is\\n  IOpenAvatarGen0AssetsCanvasStoreWrite,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0Assets\\n * @dev This interface reads and writes asset data\\n */\\ninterface IOpenAvatarGen0Assets is IOpenAvatarGen0AssetsRead, IOpenAvatarGen0AssetsWrite {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0Renderer\\n * @dev The primary interface for rendering an Avatar.\\n */\\ninterface IOpenAvatarGen0Renderer {\\n  function renderURI(bytes32 dna) external view returns (string memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0RendererDecorator\\n * @dev The IOpenAvatarGen0RendererDecorator interface.\\n */\\ninterface IOpenAvatarGen0RendererDecorator is IOpenAvatarGen0Renderer {\\n  function renderHex(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderPNG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderBase64PNG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderSVG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderBase64SVG(bytes32 dna) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0RendererRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0RendererRegistryRead\\n * @dev An interface for reading registered OpenAvatar renderers.\\n */\\ninterface IOpenAvatarGen0RendererRegistryRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Read\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumRenderers() external view returns (uint);\\n\\n  function getRendererByKey(string calldata key) external view returns (address);\\n\\n  function getRendererByDNA(bytes32 dna) external view returns (address);\\n\\n  function getDefaultRenderer() external view returns (address);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0RendererRegistryWrite\\n * @dev An interface for registering OpenAvatar renderers.\\n */\\ninterface IOpenAvatarGen0RendererRegistryWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Write\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function addRenderer(string calldata key, address _renderer) external;\\n\\n  function setDefaultRendererByKey(string calldata key) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0RendererRegistry\\n * @dev An interface for registering OpenAvatar renderers.\\n */\\ninterface IOpenAvatarGen0RendererRegistry is IOpenAvatarGen0RendererRegistryRead, IOpenAvatarGen0RendererRegistryWrite {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0TextRecords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\nimport {IERC634} from './core/dependencies/IERC634.sol';\\n\\n/**\\n * @title Text Record\\n * @notice A key-value string pair.\\n */\\nstruct TextRecord {\\n  string key;\\n  string value;\\n}\\n\\n/**\\n * @title DNA Text Record\\n * @notice A DNA and a key-value string pair.\\n */\\nstruct DNATextRecord {\\n  bytes32 dna;\\n  string key;\\n  string value;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TextRecords\\n * @dev The TextStore contract stores text data by 32-byte OpenAvatar DNA.\\n *\\n * This contract is based on ERC-634 originally developed for ENS.\\n */\\ninterface IOpenAvatarGen0TextRecords is IERC634 {\\n  function setText(bytes32 dna, string calldata key, string calldata value) external;\\n\\n  function setText2(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2\\n  ) external;\\n\\n  function setText3(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3\\n  ) external;\\n\\n  function setText4(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3,\\n    string calldata key4,\\n    string calldata value4\\n  ) external;\\n\\n  function setTexts(bytes32 dna, TextRecord[] calldata records) external;\\n\\n  function setTextBatch(DNATextRecord[] calldata records) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatar} from './IOpenAvatar.sol';\\n\\n/**\\n * @title OpenAvatarGen0TokenMetadata\\n * @dev The OpenAvatar metadata.\\n */\\nstruct OpenAvatarGen0TokenMetadata {\\n  uint generation;\\n  uint tokenId;\\n  bytes32 dna;\\n  address creator;\\n  address renderer;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMetadata\\n * @dev An interface for the OpenAvatar metadata.\\n */\\ninterface IOpenAvatarGen0TokenMetadata {\\n  function getOpenAvatarGen0TokenMetadataByDNA(bytes32 dna) external view returns (OpenAvatarGen0TokenMetadata memory);\\n\\n  function getOpenAvatarGen0TokenMetadataByTokenId(\\n    uint tokenId\\n  ) external view returns (OpenAvatarGen0TokenMetadata memory);\\n\\n  function openAvatarURI(bytes32 dna) external view returns (string memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenDNA\\n * @dev An interface for the OpenAvatar DNA.\\n */\\ninterface IOpenAvatarGen0TokenDNA {\\n  function getDNAByTokenId(uint tokenId) external view returns (bytes32);\\n\\n  function getDNAsByTokenIds(uint[] calldata tokenIds) external view returns (bytes32[] memory);\\n\\n  function getTokenIdByDNA(bytes32 dna) external view returns (uint);\\n\\n  function getTokenIdsByDNAs(bytes32[] calldata dnas) external view returns (uint[] memory);\\n\\n  function creatorOf(uint tokenId) external view returns (address);\\n\\n  function creatorOfDNA(bytes32 dna) external view returns (address);\\n\\n  function ownerOfDNA(bytes32 dna) external view returns (address);\\n\\n  function ownerOfDNAs(bytes32[] calldata dnas) external view returns (address[] memory);\\n}\\n\\n/*\\n| Function                  | Mint State | Payment       | Batch  | Specify Recipient |\\n|---------------------------|------------|---------------|--------|-------------------|\\n| mint(dna)                 | Public     | mintPrice     | No     | No                |\\n| mintTo(to, dna)           | Public     | mintPrice     | No     | Yes               |\\n| mintBatch(dnas)           | Public     | mintPrice * N | Yes    | No                |\\n| mintBatchTo(to, dnas)     | Public     | mintPrice * N | Yes    | Yes               |\\n*/\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintRead\\n * @notice An interface for reading OpenAvatar minting state.\\n */\\ninterface IOpenAvatarGen0TokenMintRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Supply\\n  /////////////////////////////////////////////////////////////////////////////\\n  function supplySoftCap() external view returns (uint16);\\n\\n  function supplyHardCap() external view returns (uint16);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Price\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getMintPrice() external view returns (uint);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint State\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function isMinted(bytes32 dna) external view returns (bool);\\n\\n  function isMintedEach(bytes32[] calldata dnas) external view returns (bool[] memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintWrite\\n * @notice An interface for minting OpenAvatars.\\n */\\ninterface IOpenAvatarGen0TokenMintWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint\\n  /////////////////////////////////////////////////////////////////////////////\\n  function mint(bytes32 dna) external payable;\\n\\n  function mintTo(address to, bytes32 dna) external payable;\\n\\n  function mintBatch(bytes32[] calldata dnas) external payable;\\n\\n  function mintBatchTo(address to, bytes32[] calldata dnas) external payable;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintAdmin\\n * @notice An interface allowing the public mint price to be updated.\\n */\\ninterface IOpenAvatarGen0TokenMintAdmin {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Price\\n  /////////////////////////////////////////////////////////////////////////////\\n  function setMintPrice(uint val) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMint\\n * @notice The mint interfaces for OpenAvatarGen0Token.\\n */\\ninterface IOpenAvatarGen0TokenMint is\\n  IOpenAvatarGen0TokenMintRead,\\n  IOpenAvatarGen0TokenMintWrite,\\n  IOpenAvatarGen0TokenMintAdmin\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatar\\n * @dev The OpenAvatar interface.\\n */\\ninterface IOpenAvatarGen0Token is\\n  IOpenAvatar,\\n  IOpenAvatarGen0TokenMetadata,\\n  IOpenAvatarGen0TokenDNA,\\n  IOpenAvatarGen0TokenMint\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {OpenAvatarGen0AssetsCanvasStore} from './core/assets/OpenAvatarGen0AssetsCanvasStore.sol';\\nimport {OpenAvatarGen0AssetsPaletteStore} from './core/assets/OpenAvatarGen0AssetsPaletteStore.sol';\\nimport {OpenAvatarGen0AssetsPatternStore} from './core/assets/OpenAvatarGen0AssetsPatternStore.sol';\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {IOpenAvatarGen0Assets} from './IOpenAvatarGen0Assets.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\n\\n/**\\n * @title OpenAvatarGen0Assets\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @dev This contract is responsible for storing OpenAvatar art assets and\\n *      metadata. The art was created by hand by the contract author.\\n *\\n * Immutability:\\n * - This contract references no other contracts\\n * - All assets are stored in append-only arrays.\\n * - Once uploaded, no asset can be modified or deleted.\\n * - So, asset references are immutable and reads are invariant.\\n * - Fuses can be burned to prevent contract owner uploading further assets.\\n * - If all fuses are burned, no further assets can be uploaded and storage is\\n *   effectively frozen.\\n *\\n * Terminology:\\n * Colors are stored as color palettes.\\n * Patterns are byte arrays that reference colors in a palette.\\n *\\n * - Palettes:\\n *   - A \\\"palette\\\" is an array of RGBA colors (bytes4[]).\\n *   - A \\\"palette code\\\" defines an array of palettes (bytes4[][]).\\n *\\n * - Canvas\\n *   - A \\\"canvas\\\" is an image canvas with header (uint8 id, uint8 height,\\n *   uint8 width), and an array of layers.\\n *\\n * - Layer\\n *   - A \\\"layer\\\" is a layer of a canvas, which references an array of patterns.\\n *\\n * - Pattern\\n *  - A \\\"pattern\\\" is a byte array that references colors by index in a palette.\\n *\\n * Fuses:\\n * - A fuse can be burned to prevent adding new canvases.\\n * - A fuse can be burned to prevent adding new layers (for all canvases).\\n * - A fuse can be burned to prevent adding new patterns (for all layers).\\n * - A fuse can be burned to prevent adding new palettes (for all patterns).\\n *\\n * Solidity:\\n * Due to C3 Linearization, we cannot \\\"is\\\" IOpenAvatarGen0Assets.\\n * However, IOpenAvatarGen0Assets is indeed implemented fully by OpenAvatarGen0AssetsPatternStore.\\n */\\ncontract OpenAvatarGen0Assets is OpenAvatarGenerationZero, OpenAvatarGen0AssetsPatternStore, ENSReverseClaimer {\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0AssetsPatternStore(ownerProxy) {}\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override(OpenAvatarGenerationZero, OpenAvatarGen0AssetsPatternStore) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // assets\\n      interfaceId == 0x67bf31d1 || // ERC165 interface ID for IOpenAvatarGen0AssetsRead.\\n      interfaceId == 0x511ecd08 || // ERC165 interface ID for IOpenAvatarGen0AssetsWrite.\\n      interfaceId == 0x36a1fcd9 || // ERC165 interface ID for IOpenAvatarGen0Assets.\\n      // canvas\\n      interfaceId == 0x91411495 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreRead.\\n      interfaceId == 0x4d4a1c57 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStoreWrite.\\n      interfaceId == 0xdc0b08c2 || // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasStore.\\n      // palette\\n      interfaceId == 0x5577825f || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreRead.\\n      interfaceId == 0x9c9764e9 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStoreWrite.\\n      interfaceId == 0xc9e0e6b6 || // ERC165 interface ID for IOpenAvatarGen0AssetsPaletteStore.\\n      // pattern\\n      interfaceId == 0x32c8b38e || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreRead.\\n      interfaceId == 0xcd89a9e1 || // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStoreWrite.\\n      interfaceId == 0xff411a6f; // ERC165 interface ID for IOpenAvatarGen0AssetsPatternStore.\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {OpenAvatarGen0CanvasRenderer} from './core/render/OpenAvatarGen0CanvasRenderer.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\n\\n/**\\n * @title OpenAvatarGen0Renderer\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @dev This contract is responsible for rendering an Avatar based on its DNA.\\n *      Avatars are rendered as 32x32 RGBA images with transparency around\\n *      the Avatar's body. Avatars are rendered using hand-drawn, original art\\n *      created by the contract author (one pixel at a time with a ball mouse).\\n *\\n * Immutable:\\n * Once initialized, the contract is immutable.\\n * Art stored in OpenAvatarGen0Assets is immutable (append-only storage).\\n * So, rendering is deterministic.\\n *\\n * Gas:\\n * Due to PNG encoding, rendering may cost 10,000,000+ gas.\\n * With further base64 encoding (i.e. token URI), combined rendering and\\n * encoding may cost 15,000,000+ gas.\\n *\\n * Terminology:\\n * - Canvas Id (uint8): Selects from an array of canvases\\n * - Layer Index (uint8): Selects from an array of layers for a given canvas\\n * - Pattern Index (uint8): Selects from an array of patterns for a given layer\\n * - Palette Index (uint8): Selects from an array of palettes for a given\\n *                          pattern\\n * - Color Index (uint8): Selects from an array of colors for a given palette\\n * - Color (bytes4): RGBA\\n *\\n * Structure:\\n * - Every layer contains an array of selectable patterns.\\n * - Each pattern references a specific palette code.\\n * - Each palette code corresponds to an array of palettes.\\n * - Each pattern (uncompressed) is a 32x32=1024 array of color indices.\\n *      - compressed as [height, width, offsetX, offsetY, bytes]\\n *  -Each palette is an array of RGBA (bytes4[]) which always starts with\\n *   0x00000000 (transparent).\\n * - So, a color index of 0x00 is transparent.\\n * - In essence, each byte in a pattern is a color index which defines an\\n *   RGBA color in the corresponding palette array to draw for that pixel.\\n *\\n * Rendering:\\n * Layers are drawn one over another, from lowest to highest layer index,\\n * with alpha-blending. The 32-byte Avatar DNA is interpretted to as\\n * defining the pattern and palette for each layer. Pixels are drawn based\\n * on color derived from DNA-encoded pattern and palette index. If a DNA\\n * defines an invalid index, the layer is drawn as transparent.\\n *\\n * DNA:\\n * It should be noted that while OpenAvatar DNA is interpretted here as\\n * implicitly defining asset references for drawing the Avatar, the concept\\n * of DNA is designed as a standalone building block. Application-specific\\n * re-interpretations of OpenAvatar DNA are entirely possible and encouraged.\\n *\\n * Encoding:\\n * Avatars are rendered as base64-encoded PNGs, embedded within an SVG. The\\n * SVG embeds the PNG as a <foreignObject>, chosen due to Safari's lack of\\n * support (bug?) for \\\"image-rendering: pixelated\\\" of <image> elements within\\n * SVGs.\\n */\\ncontract OpenAvatarGen0Renderer is OpenAvatarGenerationZero, OpenAvatarGen0CanvasRenderer, ENSReverseClaimer {\\n  /// @dev The canvas ID for the default, front-facing Avatar pose.\\n  uint8 public constant CANVAS_ID = 0;\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0CanvasRenderer(ownerProxy, CANVAS_ID) {}\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override(OpenAvatarGenerationZero, OpenAvatarGen0CanvasRenderer) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // IOpenAvatarGen0AssetsCanvasLayerCompositor\\n      interfaceId == 0xb93e4881 || // ERC165 interface ID for IOpenAvatarGen0Renderer.\\n      interfaceId == 0x00a663b1 || // ERC165 interface ID for IOpenAvatarGen0RendererDecorator.\\n      interfaceId == 0x13247985 || // ERC165 interface ID for IOpenAvatarGen0CanvasRenderer.\\n      interfaceId == 0x2638c94b; // ERC165 interface ID for IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0RendererRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {FuseGuard} from './core/lib/FuseGuard.sol';\\nimport {IOpenAvatarGen0TokenDNA} from './IOpenAvatarGen0Token.sol';\\nimport {IOpenAvatarGen0RendererRegistry} from './IOpenAvatarGen0RendererRegistry.sol';\\nimport {IOpenAvatarGen0TextRecords} from './IOpenAvatarGen0TextRecords.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\n\\n/**\\n * @title OpenAvatarGen0RendererRegistry\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @notice An append-only registry of OpenAvatarGen0Renderer contracts.\\n * @dev An append-only registry of renderer addresses.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Renderer Registry\\n * ----------------------------------------------------------------------------\\n * A separate `OpenAvatarGen0RendererRegistry` contract is used to register\\n * Renderers for use by the `OpenAvatarGen0Token` contract.\\n *\\n * The `OpenAvatarGen0Token` contract determines which Renderer to use for a\\n * given token by delegating to the `OpenAvatarGen0RendererRegistry` contract.\\n *\\n * Default Renderer:\\n * The registry maintains a concept of \\\"default\\\" Renderer, which may be\\n * modified by the contract owner.\\n *\\n * Token Owners may optionally override the default Renderer for their token by\\n * writing a valid 'gen0.renderer` text record to the\\n * `OpenAvatarGen0TextRecords` contract.\\n *\\n * When the ERC721::tokenURI method is called, the Renderer (token default if\\n * exists, otherwise registry default) is called to render the URI.\\n *\\n * The net effect is that rendering is invariant and onchain.\\n *\\n * If further Renderers are made available by the registry owner, token owners\\n * may opt-in to those upgrades either in general (by not setting a token\\n * default) or explicit choice (by setting their corresponding text record).\\n *\\n * This \\\"soft-upgradeability\\\" can be sunset by burning the registry fuse which\\n * blocks further additions, thereby making the list of available Renderers\\n * fully immutable.\\n *\\n * At launch, two Renderers are provided, described below.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * 'base' Renderer\\n * ----------------------------------------------------------------------------\\n * A base Renderer is provided with the key \\\"base\\\".\\n *\\n * The 'base' Renderer renders the Avatar with transparent background as a\\n * forward-facing sprite.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * 'pfp' Renderer\\n * ----------------------------------------------------------------------------\\n * A Profile Picture Renderer is provided with the key \\\"pfp\\\".\\n *\\n * The 'pfp' Renderer renders the Avatar with a configurable background color\\n * determined by the 'gen0.renderer.pfp.background-color' text record, which\\n * should be a valid RGB hex color code (e.g. \\\"#ff0000\\\" for red).\\n *\\n * Further, the 'pfp' Renderer provides the option of masking the Avatar\\n * below the neck to create a \\\"floating head\\\" effect. This can be configured\\n * by setting the `gen0.renderer.pfp.mask` text record to \\\"below-the-neck\\\".\\n *\\n * The Profile Picture Renderer is a demonstration of combining the OpenAvatar\\n * building blocks together to create dynamic, owner-customizable behavior. It\\n * utilizes onchain assets, onchain rendering, and onchain text records to\\n * render a customizable Avatar pfp.\\n *\\n * This pattern is permissionless.\\n */\\ncontract OpenAvatarGen0RendererRegistry is\\n  IOpenAvatarGen0RendererRegistry,\\n  OpenAvatarGenerationZero,\\n  FuseGuard,\\n  ENSReverseClaimer\\n{\\n  /// @dev Event emitted when default renderer is changed.\\n  event DefaultRendererChange(string indexed key);\\n  /// @dev Event emitted when the fuse is burned to disable adding renderers.\\n  event FuseBurnedCanAddRenderer();\\n  /// @dev Event emitted when a renderer is added.\\n  event RendererAdd(string indexed key, address renderer);\\n\\n  /// @dev Error when a component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Event emitted when an interface is not supported.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Revert error when renderer index is out of bounds.\\n  error RendererDoesNotExist(string key);\\n  /// @dev Revert error when renderer already exists.\\n  error RendererAlreadyExists(address renderer);\\n  /// @dev Event emitted when a renderer key already exists.\\n  error RendererKeyAlreadyExists(string key);\\n  /// @dev Revert error when renderer key is empty.\\n  error RendererKeyCannotBeEmpty();\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0Renderer (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_RENDERER = 0xb93e4881;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0TextRecords ERC-634 text() (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TEXT = 0x59d1d43c;\\n\\n  /// @dev The text key for the renderer.\\n  string public constant TEXT_KEY_RENDERER = 'gen0.renderer';\\n\\n  /// @dev The OpenAvatarGen0TextRecords dependency.\\n  IOpenAvatarGen0TextRecords public openAvatarGen0TextRecords;\\n\\n  /// @dev The default renderer index.\\n  string private defaultRendererKey;\\n\\n  /// @dev The list of renderers.\\n  mapping(string key => address renderer) public renderers;\\n  /// @dev The list of renderer keys.\\n  string[] public rendererKeys;\\n  /// @dev The list of renderer keys by address.\\n  mapping(address renderer => bool) public isRenderer;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for changing the mint state.\\n  bool public fuseBurnedCanAddRenderer = false;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the\\n    // configured owner.\\n    // using a proxy allows for using same constructor args and thus same\\n    // bytecode for all instances of this contract.\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure override(OpenAvatarGenerationZero) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // IOpenAvatarGen0RendererRegistry\\n      interfaceId == 0x8646df82; // ERC165 interface ID for IOpenAvatarGen0RendererRegistry\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0TextRecords_ The address of the OpenAvatarGen0TextRecords contract.\\n   */\\n  function initialize(address openAvatarGen0TextRecords_) external onlyOwner {\\n    setOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0TextRecords) != address(0);\\n  }\\n\\n  /**\\n   * @notice Get the OpenAvatarGen0TextRecords.\\n   * @return The address of the OpenAvatarGen0TextRecords.\\n   */\\n  function getOpenAvatarGen0TextRecords() external view returns (address) {\\n    return address(openAvatarGen0TextRecords);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatarGen0TextRecords address.\\n   * @param openAvatarGen0TextRecords_ The address of the OpenAvatarGen0TextRecords contract.\\n   */\\n  function setOpenAvatarGen0TextRecords(address openAvatarGen0TextRecords_) internal {\\n    // only set once\\n    if (address(openAvatarGen0TextRecords) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only text() interface is required\\n    if (!IERC165(openAvatarGen0TextRecords_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TEXT)) {\\n      revert InterfaceUnsupported(openAvatarGen0TextRecords_, INTERFACE_ID_OPENAVATAR_GEN0_TEXT);\\n    }\\n\\n    // set\\n    openAvatarGen0TextRecords = IOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Default renderer\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns the default Renderer address for all token ids.\\n   * @return The default Renderer address for all token ids.\\n   */\\n  function getDefaultRenderer() external view returns (address) {\\n    return renderers[defaultRendererKey];\\n  }\\n\\n  /**\\n   * @notice Sets the default Renderer address for all token ids.\\n   * @param key The key of the Renderer to set as the default.\\n   */\\n  function setDefaultRendererByKey(string calldata key) external onlyOwner {\\n    // check if the key exists\\n    address renderer = renderers[key];\\n    if (renderer == address(0)) revert RendererDoesNotExist(key);\\n    // check if the key is the same as the current default\\n    bool isSame = (bytes(defaultRendererKey).length == bytes(key).length) &&\\n      (keccak256(bytes(defaultRendererKey)) == keccak256(bytes(key)));\\n    if (isSame) return;\\n    // set the new default\\n    defaultRendererKey = key;\\n    emit DefaultRendererChange(key);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Read\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns the number of renderers available.\\n   * @return The number of renderers available.\\n   */\\n  function getNumRenderers() external view returns (uint) {\\n    return rendererKeys.length;\\n  }\\n\\n  /**\\n   * @notice Returns the keys of the renderers.\\n   * @return The keys of the renderers.\\n   */\\n  function getRendererKeys() external view returns (string[] memory) {\\n    return rendererKeys;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the renderer.\\n   * @return The address of the renderer or 0x0 if not found.\\n   */\\n  function getRendererByKey(string calldata key) external view returns (address) {\\n    return renderers[key];\\n  }\\n\\n  /**\\n   * @notice Returns the Renderer address for a given DNA.\\n   * @param dna The dna to lookup.\\n   * @return The Renderer address for the given DNA.\\n   * @dev If the DNA has not been minted, this will revert.\\n   */\\n  function getRendererByDNA(bytes32 dna) public view returns (address) {\\n    address renderer = address(0);\\n    if (address(openAvatarGen0TextRecords) != address(0)) {\\n      string memory rendererKey = openAvatarGen0TextRecords.text(dna, TEXT_KEY_RENDERER);\\n      renderer = renderers[rendererKey];\\n    }\\n    if (renderer == address(0)) return renderers[defaultRendererKey];\\n    return renderer;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Write\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Pushes the address of the renderer to the end of the list.\\n   * @param key The key of the renderer.\\n   * @param renderer The address of the renderer.\\n   * @dev Only callable by owner. Reverts if the key already exists.\\n   */\\n  function addRenderer(string calldata key, address renderer) external onlyOwner {\\n    // fuse must not be burned\\n    if (fuseBurnedCanAddRenderer) revert OperationBlockedByBurnedFuse();\\n\\n    // key must not be empty\\n    if (bytes(key).length == 0) revert RendererKeyCannotBeEmpty();\\n\\n    // must support the interface\\n    if (!IERC165(renderer).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_RENDERER)) {\\n      revert InterfaceUnsupported(renderer, INTERFACE_ID_OPENAVATAR_GEN0_RENDERER);\\n    }\\n\\n    // should not already exist\\n    if (renderers[key] != address(0)) revert RendererKeyAlreadyExists(key);\\n    // address should not already exist\\n    if (isRenderer[renderer]) revert RendererAlreadyExists(renderer);\\n\\n    // add the renderer\\n    renderers[key] = renderer;\\n    rendererKeys.push(key);\\n    isRenderer[renderer] = true;\\n    emit RendererAdd(key, renderer);\\n\\n    // set the default if it is empty\\n    if (bytes(defaultRendererKey).length == 0) {\\n      defaultRendererKey = key;\\n      emit DefaultRendererChange(key);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////\\n  // Fuse - Can Add Renderer\\n  /////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Burn the fuse to permanently disable changing the public mint time.\\n   * @dev Only callable by owner.\\n   * @dev no-op if fuse is already burned\\n   */\\n  function burnFuseCanAddRenderer() external onlyOwner {\\n    if (fuseBurnedCanAddRenderer) return;\\n    fuseBurnedCanAddRenderer = true;\\n    emit FuseBurnedCanAddRenderer();\\n  }\\n\\n  /**\\n   * @notice Returns whether the fuse is burned to permanently disable changing the public mint time.\\n   * @return Whether the fuse is burned to permanently disable changing the public mint time.\\n   */\\n  function isFuseBurnedCanAddRenderer() external view returns (bool) {\\n    return fuseBurnedCanAddRenderer;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0TextRecords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {DNATextRecord, IOpenAvatarGen0TextRecords, TextRecord} from './IOpenAvatarGen0TextRecords.sol';\\nimport {IERC634} from './core/dependencies/IERC634.sol';\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {KeepAlive} from './core/lib/KeepAlive.sol';\\nimport {IOpenAvatarGen0TokenDNA} from './IOpenAvatarGen0Token.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\n\\n/**\\n * @title OpenAvatarGen0TextRecords\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @notice This contract stores text records as key/value pairs, by 32-byte\\n * OpenAvatar DNA.\\n * @dev This contract is based on ERC-634 text() originally developed for ENS.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Text Records\\n * ----------------------------------------------------------------------------\\n * A *Text Record* is a core building block of OpenAvatar.\\n *\\n * Text records are key-value pairs of strings stored onchain by Avatar DNA\\n * in the `OpenAvatarGen0TextRecords` contract. Token owners may store any\\n * key/value pair for their token's DNA.\\n *\\n * This mechanism provides an onchain key/value data store for Avatar DNA.\\n *\\n * Text records may be used by other contracts and applications to read/write\\n * arbitrary data to an OpenAvatar.\\n *\\n * For example, text records are used to determine if the token owner has\\n * set the background color for their Profile Picture Renderer. This allows\\n * token owners to dynamically customize their Avatar onchain, and provides\\n * an example for more complex integrations.\\n */\\ncontract OpenAvatarGen0TextRecords is\\n  IOpenAvatarGen0TextRecords,\\n  OpenAvatarGenerationZero,\\n  ENSReverseClaimer,\\n  KeepAlive\\n{\\n  /// @dev Error when a component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Error when the required ERC-165 interfaces are not supported.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Error when the caller is not the token owner.\\n  error NotTokenOwner();\\n\\n  /// @dev The EIP-165 interface id for the text data extension\\n  bytes4 private constant INTERFACE_ID_TEXT = 0x59d1d43c;\\n  /// @dev The ERC-165 interface id for the OpenAvatarDNA (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA = 0x2717336f;\\n\\n  /// @dev An event emitted when text data is set for a DNA\\n  event TextChanged(bytes32 indexed dna, string indexedKey, string key);\\n\\n  /// @dev The text data for each DNA\\n  mapping(bytes32 => mapping(string => string)) private texts;\\n\\n  /// @dev The OpenAvatar contract\\n  IOpenAvatarGen0TokenDNA public openAvatarGen0Token;\\n\\n  constructor(address ownerProxy) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the\\n    // configured owner.\\n    // using a proxy allows for using same constructor args and thus same\\n    // bytecode for all instances of this contract.\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   */\\n  function initialize(address openAvatarGen0Token_) external onlyOwner {\\n    setOpenAvatarGen0Token(openAvatarGen0Token_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0Token) != address(0);\\n  }\\n\\n  /**\\n   * @dev Get the OpenAvatar token.\\n   * @return The address of the OpenAvatar token read interface contract.\\n   */\\n  function getOpenAvatarGen0Token() external view returns (address) {\\n    return address(openAvatarGen0Token);\\n  }\\n\\n  /**\\n   * @dev Set the OpenAvatar token address.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   */\\n  function setOpenAvatarGen0Token(address openAvatarGen0Token_) internal {\\n    // only set once\\n    if (address(openAvatarGen0Token) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only DNA interface is required\\n    if (!IERC165(openAvatarGen0Token_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA)) {\\n      revert InterfaceUnsupported(openAvatarGen0Token_, INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA);\\n    }\\n\\n    // set\\n    openAvatarGen0Token = IOpenAvatarGen0TokenDNA(openAvatarGen0Token_);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure override(OpenAvatarGenerationZero) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // ERC634\\n      interfaceId == INTERFACE_ID_TEXT || // ERC165 interface ID for ERC634.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // IOpenAvatarGen0TextRecords\\n      interfaceId == 0x8aacdebd; // ERC165 interface ID for IOpenAvatarGen0TextRecords.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-634 equivalent\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Retrieves text metadata for DNA.\\n   * Each DNA may have multiple pieces of metadata, identified by a unique string key.\\n   * f no text data exists for DNA with the key key, the empty string is returned.\\n   * @param dna The DNA to query.\\n   * @param key The text data key to query.\\n   * @return The associated text data.\\n   */\\n  function text(bytes32 dna, string calldata key) external view returns (string memory) {\\n    return texts[dna][key];\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Setters\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Sets text records for DNA with the unique key key to value,\\n   * overwriting anything previously stored for DNA and key. To clear a\\n   * text field, set it to the empty string.\\n   * @param dna The DNA to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   */\\n  function _setText(bytes32 dna, string calldata key, string calldata value) internal {\\n    texts[dna][key] = value;\\n    emit TextChanged(dna, key, key);\\n  }\\n\\n  /**\\n   * @dev Sets text records for DNA with the unique key key to value,\\n   * overwriting anything previously stored for DNA and key. To clear a\\n   * text field, set it to the empty string.\\n   * Only callable by the token owner.\\n   * @param dna The DNA to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   */\\n  function setText(bytes32 dna, string calldata key, string calldata value) external {\\n    if (openAvatarGen0Token.ownerOfDNA(dna) != msg.sender) revert NotTokenOwner();\\n    _setText(dna, key, value);\\n  }\\n\\n  /**\\n   * @dev Sets text records for DNA with the unique key key to value,\\n   * overwriting anything previously stored for DNA and key. To clear a\\n   * text field, set it to the empty string.\\n   * Only callable by the token owner.\\n   * @param dna The DNA to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   * @param key2 The second key to set.\\n   * @param value2 The second text data value to set.\\n   */\\n  function setText2(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2\\n  ) external {\\n    if (openAvatarGen0Token.ownerOfDNA(dna) != msg.sender) revert NotTokenOwner();\\n    _setText(dna, key, value);\\n    _setText(dna, key2, value2);\\n  }\\n\\n  /**\\n   * @dev Sets text records for DNA with the unique key key to value,\\n   * overwriting anything previously stored for DNA and key. To clear a\\n   * text field, set it to the empty string.\\n   * Only callable by the token owner.\\n   * @param dna The DNA to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   * @param key2 The second key to set.\\n   * @param value2 The second text data value to set.\\n   * @param key3 The third key to set.\\n   * @param value3 The third text data value to set.\\n   */\\n  function setText3(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3\\n  ) external {\\n    if (openAvatarGen0Token.ownerOfDNA(dna) != msg.sender) revert NotTokenOwner();\\n    _setText(dna, key, value);\\n    _setText(dna, key2, value2);\\n    _setText(dna, key3, value3);\\n  }\\n\\n  /**\\n   * @dev Sets text records for DNA with the unique key key to value,\\n   * overwriting anything previously stored for DNA and key. To clear a\\n   * text field, set it to the empty string.\\n   * Only callable by the token owner.\\n   * @param dna The DNA to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   * @param key2 The second key to set.\\n   * @param value2 The second text data value to set.\\n   * @param key3 The third key to set.\\n   * @param value3 The third text data value to set.\\n   * @param key4 The fourth key to set.\\n\\n   */\\n  function setText4(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3,\\n    string calldata key4,\\n    string calldata value4\\n  ) external {\\n    if (openAvatarGen0Token.ownerOfDNA(dna) != msg.sender) revert NotTokenOwner();\\n    _setText(dna, key, value);\\n    _setText(dna, key2, value2);\\n    _setText(dna, key3, value3);\\n    _setText(dna, key4, value4);\\n  }\\n\\n  /**\\n   * @dev Sets an array of text records for a DNA. Each text record is a key/value pair.\\n   * Only callable by the token owner.\\n   * @param dna The DNA to update.\\n   * @param records The text records to set.\\n   */\\n  function setTexts(bytes32 dna, TextRecord[] calldata records) external {\\n    if (openAvatarGen0Token.ownerOfDNA(dna) != msg.sender) revert NotTokenOwner();\\n    uint length = records.length;\\n    for (uint256 i = 0; i < length; ) {\\n      TextRecord calldata record = records[i];\\n      _setText(dna, record.key, record.value);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Set a batch text records where each record may be a different DNA.\\n   *\\n   * @param records The records to set.\\n   */\\n  function setTextBatch(DNATextRecord[] calldata records) external {\\n    uint length = records.length;\\n    for (uint256 i = 0; i < length; ) {\\n      DNATextRecord calldata record = records[i];\\n      if (openAvatarGen0Token.ownerOfDNA(record.dna) != msg.sender) revert NotTokenOwner();\\n      _setText(record.dna, record.key, record.value);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGen0Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {ERC721A, ERC721AQueryable, IERC721A} from 'erc721a/contracts/extensions/ERC721AQueryable.sol';\\nimport {Base64} from './core/dependencies/Base64.sol';\\nimport {AOpenAvatarMintStateMachine} from './core/erc721/AOpenAvatarMintStateMachine.sol';\\nimport {Treasury} from './core/erc721/Treasury.sol';\\nimport {ENSReverseClaimer} from './core/lib/ENSReverseClaimer.sol';\\nimport {OpenAvatarGenerationZero} from './OpenAvatarGenerationZero.sol';\\nimport {IOpenAvatarGen0RendererRegistry} from './IOpenAvatarGen0RendererRegistry.sol';\\nimport {IOpenAvatarGen0Renderer} from './IOpenAvatarGen0Renderer.sol';\\nimport {IOpenAvatarGen0Token, OpenAvatarGen0TokenMetadata} from './IOpenAvatarGen0Token.sol';\\n\\n/**\\n * @title OpenAvatarGen0Token\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @notice OpenAvatar is an onchain protocol for Avatars.\\n * @dev This contract is the main entry point for the OpenAvatar protocol.\\n *\\n * ----------------------------------------------------------------------------\\n * Generation 0\\n * ----------------------------------------------------------------------------\\n * This is OpenAvatar Generation 0.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * ERC-721\\n * ----------------------------------------------------------------------------\\n * OpenAvatarGen0Token is an ERC-721 token that represents an OpenAvatar.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * DNA\\n * ----------------------------------------------------------------------------\\n * *DNA* is a core building block of OpenAvatar.\\n *\\n * Every OpenAvatar is defined by a unique 32-byte DNA (gen 0). No two\\n * OpenAvatars can have the same DNA.\\n *\\n * DNA is an extensible building block of OpenAvatar. Application-specific\\n * re-interpretations of OpenAvatar DNA are entirely possible and encouraged.\\n *\\n * DNA determines how an OpenAvatar is rendered (gen 0). When users select how\\n * their Avatar looks, they are by proxy choosing the Avatar's 32-byte DNA.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Renderer\\n * ----------------------------------------------------------------------------\\n * A *Renderer* is a core building block of OpenAvatar.\\n *\\n * A render interface is defined, consisting of the following method:\\n *   ```\\n *   interface IOpenAvatarGen0Renderer {\\n *       function renderURI(bytes32 dna) external view returns (string memory);\\n *   }\\n *   ```\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Text Records\\n * ----------------------------------------------------------------------------\\n * A *Text Record* is a core building block of OpenAvatar.\\n *\\n * Text records are key-value pairs of strings stored onchain by Avatar DNA\\n * in the `OpenAvatarGen0TextRecords` contract. Token owners may store any\\n * key/value pair for their token's DNA.\\n *\\n * This mechanism provides an onchain key/value data store for Avatar DNA.\\n *\\n * Text records may be used by other contracts and applications to read/write\\n * arbitrary data to an OpenAvatar.\\n *\\n * For example, text records are used to determine if the token owner has\\n * set the background color for their Profile Picture Renderer. This allows\\n * token owners to dynamically customize their Avatar onchain, and provides\\n * an example for more complex integrations.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Renderer Registry\\n * ----------------------------------------------------------------------------\\n * A separate `OpenAvatarGen0RendererRegistry` contract is used to register\\n * Renderers for use by the `OpenAvatarGen0Token` contract.\\n *\\n * The `OpenAvatarGen0Token` contract determines which Renderer to use for a\\n * given token by delegating to the `OpenAvatarGen0RendererRegistry` contract.\\n *\\n * Default Renderer:\\n * The registry maintains a concept of \\\"default\\\" Renderer, which may be\\n * modified by the contract owner.\\n *\\n * Token Owners may optionally override the default Renderer for their token by\\n * writing a valid 'gen0.renderer` text record to the\\n * `OpenAvatarGen0TextRecords` contract.\\n *\\n * When the ERC721::tokenURI method is called, the Renderer (token default if\\n * exists, otherwise registry default) is called to render the URI.\\n *\\n * The net effect is that rendering is invariant and onchain.\\n *\\n * If further Renderers are made available by the registry owner, token owners\\n * may opt-in to those upgrades either in general (by not setting a token\\n * default) or explicit choice (by setting their corresponding text record).\\n *\\n * This \\\"soft-upgradeability\\\" can be sunset by burning the registry fuse which\\n * blocks further additions, thereby making the list of available Renderers\\n * fully immutable.\\n *\\n * At launch, two Renderers are provided, described below.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * 'base' Renderer\\n * ----------------------------------------------------------------------------\\n * A base Renderer is provided with the key \\\"base\\\".\\n *\\n * The 'base' Renderer renders the Avatar with transparent background as a\\n * forward-facing sprite.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * 'pfp' Renderer\\n * ----------------------------------------------------------------------------\\n * A Profile Picture Renderer is provided with the key \\\"pfp\\\".\\n *\\n * The 'pfp' Renderer renders the Avatar with a configurable background color\\n * determined by the 'gen0.renderer.pfp.background-color' text record, which\\n * should be a valid RGB hex color code (e.g. \\\"#ff0000\\\" for red).\\n *\\n * Further, the 'pfp' Renderer provides the option of masking the Avatar\\n * below the neck to create a \\\"floating head\\\" effect. This can be configured\\n * by setting the `gen0.renderer.pfp.mask` text record to \\\"below-the-neck\\\".\\n *\\n * The Profile Picture Renderer is a demonstration of combining the OpenAvatar\\n * building blocks together to create dynamic, owner-customizable behavior. It\\n * utilizes onchain assets, onchain rendering, and onchain text records to\\n * render a customizable Avatar pfp.\\n *\\n * This pattern is permissionless.\\n */\\ncontract OpenAvatarGen0Token is\\n  OpenAvatarGenerationZero,\\n  IOpenAvatarGen0Renderer,\\n  IOpenAvatarGen0Token,\\n  AOpenAvatarMintStateMachine,\\n  Treasury,\\n  ENSReverseClaimer,\\n  ERC721AQueryable\\n{\\n  using Strings for address;\\n  using Strings for uint256;\\n\\n  /// @dev Event emitted when the fuse is burned for increasing the soft cap\\n  ///      supply\\n  event FuseBurnedCanIncreaseSupplySoftCap();\\n  /// @dev Event emitted when the fuse is burned for lowering the mint price\\n  event FuseBurnedCanLowerMintPrice();\\n  /// @dev Event emitted when the fuse is burned for raising the mint price\\n  event FuseBurnedCanRaiseMintPrice();\\n  /// @dev Event emitted when a new avatar is minted.\\n  event Mint(address to, bytes32 dna, uint tokenId);\\n  /// @dev Event emitted when the mint price is changed\\n  event MintPriceChange(uint oldPrice, uint newPrice);\\n\\n  /// @dev Error when a component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Revert error when the DNA does already minted.\\n  error DNAAlreadyMinted(bytes32 dna);\\n  /// @dev Revert error when the DNA does not exist.\\n  error DNADoesNotExist(bytes32 dna);\\n  /// @dev Event emitted when an interface is not supported.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Revert error when the batch size limit is exceeded.\\n  error MintBatchSizeLimitExceeded(uint batchSize);\\n  /// @dev Revert error when underpaid for a mint.\\n  error MintUnderpaid();\\n  /// @dev Revert error when not token owner for a permissioned action.\\n  error NotTokenOwner(uint tokenId);\\n  /// @dev Revert error when trying to batch mint the null DNA, which is not\\n  /// allowed.\\n  error NullDNARestrictedFromBatchMint(bytes32 dna);\\n  /// @dev Revert error when the supply cap is exceeded.\\n  error SupplyCapExceeded();\\n  /// @dev Revert error when the supply cap change would decrease the supply\\n  ///      cap.\\n  error SupplySoftCapChangeIsNotAnIncrease();\\n  /// @dev Revert error when the supply cap increase is not higher than the\\n  /// current supply cap.\\n  error SupplySoftCapIsMonotonicallyIncraesing();\\n  /// @dev Revert error when the supply cap change exceeds hard cap.\\n  error SupplySoftCapWouldExceedHardCap(uint newSupplyCap);\\n  /// @dev Revert error when token id does not exist.\\n  error TokenIdDoesNotExist(uint tokenId);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0Renderer\\n  ///      (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_RENDERER_REGISTRY = 0x8646df82;\\n\\n  /// @dev The IOpenAvatarGen0RendererRegistry dependency.\\n  IOpenAvatarGen0RendererRegistry public openAvatarGen0RendererRegistry;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Internal Data Structures\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  // bidirectional mapping from token id <--> dna\\n\\n  /// @dev One half of bi-directional mapping from DNA <-> token id.\\n  mapping(bytes32 dna => uint tokenId) private dnaToTokenId;\\n  /// @dev One half of bi-directional mapping from token id <-> DNA.\\n  mapping(uint tokenId => bytes32 dna) private tokenIdToDna;\\n  /// @dev track who minted each token\\n  mapping(bytes32 dna => address minter) private dnaToCreator;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Supply\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The maxium number of avatars.\\n  ///      Invariant: totalSupply() <= supplySoftCap() <= supplyHardCap()\\n  uint16 public constant MAX_SUPPLY = 16384;\\n  /// @dev The maxium number of avatars that can be minted in a single batch.\\n  uint8 public constant MAX_MINT_BATCH_SIZE_LIMIT = 20;\\n\\n  /// @dev The total number of avatars that can be minted.\\n  ///      Invariant: totalSupply() <= supplySoftCap() <= supplyHardCap()\\n  uint16 public _supplySoftCap = 0;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Price\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev The price to mint an avatar.\\n  uint public mintPrice;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Flag to indicate if the fuse has been burned for increasing the\\n  ///      supply cap\\n  bool public fuseBurnedCanIncreaseSupplySoftCap = false;\\n  /// @dev Flag to indicate if the fuse has been burned for lowering the mint\\n  ///      price\\n  bool public fuseBurnedCanLowerMintPrice = false;\\n  /// @dev Flag to indicate if the fuse has been burned for raising the mint\\n  ///      price\\n  bool public fuseBurnedCanRaiseMintPrice = false;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Constructor\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  constructor(address ownerProxy) ERC721A('OpenAvatar', 'AVATR') {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the\\n    // configured owner.\\n    // using a proxy allows for using same constructor args and thus same\\n    // bytecode for all instances of this contract.\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override(OpenAvatarGenerationZero, ERC721A, IERC721A) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // ERC721\\n      interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n      interfaceId == 0x5b5e139f || // ERC165 interface ID for ERC721Metadata.\\n      // IOpenAvatarGen0Renderer\\n      interfaceId == 0xb93e4881 || // ERC165 interface ID for IOpenAvatarGen0Renderer.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // IOpenAvatarGen0Token\\n      interfaceId == 0xc5f6fb61 || // ERC165 interface ID for IOpenAvatarGen0TokenMetadata.\\n      interfaceId == 0x2717336f || // ERC165 interface ID for IOpenAvatarGen0TokenDNA.\\n      interfaceId == 0x9840fe50 || // ERC165 interface ID for IOpenAvatarGen0Token.\\n      // IOpenAvatarGen0TokenMint\\n      interfaceId == 0x27fc9ea2 || // ERC165 interface ID for IOpenAvatarGen0TokenMintRead.\\n      interfaceId == 0x2f683360 || // ERC165 interface ID for IOpenAvatarGen0TokenMintWrite\\n      interfaceId == 0xf4a0a528 || // ERC165 interface ID for IOpenAvatarGen0TokenMintAdmin\\n      interfaceId == 0xfc3408ea; // ERC165 interface ID for IOpenAvatarGen0TokenMint.\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0RendererRegistry_ The address of the `OpenAvatarGen0RendererRegistry` contract.\\n   */\\n  function initialize(address openAvatarGen0RendererRegistry_) external onlyOwner {\\n    setOpenAvatarGen0RendererRegistry(openAvatarGen0RendererRegistry_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0RendererRegistry) != address(0);\\n  }\\n\\n  /**\\n   * @notice Retrieves the address of the `OpenAvatarGen0RendererRegistry`\\n   * contract.\\n   *\\n   * The `OpenAvatarGen0RendererRegistry` contract is a registry that contains\\n   * references to all available renderers. A renderer is a contract that\\n   * takes avatar DNA and generates an image representation of the avatar.\\n   *\\n   * These renderers can be selected by token owners to customize the look\\n   * of their avatar, as specified in the 'gen0.renderer' field in the\\n   * `OpenAvatarGen0TextRecords` contract.\\n   *\\n   * Furthermore, the `OpenAvatarGen0RendererRegistry` contract can be\\n   * controlled by the registry owner, who can add new renderers or\\n   * permanently lock the list of registered renderers.\\n   *\\n   * @return The address of the `OpenAvatarGen0RendererRegistry` contract.\\n   */\\n  function getOpenAvatarGen0RendererRegistry() external view returns (address) {\\n    return address(openAvatarGen0RendererRegistry);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatarGen0RendererRegistry address.\\n   * @param openAvatarGen0RendererRegistry_ The address of the\\n   * OpenAvatarGen0RendererRegistry contract.\\n   * @dev This function can only be called once.\\n   */\\n  function setOpenAvatarGen0RendererRegistry(address openAvatarGen0RendererRegistry_) internal {\\n    // only set once\\n    if (address(openAvatarGen0RendererRegistry) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only DNA interface is required\\n    if (!IERC165(openAvatarGen0RendererRegistry_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_RENDERER_REGISTRY)) {\\n      revert InterfaceUnsupported(openAvatarGen0RendererRegistry_, INTERFACE_ID_OPENAVATAR_GEN0_RENDERER_REGISTRY);\\n    }\\n\\n    // set\\n    openAvatarGen0RendererRegistry = IOpenAvatarGen0RendererRegistry(openAvatarGen0RendererRegistry_);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC721Metadata\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Generates and returns a base64 encoded JSON URI containing\\n   * metadata for a specified token ID.\\n   *\\n   * This URI encapsulates data such as the Generation of the avatar,\\n   * the DNA (unique identifier), the address of the OpenAvatarGen0Renderer\\n   * used to render the avatar, the ABI signature of the rendering function,\\n   * the token ID, and the owner of the token. It also includes an 'image'\\n   * field with a URI representing the avatar's image, and an 'attributes'\\n   * array containing trait metadata.\\n   *\\n   * @param tokenId The unique identifier of the token whose metadata to\\n   * retrieve.\\n   *\\n   * @return A base64 encoded JSON URI that contains metadata of the\\n   * given token ID.\\n   *\\n   * @dev This function will revert if the provided token ID has not\\n   * been minted yet.\\n   *\\n   * @dev The provided metadata extends the OpenAvatar URI to include\\n   * adherence to the OpenSea metadata standards.\\n   */\\n  function tokenURI(uint tokenId) public view override(ERC721A, IERC721A) returns (string memory) {\\n    if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n    string memory generationZeroStr = OPENAVATAR_GENERATION_ZERO.toString();\\n    bytes32 dna = tokenIdToDna[tokenId];\\n    address mintedBy = dnaToCreator[dna];\\n    string memory mintedByStr = mintedBy.toHexString();\\n    address rendererAddress = openAvatarGen0RendererRegistry.getRendererByDNA(dna);\\n    string memory rendererAddressStr = rendererAddress.toHexString();\\n    string memory tokenIdStr = tokenId.toString();\\n    string memory dnaStr = uint(dna).toHexString(32);\\n    return\\n      string(\\n        abi.encodePacked(\\n          'data:application/json;base64,',\\n          Base64.encode(\\n            abi.encodePacked(\\n              '{\\\"generation\\\":',\\n              generationZeroStr,\\n              ',\\\"dna\\\":\\\"',\\n              dnaStr,\\n              '\\\",\\\"creator\\\":\\\"',\\n              dnaToCreator[dna].toHexString(),\\n              '\\\",\\\"renderer\\\":\\\"',\\n              rendererAddressStr,\\n              '\\\",\\\"renderer_abi\\\":\\\"renderURI(bytes32)\\\",\\\"token_id\\\":',\\n              tokenIdStr,\\n              ',\\\"name\\\":\\\"OpenAvatar #',\\n              tokenIdStr,\\n              '\\\",\\\"description\\\":\\\"OpenAvatar is an onchain protocol for Avatars.\\\",\\\"image\\\":\\\"',\\n              IOpenAvatarGen0Renderer(rendererAddress).renderURI(dna),\\n              '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Generation\\\",\\\"value\\\":',\\n              generationZeroStr,\\n              ',\\\"display_type\\\":\\\"number\\\"},{\\\"trait_type\\\":\\\"DNA\\\",\\\"value\\\":\\\"',\\n              dnaStr,\\n              '\\\"},{\\\"trait_type\\\":\\\"Creator\\\",\\\"value\\\":\\\"',\\n              mintedByStr,\\n              '\\\"},{\\\"trait_type\\\":\\\"Renderer\\\",\\\"value\\\":\\\"',\\n              rendererAddressStr,\\n              '\\\"},{\\\"trait_type\\\":\\\"Token ID\\\",\\\"value\\\":',\\n              tokenIdStr,\\n              ',\\\"display_type\\\":\\\"number\\\"}]}'\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGen0Renderer\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice This function provides a render URI that represents the renderered\\n   * image for a specific avatar DNA. The `OpenAvatarGen0RendererRegistry`\\n   * contract manages a list of available renderers.\\n   *\\n   * The token owner can specify their preferred renderer from these\\n   * available options by setting the 'gen0.renderer' key in the\\n   * `OpenAvatarGen0TextRecords` contract to the renderer key. For example,\\n   *   ```\\n   *   openAvatarGen0TextRecords.setText(<dna>, 'gen0.renderer', 'base');\\n   *   ```\\n   * or,\\n   *   ```\\n   *   openAvatarGen0TextRecords.setText(<dna>, 'gen0.renderer', 'pfp');\\n   *   ```\\n   *\\n   * The registry owner may add more registries to become available\\n   * in the future, or the registry owner may burn a fuse to prevent\\n   * new renderes being added and permanently lock list of registered\\n   * renderers.\\n   *\\n   * This function, essentially, delegates the rendering task to the\\n   * `renderURI` function of the `OpenAvatarGen0Renderer` that matches the\\n   * given DNA. If no specific renderer is assigned to a token, it uses\\n   * the default renderer.\\n   *\\n   * @param dna The unique DNA of the avatar to render.\\n   * @return A base64 encoded URI that represents the rendered image\\n   * for the provided avatar DNA.\\n   *\\n   * @dev For a minted DNA, this function uses the assigned renderer or\\n   * the default renderer if none is set. For an un-minted DNA, it always\\n   * uses the default renderer.\\n   */\\n  function renderURI(bytes32 dna) external view returns (string memory) {\\n    return IOpenAvatarGen0Renderer(openAvatarGen0RendererRegistry.getRendererByDNA(dna)).renderURI(dna);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGen0TokenMetadata - An interface for the OpenAvatar metadata.\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns a base64-encoded JSON URI that encapsulates OpenAvatar\\n   * metadata for the given OpenAvatar DNA.\\n   *\\n   * The resulting URI includes the Generation of the avatar, the DNA\\n   * itself, the OpenAvatarGen0Renderer used to render the image of the avatar,\\n   * the ABI signature of the rendering function, the token ID associated\\n   * with the DNA, and the owner of that token.\\n   *\\n   * @param dna The unique DNA of the avatar whose metadata to retrieve.\\n   *\\n   * @return A base64 encoded URI representing the metadata of the given\\n   * avatar DNA.\\n   *\\n   * @dev This function will revert if the provided DNA has not been minted\\n   * into a token yet.\\n   */\\n  function openAvatarURI(bytes32 dna) external view returns (string memory) {\\n    uint tokenId = _getTokenIdByDNA(dna);\\n    string memory generationZeroStr = OPENAVATAR_GENERATION_ZERO.toString();\\n    address creatorAddress = dnaToCreator[dna];\\n    string memory creatorAddressStr = creatorAddress.toHexString();\\n    address rendererAddress = openAvatarGen0RendererRegistry.getRendererByDNA(dna);\\n    string memory rendererAddressStr = rendererAddress.toHexString();\\n    string memory tokenIdStr = tokenId.toString();\\n    string memory dnaStr = uint(dna).toHexString(32);\\n    return\\n      string(\\n        abi.encodePacked(\\n          'data:application/json;base64,',\\n          Base64.encode(\\n            abi.encodePacked(\\n              '{\\\"generation\\\":',\\n              generationZeroStr,\\n              ',\\\"dna\\\":\\\"',\\n              dnaStr,\\n              '\\\",\\\"creator\\\":\\\"',\\n              creatorAddressStr,\\n              '\\\",\\\"renderer\\\":\\\"',\\n              rendererAddressStr,\\n              '\\\",\\\"renderer_abi\\\":\\\"renderURI(bytes32)\\\",\\\"token_id\\\":',\\n              tokenIdStr,\\n              '}'\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice Retrieves OpenAvatar metadata associated with a specific token ID.\\n   *\\n   * The metadata encapsulates details such as the generation of the avatar,\\n   * the DNA, the chosen renderer for the avatar, the ABI signature of the\\n   * rendering function, the token ID itself, and the owner of the token.\\n   *\\n   * @param tokenId The unique identifier of the token to query.\\n   *\\n   * @return A `OpenAvatarGen0TokenMetadata` struct representing the metadata\\n   * associated with the token ID.\\n   *\\n   * @dev This function will revert if the provided token ID has not been\\n   * minted yet.\\n   */\\n  function _getOpenAvatarGen0TokenMetadataByTokenId(\\n    uint tokenId\\n  ) internal view returns (OpenAvatarGen0TokenMetadata memory) {\\n    if (!_exists(tokenId)) revert TokenIdDoesNotExist(tokenId);\\n\\n    // struct OpenAvatarGen0TokenMetadata {\\n    //   uint generation;\\n    //   bytes32 dna;\\n    //   address renderer;\\n    //   uint tokenId;\\n    //   address owner;\\n    // }\\n    bytes32 dna = _getDNAByTokenId(tokenId);\\n    return\\n      OpenAvatarGen0TokenMetadata(\\n        OPENAVATAR_GENERATION_ZERO,\\n        tokenId,\\n        dna,\\n        dnaToCreator[dna],\\n        openAvatarGen0RendererRegistry.getRendererByDNA(dna)\\n      );\\n  }\\n\\n  /**\\n   * @notice Retrieves OpenAvatar metadata associated with a specific DNA.\\n   *\\n   * The metadata encapsulates details such as the generation of the avatar,\\n   * the DNA itself, the chosen renderer for the avatar, the ABI signature of\\n   * the rendering function, the token ID, and the owner of the token.\\n   *\\n   * @param dna The unique DNA identifier of the avatar to query.\\n   *\\n   * @return A `OpenAvatarGen0TokenMetadata` struct representing the metadata\\n   * associated with the avatar's DNA.\\n   *\\n   * @dev This function will revert if the provided DNA has not been\\n   * minted into a token yet.\\n   */\\n  function getOpenAvatarGen0TokenMetadataByDNA(bytes32 dna) external view returns (OpenAvatarGen0TokenMetadata memory) {\\n    return _getOpenAvatarGen0TokenMetadataByTokenId(_getTokenIdByDNA(dna));\\n  }\\n\\n  /**\\n   * @notice Retrieves OpenAvatar metadata associated with a specific token ID.\\n   *\\n   * The metadata encapsulates details such as the generation of the avatar,\\n   * the DNA, the chosen renderer for the avatar, the ABI signature of the\\n   * rendering function, the token ID itself, and the owner of the token.\\n   *\\n   * @param tokenId The unique identifier of the token to query.\\n   *\\n   * @return A `OpenAvatarGen0TokenMetadata` struct representing the metadata\\n   * associated with the token ID.\\n   *\\n   * @dev This function will revert if the provided token ID has not been\\n   * minted yet.\\n   */\\n  function getOpenAvatarGen0TokenMetadataByTokenId(\\n    uint tokenId\\n  ) external view returns (OpenAvatarGen0TokenMetadata memory) {\\n    return _getOpenAvatarGen0TokenMetadataByTokenId(tokenId);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGen0TokenDNA - An interface for the OpenAvatar DNA.\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Retrieves the DNA associated with a specific token ID.\\n   *\\n   * This function is a helper function to fetch the DNA for a given token ID.\\n   * The DNA serves as a unique identifier for each token, which can then be\\n   * used to retrieve other related information such as the token's metadata.\\n   *\\n   * @param tokenId The unique identifier of the token for which to retrieve\\n   * the DNA.\\n   *\\n   * @return The DNA represented as a bytes32 value associated with the token\\n   * ID.\\n   *\\n   * @dev This function will revert if the token ID provided has not been\\n   * minted yet.\\n   */\\n  function _getDNAByTokenId(uint tokenId) internal view returns (bytes32) {\\n    if (!_exists(tokenId)) revert TokenIdDoesNotExist(tokenId);\\n\\n    return tokenIdToDna[tokenId];\\n  }\\n\\n  /**\\n   * @notice Retrieves the DNA associated with a specific token ID for external\\n   * callers.\\n   *\\n   * @param tokenId The unique identifier of the token for which to retrieve\\n   * the DNA.\\n   *\\n   * @return The DNA represented as a bytes32 value associated with the token\\n   * ID.\\n   *\\n   * @dev This function will revert if the token ID provided has not been\\n   * minted yet.\\n   */\\n  function getDNAByTokenId(uint tokenId) external view returns (bytes32) {\\n    return _getDNAByTokenId(tokenId);\\n  }\\n\\n  /**\\n   * @notice Retrieves the DNAs associated with an array of token IDs.\\n   *\\n   * This function accepts an array of token IDs and returns an array of DNAs\\n   * corresponding to those IDs.\\n   *\\n   * @param tokenIds An array of unique identifiers for which to retrieve the\\n   * DNAs.\\n   *\\n   * @return An array of DNAs represented as bytes32 values associated with the\\n   * token IDs.\\n   *\\n   * @dev This function will revert if any of the token IDs provided have not\\n   * been minted yet.\\n   */\\n  function getDNAsByTokenIds(uint[] calldata tokenIds) external view returns (bytes32[] memory) {\\n    uint length = tokenIds.length;\\n    bytes32[] memory dnas = new bytes32[](length);\\n    for (uint i = 0; i < length; ) {\\n      dnas[i] = _getDNAByTokenId(tokenIds[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return dnas;\\n  }\\n\\n  /**\\n   * @notice Retrieves the token ID associated with a specific DNA.\\n   *\\n   * This internal function takes a DNA value and returns the corresponding\\n   * token ID. If the DNA provided does not correspond to a minted token, the\\n   * function will revert\\n   *\\n   * @param dna The DNA for which to retrieve the token ID.\\n   *\\n   * @return The token ID associated with the provided DNA.\\n   *\\n   * @dev This function will revert if the DNA provided has not been minted\\n   * yet.\\n   */\\n  function _getTokenIdByDNA(bytes32 dna) internal view returns (uint) {\\n    uint tokenId = dnaToTokenId[dna];\\n    // defaults to 0 in which case we need to double check\\n    // that tokenId exists and matches provided dna\\n    // else it's just a consequence of 0 being default return\\n    if (tokenId == 0) {\\n      // Happy case  : tokenId exists, can return\\n      // Revert case : tokenId does not exist, revert\\n      //\\n      // We need to determine happy vs revert case\\n      //\\n      // CASE 1 (revert):\\n      //    tokenId == 0 && it doesn't exist\\n      //    --> revert (since not exists)\\n      //\\n      // CASE 2\\n      //    tokenId == 0 && it does exist\\n      //    => the 0 token has been minted\\n      //    => we need to disambiguate whether we got tokenId == 0\\n      //       because of the default return or because it's the 0 token\\n      //\\n      //    CASE A (happy):\\n      //            tokenIdToDna[tokenId] == dna\\n      //            => we got the 0 token\\n      //            => return tokenId (which is 0)\\n      //\\n      //    CASE B: (revert)\\n      //            tokenIdToDna[tokenId] != dna\\n      //            => we got the default return\\n      //            => revert (since not exists)\\n      //\\n      if (!_exists(tokenId) || tokenIdToDna[tokenId] != dna) {\\n        revert DNADoesNotExist(dna);\\n      }\\n    }\\n    return tokenId;\\n  }\\n\\n  /**\\n   * @notice Retrieves the token ID associated with a specific DNA.\\n   *\\n   * @param dna The DNA for which to retrieve the token ID.\\n   *\\n   * @return The token ID associated with the provided DNA.\\n   *\\n   * @dev This function will revert if the DNA provided has not been minted\\n   * yet.\\n   */\\n  function getTokenIdByDNA(bytes32 dna) external view returns (uint) {\\n    return _getTokenIdByDNA(dna);\\n  }\\n\\n  /**\\n   * @notice Retrieves the token IDs associated with an array of DNAs.\\n   *\\n   * This function accepts an array of DNAs and returns an array of token\\n   * IDs corresponding to those DNAs.\\n   *\\n   * @param dnas An array of DNAs for which to retrieve the token IDs.\\n   *\\n   * @return An array of token IDs associated with the provided DNAs.\\n   *\\n   * @dev This function will revert if any of the DNAs provided have not been\\n   * minted yet.\\n   */\\n  function getTokenIdsByDNAs(bytes32[] calldata dnas) external view returns (uint[] memory) {\\n    uint length = dnas.length;\\n    uint[] memory tokenIds = new uint[](length);\\n    for (uint i = 0; i < length; ) {\\n      tokenIds[i] = _getTokenIdByDNA(dnas[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return tokenIds;\\n  }\\n\\n  /**\\n   * @notice Retrieves the creator of a token.\\n   *\\n   * This function uses the DNA to identify the corresponding token and fetch\\n   * the creator of that token.\\n   *\\n   * @param tokenId The unique identifier of the token for which to retrieve\\n   * the DNA.\\n   *\\n   * @return The address of the creator of the token associated with the\\n   * provided token ID. If the token ID has not been minted yet, the zero\\n   * address is returned.\\n   */\\n  function creatorOf(uint tokenId) external view returns (address) {\\n    return dnaToCreator[_getDNAByTokenId(tokenId)];\\n  }\\n\\n  /**\\n   * @notice Retrieves the creator of a token given its DNA.\\n   *\\n   * This function uses the DNA to identify the corresponding token and fetch\\n   * the creator of that token.\\n   *\\n   * @param dna The DNA of the token for which to retrieve the creator.\\n   *\\n   * @return The address of the creator of the token associated with the provided\\n   * DNA.\\n   *\\n   * @dev This function will revert if the DNA provided has not been minted\\n   * yet.\\n   */\\n  function creatorOfDNA(bytes32 dna) external view returns (address) {\\n    if (!_exists(_getTokenIdByDNA(dna))) revert DNADoesNotExist(dna);\\n    return dnaToCreator[dna];\\n  }\\n\\n  /**\\n   * @notice Retrieves the owner of a token given its DNA.\\n   *\\n   * This function uses the DNA to identify the corresponding token and fetch\\n   * the owner of that token.\\n   *\\n   * @param dna The DNA of the token for which to retrieve the owner.\\n   *\\n   * @return The address of the owner of the token associated with the provided\\n   * DNA.\\n\\n   * @dev This function will revert if the DNA provided has not been minted\\n   * yet.\\n   */\\n  function ownerOfDNA(bytes32 dna) external view returns (address) {\\n    return ownerOf(_getTokenIdByDNA(dna));\\n  }\\n\\n  /**\\n   * @notice Retrieves the owners of tokens given an array of DNAs.\\n   *\\n   * This function accepts an array of DNAs and returns an array of owners\\n   * corresponding to those DNAs.\\n   *\\n   * @param dnas An array of DNAs for which to retrieve the owners.\\n   *\\n   * @return An array of addresses representing the owners of the tokens\\n   * associated with the provided DNAs.\\n   *\\n   * @dev This function will revert if any of the DNAs provided have not been\\n   * minted yet.\\n   */\\n  function ownerOfDNAs(bytes32[] calldata dnas) external view returns (address[] memory) {\\n    uint length = dnas.length;\\n    address[] memory owners = new address[](length);\\n    for (uint i = 0; i < length; i++) {\\n      owners[i] = ownerOf(_getTokenIdByDNA(dnas[i]));\\n    }\\n    return owners;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarMintRead - An interface for reading OpenAvatar minting state.\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the specified DNA has been associated with a token\\n   * (minted).\\n   * @param dna The DNA string to be checked.\\n   * @return Returns true if the DNA has been minted, false otherwise.\\n   */\\n  function isMinted(bytes32 dna) external view returns (bool) {\\n    uint tokenId = dnaToTokenId[dna];\\n    if (tokenId > 0) {\\n      // if the token id is > 0, then the dna has been minted\\n      // we don't need to check _exists because this mapping is\\n      // only set when the token is minted\\n      // (but it's not trivial because of the way batch mint\\n      //  has to check this data structure first)\\n      return true;\\n    }\\n\\n    // we need to double check that the token id exists and matches the\\n    // provided dna\\n    bytes32 dnaFromTokenId = tokenIdToDna[tokenId];\\n    // if the dna from the token id does not match the provided dna\\n    // then the dna has not been minted\\n    if (dnaFromTokenId != dna) return false;\\n\\n    // if they are both zero, then the dna has not been minted\\n    // except in one exceptional case:\\n    //    an invalid batch mint of [DNA=0, DNA=0] as the first two tokens\\n\\n    // otherwise, the dna has been minted\\n    return _exists(tokenId);\\n  }\\n\\n  /**\\n   * @notice Checks the mint status for each DNA in the provided list.\\n   * @param dnas An array of DNA strings to be checked.\\n   * @return An array of booleans indicating the mint status for each DNA. A\\n   * true value at index i indicates that dnas[i] has been minted.\\n   */\\n  function isMintedEach(bytes32[] calldata dnas) external view returns (bool[] memory) {\\n    uint length = dnas.length;\\n    bool[] memory minted = new bool[](length);\\n    for (uint i = 0; i < length; ) {\\n      minted[i] = this.isMinted(dnas[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return minted;\\n  }\\n\\n  /**\\n   * @notice Retrieves the current price required to mint a new token via the\\n   * mint function.\\n   * @return The current price in wei for minting a new token.\\n   */\\n  function getMintPrice() external view returns (uint) {\\n    return mintPrice;\\n  }\\n\\n  /**\\n   * @notice Retrieves the \\\"soft cap\\\" token mint quantity. This number is\\n   * tokens tha can be minted. This number is mutable and can increase up\\n   * to the hard cap.\\n   * Invariant: totalSupply() <= supplySoftCap() <= supplyHardCap().\\n   * @return Maximum quantity of tokens mintable.\\n   */\\n  function supplySoftCap() external view returns (uint16) {\\n    return _supplySoftCap;\\n  }\\n\\n  /**\\n   * @notice increases the soft cap supply. This number is mutable and can\\n   * increase up to the hard cap. Invariant: totalSupply() <= supplySoftCap()\\n   * <= supplyHardCap().\\n   * @param amount The new soft cap supply.\\n   */\\n  function increaseSupplySoftCap(uint16 amount) external onlyOwner {\\n    if (fuseBurnedCanIncreaseSupplySoftCap) revert OperationBlockedByBurnedFuse();\\n    if (amount <= _supplySoftCap) revert SupplySoftCapChangeIsNotAnIncrease();\\n    if (amount > MAX_SUPPLY) revert SupplySoftCapWouldExceedHardCap(amount);\\n    _supplySoftCap = amount;\\n  }\\n\\n  /**\\n   * @notice Retrieves the maximum token mint quantity. This number is immutable\\n   * and can never change. The number of tokens minted can never exceed this\\n   * number. Invariant: totalSupply() <= supplySoftCap() <= supplyHardCap().\\n   * @return Maximum quantity of tokens mintable.\\n   */\\n  function supplyHardCap() external pure returns (uint16) {\\n    return MAX_SUPPLY;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarMint - An interface allowing the mint price to be updated.\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Sets the price to mint a new token using the mint function.\\n   * @param val The new price to mint a new token using the mint function.\\n   * @dev Only callable by the owner.\\n   */\\n  function setMintPrice(uint val) external onlyOwner {\\n    if (val > mintPrice && fuseBurnedCanRaiseMintPrice) revert OperationBlockedByBurnedFuse();\\n    if (val < mintPrice && fuseBurnedCanLowerMintPrice) revert OperationBlockedByBurnedFuse();\\n    if (mintPrice == val) return;\\n    uint oldPrice = mintPrice;\\n    mintPrice = val;\\n    emit MintPriceChange(oldPrice, val);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Check if fuse for increasing soft cap supply.\\n   * @return True if fuse is burned, false otherwise.\\n   */\\n  function isFuseBurnedCanIncreaseSupplySoftCap() external view returns (bool) {\\n    return fuseBurnedCanIncreaseSupplySoftCap;\\n  }\\n\\n  /**\\n   * @notice Burns the fuse that prohibits increasing the soft cap supply.\\n   * @dev Executable only by owner. No effect if fuse is already burned.\\n   */\\n  function burnFuseCanIncreaseSupplySoftCap() external onlyOwner {\\n    if (fuseBurnedCanIncreaseSupplySoftCap) return;\\n    fuseBurnedCanIncreaseSupplySoftCap = true;\\n    emit FuseBurnedCanIncreaseSupplySoftCap();\\n  }\\n\\n  /**\\n   * @notice Check if fuse for lowering mint price is burned.\\n   * @return True if fuse is burned, false otherwise.\\n   */\\n  function isFuseBurnedCanLowerMintPrice() external view returns (bool) {\\n    return fuseBurnedCanLowerMintPrice;\\n  }\\n\\n  /**\\n   * @notice Burns the fuse that prohibits decreasing the mint price.\\n   * @dev Executable only by owner. No effect if fuse is already burned.\\n   */\\n  function burnFuseCanLowerMintPrice() external onlyOwner {\\n    if (fuseBurnedCanLowerMintPrice) return;\\n    fuseBurnedCanLowerMintPrice = true;\\n    emit FuseBurnedCanLowerMintPrice();\\n  }\\n\\n  /**\\n   * @notice Check if fuse for raising mint price is burned.\\n   * @return True if fuse is burned, false otherwise.\\n   */\\n  function isFuseBurnedCanRaiseMintPrice() external view returns (bool) {\\n    return fuseBurnedCanRaiseMintPrice;\\n  }\\n\\n  /**\\n   * @notice Burns the fuse that prohibits increasing the mint price.\\n   * @dev Executable only by owner. No effect if fuse is already burned.\\n   */\\n  function burnFuseCanRaiseMintPrice() external onlyOwner {\\n    if (fuseBurnedCanRaiseMintPrice) return;\\n    fuseBurnedCanRaiseMintPrice = true;\\n    emit FuseBurnedCanRaiseMintPrice();\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarMintWrite - An interface for minting OpenAvatars.\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Mints a token for a given address.\\n   * @param to The recipient of the minted token.\\n   * @param dna The dna of the minted token.\\n   */\\n  function _mintTo(address to, bytes32 dna) internal {\\n    // ensure dna is not already used\\n    if (this.isMinted(dna)) revert DNAAlreadyMinted(dna);\\n\\n    // 0-indexed token id\\n    uint tokenId = totalSupply();\\n\\n    // ensure its not bigger than max supply\\n    if (tokenId < _supplySoftCap) {\\n      tokenIdToDna[tokenId] = dna;\\n      dnaToTokenId[dna] = tokenId;\\n      dnaToCreator[dna] = to;\\n\\n      // mint\\n      _safeMint(to, 1);\\n\\n      // emit event\\n      emit Mint(to, dna, tokenId);\\n    } else {\\n      revert SupplyCapExceeded();\\n    }\\n  }\\n\\n  /**\\n   * @notice Mints a token.\\n   * @param dna The dna of the minted token.\\n   * @dev Only callable if mint is public.\\n   */\\n  function mint(bytes32 dna) external payable onlyAuthorizedMint {\\n    if (msg.value < mintPrice) revert MintUnderpaid();\\n    // mint to the immediate caller, either EOA or contract\\n    _mintTo(msg.sender, dna);\\n  }\\n\\n  /**\\n   * @notice Mints a token for a given address.\\n   * @param to The recipient of the minted token.\\n   * @param dna The dna of the minted token.\\n   * @dev Only callable if mint is public.\\n   */\\n  function mintTo(address to, bytes32 dna) external payable onlyAuthorizedMint {\\n    if (msg.value < mintPrice) revert MintUnderpaid();\\n    // mint to provided address\\n    _mintTo(to, dna);\\n  }\\n\\n  /**\\n   * @notice Mints a batch of tokens for a given address.\\n   * @param to The recipient of the minted tokens.\\n   * @param dnas The dnas of the minted tokens.\\n   */\\n  function _mintBatchTo(address to, bytes32[] calldata dnas) internal {\\n    uint totalSupply = totalSupply();\\n    uint n = dnas.length;\\n    if (n == 0) return; // no-op\\n    if (n > MAX_MINT_BATCH_SIZE_LIMIT) revert MintBatchSizeLimitExceeded(n);\\n\\n    if (totalSupply + n - 1 < _supplySoftCap) {\\n      for (uint i; i < n; ) {\\n        bytes32 dna = dnas[i];\\n\\n        // don't allow batch minting of the null DNA\\n        // else we might end up with multiple tokens with the same DNA\\n        // because the way the mapping checks work in the isMinted function\\n        // we cannot distinguish between a DNA with tokenId=0 and a DNA that\\n        // has not been minted\\n        //\\n        // so ultimately this primarily prevents a bug of calling\\n        // mintBatch([0, 0, ...]) before mint(0) has been called\\n        //\\n        // for prod, call mint(0) before public mint opens then this can be\\n        // removed for gas optimization since isMinted will return true for\\n        // null DNA\\n        if (dna == 0) revert NullDNARestrictedFromBatchMint(dna);\\n\\n        // ensure dna is not already used\\n        if (this.isMinted(dna)) revert DNAAlreadyMinted(dna);\\n\\n        // 0-indexed token id\\n        uint tokenId = totalSupply + i;\\n\\n        tokenIdToDna[tokenId] = dna;\\n        dnaToTokenId[dna] = tokenId;\\n        dnaToCreator[dna] = to;\\n\\n        // emit event\\n        emit Mint(to, dna, tokenId);\\n\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      // mint all as one batch\\n      _safeMint(to, n);\\n    } else {\\n      revert SupplyCapExceeded();\\n    }\\n  }\\n\\n  /**\\n   * @notice Mints a batch of tokens.\\n   * @param dnas The dnas of the minted tokens.\\n   * @dev Only callable if mint is public.\\n   */\\n  function mintBatch(bytes32[] calldata dnas) external payable onlyAuthorizedMint {\\n    if (msg.value < mintPrice * dnas.length) revert MintUnderpaid();\\n    // mint to the immediate caller, either EOA or contract\\n    _mintBatchTo(msg.sender, dnas);\\n  }\\n\\n  /**\\n   * @notice Mints a batch of tokens for a given address.\\n   * @param to The recipient of the minted tokens.\\n   * @param dnas The dnas of the minted tokens.\\n   * @dev Only callable if mint is public.\\n   */\\n  function mintBatchTo(address to, bytes32[] calldata dnas) external payable onlyAuthorizedMint {\\n    if (msg.value < mintPrice * dnas.length) revert MintUnderpaid();\\n    // mint to the provided address\\n    _mintBatchTo(to, dnas);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGenerationZero.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatar} from './IOpenAvatar.sol';\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev OpenAvatar Generation 0 common definitions.\\n */\\nabstract contract OpenAvatarGenerationZero is IOpenAvatar {\\n  /// @dev OpenAvatar Generation 0.\\n  uint public constant OPENAVATAR_GENERATION_ZERO = 0;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGeneration\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns 0, in reference to Open Avatar Generation 0.\\n   * @return 0 (zero).\\n   */\\n  function openAvatarGeneration() external pure returns (uint) {\\n    return OPENAVATAR_GENERATION_ZERO;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarSentinel\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns true.\\n   * @dev This is a sentinel function to indicate that this contract is an\\n   * OpenAvatar contract.\\n   * @return True.\\n   */\\n  function openAvatar() public pure returns (bool) {\\n    return true;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4; // ERC165 interface ID for IOpenAvatar.\\n  }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721AQueryable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721AQueryable.\\n *\\n * @dev ERC721A subclass with convenience query functions.\\n */\\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\\n        TokenOwnership memory ownership;\\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\\n            return ownership;\\n        }\\n        ownership = _ownershipAt(tokenId);\\n        if (ownership.burned) {\\n            return ownership;\\n        }\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (TokenOwnership[] memory)\\n    {\\n        unchecked {\\n            uint256 tokenIdsLength = tokenIds.length;\\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\\n            for (uint256 i; i != tokenIdsLength; ++i) {\\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\\n            }\\n            return ownerships;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            if (start >= stop) revert InvalidQueryRange();\\n            uint256 tokenIdsIdx;\\n            uint256 stopLimit = _nextTokenId();\\n            // Set `start = max(start, _startTokenId())`.\\n            if (start < _startTokenId()) {\\n                start = _startTokenId();\\n            }\\n            // Set `stop = min(stop, stopLimit)`.\\n            if (stop > stopLimit) {\\n                stop = stopLimit;\\n            }\\n            uint256 tokenIdsMaxLength = balanceOf(owner);\\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\\n            // to cater for cases where `balanceOf(owner)` is too big.\\n            if (start < stop) {\\n                uint256 rangeLength = stop - start;\\n                if (rangeLength < tokenIdsMaxLength) {\\n                    tokenIdsMaxLength = rangeLength;\\n                }\\n            } else {\\n                tokenIdsMaxLength = 0;\\n            }\\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\\n            if (tokenIdsMaxLength == 0) {\\n                return tokenIds;\\n            }\\n            // We need to call `explicitOwnershipOf(start)`,\\n            // because the slot at `start` may not be initialized.\\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\\n            address currOwnershipAddr;\\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\\n            if (!ownership.burned) {\\n                currOwnershipAddr = ownership.addr;\\n            }\\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            // Downsize the array to fit.\\n            assembly {\\n                mstore(tokenIds, tokenIdsIdx)\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"shanghai\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"DNAAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"DNADoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"InterfaceUnsupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"}],\"name\":\"MintBatchSizeLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintPermanentlyDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintUnderpaid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"NullDNARestrictedFromBatchMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationBlockedByBurnedFuse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PublicMintNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyCapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplySoftCapChangeIsNotAnIncrease\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplySoftCapIsMonotonicallyIncraesing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSupplyCap\",\"type\":\"uint256\"}],\"name\":\"SupplySoftCapWouldExceedHardCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenIdDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanChangeMintState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanChangePublicMintTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanIncreaseSupplySoftCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanLowerMintPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedCanRaiseMintPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"MintPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum AOpenAvatarMintStateMachine.MintState\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"MintStateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PublicMintTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TreasuryWithdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MINT_BATCH_SIZE_LIMIT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPENAVATAR_GENERATION_ZERO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_supplySoftCap\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanChangeMintState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanChangePublicMintTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanIncreaseSupplySoftCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanLowerMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseCanRaiseMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"}],\"name\":\"claimReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"creatorOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"creatorOfDNA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"explicitOwnershipOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"explicitOwnershipsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanChangeMintState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanChangePublicMintTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanIncreaseSupplySoftCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanLowerMintPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedCanRaiseMintPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getDNAByTokenId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getDNAsByTokenIds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintState\",\"outputs\":[{\"internalType\":\"enum AOpenAvatarMintStateMachine.MintState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAvatarGen0RendererRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"getOpenAvatarGen0TokenMetadataByDNA\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"}],\"internalType\":\"struct OpenAvatarGen0TokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getOpenAvatarGen0TokenMetadataByTokenId\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"}],\"internalType\":\"struct OpenAvatarGen0TokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"getTokenIdByDNA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"name\":\"getTokenIdsByDNAs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"increaseSupplySoftCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"openAvatarGen0RendererRegistry_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanChangeMintState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanChangePublicMintTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanIncreaseSupplySoftCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanLowerMintPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFuseBurnedCanRaiseMintPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintOnlyOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintPermanentlyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintPublicPendingBlockTimestamp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"isMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"name\":\"isMintedEach\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"name\":\"mintBatchTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintStatus\",\"outputs\":[{\"internalType\":\"enum AOpenAvatarMintStateMachine.MintState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGen0RendererRegistry\",\"outputs\":[{\"internalType\":\"contract IOpenAvatarGen0RendererRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"openAvatarURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"ownerOfDNA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"name\":\"ownerOfDNAs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"renderURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum AOpenAvatarMintStateMachine.MintState\",\"name\":\"val\",\"type\":\"uint8\"}],\"name\":\"setMintState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_publicMintTime\",\"type\":\"uint256\"}],\"name\":\"setPublicMintTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyHardCap\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplySoftCap\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OpenAvatarGen0Token", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000027390b412440c58100929acfeae2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}