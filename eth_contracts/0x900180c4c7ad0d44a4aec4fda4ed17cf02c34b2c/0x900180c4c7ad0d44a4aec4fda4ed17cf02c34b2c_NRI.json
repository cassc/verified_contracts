{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"contracts/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/INUI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.22;\\r\\n\\r\\nimport { UserData } from \\\"../lib/GenStructs.sol\\\";\\r\\ninterface INUI {\\r\\n    function closePosition(bytes32 _identifier, address _user) external;\\r\\n    function updateAllowance(uint40 _id) external;\\r\\n    function totalDCAs() external view returns (uint40);\\r\\n    function userData(uint40 _id) external view returns (UserData memory);\\r\\n    function updatePositionPerExecution(uint40 _timeToDelete, uint40 _timeToUpdate) external;\\r\\n    function positionPerExecution(uint40) external view returns (uint40);\\r\\n}\"\r\n    },\r\n    \"contracts/lib/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.22;\\r\\n\\r\\nlibrary DateTime {\\r\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\r\\n\\r\\n    function getHour(uint256 _timestamp) private pure returns (uint256) {\\r\\n        uint256 secs = _timestamp % SECONDS_PER_DAY;\\r\\n        return secs / SECONDS_PER_HOUR;\\r\\n    }\\r\\n\\r\\n    function getMinute(uint256 _timestamp) private pure returns (uint256) {\\r\\n        uint256 secs = _timestamp % SECONDS_PER_HOUR;\\r\\n        return secs / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function getSecond(uint256 _timestamp) private pure returns (uint256) {\\r\\n        return _timestamp % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function subHours(uint256 _timestamp, uint256 _hours) private pure returns (uint256) {\\r\\n        return _timestamp - _hours * SECONDS_PER_HOUR;\\r\\n    }\\r\\n\\r\\n    function subMinutes(uint256 _timestamp, uint256 _minutes) private pure returns (uint256) {\\r\\n        return _timestamp - _minutes * SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function subSeconds(uint256 _timestamp, uint256 _seconds) private pure returns (uint256) {\\r\\n        return _timestamp - _seconds;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Generate midnight timestamp (Sunday MM DD, YYYY 00:00:00).\\r\\n     * @param   _timestamp  block timestamp.\\r\\n     * @return  uint256  midnight timestamp.\\r\\n     */\\r\\n    function getMidnightTimestamp(uint256 _timestamp) internal pure returns (uint256) {\\r\\n        uint256 midnightTimestap = subHours(_timestamp, getHour(_timestamp));\\r\\n        midnightTimestap = subMinutes(midnightTimestap, getMinute(_timestamp));\\r\\n        return subSeconds(midnightTimestap, getSecond(_timestamp));\\r\\n\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/lib/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * The default value of {decimals} is 18. To change this, you should override\\r\\n * this function so it returns a different value.\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n}\"\r\n    },\r\n    \"contracts/lib/GenStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.22;\\r\\n\\r\\nstruct UserData {\\r\\n    bool toBeClosed;\\r\\n    bytes32 identifier;\\r\\n    address owner;\\r\\n    address receiver;\\r\\n    address srcToken;\\r\\n    address dstToken;\\r\\n    uint8 tau;\\r\\n    uint40 exeRequired; //0 = Unlimited\\r\\n    uint256 srcAmount;\\r\\n    uint256 limitOrderBuy; //USD (precision 6 dec)\\r\\n}\\r\\nstruct UserDetail {\\r\\n    address receiver;\\r\\n    uint8 tau;\\r\\n    uint40 nextExecution;\\r\\n    uint40 lastExecution;\\r\\n    uint256 limitOrderBuy; //USD (precision 6 dec)\\r\\n}\\r\\nstruct UserDca {\\r\\n    bool toBeClosed;\\r\\n    bytes32 identifier;\\r\\n    address srcToken;\\r\\n    address dstToken;\\r\\n    uint16 code;\\r\\n    uint40 dateCreation; //sec\\r\\n    uint40 exeRequired;\\r\\n    uint40 exePerformed;\\r\\n    uint256 srcAmount;\\r\\n}\\r\\nstruct ExeData {\\r\\n    uint8 onGoing;\\r\\n    uint8 errCount;\\r\\n    uint8 limitCount;\\r\\n    uint16 code;\\r\\n    uint40 dateCreation; //sec\\r\\n    uint40 nextExecution; //sec\\r\\n    uint40 lastExecution; //sec\\r\\n    uint40 exePerformed;\\r\\n    uint256 fundTransferred;\\r\\n}\\r\\nstruct ResolverData {\\r\\n    bool toBeClosed;\\r\\n    bool allowOk;\\r\\n    bool balanceOk;\\r\\n    address owner;\\r\\n    address receiver;\\r\\n    address srcToken;\\r\\n    address dstToken;\\r\\n    uint8 srcDecimals;\\r\\n    uint8 dstDecimals;\\r\\n    uint8 onGoing;\\r\\n    uint256 srcAmount;\\r\\n    uint256 limitOrderBuy; //USD (precision 6 dec)\\r\\n}\\r\\nstruct StoredData {\\r\\n    uint256 timestamp;\\r\\n    uint256 tokenValue; //USD (precision 6 dec)\\r\\n    uint256 tokenAmount;\\r\\n}\\r\\nstruct QueueData {\\r\\n    bytes32 identifier;\\r\\n    address owner;\\r\\n    address receiver;\\r\\n    address srcToken;\\r\\n    address dstToken;\\r\\n    uint8 tau;\\r\\n    uint40 exeRequired; //0 = Unlimited\\r\\n    uint40 dateCreation; //sec **\\r\\n    uint40 nextExecution; //sec **\\r\\n    uint256 srcAmount;\\r\\n    uint256 limitOrderBuy; //USD (precision 6 dec)\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/NRI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.22;\\r\\n\\r\\nimport { UserData, ExeData, ResolverData } from \\\"./lib/GenStructs.sol\\\";\\r\\nimport { ERC20 } from \\\"./lib/ERC20.sol\\\";\\r\\nimport { SafeERC20 } from \\\"./utils/SafeERC20.sol\\\";\\r\\nimport { INUI } from \\\"./interfaces/INUI.sol\\\";\\r\\nimport { DateTime } from \\\"./lib/DateTime.sol\\\";\\r\\n\\r\\nerror NotAuthorized();\\r\\nerror ExecutionNotRequired();\\r\\nerror EmergencyPause();\\r\\n\\r\\n/**\\r\\n * @author  Nebula Labs for Neon Protocol.\\r\\n * @title   Resolver interface for automatic execution.\\r\\n */\\r\\ncontract NRI {\\r\\n    using SafeERC20 for ERC20;\\r\\n\\r\\n    ExeData[] private dcaExeData;\\r\\n    mapping (bytes32 => uint40) private dcaPosition;\\r\\n    mapping (uint40 => uint40) private positionToChange;\\r\\n    mapping (uint40 => bool) private changeRequired;\\r\\n    bool public resolverRunning;\\r\\n    bool public operative;\\r\\n    uint40 public maxDcaExecutable;\\r\\n\\r\\n    uint24 constant private TIME_BASE = 1 days;\\r\\n    uint8 constant private ERROR_LIMIT = 2;\\r\\n    uint8 constant private LIMIT_ORDER_ERROR = 5;\\r\\n    address immutable public NUI;\\r\\n    address immutable public RESOLVER;\\r\\n    address immutable public ADMIN;\\r\\n\\r\\n    event PositionCompleted(address owner, bytes32 identifier);\\r\\n    event PositionClosedByError(address owner, bytes32 identifier);\\r\\n    event PositionClosedByLimitOrderLimit(address owner, bytes32 identifier);\\r\\n    event PositionClosedByQueue(address owner, bytes32 identifier);\\r\\n\\r\\n    modifier onlyResolver(){\\r\\n        if(msg.sender != RESOLVER) revert NotAuthorized();\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyNUI(){\\r\\n        require(msg.sender == NUI, \\\"Not Authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyAdmin(){\\r\\n        require(msg.sender == ADMIN, \\\"Not Authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n    modifier protocolOperative(){\\r\\n        if(!operative) revert EmergencyPause();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _NUI, address _resolver){\\r\\n        NUI = _NUI;\\r\\n        RESOLVER = _resolver;\\r\\n        ADMIN = msg.sender;\\r\\n        operative = true;\\r\\n        maxDcaExecutable = type(uint40).max;\\r\\n    }\\r\\n\\r\\n    /* WRITE METHODS*/\\r\\n    /**\\r\\n     * @notice  Pause execution for safety, user can still create or delete DCAs.\\r\\n     * @dev     Only Admin.\\r\\n     */\\r\\n    function emergencyPause() external onlyAdmin {\\r\\n        operative = !operative;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Initialize number of executable DCAs.\\r\\n     * @dev     Only Admin.\\r\\n     */\\r\\n    function initMaxDcaExecutable() external onlyAdmin {\\r\\n        maxDcaExecutable = type(uint40).max;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Update next execution date with \\\"skipExecution\\\".\\r\\n     * @dev     Only NUI.\\r\\n     * @param   _identifier  position identifier.\\r\\n     * @param   _tau  frequency of execution.\\r\\n     */\\r\\n    function updateExecutionDate(bytes32 _identifier, uint8 _tau) external onlyNUI {\\r\\n        uint40 position = dcaPosition[_identifier];\\r\\n        uint40 newExeDate = _positionSlippage(dcaExeData[position].nextExecution, _tau);\\r\\n        INUI(NUI).updatePositionPerExecution(dcaExeData[position].nextExecution, newExeDate);\\r\\n        dcaExeData[position].nextExecution = newExeDate;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Create execution position with \\\"createDCA\\\" & \\\"manageQueue\\\".\\r\\n     * @dev     Only NUI.\\r\\n     * @param   _identifier  position identifier.\\r\\n     * @param   _nextExecution  next execution time.\\r\\n     */\\r\\n    function createPosition(bytes32 _identifier, uint40 _nextExecution) external onlyNUI {\\r\\n        dcaPosition[_identifier] = INUI(NUI).totalDCAs();\\r\\n        _setExeData(uint40(block.timestamp), _nextExecution);\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Close execution position with \\\"_closeDca\\\".\\r\\n     * @dev     Only NUI.\\r\\n     * @param   _identifier  position identifier.\\r\\n     * @param   _identifierLast  last position identifier.\\r\\n     */\\r\\n    function closePosition(bytes32 _identifier, bytes32 _identifierLast) external onlyNUI {\\r\\n        if(_identifier != _identifierLast){\\r\\n            dcaExeData[dcaPosition[_identifier]] = dcaExeData[dcaPosition[_identifierLast]];\\r\\n            dcaPosition[_identifierLast] = dcaPosition[_identifier];\\r\\n        }\\r\\n        dcaPosition[_identifier] = 0;\\r\\n        dcaExeData.pop();\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Prepares the static database for execution.\\r\\n     * @dev     Only Resover & No Pause.\\r\\n     */\\r\\n    function snapsExecution() external onlyResolver protocolOperative {\\r\\n        resolverRunning = true;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Start execution, sending the funds to the resolver.\\r\\n     * @dev     Only Resover & No Pause.\\r\\n     * @param   _id  array position.\\r\\n     */\\r\\n    function executionStart(uint40[] memory _id) external onlyResolver protocolOperative {\\r\\n        UserData memory userInfo;\\r\\n        uint40 length = uint40(_id.length);\\r\\n        uint256 initBalance;\\r\\n        if(!resolverRunning) resolverRunning = true;\\r\\n        for(uint40 i; i < length; ++i){\\r\\n            if(block.timestamp < dcaExeData[_id[i]].nextExecution || dcaExeData[_id[i]].onGoing > 0) continue;\\r\\n            if(changeRequired[_id[i]]) changeRequired[_id[i]] = false;\\r\\n            userInfo = INUI(NUI).userData(_id[i]); \\r\\n            dcaExeData[_id[i]].onGoing = 1;\\r\\n            if(!userInfo.toBeClosed){\\r\\n                //Manage feeOnTrasfer token            \\r\\n                initBalance = ERC20(userInfo.srcToken).balanceOf(RESOLVER);\\r\\n                ERC20(userInfo.srcToken).safeTransferFrom(userInfo.owner, RESOLVER, userInfo.srcAmount);\\r\\n                dcaExeData[_id[i]].fundTransferred = ERC20(userInfo.srcToken).balanceOf(RESOLVER) - initBalance;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Data update after swap execution.\\r\\n     * @dev     Only Resover & No Pause.\\r\\n     * @param   _id  array position.\\r\\n     * @param   _code  result of execution.\\r\\n     */\\r\\n    function updatePositions(uint40[] memory _id, uint16[] memory _code) external onlyResolver protocolOperative {\\r\\n        UserData memory userInfo;\\r\\n        uint40 length = uint40(_id.length);\\r\\n        for(uint40 i; i < length; ++i){\\r\\n            if(block.timestamp < dcaExeData[_id[i]].nextExecution) continue;\\r\\n            userInfo = INUI(NUI).userData(_id[i]); \\r\\n            dcaExeData[_id[i]].onGoing = 2;\\r\\n            dcaExeData[_id[i]].lastExecution = dcaExeData[_id[i]].nextExecution;\\r\\n            dcaExeData[_id[i]].nextExecution = _generateNextExecution(dcaExeData[_id[i]].nextExecution, userInfo.tau);\\r\\n            dcaExeData[_id[i]].code = _code[i];\\r\\n            if(_code[i] == 200){\\r\\n                if (dcaExeData[_id[i]].errCount != 0) dcaExeData[_id[i]].errCount = 0;\\r\\n                if (dcaExeData[_id[i]].limitCount != 0) dcaExeData[_id[i]].limitCount = 0;\\r\\n                unchecked {\\r\\n                    ++dcaExeData[_id[i]].exePerformed;\\r\\n                }\\r\\n                INUI(NUI).updateAllowance(_id[i]);\\r\\n            }else{\\r\\n                unchecked {\\r\\n                    _code[i] == 402 ? ++dcaExeData[_id[i]].limitCount : ++dcaExeData[_id[i]].errCount;\\r\\n                }\\r\\n                if(_code[i] != 999 && dcaExeData[_id[i]].fundTransferred != 0){\\r\\n                    ERC20(userInfo.srcToken).safeTransferFrom(RESOLVER, userInfo.owner, dcaExeData[_id[i]].fundTransferred);\\r\\n                }\\r\\n            }\\r\\n            dcaExeData[_id[i]].fundTransferred = 0;\\r\\n            INUI(NUI).updatePositionPerExecution(dcaExeData[_id[i]].lastExecution, dcaExeData[_id[i]].nextExecution);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Closes the positions to be closed and adjusts the location.\\r\\n     * @dev     Only Resover & No Pause.\\r\\n     * @param   _id  array position.\\r\\n     * @param   _maxDca  number of maximum DCAs that can be executed at the next execution.\\r\\n     */\\r\\n    function executionCompletion(uint40[] memory _id, uint40 _maxDca) external onlyResolver protocolOperative {\\r\\n        UserData memory userInfo;\\r\\n        bool close;\\r\\n        uint40 length = uint40(_id.length);\\r\\n        uint40 id;\\r\\n        if(_maxDca != 0) maxDcaExecutable = _maxDca;\\r\\n        for(uint40 i; i < length; ++i){\\r\\n            id = _adjustPositionAfterDelete(changeRequired[_id[i]], _id[i], positionToChange[_id[i]]);\\r\\n            dcaExeData[id].onGoing = 0;\\r\\n            userInfo = INUI(NUI).userData(id);\\r\\n            if(dcaExeData[id].errCount >= ERROR_LIMIT){\\r\\n                close = true;\\r\\n                emit PositionClosedByError(userInfo.owner, userInfo.identifier);\\r\\n            }else if(dcaExeData[id].limitCount >= LIMIT_ORDER_ERROR){\\r\\n                close = true;\\r\\n                emit PositionClosedByLimitOrderLimit(userInfo.owner, userInfo.identifier);\\r\\n            }else if(userInfo.exeRequired > 0 && dcaExeData[id].exePerformed >= userInfo.exeRequired){\\r\\n                close = true;\\r\\n                emit PositionCompleted(userInfo.owner, userInfo.identifier);\\r\\n            }else if(userInfo.toBeClosed){\\r\\n                close = true;\\r\\n                emit PositionClosedByQueue(userInfo.owner, userInfo.identifier);\\r\\n            }\\r\\n            if(close){\\r\\n                close = false;\\r\\n                INUI(NUI).updatePositionPerExecution(dcaExeData[id].nextExecution, 0);\\r\\n                INUI(NUI).closePosition(userInfo.identifier, userInfo.owner);\\r\\n                positionToChange[INUI(NUI).totalDCAs()] = id;\\r\\n                changeRequired[INUI(NUI).totalDCAs()] = true;\\r\\n            }\\r\\n        }\\r\\n        if(resolverRunning) resolverRunning = false;\\r\\n    }\\r\\n    /* VIEW METHODS*/\\r\\n    function positionDetail(bytes32 _identifier) external view onlyNUI returns (ExeData memory){\\r\\n        return dcaExeData[dcaPosition[_identifier]];\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Retrieve number of executable positions.\\r\\n     * @return  uint40  number of DCAs that must be executed.\\r\\n     */\\r\\n    function amountExecutablePositions() external view onlyResolver returns (uint40){\\r\\n        uint40 totalpositions = INUI(NUI).totalDCAs();\\r\\n        uint40 executablePositions;\\r\\n        for(uint40 i; i < totalpositions; ++i){\\r\\n            if(block.timestamp >= dcaExeData[i].nextExecution || dcaExeData[i].onGoing > 0){\\r\\n                unchecked {\\r\\n                    ++executablePositions;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return executablePositions;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Retrieve position of executable DCAs.\\r\\n     * @param   _amountExecutablePositions  total executable DCAs.\\r\\n     * @return  uint40[]  position of DCAs that must be executed.\\r\\n     */\\r\\n    function executableIds(uint40 _amountExecutablePositions) external view onlyResolver returns (uint40[] memory){\\r\\n        uint40 totalpositions = INUI(NUI).totalDCAs();\\r\\n        uint40[] memory ids = new uint40[](_amountExecutablePositions);\\r\\n        uint40 idx;\\r\\n        for(uint40 i; i < totalpositions; ++i){\\r\\n            if(block.timestamp >= dcaExeData[i].nextExecution || dcaExeData[i].onGoing > 0){\\r\\n                ids[idx] = i;\\r\\n                unchecked {\\r\\n                    ++idx;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ids;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Execution data for the resolver.\\r\\n     * @param   _id  Array of DCAs ids (position).\\r\\n     * @return  ResolverData[]  resolver data.\\r\\n     */\\r\\n    function executionsDetail(uint40[] memory _id) external view onlyResolver returns (ResolverData[] memory){\\r\\n        uint40 length = uint40(_id.length);\\r\\n        UserData memory userInfo;\\r\\n        ResolverData[] memory resultData = new ResolverData[](length);\\r\\n        for(uint40 i; i < length; ++i){\\r\\n            userInfo = INUI(NUI).userData(_id[i]);\\r\\n            resultData[i] = ResolverData(\\r\\n                userInfo.toBeClosed,\\r\\n                ERC20(userInfo.srcToken).allowance(userInfo.owner, address(this)) >= userInfo.srcAmount,\\r\\n                ERC20(userInfo.srcToken).balanceOf(userInfo.owner) >= userInfo.srcAmount,\\r\\n                userInfo.owner,\\r\\n                userInfo.receiver,\\r\\n                userInfo.srcToken,\\r\\n                userInfo.dstToken,\\r\\n                ERC20(userInfo.srcToken).decimals(),\\r\\n                ERC20(userInfo.dstToken).decimals(),\\r\\n                dcaExeData[_id[i]].onGoing,\\r\\n                userInfo.srcAmount,\\r\\n                userInfo.limitOrderBuy\\r\\n            );\\r\\n        }\\r\\n        return resultData;\\r\\n    }\\r\\n    /**\\r\\n     * @notice  Amount trasferred to the resolver in the currect execution.\\r\\n     * @param   _id  DCA position.\\r\\n     * @return  uint256  trasferred amount.\\r\\n     */\\r\\n    function amountTransfered(uint40 _id) external view onlyResolver returns (uint256){\\r\\n        return dcaExeData[_id].fundTransferred;\\r\\n    }\\r\\n    /* PRIVATE METHODS*/\\r\\n    function _setExeData(\\r\\n        uint40 _dateCreation,\\r\\n        uint40 _nextExecution\\r\\n    ) private {\\r\\n        dcaExeData.push(ExeData(\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            _dateCreation,\\r\\n            _nextExecution,\\r\\n            0,\\r\\n            0,\\r\\n            0\\r\\n        ));\\r\\n    }\\r\\n    /**\\r\\n     * @dev     Manage deviation if _baseExecution is 1 day late on execution, time will be adjusted current + frequency.\\r\\n     *          And check execution capacity.\\r\\n     */\\r\\n    function _generateNextExecution(uint40 _baseExecution, uint8 _tau) private view returns (uint40){\\r\\n        uint40 timestamp = uint40(DateTime.getMidnightTimestamp(block.timestamp));\\r\\n        uint40 nextExecution = (timestamp - _baseExecution) >= TIME_BASE ? timestamp : _baseExecution;\\r\\n        return _positionSlippage(nextExecution, _tau);\\r\\n    }\\r\\n\\r\\n    function _positionSlippage(uint40 _nextExecution, uint8 _tau) private view returns (uint40) {\\r\\n        uint40 nextExecution = _nextExecution + (_tau * TIME_BASE);\\r\\n        if(INUI(NUI).positionPerExecution(nextExecution) + 1 > maxDcaExecutable){// +1 day\\r\\n            nextExecution += TIME_BASE;\\r\\n            if(INUI(NUI).positionPerExecution(nextExecution) + 1 > maxDcaExecutable){// +2 days\\r\\n                nextExecution += TIME_BASE;\\r\\n                if(INUI(NUI).positionPerExecution(nextExecution) + 1 > maxDcaExecutable){// 1 week\\r\\n                    nextExecution += (5 * TIME_BASE);\\r\\n                    if(INUI(NUI).positionPerExecution(nextExecution) + 1 > maxDcaExecutable){// +2 weeks\\r\\n                        nextExecution += (7 * TIME_BASE);\\r\\n                        if(INUI(NUI).positionPerExecution(nextExecution) + 1 > maxDcaExecutable){// +1 month\\r\\n                            nextExecution += (14 * TIME_BASE);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return nextExecution;\\r\\n    }\\r\\n\\r\\n    function _adjustPositionAfterDelete(bool _isRequired, uint40 currentPosition, uint40 newPosition) private pure returns (uint40){\\r\\n        return _isRequired ? newPosition : currentPosition;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NUI\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmergencyPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"PositionClosedByError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"PositionClosedByLimitOrderLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"PositionClosedByQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"PositionCompleted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESOLVER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountExecutablePositions\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"amountTransfered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_identifierLast\",\"type\":\"bytes32\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"_nextExecution\",\"type\":\"uint40\"}],\"name\":\"createPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_amountExecutablePositions\",\"type\":\"uint40\"}],\"name\":\"executableIds\",\"outputs\":[{\"internalType\":\"uint40[]\",\"name\":\"\",\"type\":\"uint40[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40[]\",\"name\":\"_id\",\"type\":\"uint40[]\"},{\"internalType\":\"uint40\",\"name\":\"_maxDca\",\"type\":\"uint40\"}],\"name\":\"executionCompletion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40[]\",\"name\":\"_id\",\"type\":\"uint40[]\"}],\"name\":\"executionStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40[]\",\"name\":\"_id\",\"type\":\"uint40[]\"}],\"name\":\"executionsDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"toBeClosed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOk\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"balanceOk\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"srcDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dstDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"onGoing\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitOrderBuy\",\"type\":\"uint256\"}],\"internalType\":\"struct ResolverData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initMaxDcaExecutable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDcaExecutable\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operative\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_identifier\",\"type\":\"bytes32\"}],\"name\":\"positionDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"onGoing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"errCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"limitCount\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"dateCreation\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"nextExecution\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"lastExecution\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"exePerformed\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"fundTransferred\",\"type\":\"uint256\"}],\"internalType\":\"struct ExeData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolverRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapsExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_tau\",\"type\":\"uint8\"}],\"name\":\"updateExecutionDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40[]\",\"name\":\"_id\",\"type\":\"uint40[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_code\",\"type\":\"uint16[]\"}],\"name\":\"updatePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NRI", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000aab9a750f02016f56f8127c2cada50ee878fb1760000000000000000000000003bb2479603143d58b86854fb466a492cea7d85fa", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}