{"SourceCode": "/*\r\n          ,/`.\r\n        ,'/ __`.\r\n      ,'_/__ _ _`.\r\n    ,'__/__ _ _  _`.\r\n  ,'_  /___ __ _ __ `.\r\n '-.._/___ _ __ __  __`.\r\n*/\r\npragma solidity ^0.8.18;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _ownerOf(tokenId);\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function uintToString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        \r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        \r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        \r\n        bytes memory buffer = new bytes(digits);\r\n        \r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n    \r\n        return string(buffer);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, uintToString(tokenId) )) : \"\";\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not token owner or approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        _requireMinted(tokenId);\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\r\n        return _owners[tokenId];\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _ownerOf(tokenId) != address(0);\r\n    }\r\n\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\r\n\r\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        unchecked {\r\n            _balances[to] += 1;\r\n        }\r\n\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId, 1);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\r\n\r\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\r\n        owner = ERC721.ownerOf(tokenId);\r\n\r\n        // Clear approvals\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            _balances[owner] -= 1;\r\n        }\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n\r\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        //require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId, 1);\r\n\r\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n\r\n        // Clear approvals from the previous owner\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            _balances[from] -= 1;\r\n            _balances[to] += 1;\r\n        }\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId, 1);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n\r\n    function isContract(address _addr) public view returns (bool is_contract) {\r\n        return _addr.code.length > 0;\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 firstTokenId,\r\n        uint256 batchSize\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 firstTokenId,\r\n        uint256 batchSize\r\n    ) internal virtual {}\r\n}\r\n\r\nabstract contract ERC721URIStorage is ERC721 {\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = _baseURI();\r\n\r\n        // If there is no base URI, return the token URI.\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n\r\n        return super.tokenURI(tokenId);\r\n    }\r\n}\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n    uint256[] private _allTokens;\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 firstTokenId,\r\n        uint256 batchSize\r\n    ) internal virtual override{\r\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\r\n\r\n        if (batchSize > 1) {\r\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\r\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\r\n        }\r\n\r\n        uint256 tokenId = firstTokenId;\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\ncontract $ObelusBonds is ERC721, ERC721Enumerable, ERC721URIStorage {\r\n    address THIS = address(this);\r\n    Renderer renderer;\r\n    \r\n    address public admin;\r\n    address hypeToken;\r\n    uint hypeRatio;\r\n\r\n    constructor() ERC721(\"Obelus Bond\", \"OBLS\"){\r\n        resolveToken = new ResolveToken( THIS );\r\n        renderer = Renderer(THIS);\r\n        address sender = msg.sender;\r\n        resolveToken.mint(sender, 100*1e18);\r\n        admin = sender;\r\n    }\r\n\r\n    function setOwner(address addr) public {\r\n        require(msg.sender == admin);\r\n        admin = addr;\r\n    }\r\n    \r\n    function setRenderer(address addr) public {\r\n        require(msg.sender== admin);\r\n        renderer = Renderer(addr);\r\n    }\r\n    \r\n    function setHypeToken(address addr, uint ratio) public {\r\n        require(msg.sender== admin && hypeToken == address(0) );\r\n        hypeToken = addr;\r\n        hypeRatio = ratio;\r\n    }\r\n    \r\n    function hype(uint amount) public {\r\n        address sender = msg.sender;\r\n        require(ERC20TransferFrom(hypeToken).transferFrom(sender, THIS, amount));\r\n        uint mintAmount = amount * hypeRatio / 1e18;\r\n        resolveToken.mint(sender, mintAmount);\r\n        resolveToken.mint(admin, mintAmount);\r\n    }\r\n\r\n    // scaleFactor is used to convert Ether into bonds and vice-versa: they're of different\r\n    // orders of magnitude, hence the need to bridge between the two.\r\n    uint256 constant scaleFactor = 0x10000000000000000;\r\n    uint totalMass;\r\n    address address0 = address(0);\r\n\r\n    // Slope\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n\r\n    struct Card{\r\n        bool kind;//false = bond, true = stake\r\n        uint average_ethSpent;//for bonds only\r\n        uint average_buyInTimeSum;//for bonds only\r\n        int payouts;//to be payed out or what has been payed out depending on kind\r\n        uint mass;//dividend share weight or bond weight depending on kind\r\n    }\r\n\r\n    mapping(uint256 => Card) cards;\r\n\r\n    // The total number of resolves being staked in this contract\r\n    uint256 public dissolvingResolves;\r\n\r\n    // For calculating the hodl multiplier. Weighted average release time\r\n    uint public sumOfInputETH;\r\n    uint public sumOfInputTime;\r\n    uint public sumOfOutputETH;\r\n    uint public sumOfOutputTime;\r\n\r\n\r\n    // Variable tracking how much Ether each token is currently worth\r\n    // Note that this is scaled by the scaleFactor variable.\r\n    uint256 public earningsPerResolve;\r\n\r\n    //The resolve token contract\r\n    ResolveToken public resolveToken;\r\n\r\n    function fluxFee(uint paidAmount) public view returns(uint fee) {\r\n        //we're only going to count resolve tokens that haven't been burned.\r\n        uint totalResolveSupply = resolveToken.totalSupply() - resolveToken.balanceOf( address(0) );\r\n        if ( dissolvingResolves == 0 || sumOfInputETH==0)\r\n            return 0;\r\n\r\n        //the fee is the % of resolve tokens outside of the contract times easing function\r\n        return paidAmount * ( totalResolveSupply - dissolvingResolves ) / totalResolveSupply * sumOfOutputETH / sumOfInputETH;\r\n    }\r\n\r\n    // Calculate the current resolveEarnings associated with the caller address. This is the net result\r\n    // of multiplying the number of resolves held by their current value in Ether and subtracting the\r\n    // Ether that has already been paid out.\r\n    function resolveEarnings(uint stakeID) public view returns (uint256 amount) {\r\n        Card memory stake = cards[stakeID];\r\n        return uint( int(earningsPerResolve * stake.mass) - stake.payouts) / scaleFactor;\r\n    }\r\n\r\n    event Buy( address indexed addr, uint256 spent, uint256 mass, uint256 resolveTax);\r\n    function buy(address addr) public payable returns(uint createdBonds){\r\n        // Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\n        if ( msg.value < 0.000001 ether )\r\n            revert();\r\n\r\n        // Calculate the fee\r\n        uint fee = fluxFee(msg.value);\r\n\r\n        // The amount of Ether used to purchase new bonds for the caller.\r\n        uint numEther = msg.value;\r\n\r\n        numEther = numEther - fee;\r\n\r\n        //resolve reward tracking stuff\r\n        uint currentTime = block.timestamp;\r\n        Card storage bond = cards[_mint(addr)];\r\n        bond.average_ethSpent = numEther;\r\n        bond.average_buyInTimeSum = currentTime * scaleFactor * numEther;\r\n        sumOfInputETH += numEther;\r\n        sumOfInputTime += currentTime * scaleFactor * numEther;\r\n\r\n        // The number of bonds which can be purchased for numEther.\r\n        createdBonds = ethereumToTokens_(numEther);\r\n\r\n        // Add the createdBonds to the total supply.\r\n        totalMass += createdBonds;\r\n\r\n        // Assign the bonds to the balance of the buyer.\r\n        bond.mass = createdBonds;\r\n\r\n        // Check if we have resolves dissolving\r\n        uint resolveFee;\r\n        if (dissolvingResolves > 0){\r\n            resolveFee = fee/2 * scaleFactor;\r\n            bond.payouts = int(fee)/2;\r\n\r\n            // Fee is distributed to all existing resolve holders before the new bonds are purchased.\r\n            // rewardPerResolve is the amount gained per resolve token from this purchase.\r\n            uint rewardPerResolve = resolveFee/dissolvingResolves;\r\n\r\n            // The Ether value per resolve is increased proportionally.\r\n            earningsPerResolve += rewardPerResolve;\r\n        }\r\n\r\n        emit Buy(addr, msg.value, createdBonds, resolveFee);\r\n        return createdBonds;\r\n    }\r\n\r\n    function _mint(address _to) internal returns (uint256 _mintedTokenId) {\r\n        uint bondID = totalMinted;\r\n        totalMinted++;\r\n\r\n        _safeMint(_to, bondID, '');\r\n        emit Mint(bondID, msg.sender, _to);\r\n        emit Transfer(address0, _to, bondID);\r\n    \r\n        return bondID;\r\n    }\r\n\r\n    function avgHodl() public view returns(uint hodlTime){\r\n        return (sumOfInputTime - sumOfOutputTime) / (sumOfInputETH - sumOfOutputETH) / scaleFactor;\r\n    }\r\n\r\n    function getReturnsForBonds(uint bondID, uint bondsReleased) public view returns(uint etherValue, uint mintedResolves, uint new_releaseTimeSum, uint new_releaseAmount, uint initialInput_ETH){\r\n        Card memory bond = cards[bondID];\r\n        uint output_ETH = tokensToEthereum_(bondsReleased);\r\n        uint input_ETH = bond.average_ethSpent * bondsReleased / bond.mass;\r\n        // hodl multiplier. because if you don't hodl at all, you shouldn't be rewarded resolves.\r\n        // and the multiplier you get for hodling needs to be relative to the average hodl\r\n        uint buyInTime = bond.average_buyInTimeSum / bond.average_ethSpent;\r\n        uint NOW = block.timestamp;\r\n        uint cashoutTime = NOW * scaleFactor - buyInTime;\r\n        uint new_sumOfOutputTime = sumOfOutputTime + bond.average_buyInTimeSum * bondsReleased / bond.mass;\r\n        uint new_sumOfOutputETH = sumOfOutputETH + input_ETH;\r\n        uint averageHoldingTime = NOW * scaleFactor - ( sumOfInputTime - sumOfOutputTime ) / ( sumOfInputETH - sumOfOutputETH );\r\n        return (\r\n            output_ETH, \r\n            averageHoldingTime>0?input_ETH * cashoutTime / averageHoldingTime * input_ETH / output_ETH:0,\r\n            new_sumOfOutputTime,\r\n            new_sumOfOutputETH,\r\n            input_ETH\r\n        );\r\n    }\r\n\r\n    // Sells your bonds for Ether\r\n    function sellBonds(uint[] memory bondIDs, uint[] memory amounts) public returns(uint _returned_eth, uint _returned_resolves, uint _initialInput_ETH){\r\n        address sender = msg.sender;\r\n        uint L = bondIDs.length;\r\n        uint returned_eth;\r\n        uint returned_resolves;\r\n        uint initialInput_ETH;\r\n        uint bondIndex;\r\n        Card storage bond;\r\n        for(uint i;i<L;i++){\r\n            bondIndex = bondIDs[i];\r\n            bond = cards[bondIndex];\r\n            require(bond.mass >= amounts[i] && ownerOf(bondIndex) == sender && !bond.kind);\r\n            ( returned_eth, returned_resolves, initialInput_ETH ) = sell( bondIndex, amounts[i]);\r\n\r\n            _returned_eth += returned_eth;\r\n            _returned_resolves += returned_resolves;\r\n            _initialInput_ETH += initialInput_ETH;\r\n        }\r\n        return (returned_eth, returned_resolves, initialInput_ETH);\r\n    }\r\n\r\n    event Sell( address indexed addr, uint indexed bondID, uint256 bondsSold, uint256 cashout, uint256 resolves, uint256 resolveTax, uint256 initialCash);\r\n    function sell(uint bondID,uint256 amount) internal returns(uint eth, uint resolves, uint initialInput){\r\n        Card storage bond = cards[bondID];\r\n        address payable sender = payable(msg.sender);\r\n        // Calculate the amount of Ether & Resolves that the holder's bonds sell for at the current sell price.\r\n\r\n        uint _payouts = uint(bond.payouts) * amount / bond.mass;\r\n        bond.payouts -= int(_payouts);\r\n\r\n        uint[] memory UINTs = new uint[](5);\r\n        (\r\n        UINTs[0]/*ether out*/,\r\n        UINTs[1]/*minted resolves*/,\r\n        UINTs[2]/*new_sumOfOutputTime*/,\r\n        UINTs[3]/*new_sumOfOutputETH*/,\r\n        UINTs[4]/*initialInput_ETH*/) = getReturnsForBonds(bondID, amount);\r\n\r\n        // magic distribution\r\n        resolveToken.mint(sender, UINTs[1]/*minted resolves*/);\r\n\r\n        // update weighted average cashout time\r\n        sumOfOutputTime = UINTs[2] /*new_sumOfOutputTime*/;\r\n        sumOfOutputETH = UINTs[3] /*new_sumOfOutputETH*/;\r\n\r\n        // reduce the amount of \"eth spent\" based on the percentage of bonds being sold back into the contract\r\n        bond.average_ethSpent = bond.average_ethSpent * ( bond.mass - amount ) / bond.mass;\r\n        // reduce the \"buyInTime\" sum that's used for average buy in time\r\n        bond.average_buyInTimeSum = bond.average_buyInTimeSum * (bond.mass - amount) / bond.mass;\r\n\r\n        // Net Ether for the seller.\r\n        uint numEthers = UINTs[0]/*ether out*/;\r\n\r\n        // Burn the bonds which were just sold from the total supply.\r\n        totalMass -= amount;\r\n\r\n        // Remove the bonds from the balance of the buyer.\r\n        bond.mass -= amount;\r\n        if(bond.mass==0){\r\n            _transfer(sender, address0, bondID);\r\n        }\r\n\r\n        // Check if we have resolves dissolving\r\n        if ( dissolvingResolves > 0 ){\r\n            // SellSideDivs are distributed to all remaining resolve holders.\r\n            // rewardPerResolve is the amount gained per resolve thanks to this sell.\r\n            uint rewardPerResolve = _payouts * scaleFactor/dissolvingResolves;\r\n\r\n            // The Ether value per resolve is increased proportionally.\r\n            earningsPerResolve += rewardPerResolve;\r\n        }\r\n        \r\n        \r\n        (bool success, ) = sender.call{value:numEthers}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n\r\n        emit Sell( sender, bondID, amount, numEthers, UINTs[1]/*minted resolves*/, _payouts, UINTs[4] /*initialInput_ETH*/);\r\n        return (numEthers, UINTs[1]/*minted resolves*/, UINTs[4] /*initialInput_ETH*/);\r\n    }\r\n\r\n    // Allow contract to accept resolve tokens\r\n    event StakeResolves( uint indexed stakeID, uint256 amountStaked );\r\n    function tokenFallback(address from, uint value, bytes calldata _data) external{\r\n        if(msg.sender == address(resolveToken) ){\r\n            uint stakeID = uint(bytes32(_data));\r\n            Card storage stake;\r\n            if(stakeID>0){\r\n                stake = cards[stakeID];\r\n                require(stake.kind);//require that this is actually a staking position and not a bond. (safety)\r\n            }else{\r\n                stakeID = _mint(from);\r\n                stake = cards[stakeID];\r\n                stake.kind = true;\r\n            }\r\n            stake.mass += value;\r\n            dissolvingResolves += value;\r\n\r\n            // Then we update the payouts array for the \"resolve shareholder\" with this amount\r\n            stake.payouts += int(earningsPerResolve * value);\r\n\r\n            emit StakeResolves(stakeID, value);\r\n        }else if(msg.sender == 0xe324C8cF74899461Ef7aD2c3EB952DA7819aabc5/*ring hop old supply*/){\r\n            resolveToken.mint(from, value);\r\n        }else{\r\n            revert(\"no want\");\r\n        }\r\n    }\r\n\r\n    // Withdraws resolveEarnings held by the caller sending the transaction, updates\r\n    // the requisite global variables, and transfers Ether back to the caller.\r\n    event Withdraw( address indexed addr, uint indexed stakeID, uint256 earnings, uint256 dissolve );\r\n    function withdraw(uint stakeID, uint amount) public returns(uint){\r\n        address payable sender = payable(msg.sender);\r\n        Card storage stake = cards[stakeID];\r\n        // Retrieve the resolveEarnings associated with the address the request came from.\r\n        uint upScaleDivs = uint( int( earningsPerResolve * stake.mass ) - stake.payouts);\r\n        uint totalEarnings = upScaleDivs / scaleFactor;\r\n        require( amount <= totalEarnings && amount > 0 && stake.kind && ownerOf(stakeID)==sender );\r\n        uint oldWeight = stake.mass;\r\n        stake.mass = oldWeight * ( totalEarnings - amount ) / totalEarnings;\r\n        uint weightDiff = oldWeight - stake.mass;\r\n        \r\n        if(oldWeight == weightDiff){\r\n            _transfer(sender, address0, stakeID);\r\n        }\r\n\r\n        resolveToken.transfer( address0, weightDiff);\r\n        dissolvingResolves -= weightDiff;\r\n        \r\n        stake.payouts += int(upScaleDivs * amount / totalEarnings) - int(weightDiff*earningsPerResolve);\r\n\r\n        // Send the resolveEarnings to the address that requested the withdraw.\r\n        (bool success, ) = sender.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n\r\n        emit Withdraw( sender, stakeID, amount, weightDiff);\r\n        return weightDiff;\r\n    }\r\n\r\n    event PullResolves( address indexed addr, uint indexed stakeID, uint256 pulledResolves, uint256 forfeiture);\r\n    function pullResolves(uint stakeID, uint amount) public returns (uint forfeiture){\r\n        Card storage stake = cards[stakeID];\r\n        address sender = msg.sender;\r\n        uint resolves = stake.mass;\r\n        require(amount <= resolves && amount > 0 && stake.kind && ownerOf(stakeID)==sender );\r\n        require(amount < dissolvingResolves);//\"you can't forfeit the last resolve\"\r\n\r\n        uint yourTotalEarnings = (uint)((int256)(resolves * earningsPerResolve) - stake.payouts);\r\n        uint forfeitedEarnings = yourTotalEarnings * amount / resolves;\r\n\r\n        // Update the payout array so that the \"resolve shareholder\" cannot claim resolveEarnings on previous staked resolves.\r\n        stake.payouts += (int256)(forfeitedEarnings) - (int256)(earningsPerResolve * amount);\r\n\r\n        stake.mass -= amount;\r\n        dissolvingResolves -= amount;\r\n        // The Ether value per token is increased proportionally.\r\n        earningsPerResolve += forfeitedEarnings / dissolvingResolves;\r\n\r\n        resolveToken.transfer( sender, amount );\r\n        emit PullResolves( sender, stakeID, amount, forfeitedEarnings / scaleFactor);\r\n        return forfeitedEarnings / scaleFactor;\r\n    }\r\n\r\n    function mixBonds(uint bondID_from, uint bondID_to, uint _amount) external{\r\n        //mix bond values\r\n        address owner = ownerOf(bondID_to);\r\n        Card storage bondFrom = cards[bondID_from];\r\n        Card storage bondTo = cards[bondID_to];\r\n        require( ownerOf(bondID_from) == owner && owner == msg.sender && !bondFrom.kind && !bondTo.kind);\r\n        uint totalMassOfBond = bondFrom.mass;\r\n        uint ethSpent = bondFrom.average_ethSpent * _amount / totalMassOfBond;\r\n        uint buyInTimeSum = bondFrom.average_buyInTimeSum * _amount / totalMassOfBond;\r\n        bondFrom.average_ethSpent -= ethSpent;\r\n        bondFrom.average_buyInTimeSum -= buyInTimeSum;\r\n        bondTo.average_ethSpent += ethSpent;\r\n        bondTo.average_buyInTimeSum += buyInTimeSum;\r\n    }\r\n\r\n    function calculateMassReceived(uint256 _ethereumToSpend) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 _dividends = fluxFee(_ethereumToSpend);\r\n        uint256 _taxedEthereum = subtract(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived = \r\n        (\r\n            (\r\n                // underflow attempts BTFO\r\n                subtract(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(totalMass**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*totalMass)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(totalMass)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (totalMass + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            subtract(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    function subtract(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    uint256 internal totalMinted = 0;\r\n    \r\n    // The following functions are overrides required by Solidity.\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721Enumerable)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function totalSupply() public view override(ERC721Enumerable)returns (uint256){\r\n        return totalMinted;\r\n    }\r\n\r\n    function getAccount(address account) external view returns(uint[] memory cardIDs){\r\n        uint L = balanceOf(account);\r\n        cardIDs = new uint[](L);\r\n        for(uint i;i<L;i++){\r\n            cardIDs[i] = tokenOfOwnerByIndex(account,i);\r\n        }\r\n    }\r\n\r\n    function getCardData(uint[] memory cardIDs) external view returns(bool[] memory kinds, uint[] memory masses,uint[] memory average_ethSpent,uint[] memory bondValues,uint[] memory average_buyInTimeSum,uint[] memory payouts,uint[] memory resolvePotential){\r\n        uint L = cardIDs.length;\r\n        masses = new uint[](L);\r\n        average_ethSpent = new uint[](L);\r\n        average_buyInTimeSum = new uint[](L);\r\n        payouts = new uint[](L);\r\n        resolvePotential = new uint[](L);\r\n        bondValues = new uint[](L);\r\n        kinds = new bool[](L);\r\n        Card memory card;\r\n        uint cardID;\r\n        uint resolves;\r\n        uint bondValue;\r\n        for(uint i;i<L;i++){\r\n            cardID = cardIDs[i];\r\n            card = cards[cardID];\r\n            kinds[i] = card.kind;\r\n\r\n            masses[i] = card.mass;\r\n            \r\n            average_ethSpent[i] = card.average_ethSpent;\r\n            average_buyInTimeSum[i] = (card.average_ethSpent>0)?card.average_buyInTimeSum/card.average_ethSpent/scaleFactor:0;\r\n\r\n            if(card.kind){\r\n                payouts[i] = resolveEarnings(cardID);//what this staking position has earned\r\n            }else{\r\n                payouts[i] = uint(card.payouts);//earnings this bond has yet to distribute when sold\r\n            }\r\n\r\n            if(card.mass>0 && !card.kind){\r\n                (bondValue,resolves,,,) = getReturnsForBonds(cardID,card.mass);\r\n            }else{\r\n                bondValue = 0;\r\n                resolves = 0; \r\n            }\r\n            \r\n            bondValues[i] = bondValue;\r\n            resolvePotential[i] = resolves;\r\n        }\r\n    }\r\n\r\n    function getStakeValue(uint cardID) external view returns(uint){\r\n        return resolveEarnings(cardID);\r\n    }\r\n\r\n    function globalData() external view returns(uint liquidity, uint _totalMass, uint _totalSupply, uint resolves_inside, uint resolves_total, uint _fluxFee, uint average_hodl){\r\n        liquidity = totalMass>0?tokensToEthereum_(totalMass):0;\r\n        _totalMass = totalMass;\r\n        _totalSupply = totalSupply();\r\n        resolves_inside = dissolvingResolves;\r\n        resolves_total = resolveToken.totalSupply() - resolveToken.balanceOf( address(0) );\r\n        _fluxFee = fluxFee(1000000);\r\n        average_hodl = (sumOfInputETH - sumOfOutputETH)>0?avgHodl():0;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override(ERC721, ERC721Enumerable){\r\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\r\n    }\r\n    \r\n    function tokenURI(uint256 tokenId) public view override(ERC721,ERC721URIStorage) returns (string memory) {\r\n        require( _exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        return string(abi.encodePacked(\"data:application/json;utf8,\", renderer.json(tokenId)));\r\n    }\r\n\r\n    function json(uint256 id) public view returns(string memory){\r\n        return '';\r\n    }\r\n\r\n    event Mint(uint indexed tokenId, address indexed mintedBy, address indexed mintedTo);\r\n}\r\n\r\nabstract contract ERC20TransferFrom {\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);\r\n}\r\n\r\nabstract contract Renderer{\r\n    function json(uint id) public view virtual returns(string memory);\r\n}\r\n\r\ncontract ResolveToken{\r\n\r\n    string public name = \"Resolve\";\r\n    string public symbol = \"RSLV\";\r\n    uint8 constant public decimals = 18;\r\n    address public hourglass;\r\n\r\n    constructor(address _hourglass){\r\n        hourglass = _hourglass;\r\n    }\r\n\r\n    modifier hourglassOnly{\r\n        require(msg.sender == hourglass);\r\n        _;\r\n    }\r\n\r\n    function mint(address _address, uint _value) external hourglassOnly(){\r\n        balances[_address] += _value;\r\n        _totalSupply += _value;\r\n        emit Transfer(address(0), _address, _value);\r\n    }\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => mapping(address => uint)) approvals;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data\r\n    );\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Standard function transfer similar to ERC20 transfer with no _data.\r\n    // Added due to backwards compatibility reasons.\r\n    function transfer(address _to, uint _value) public virtual returns (bool) {\r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if(isContract(_to)){\r\n            return transferToContract(_to, _value, empty);\r\n        }else{\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds.\r\n    function transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) {\r\n        if( isContract(_to) ){\r\n            return transferToContract(_to, _value, _data);\r\n        }else{\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n    \r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n        moveTokens(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //function that is called when transaction target is a contract\r\n    function transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n        moveTokens(msg.sender, _to, _value);\r\n        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function moveTokens(address _from, address _to, uint _amount) internal{\r\n        require( _amount <= balances[_from] );\r\n\r\n        //update balances\r\n        balances[_from] -= _amount;\r\n        balances[_to] += _amount;\r\n    }\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n    \r\n    function transferFrom(address src, address dst, uint amount) public returns (bool){\r\n        address sender = msg.sender;\r\n        require(approvals[src][sender] >=  amount);\r\n        require(balances[src] >= amount);\r\n        approvals[src][sender] -= amount;\r\n        moveTokens(src,dst,amount);\r\n        bytes memory empty;\r\n        emit Transfer(sender, dst, amount, empty);\r\n        emit Transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint amount);\r\n    function approve(address guy, uint amount) public returns (bool) {\r\n        address sender = msg.sender;\r\n        approvals[sender][guy] = amount;\r\n\r\n        emit Approval( sender, guy, amount );\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _addr) public view returns (bool is_contract) {\r\n        return _addr.code.length > 0;\r\n    }\r\n}\r\n\r\nabstract contract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external virtual;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mass\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintedBy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintedTo\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pulledResolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forfeiture\",\"type\":\"uint256\"}],\"name\":\"PullResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bondID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondsSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialCash\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"}],\"name\":\"StakeResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dissolve\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgHodl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hodlTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdBonds\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateMassReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dissolvingResolves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningsPerResolve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"fluxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"cardIDs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"cardIDs\",\"type\":\"uint256[]\"}],\"name\":\"getCardData\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"kinds\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"masses\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"average_ethSpent\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bondValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"average_buyInTimeSum\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"payouts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"resolvePotential\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondsReleased\",\"type\":\"uint256\"}],\"name\":\"getReturnsForBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedResolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseTimeSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialInput_ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardID\",\"type\":\"uint256\"}],\"name\":\"getStakeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalMass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resolves_inside\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resolves_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fluxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"average_hodl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"hype\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is_contract\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"json\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondID_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondID_to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mixBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullResolves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forfeiture\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"resolveEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolveToken\",\"outputs\":[{\"internalType\":\"contract ResolveToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bondIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"sellBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_returned_eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_returned_resolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialInput_ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setHypeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfInputETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfInputTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfOutputETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfOutputTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "$ObelusBonds", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e50103cc2f7a59a6d0b9f862f0a4057589edc8145fcb66bcd8e9cfa673613b21"}