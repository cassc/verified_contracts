{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.7/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ICoreRegistryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IEngineRegistryV0.sol\\\";\\n\\ninterface ICoreRegistryV1 is IEngineRegistryV0 {\\n    function registerContracts(\\n        address[] calldata contractAddresses,\\n        bytes32[] calldata coreVersions,\\n        bytes32[] calldata coreTypes\\n    ) external;\\n\\n    function unregisterContracts(address[] calldata contractAddresses) external;\\n\\n    function getNumRegisteredContracts() external view returns (uint256);\\n\\n    function getRegisteredContractAt(\\n        uint256 index\\n    ) external view returns (address);\\n\\n    function isRegisteredContract(\\n        address contractAddress\\n    ) external view returns (bool isRegistered);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IEngineRegistryV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\ninterface IEngineRegistryV0 {\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been registered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractRegistered(\\n        address indexed _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been unregistered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractUnregistered(address indexed _contractAddress);\\n\\n    /**\\n     * @notice Emits a `ContractRegistered` event with the provided information.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function registerContract(\\n        address _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    ) external;\\n\\n    /**\\n     * @notice Emits a `ContractUnregistered` event with the provided information, validating that the provided\\n     *         address was indeed previously registered.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function unregisterContract(address _contractAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ICoreRegistryV1.sol\\\";\\nimport \\\"./IAdminACLV0.sol\\\";\\n\\n/**\\n * @title IMinterFilterV1\\n * @author Art Blocks Inc.\\n * @notice Interface for a new minter filter contract.\\n * This interface does not extend the previous version of the minter filter\\n * interface, as the previous version is not compatible with the new\\n * minter filter architecture.\\n * @dev This interface is for a minter filter that supports multiple core\\n * contracts, and allows for a minter to be set on a per-project basis.\\n */\\ninterface IMinterFilterV1 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Globally approved minter `minter`.\\n     */\\n    event MinterApprovedGlobally(address indexed minter, string minterType);\\n\\n    /**\\n     * @notice Globally revoked minter `minter`.\\n     * @dev contract owner may still approve this minter on a per-contract\\n     * basis.\\n     */\\n    event MinterRevokedGlobally(address indexed minter);\\n\\n    /**\\n     * @notice Approved minter `minter` on core contract\\n     * `coreContract`.\\n     */\\n    event MinterApprovedForContract(\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Revoked minter `minter` on core contract `coreContract`.\\n     * @dev minter filter owner may still globally approve this minter for all\\n     * contracts.\\n     */\\n    event MinterRevokedForContract(\\n        address indexed coreContract,\\n        address indexed minter\\n    );\\n\\n    /**\\n     * @notice Minter at address `minter` set as minter for project\\n     * `projectId` on core contract `coreContract`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Minter removed for project `projectId` on core contract\\n     * `coreContract`.\\n     */\\n    event ProjectMinterRemoved(\\n        uint256 indexed projectId,\\n        address indexed coreContract\\n    );\\n\\n    /**\\n     * @notice Admin ACL contract updated to `adminACLContract`.\\n     */\\n    event AdminACLUpdated(address indexed adminACLContract);\\n\\n    /**\\n     * @notice Core Registry contract updated to `coreRegistry`.\\n     */\\n    event CoreRegistryUpdated(address indexed coreRegistry);\\n\\n    // struct used to return minter info\\n    // @dev this is not used for storage of data\\n    struct MinterWithType {\\n        address minterAddress;\\n        string minterType;\\n    }\\n\\n    function setMinterForProject(\\n        uint256 projectId,\\n        address coreContract,\\n        address minter\\n    ) external;\\n\\n    function removeMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // @dev function name is optimized for gas\\n    function mint_joo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function updateCoreRegistry(address coreRegistry) external;\\n\\n    /**\\n     * @notice Returns if `sender` is allowed to call function on `contract`\\n     * with `selector` selector, according to the MinterFilter's Admin ACL.\\n     */\\n    function adminACLAllowed(\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) external returns (bool);\\n\\n    function minterFilterType() external pure returns (string memory);\\n\\n    function getMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (address);\\n\\n    function projectHasMinter(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice View that returns if a core contract is registered with the\\n     * core registry, allowing this minter filter to service it.\\n     * @param coreContract core contract address to be checked\\n     */\\n    function isRegisteredCoreContract(\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /// Address of current core registry contract\\n    function coreRegistry() external view returns (ICoreRegistryV1);\\n\\n    /// The current admin ACL contract\\n    function adminACLContract() external view returns (IAdminACLV0);\\n\\n    /// The quantity of projects on a core contract that have assigned minters\\n    function getNumProjectsOnContractWithMinters(\\n        address coreContract\\n    ) external view returns (uint256);\\n\\n    function getProjectAndMinterInfoOnContractAt(\\n        address coreContract,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 projectId,\\n            address minterAddress,\\n            string memory minterType\\n        );\\n\\n    function getAllGloballyApprovedMinters()\\n        external\\n        view\\n        returns (MinterWithType[] memory mintersWithTypes);\\n\\n    function getAllContractApprovedMinters(\\n        address coreContract\\n    ) external view returns (MinterWithType[] memory mintersWithTypes);\\n\\n    /**\\n     * Owner of contract.\\n     * @dev This returns the address of the Admin ACL contract.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface ISharedMinterV0 {\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/Bytes32Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n// Inspired by: https://ethereum.stackexchange.com/a/123950/103422\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Operations on bytes32 data type, dealing with conversion to string.\\n */\\nlibrary Bytes32Strings {\\n    /**\\n     * @notice Intended to convert a `bytes32`-encoded string literal to `string`.\\n     * Trims zero padding to arrive at original string literal.\\n     */\\n    function toString(\\n        bytes32 source\\n    ) internal pure returns (string memory result) {\\n        uint8 length;\\n        while (source[length] != 0 && length < 32) {\\n            length++;\\n        }\\n        assembly {\\n            // free memory pointer\\n            result := mload(0x40)\\n            // update free memory pointer to new \\\"memory end\\\"\\n            // (offset is 64-bytes: 32 for length, 32 for data)\\n            mstore(0x40, add(result, 0x40))\\n            // store length in first 32-byte memory slot\\n            mstore(result, length)\\n            // write actual data in second 32-byte memory slot\\n            mstore(add(result, 0x20), source)\\n        }\\n    }\\n\\n    /**\\n     * @notice Intended to check if a `bytes32`-encoded string contains a given\\n     * character with UTF-8 character code `utf8CharCode exactly `targetQty`\\n     * times. Does not support searching for multi-byte characters, only\\n     * characters with UTF-8 character codes < 0x80.\\n     */\\n    function containsExactCharacterQty(\\n        bytes32 source,\\n        uint8 utf8CharCode,\\n        uint8 targetQty\\n    ) internal pure returns (bool) {\\n        uint8 _occurrences;\\n        uint8 i;\\n        for (i; i < 32; ) {\\n            uint8 _charCode = uint8(source[i]);\\n            // if not a null byte, or a multi-byte UTF-8 character, check match\\n            if (_charCode != 0 && _charCode < 0x80) {\\n                if (_charCode == utf8CharCode) {\\n                    unchecked {\\n                        // no risk of overflow since max 32 iterations < max uin8=255\\n                        ++_occurrences;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                // no risk of overflow since max 32 iterations < max uin8=255\\n                ++i;\\n            }\\n        }\\n        return _occurrences == targetQty;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/MinterFilter/MinterFilterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\n// @dev fixed to specific solidity version for clarity and for more clear\\n// source code verification purposes.\\npragma solidity 0.8.19;\\n\\nimport {IMinterFilterV1} from \\\"../../interfaces/v0.8.x/IMinterFilterV1.sol\\\";\\nimport {ISharedMinterV0} from \\\"../../interfaces/v0.8.x/ISharedMinterV0.sol\\\";\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport {ICoreRegistryV1} from \\\"../../interfaces/v0.8.x/ICoreRegistryV1.sol\\\";\\nimport {IAdminACLV0} from \\\"../../interfaces/v0.8.x/IAdminACLV0.sol\\\";\\n\\nimport {Bytes32Strings} from \\\"../../libs/v0.8.x/Bytes32Strings.sol\\\";\\n\\nimport {Ownable} from \\\"@openzeppelin-4.7/contracts/access/Ownable.sol\\\";\\nimport {EnumerableMap} from \\\"@openzeppelin-4.7/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin-4.7/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Math} from \\\"@openzeppelin-4.7/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title MinterFilterV2\\n * @dev At the time of deployment, this contract is intended to be used with\\n * core contracts that implement IGenArt721CoreContractV3_Base.\\n * @author Art Blocks Inc.\\n * @notice This Minter Filter V2 contract allows minters to be set on a\\n * per-project basis, for any registered core contract. This minter filter does\\n * not extend the previous version of the minter filters, as the previous\\n * version is not compatible with multiple core contracts.\\n *\\n * This contract is designed to be managed by an Admin ACL contract, as well as\\n * delegated privileges to core contract artists and Admin ACL contracts.\\n * These roles hold extensive power and can arbitrarily control and modify\\n * how a project's tokens may be minted.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted as allowed by this contract's Admin\\n * ACL:\\n * - updateCoreRegistry\\n * - approveMinterGlobally\\n * - revokeMinterGlobally\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted as allowed by each core contract's\\n * Admin ACL contract:\\n * - approveMinterForContract\\n * - revokeMinterForContract\\n * - removeMintersForProjectsOnContract\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted as allowed by each core contract's\\n * Admin ACL contract, or to the artist address of the project:\\n * - setMinterForProject\\n * - removeMinterForProject\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on minters,\\n * registries, and other contracts that may interact with this contract.\\n */\\ncontract MinterFilterV2 is Ownable, IMinterFilterV1 {\\n    // add Enumerable Map, Enumerable Set methods\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    // add Bytes32Strings methods\\n    using Bytes32Strings for bytes32;\\n\\n    /// @notice Version of this minter filter contract\\n    // @dev use function minterFilterVersion to get this as a string\\n    bytes32 constant MINTER_FILTER_VERSION = \\\"v2.0.0\\\";\\n\\n    /// @notice Type of this minter filter contract\\n    // @dev use function minterFilterType to get this as a string\\n    bytes32 constant MINTER_FILTER_TYPE = \\\"MinterFilterV2\\\";\\n\\n    /// @notice Admin ACL contract for this minter filter\\n    IAdminACLV0 public adminACLContract;\\n\\n    /**\\n     * @notice Core registry, that tracks all registered core contracts\\n     */\\n    ICoreRegistryV1 public coreRegistry;\\n\\n    /// @notice Minter address => qty projects across all core contracts currently\\n    /// using the minter\\n    mapping(address minterAddress => uint256 numProjects)\\n        public numProjectsUsingMinter;\\n\\n    /**\\n     * @notice Enumerable Set of globally approved minters.\\n     * This is a Set of addresses that are approved to mint on any\\n     * project, for any core contract.\\n     * @dev note that contract admins can extend a separate Set of minters for\\n     * their core contract via the `approveMinterForContract` function.\\n     */\\n    EnumerableSet.AddressSet private _globallyApprovedMinters;\\n\\n    /**\\n     * @notice Mapping of core contract addresses to Enumerable Sets of approved\\n     * minters for that core contract.\\n     * @dev note that contract admins can extend this Set for their core\\n     * contract by via the `approveMinterForContract` function, and can remove\\n     * minters from this Set via the `revokeMinterForContract` function.\\n     */\\n    mapping(address coreContract => EnumerableSet.AddressSet approvedMintersForContract)\\n        private _contractApprovedMinters;\\n\\n    /**\\n     * @notice Mapping of core contract addresses to Enumerable Maps of project IDs to\\n     * minter addresses.\\n     */\\n    mapping(address coreContract => EnumerableMap.UintToAddressMap projectIdToMinterAddress)\\n        private _minterForProject;\\n\\n    /**\\n     * @notice Function to validate an address is non-zero.\\n     * @param address_ Address to validate\\n     */\\n    function _onlyNonZeroAddress(address address_) internal pure {\\n        require(address_ != address(0), \\\"Only non-zero address\\\");\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls\\n     * on this minter filter's admin ACL contract.\\n     * @param selector function selector to be checked\\n     */\\n    function _onlyAdminACL(bytes4 selector) internal {\\n        require(\\n            adminACLAllowed(msg.sender, address(this), selector),\\n            \\\"Only Admin ACL allowed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls\\n     * on a given core contract.\\n     * @dev defers to the ACL contract used by the core contract\\n     * @param coreContract core contract address\\n     * @param selector function selector to be checked\\n     */\\n    function _onlyCoreAdminACL(address coreContract, bytes4 selector) internal {\\n        require(\\n            IGenArt721CoreContractV3_Base(coreContract).adminACLAllowed({\\n                _sender: msg.sender,\\n                _contract: address(this),\\n                _selector: selector\\n            }),\\n            \\\"Only Core AdminACL allowed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only core AdminACL or the project artist.\\n     * @dev Defers to the ACL contract used by the core contract\\n     * @param coreContract core contract address\\n     * @param selector function selector to be checked\\n     */\\n    function _onlyCoreAdminACLOrArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        bytes4 selector\\n    ) internal {\\n        IGenArt721CoreContractV3_Base genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\\n                coreContract\\n            );\\n        require(\\n            (msg.sender ==\\n                genArtCoreContract_Base.projectIdToArtistAddress(projectId)) ||\\n                (\\n                    genArtCoreContract_Base.adminACLAllowed({\\n                        _sender: msg.sender,\\n                        _contract: address(this),\\n                        _selector: selector\\n                    })\\n                ),\\n            \\\"Only Artist or Core Admin ACL\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only core contracts registered with the\\n     * currently configured core registry. This is used to prevent non-registered core\\n     * contracts from being used with this minter filter.\\n     * @param coreContract core contract address\\n     */\\n    function _onlyRegisteredCoreContract(address coreContract) internal view {\\n        // @dev use core registry to check if core contract is registered\\n        require(\\n            coreRegistry.isRegisteredContract(coreContract),\\n            \\\"Only registered core contract\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only valid project IDs.\\n     * @param projectId Project ID to validate.\\n     * @param coreContract core contract address\\n     */\\n    function _onlyValidProjectId(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view {\\n        IGenArt721CoreContractV3_Base genArtCoreContract = IGenArt721CoreContractV3_Base(\\n                coreContract\\n            );\\n        require(\\n            (projectId >= genArtCoreContract.startingProjectId()) &&\\n                (projectId < genArtCoreContract.nextProjectId()),\\n            \\\"Only valid project ID\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to check if minter is globally approved or approved for a core contract.\\n     * @param coreContract core contract address\\n     * @param minter Minter to validate.\\n     */\\n    function _onlyApprovedMinter(\\n        address coreContract,\\n        address minter\\n    ) internal view {\\n        require(\\n            isApprovedMinterForContract({\\n                coreContract: coreContract,\\n                minter: minter\\n            }),\\n            \\\"Only approved minters\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Initializes contract to be a Minter for `genArt721Address`.\\n     * @param adminACLContract_ Address of admin access control contract, to be\\n     * set as contract owner.\\n     * @param coreRegistry_ Address of core registry contract.\\n     */\\n    constructor(address adminACLContract_, address coreRegistry_) {\\n        // set AdminACL management contract as owner\\n        _transferOwnership(adminACLContract_);\\n        // set core registry contract\\n        _updateCoreRegistry(coreRegistry_);\\n        emit Deployed();\\n    }\\n\\n    /**\\n     * @notice returns the version of this minter filter contract\\n     */\\n    function minterFilterVersion() external pure returns (string memory) {\\n        return MINTER_FILTER_VERSION.toString();\\n    }\\n\\n    /**\\n     * @notice returns the type of this minter filter contract\\n     */\\n    function minterFilterType() external pure returns (string memory) {\\n        return MINTER_FILTER_TYPE.toString();\\n    }\\n\\n    /**\\n     * @notice Updates the core registry contract to be used by this contract.\\n     * Only callable as allowed by AdminACL of this contract.\\n     * @param coreRegistry_ Address of the new core registry contract.\\n     */\\n    function updateCoreRegistry(address coreRegistry_) external {\\n        _onlyAdminACL(this.updateCoreRegistry.selector);\\n        _updateCoreRegistry(coreRegistry_);\\n    }\\n\\n    /**\\n     * @notice Globally approves minter `minter` to be available for\\n     * minting on any project, for any core contract.\\n     * Only callable as allowed by AdminACL of this contract.\\n     * @dev Reverts if minter is already globally approved, or does not\\n     * implement minterType().\\n     * @param minter Minter to be approved.\\n     */\\n    function approveMinterGlobally(address minter) external {\\n        _onlyAdminACL(this.approveMinterGlobally.selector);\\n        // @dev add() return true if the value was added to the set\\n        require(\\n            _globallyApprovedMinters.add(minter),\\n            \\\"Minter already approved\\\"\\n        );\\n        emit MinterApprovedGlobally({\\n            minter: minter,\\n            minterType: ISharedMinterV0(minter).minterType()\\n        });\\n    }\\n\\n    /**\\n     * @notice Removes previously globally approved minter `minter`\\n     * from the list of globally approved minters.\\n     * Only callable as allowed by AdminACL of this contract.\\n     * Reverts if minter is not globally approved.\\n     * @dev intentionally do not check if minter is still in use by any\\n     * project, meaning that any projects currently using the minter will\\n     * continue to be able to use it. If existing projects should be forced\\n     * to discontinue using a minter, the minter may be removed by the minter\\n     * filter admin in bulk via the `removeMintersForProjectsOnContract`\\n     * function.\\n     * @param minter Minter to remove.\\n     */\\n    function revokeMinterGlobally(address minter) external {\\n        _onlyAdminACL(this.revokeMinterGlobally.selector);\\n        // @dev remove() returns true only if the value was already in the Set\\n        require(\\n            _globallyApprovedMinters.remove(minter),\\n            \\\"Only previously approved minter\\\"\\n        );\\n        emit MinterRevokedGlobally(minter);\\n    }\\n\\n    /**\\n     * @notice Approves minter `minter` to be available for minting on\\n     * any project on core contarct `coreContract`.\\n     * Only callable as allowed by AdminACL of core contract `coreContract`.\\n     * Reverts if core contract is not registered, if minter is already\\n     * approved for the contract, or if minter does not implement minterType().\\n     * @param coreContract Core contract to approve minter for.\\n     * @param minter Minter to be approved.\\n     */\\n    function approveMinterForContract(\\n        address coreContract,\\n        address minter\\n    ) external {\\n        _onlyRegisteredCoreContract(coreContract);\\n        _onlyCoreAdminACL({\\n            coreContract: coreContract,\\n            selector: this.approveMinterForContract.selector\\n        });\\n        // @dev add() returns true if the value was added to the Set\\n        require(\\n            _contractApprovedMinters[coreContract].add(minter),\\n            \\\"Minter already approved\\\"\\n        );\\n        emit MinterApprovedForContract({\\n            coreContract: coreContract,\\n            minter: minter,\\n            minterType: ISharedMinterV0(minter).minterType()\\n        });\\n    }\\n\\n    /**\\n     * @notice Removes previously approved minter `minter` from the\\n     * list of approved minters on core contract `coreContract`.\\n     * Only callable as allowed by AdminACL of core contract `coreContract`.\\n     * Reverts if core contract is not registered, or if minter is not approved\\n     * on contract.\\n     * @dev intentionally does not check if minter is still in use by any\\n     * project, meaning that any projects currently using the minter will\\n     * continue to be able to use it. If existing projects should be forced\\n     * to discontinue using a minter, the minter may be removed by the contract\\n     * admin in bulk via the `removeMintersForProjectsOnContract` function.\\n     * @param coreContract Core contract to remove minter from.\\n     * @param minter Minter to remove.\\n     */\\n    function revokeMinterForContract(\\n        address coreContract,\\n        address minter\\n    ) external {\\n        _onlyRegisteredCoreContract(coreContract);\\n        _onlyCoreAdminACL({\\n            coreContract: coreContract,\\n            selector: this.revokeMinterForContract.selector\\n        });\\n        // @dev intentionally do not check if minter is still in use by any\\n        // project, since it is possible that a different contract's project is\\n        // using the minter\\n        // @dev remove() returns true only if the value was already in the Set\\n        require(\\n            _contractApprovedMinters[coreContract].remove(minter),\\n            \\\"Only previously approved minter\\\"\\n        );\\n        emit MinterRevokedForContract({\\n            coreContract: coreContract,\\n            minter: minter\\n        });\\n    }\\n\\n    /**\\n     * @notice Sets minter for project `projectId` on contract `coreContract`\\n     * to minter `minter`.\\n     * Only callable by the project's artist or as allowed by AdminACL of\\n     * core contract `coreContract`.\\n     * Reverts if:\\n     *  - core contract is not registered\\n     *  - minter is not approved globally on this minter filter or for the\\n     *    project's core contract\\n     *  - project is not valid on the core contract\\n     *  - function is called by an address other than the project's artist\\n     *    or a sender allowed by the core contract's admin ACL\\n     *  - minter does not implement minterType()\\n     * @param projectId Project ID to set minter for.\\n     * @param coreContract Core contract of project.\\n     * @param minter Minter to be the project's minter.\\n     */\\n    function setMinterForProject(\\n        uint256 projectId,\\n        address coreContract,\\n        address minter\\n    ) external {\\n        /// CHECKS\\n        _onlyRegisteredCoreContract(coreContract);\\n        _onlyCoreAdminACLOrArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            selector: this.setMinterForProject.selector\\n        });\\n        _onlyApprovedMinter({coreContract: coreContract, minter: minter});\\n        _onlyValidProjectId({projectId: projectId, coreContract: coreContract});\\n        /// EFFECTS\\n        // decrement number of projects using a previous minter\\n        (bool hasPreviousMinter, address previousMinter) = _minterForProject[\\n            coreContract\\n        ].tryGet(projectId);\\n        if (hasPreviousMinter) {\\n            numProjectsUsingMinter[previousMinter]--;\\n        }\\n        // assign new minter\\n        numProjectsUsingMinter[minter]++;\\n        _minterForProject[coreContract].set(projectId, minter);\\n        emit ProjectMinterRegistered({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            minter: minter,\\n            minterType: ISharedMinterV0(minter).minterType()\\n        });\\n    }\\n\\n    /**\\n     * @notice Updates project `projectId` on contract `coreContract` to have\\n     * no configured minter.\\n     * Only callable by the project's artist or as allowed by AdminACL of\\n     * core contract `coreContract`.\\n     * Reverts if:\\n     *  - core contract is not registered\\n     *  - project does not already have a minter assigned\\n     *  - function is called by an address other than the project's artist\\n     *    or a sender allowed by the core contract's admin ACL\\n     * @param projectId Project ID to remove minter for.\\n     * @param coreContract Core contract of project.\\n     * @dev requires project to have an assigned minter\\n     */\\n    function removeMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external {\\n        _onlyRegisteredCoreContract(coreContract);\\n        _onlyCoreAdminACLOrArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            selector: this.removeMinterForProject.selector\\n        });\\n        // @dev this will revert if project does not have a minter\\n        _removeMinterForProject({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Updates an array of project IDs to have no configured minter.\\n     * Only callable as allowed by AdminACL of core contract `coreContract`.\\n     * Reverts if the core contract is not registered, or if any project does\\n     * not already have a minter assigned.\\n     * @param projectIds Array of project IDs to remove minters for.\\n     * @param coreContract Core contract of projects.\\n     * @dev caution with respect to single tx gas limits\\n     */\\n    function removeMintersForProjectsOnContract(\\n        uint256[] calldata projectIds,\\n        address coreContract\\n    ) external {\\n        _onlyRegisteredCoreContract(coreContract);\\n        _onlyCoreAdminACL({\\n            coreContract: coreContract,\\n            selector: this.removeMintersForProjectsOnContract.selector\\n        });\\n        uint256 numProjects = projectIds.length;\\n        for (uint256 i; i < numProjects; ) {\\n            _removeMinterForProject({\\n                projectId: projectIds[i],\\n                coreContract: coreContract\\n            });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Mint a token from project `projectId` on contract\\n     * `coreContract` to `to`, originally purchased by `sender`.\\n     * @param to The new token's owner.\\n     * @param projectId Project ID to mint a new token on.\\n     * @param sender Address purchasing a new token.\\n     * @param coreContract Core contract of project.\\n     * @return tokenId Token ID of minted token\\n     * @dev reverts w/nonexistent key error when project has no assigned minter\\n     * @dev does not check if core contract is registered, for gas efficiency\\n     * and because project must have already been assigned a minter, which\\n     * requires the core contract to have been previously registered. If core\\n     * contract was unregistered but the project still has an assigned minter,\\n     * minting will remain possible.\\n     * @dev function name is optimized for gas.\\n     */\\n    function mint_joo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) external returns (uint256 tokenId) {\\n        // CHECKS\\n        // minter is the project's minter\\n        require(\\n            msg.sender == _minterForProject[coreContract].get(projectId),\\n            \\\"Only assigned minter\\\"\\n        );\\n        // INTERACTIONS\\n        tokenId = IGenArt721CoreContractV3_Base(coreContract).mint_Ecf({\\n            _to: to,\\n            _projectId: projectId,\\n            _by: sender\\n        });\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Gets the assigned minter for project `projectId` on core\\n     * contract `coreContract`.\\n     * Reverts if project does not have an assigned minter.\\n     * @param projectId Project ID to query.\\n     * @param coreContract Core contract of project.\\n     * @return address Minter address assigned to project\\n     * @dev requires project to have an assigned minter\\n     * @dev this function intentionally does not check that the core contract\\n     * is registered, since it must have been registered at the time the\\n     * project was assigned a minter\\n     */\\n    function getMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (address) {\\n        // @dev use tryGet to control revert message if no minter assigned\\n        (bool hasMinter, address currentMinter) = _minterForProject[\\n            coreContract\\n        ].tryGet(projectId);\\n        require(hasMinter, \\\"No minter assigned\\\");\\n        return currentMinter;\\n    }\\n\\n    /**\\n     * @notice Queries if project `projectId` on core contract `coreContract`\\n     * has an assigned minter.\\n     * @param projectId Project ID to query.\\n     * @param coreContract Core contract of project.\\n     * @return bool true if project has an assigned minter, else false\\n     * @dev requires project to have an assigned minter\\n     * @dev this function intentionally does not check that the core contract\\n     * is registered, since it must have been registered at the time the\\n     * project was assigned a minter\\n     */\\n    function projectHasMinter(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool) {\\n        (bool hasMinter, ) = _minterForProject[coreContract].tryGet(projectId);\\n        return hasMinter;\\n    }\\n\\n    /**\\n     * @notice Gets quantity of projects on a given core contract that have\\n     * assigned minters.\\n     * @param coreContract Core contract to query.\\n     * @return uint256 quantity of projects that have assigned minters\\n     * @dev this function intentionally does not check that the core contract\\n     * is registered, since it must have been registered at the time the\\n     * project was assigned a minter\\n     */\\n    function getNumProjectsOnContractWithMinters(\\n        address coreContract\\n    ) external view returns (uint256) {\\n        return _minterForProject[coreContract].length();\\n    }\\n\\n    /**\\n     * @notice Get project ID and minter address at index `index` of\\n     * enumerable map.\\n     * @param coreContract Core contract to query.\\n     * @param index enumerable map index to query.\\n     * @return projectId project ID at index `index`\\n     * @return minterAddress minter address for project at index `index`\\n     * @return minterType minter type of minter at minterAddress\\n     * @dev index must be < quantity of projects that have assigned minters,\\n     * otherwise reverts\\n     * @dev reverts if minter does not implement minterType() function\\n     * @dev this function intentionally does not check that the core contract\\n     * is registered, since it must have been registered at the time the\\n     * project was assigned a minter\\n     */\\n    function getProjectAndMinterInfoOnContractAt(\\n        address coreContract,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 projectId,\\n            address minterAddress,\\n            string memory minterType\\n        )\\n    {\\n        // @dev at() reverts if index is out of bounds\\n        (projectId, minterAddress) = _minterForProject[coreContract].at(index);\\n        minterType = ISharedMinterV0(minterAddress).minterType();\\n    }\\n\\n    /**\\n     * @notice View that returns if a core contract is registered with the\\n     * core registry, allowing this minter filter to service it.\\n     * @param coreContract core contract address to be checked\\n     * @return bool true if core contract is registered, else false\\n     */\\n    function isRegisteredCoreContract(\\n        address coreContract\\n    ) external view override returns (bool) {\\n        return coreRegistry.isRegisteredContract(coreContract);\\n    }\\n\\n    /**\\n     * @notice Gets all projects on core contract `coreContract` that are\\n     * using minter `minter`.\\n     * Warning: Unbounded gas limit. This function is gas-intensive and should\\n     * only be used for off-chain queries. Alternatively, the subgraph indexing\\n     * layer may be used to query these values.\\n     * @param coreContract core contract to query\\n     * @param minter minter to query\\n     */\\n    function getProjectsOnContractUsingMinter(\\n        address coreContract,\\n        address minter\\n    ) external view returns (uint256[] memory projectIds) {\\n        EnumerableMap.UintToAddressMap storage minterMap = _minterForProject[\\n            coreContract\\n        ];\\n        // initialize arrays with maximum potential length\\n        // @dev use lesser of num projects using minter across all contracts\\n        // and number of projects on the contract with minters assigned, since\\n        // both values represent an upper bound on the number of projects that\\n        // could be using the minter on the contract\\n        uint256 maxNumProjects = Math.min(\\n            numProjectsUsingMinter[minter],\\n            minterMap.length()\\n        );\\n        projectIds = new uint256[](maxNumProjects);\\n        // iterate over all projects on contract, adding to array if using\\n        // `minter`\\n        uint256 numProjects = minterMap.length();\\n        uint256 numProjectsOnContractUsingMinter;\\n        for (uint256 i; i < numProjects; ) {\\n            (uint256 projectId, address minter_) = minterMap.at(i);\\n            unchecked {\\n                if (minter_ == minter) {\\n                    projectIds[numProjectsOnContractUsingMinter++] = projectId;\\n                }\\n                ++i;\\n            }\\n        }\\n        // trim array if necessary\\n        if (maxNumProjects > numProjectsOnContractUsingMinter) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(projectIds, numProjectsOnContractUsingMinter)\\n            }\\n        }\\n        return projectIds;\\n    }\\n\\n    /**\\n     * @notice Gets all minters that are globally approved on this minter\\n     * filter. Returns an array of MinterWithType structs, which contain the\\n     * minter address and minter type.\\n     * This function has unbounded gas, and should only be used for off-chain\\n     * queries.\\n     * Alternatively, the subgraph indexing layer may be used to query these\\n     * values.\\n     * @return mintersWithTypes Array of MinterWithType structs, which contain\\n     * the minter address and minter type.\\n     */\\n    function getAllGloballyApprovedMinters()\\n        external\\n        view\\n        returns (MinterWithType[] memory mintersWithTypes)\\n    {\\n        // initialize arrays with appropriate length\\n        uint256 numMinters = _globallyApprovedMinters.length();\\n        mintersWithTypes = new MinterWithType[](numMinters);\\n        // iterate over all globally approved minters, adding to array\\n        for (uint256 i; i < numMinters; ) {\\n            address minterAddress = _globallyApprovedMinters.at(i);\\n            // @dev we know minterType() does not revert, because it was called\\n            // when globally approving the minter\\n            string memory minterType = ISharedMinterV0(minterAddress)\\n                .minterType();\\n            mintersWithTypes[i] = MinterWithType({\\n                minterAddress: minterAddress,\\n                minterType: minterType\\n            });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets all minters that are approved for a specific core contract.\\n     * Returns an array of MinterWithType structs, which contain the minter\\n     * address and minter type.\\n     * This function has unbounded gas, and should only be used for off-chain\\n     * queries.\\n     * @param coreContract Core contract to query.\\n     * @return mintersWithTypes Array of MinterWithType structs, which contain\\n     * the minter address and minter type.\\n     */\\n    function getAllContractApprovedMinters(\\n        address coreContract\\n    ) external view returns (MinterWithType[] memory mintersWithTypes) {\\n        // initialize arrays with appropriate length\\n        EnumerableSet.AddressSet\\n            storage contractApprovedMinters = _contractApprovedMinters[\\n                coreContract\\n            ];\\n        uint256 numMinters = contractApprovedMinters.length();\\n        mintersWithTypes = new MinterWithType[](numMinters);\\n        // iterate over all minters approved for a given contract, adding to\\n        // array\\n        for (uint256 i; i < numMinters; ) {\\n            address minterAddress = contractApprovedMinters.at(i);\\n            // @dev we know minterType() does not revert, because it was called\\n            // when approving the minter for a contract\\n            string memory minterType = ISharedMinterV0(minterAddress)\\n                .minterType();\\n            mintersWithTypes[i] = MinterWithType({\\n                minterAddress: minterAddress,\\n                minterType: minterType\\n            });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Convenience function that returns whether `sender` is allowed\\n     * to call function with selector `selector` on contract `contract`, as\\n     * determined by this contract's current Admin ACL contract. Expected use\\n     * cases include minter contracts checking if caller is allowed to call\\n     * admin-gated functions on minter contracts.\\n     * @param sender Address of the sender calling function with selector\\n     * `selector` on contract `contract`.\\n     * @param contract_ Address of the contract being called by `sender`.\\n     * @param selector Function selector of the function being called by\\n     * `sender`.\\n     * @return bool Whether `sender` is allowed to call function with selector\\n     * `selector` on contract `contract`.\\n     * @dev assumes the Admin ACL contract is the owner of this contract, which\\n     * is expected to always be true.\\n     * @dev adminACLContract is expected to not be null address (owner cannot\\n     * renounce ownership on this contract), and conform to IAdminACLV0\\n     * interface.\\n     */\\n    function adminACLAllowed(\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) public returns (bool) {\\n        return\\n            adminACLContract.allowed({\\n                _sender: sender,\\n                _contract: contract_,\\n                _selector: selector\\n            });\\n    }\\n\\n    /**\\n     * @notice Returns whether `minter` is globally approved to mint tokens\\n     * on any contract.\\n     * @param minter Address of minter to check.\\n     */\\n    function isGloballyApprovedMinter(\\n        address minter\\n    ) public view returns (bool) {\\n        return _globallyApprovedMinters.contains(minter);\\n    }\\n\\n    /**\\n     * @notice Returns whether `minter` is approved to mint tokens on\\n     * core contract `coreContract`.\\n     * @param coreContract Address of core contract to check.\\n     * @param minter Address of minter to check.\\n     */\\n    function isApprovedMinterForContract(\\n        address coreContract,\\n        address minter\\n    ) public view returns (bool) {\\n        return\\n            isGloballyApprovedMinter(minter) ||\\n            _contractApprovedMinters[coreContract].contains(minter);\\n    }\\n\\n    /**\\n     * @notice Returns contract owner. Set to deployer's address by default on\\n     * contract deployment.\\n     * @return address Address of contract owner.\\n     * @dev ref: https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable\\n     * @dev owner role was called `admin` prior to V3 core contract\\n     */\\n    function owner()\\n        public\\n        view\\n        override(Ownable, IMinterFilterV1)\\n        returns (address)\\n    {\\n        return Ownable.owner();\\n    }\\n\\n    /// @dev override to prevent renouncing ownership\\n    /// @dev not permission gated since this immediately reverts\\n    function renounceOwnership() public pure override {\\n        revert(\\\"Cannot renounce ownership\\\");\\n    }\\n\\n    /**\\n     * @notice Updates project `projectId` to have no configured minter\\n     * Reverts if project does not already have an assigned minter.\\n     * @param projectId Project ID to remove minter.\\n     * @param coreContract Core contract of project.\\n     * @dev requires project to have an assigned minter\\n     * @dev this function intentionally does not check that the core contract\\n     * is registered, since it must have been registered at the time the\\n     * project was assigned a minter\\n     */\\n    function _removeMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        // remove minter for project and emit\\n        // @dev `minterForProject.get()` reverts tx if no minter set for project\\n        numProjectsUsingMinter[\\n            _minterForProject[coreContract].get(projectId, \\\"No minter assigned\\\")\\n        ]--;\\n        _minterForProject[coreContract].remove(projectId);\\n        emit ProjectMinterRemoved({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`owner`).\\n     * Internal function without access restriction.\\n     * @param owner_ New owner.\\n     * @dev owner role was called `admin` prior to V3 core contract.\\n     * @dev Overrides and wraps OpenZeppelin's _transferOwnership function to\\n     * also update adminACLContract for improved introspection.\\n     */\\n    function _transferOwnership(address owner_) internal override {\\n        Ownable._transferOwnership(owner_);\\n        adminACLContract = IAdminACLV0(owner_);\\n    }\\n\\n    /**\\n     * @notice Updates this contract's core registry contract to\\n     * `coreRegistry`.\\n     * @param coreRegistry_ New core registry contract address.\\n     */\\n    function _updateCoreRegistry(address coreRegistry_) internal {\\n        _onlyNonZeroAddress(coreRegistry_);\\n        coreRegistry = ICoreRegistryV1(coreRegistry_);\\n        emit CoreRegistryUpdated(coreRegistry_);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminACLContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coreRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adminACLContract\",\"type\":\"address\"}],\"name\":\"AdminACLUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreRegistry\",\"type\":\"address\"}],\"name\":\"CoreRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"name\":\"MinterApprovedForContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"name\":\"MinterApprovedGlobally\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"MinterRevokedForContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"MinterRevokedGlobally\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"name\":\"ProjectMinterRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"ProjectMinterRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"adminACLAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminACLContract\",\"outputs\":[{\"internalType\":\"contract IAdminACLV0\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"approveMinterForContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"approveMinterGlobally\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coreRegistry\",\"outputs\":[{\"internalType\":\"contract ICoreRegistryV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getAllContractApprovedMinters\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"internalType\":\"struct IMinterFilterV1.MinterWithType[]\",\"name\":\"mintersWithTypes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllGloballyApprovedMinters\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"internalType\":\"struct IMinterFilterV1.MinterWithType[]\",\"name\":\"mintersWithTypes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getMinterForProject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getNumProjectsOnContractWithMinters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getProjectAndMinterInfoOnContractAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"minterType\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"getProjectsOnContractUsingMinter\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"projectIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"isApprovedMinterForContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"isGloballyApprovedMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"isRegisteredCoreContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"mint_joo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"}],\"name\":\"numProjectsUsingMinter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numProjects\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectHasMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"removeMinterForProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"projectIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"removeMintersForProjectsOnContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"revokeMinterForContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"revokeMinterGlobally\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"setMinterForProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreRegistry_\",\"type\":\"address\"}],\"name\":\"updateCoreRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterFilterV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "000000000000000000000000fafda82cde1502c41e597e4656953533c16ca9940000000000000000000000002ee7b9bb2e038be7323a119701a191c030a61ec6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}