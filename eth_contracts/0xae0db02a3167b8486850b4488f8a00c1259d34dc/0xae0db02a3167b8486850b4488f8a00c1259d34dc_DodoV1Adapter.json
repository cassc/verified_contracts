{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AdapterModel.sol\": {\r\n      \"content\": \"\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\nimport \\\"./libraries/SafeERC20.sol\\\";\\r\\nimport \\\"./libraries/Ownable.sol\\\";\\r\\n\\r\\nabstract contract AdapterModel is Ownable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    event BrewlabsSwap(address indexed _tokenFrom, address indexed _tokenTo, uint256 _amountIn, uint256 _amountOut);\\r\\n    event UpdatedGasEstimate(address indexed _adapter, uint256 _newEstimate);\\r\\n    event Recovered(address indexed _asset, uint256 amount);\\r\\n\\r\\n    uint256 internal constant UINT_MAX = type(uint256).max;\\r\\n    uint256 public swapGasEstimate;\\r\\n    string public name;\\r\\n\\r\\n    constructor(string memory _name, uint256 _gasEstimate) {\\r\\n        setName(_name);\\r\\n        setSwapGasEstimate(_gasEstimate);\\r\\n    }\\r\\n\\r\\n    function setName(string memory _name) internal {\\r\\n        require(bytes(_name).length != 0, \\\"Invalid adapter name\\\");\\r\\n        name = _name;\\r\\n    }\\r\\n\\r\\n    function setSwapGasEstimate(uint256 _estimate) public onlyOwner {\\r\\n        require(_estimate != 0, \\\"Invalid gas-estimate\\\");\\r\\n        swapGasEstimate = _estimate;\\r\\n        emit UpdatedGasEstimate(address(this), _estimate);\\r\\n    }\\r\\n\\r\\n    function revokeAllowance(address _token, address _spender) external onlyOwner {\\r\\n        IERC20(_token).safeApprove(_spender, 0);\\r\\n    }\\r\\n\\r\\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\r\\n        require(_tokenAmount > 0, \\\"BrewlabsAdapter: Nothing to recover\\\");\\r\\n        IERC20(_tokenAddress).safeTransfer(msg.sender, _tokenAmount);\\r\\n        emit Recovered(_tokenAddress, _tokenAmount);\\r\\n    }\\r\\n\\r\\n    function recoverETH(uint256 _amount) external onlyOwner {\\r\\n        require(_amount > 0, \\\"BrewlabsAdapter: Nothing to recover\\\");\\r\\n        payable(msg.sender).transfer(_amount);\\r\\n        emit Recovered(address(0), _amount);\\r\\n    }\\r\\n\\r\\n    function query(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut\\r\\n    ) external view returns (uint256) {\\r\\n        return _query(_amountIn, _tokenIn, _tokenOut);\\r\\n    }\\r\\n\\r\\n    function swap(\\r\\n        uint256 _amountIn,\\r\\n        address _fromToken,\\r\\n        address _toToken,\\r\\n        address _to\\r\\n    ) external returns (uint256 _amountOut) {\\r\\n        uint256 toBal0 = IERC20(_toToken).balanceOf(_to);\\r\\n        _swap(_amountIn, _fromToken, _toToken, _to);\\r\\n        _amountOut = IERC20(_toToken).balanceOf(_to) - toBal0;\\r\\n        require(_amountOut > 0, 'AdapterModel: Insufficient amount out');\\r\\n        emit BrewlabsSwap(_fromToken, _toToken, _amountIn, _amountOut);\\r\\n    }\\r\\n\\r\\n    function _returnTo(\\r\\n        address _token,\\r\\n        uint256 _amount,\\r\\n        address _to\\r\\n    ) internal {\\r\\n        if (address(this) != _to) IERC20(_token).safeTransfer(_to, _amount);\\r\\n    }\\r\\n\\r\\n    function _swap(\\r\\n        uint256 _amountIn,\\r\\n        address _fromToken,\\r\\n        address _toToken,\\r\\n        address _to\\r\\n    ) internal virtual;\\r\\n\\r\\n    function _query(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut\\r\\n    ) internal view virtual returns (uint256);\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/adapters/DodoV1Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IDodoV1.sol\\\";\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../libraries/SafeERC20.sol\\\";\\r\\nimport \\\"../libraries/SafeMath.sol\\\";\\r\\nimport \\\"../AdapterModel.sol\\\";\\r\\n\\r\\ncontract DodoV1Adapter is AdapterModel {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    address public immutable HELPER;\\r\\n    mapping(address => mapping(address => address)) tknsToPool; // base > quote > pool\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        address[] memory _pools,\\r\\n        address _helper,\\r\\n        uint256 _gasEstimate\\r\\n    ) AdapterModel(_name, _gasEstimate) {\\r\\n        _setPools(_pools, true);\\r\\n        HELPER = _helper;\\r\\n    }\\r\\n\\r\\n    function setPools(address[] memory _pools, bool overwrite) external onlyOwner {\\r\\n        _setPools(_pools, overwrite);\\r\\n    }\\r\\n\\r\\n    function _rmPools(address[] memory _pools) external onlyOwner {\\r\\n        for (uint256 i; i < _pools.length; ++i) {\\r\\n            (address baseTkn, address quoteTkn) = _getTknsForPool(_pools[i]);\\r\\n            tknsToPool[baseTkn][quoteTkn] = address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setPools(address[] memory _pools, bool overwrite) internal {\\r\\n        for (uint256 i; i < _pools.length; ++i) _setPool(_pools[i], overwrite);\\r\\n    }\\r\\n\\r\\n    function _setPool(address _pool, bool overwrite) internal {\\r\\n        (address baseTkn, address quoteTkn) = _getTknsForPool(_pool);\\r\\n        if (!overwrite) _overwriteCheck(baseTkn, quoteTkn, _pool);\\r\\n        _approveTknsForPool(baseTkn, quoteTkn, _pool);\\r\\n        tknsToPool[baseTkn][quoteTkn] = _pool;\\r\\n    }\\r\\n\\r\\n    function _getTknsForPool(address _pool) internal view returns (address baseToken, address quoteToken) {\\r\\n        baseToken = IDodoV1(_pool)._BASE_TOKEN_();\\r\\n        quoteToken = IDodoV1(_pool)._QUOTE_TOKEN_();\\r\\n    }\\r\\n\\r\\n    function _overwriteCheck(\\r\\n        address baseTkn,\\r\\n        address quoteTkn,\\r\\n        address pool\\r\\n    ) internal view {\\r\\n        address existingPool = tknsToPool[baseTkn][quoteTkn];\\r\\n        require(existingPool == address(0) || existingPool == pool, \\\"Not allowed to overwrite\\\");\\r\\n    }\\r\\n\\r\\n    function _approveTknsForPool(\\r\\n        address _baseTkn,\\r\\n        address _quoteTkn,\\r\\n        address _pool\\r\\n    ) internal {\\r\\n        IERC20(_baseTkn).safeApprove(_pool, UINT_MAX);\\r\\n        IERC20(_quoteTkn).safeApprove(_pool, UINT_MAX);\\r\\n    }\\r\\n\\r\\n    function _query(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut\\r\\n    ) internal view override returns (uint256 amountOut) {\\r\\n        if (_amountIn == 0) return 0;\\r\\n        address pool = tknsToPool[_tokenIn][_tokenOut];\\r\\n        if (pool != address(0)) amountOut = IDodoV1(pool).querySellBaseToken(_amountIn);\\r\\n        pool = tknsToPool[_tokenOut][_tokenIn];\\r\\n        if (pool != address(0)) amountOut = IDodoHelper(HELPER).querySellQuoteToken(pool, _amountIn);\\r\\n    }\\r\\n\\r\\n    function _swap(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        address _to\\r\\n    ) internal override {\\r\\n        uint256 minMaxQuote = _query(_amountIn, _tokenIn, _tokenOut);\\r\\n        uint256 beforeBalance = IERC20(_tokenOut).balanceOf(address(this));\\r\\n        address pool = tknsToPool[_tokenIn][_tokenOut];\\r\\n        if (pool != address(0)) IDodoV1(pool).sellBaseToken(_amountIn, minMaxQuote, \\\"\\\");\\r\\n        pool = tknsToPool[_tokenOut][_tokenIn];\\r\\n        if (pool != address(0)) IDodoV1(pool).buyBaseToken(minMaxQuote, _amountIn, \\\"\\\");\\r\\n        uint256 amountOut = IERC20(_tokenOut).balanceOf(address(this)).sub(beforeBalance);\\r\\n        _returnTo(_tokenOut, amountOut, _to);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDodoV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IDodoHelper {\\r\\n    function querySellQuoteToken(address dodo, uint256 amount) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IDodoV1 {\\r\\n    function _QUOTE_TOKEN_() external view returns (address);\\r\\n\\r\\n    function _BASE_TOKEN_() external view returns (address);\\r\\n\\r\\n    function querySellBaseToken(uint256 amount) external view returns (uint256);\\r\\n\\r\\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256);\\r\\n\\r\\n    function sellBaseToken(\\r\\n        uint256 amount,\\r\\n        uint256 minReceiveQuote,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function buyBaseToken(\\r\\n        uint256 amount,\\r\\n        uint256 maxPayQuote,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address, address, uint256);\\r\\n    event Transfer(address, address, uint256);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function transferFrom(\\r\\n        address,\\r\\n        address,\\r\\n        uint256\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function allowance(address, address) external view returns (uint256);\\r\\n\\r\\n    function approve(address, uint256) external returns (bool);\\r\\n\\r\\n    function transfer(address, uint256) external returns (bool);\\r\\n\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n\\r\\n    function nonces(address) external view returns (uint256); // Only tokens that support permit\\r\\n\\r\\n    function permit(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        uint8,\\r\\n        bytes32,\\r\\n        bytes32\\r\\n    ) external; // Only tokens that support permit\\r\\n\\r\\n    function swap(address, uint256) external; // Only Avalanche bridge tokens\\r\\n\\r\\n    function swapSupply(address) external view returns (uint256); // Only Avalanche bridge tokens\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function withdraw(uint256 amount) external;\\r\\n\\r\\n    function deposit() external payable;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: New owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// This is a simplified version of OpenZepplin's SafeERC20 library\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_helper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"BrewlabsSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newEstimate\",\"type\":\"uint256\"}],\"name\":\"UpdatedGasEstimate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HELPER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"_rmPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"query\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"revokeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"overwrite\",\"type\":\"bool\"}],\"name\":\"setPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_estimate\",\"type\":\"uint256\"}],\"name\":\"setSwapGasEstimate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapGasEstimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DodoV1Adapter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000533da777aedce766ceae696bf90f8541a4ba80eb0000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000000000000000000000d446f646f563141646170746572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c9f93163c99695c6526b799ebca2207fdf7d61ad0000000000000000000000008876819535b48b551c9e97ebc07332c7482b4b2d00000000000000000000000075c23271661d9d143dcb617222bc4bec783eff340000000000000000000000002109f78b46a789125598f5ad2b7f243751c2934d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}