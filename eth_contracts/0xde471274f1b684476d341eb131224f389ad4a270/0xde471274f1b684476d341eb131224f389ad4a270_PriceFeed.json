{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\\n\\ncontract AxelarExecutable is IAxelarExecutable {\\n    IAxelarGateway public immutable gateway;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n\\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from './IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\\n\\n/**\\n * @title IAxelarGasService Interface\\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\\n * and refunds for cross-chain communication on the Axelar network.\\n * @dev This interface inherits IUpgradable\\n */\\ninterface IAxelarGasService is IUpgradable {\\n    error NothingReceived();\\n    error InvalidAddress();\\n    error NotCollector();\\n    error InvalidAmounts();\\n\\n    event GasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\\n\\n    event ExpressGasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeExpressGasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event Refunded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\\n     * @dev Use address(0) as the token address for native currency.\\n     * @param receiver The address to receive the collected fees\\n     * @param tokens Array of token addresses to be collected\\n     * @param amounts Array of amounts to be collected for each respective token address\\n     */\\n    function collectFees(\\n        address payable receiver,\\n        address[] calldata tokens,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\\n     * @dev Only callable by the gasCollector.\\n     * @dev Use address(0) as the token address to refund native currency.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param receiver The address to receive the refund\\n     * @param token The token address to be refunded\\n     * @param amount The amount to refund\\n     */\\n    function refund(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Returns the address of the designated gas collector.\\n     * @return address of the gas collector\\n     */\\n    function gasCollector() external returns (address);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IGovernable } from './IGovernable.sol';\\nimport { IImplementation } from './IImplementation.sol';\\n\\ninterface IAxelarGateway is IImplementation, IGovernable {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallExecuted(bytes32 indexed commandId);\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    /************************\\\\\\n    |* Governance Functions *|\\n    \\\\************************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IContractIdentifier {\\n    /**\\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\\n     * @dev Meant to be overridden in derived contracts.\\n     * @return bytes32 The contract ID\\n     */\\n    function contractId() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error InvalidAccount();\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IGovernable Interface\\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\\n */\\ninterface IGovernable {\\n    error NotGovernance();\\n    error NotMintLimiter();\\n    error InvalidGovernance();\\n    error InvalidMintLimiter();\\n\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /**\\n     * @notice Returns the governance address.\\n     * @return address of the governance\\n     */\\n    function governance() external view returns (address);\\n\\n    /**\\n     * @notice Returns the mint limiter address.\\n     * @return address of the mint limiter\\n     */\\n    function mintLimiter() external view returns (address);\\n\\n    /**\\n     * @notice Transfer the governance role to another address.\\n     * @param newGovernance The new governance address\\n     */\\n    function transferGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Transfer the mint limiter role to another address.\\n     * @param newGovernance The new mint limiter address\\n     */\\n    function transferMintLimiter(address newGovernance) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IContractIdentifier } from './IContractIdentifier.sol';\\n\\ninterface IImplementation is IContractIdentifier {\\n    error NotProxy();\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IOwnable Interface\\n * @notice IOwnable is an interface that abstracts the implementation of a\\n * contract with ownership control features. It's commonly used in upgradable\\n * contracts and includes the functionality to get current owner, transfer\\n * ownership, and propose and accept ownership.\\n */\\ninterface IOwnable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidOwnerAddress();\\n\\n    event OwnershipTransferStarted(address indexed newOwner);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return address The address of the current owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the pending owner of the contract.\\n     * @return address The address of the pending owner\\n     */\\n    function pendingOwner() external view returns (address);\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new address\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Proposes to transfer the contract's ownership to a new address.\\n     * The new owner needs to accept the ownership explicitly.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from './IOwnable.sol';\\nimport { IImplementation } from './IImplementation.sol';\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable is IOwnable, IImplementation {\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n\\n    event Upgraded(address indexed newImplementation);\\n\\n    function implementation() external view returns (address);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IImplementation } from '../interfaces/IImplementation.sol';\\n\\n/**\\n * @title Implementation\\n * @notice This contract serves as a base for other contracts and enforces a proxy-first access restriction.\\n * @dev Derived contracts must implement the setup function.\\n */\\nabstract contract Implementation is IImplementation {\\n    address private immutable implementationAddress;\\n\\n    /**\\n     * @dev Contract constructor that sets the implementation address to the address of this contract.\\n     */\\n    constructor() {\\n        implementationAddress = address(this);\\n    }\\n\\n    /**\\n     * @dev Modifier to require the caller to be the proxy contract.\\n     * Reverts if the caller is the current contract (i.e., the implementation contract itself).\\n     */\\n    modifier onlyProxy() {\\n        if (implementationAddress == address(this)) revert NotProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes contract parameters.\\n     * This function is intended to be overridden by derived contracts.\\n     * The overriding function must have the onlyProxy modifier.\\n     * @param params The parameters to be used for initialization\\n     */\\n    function setup(bytes calldata params) external virtual;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IImplementation } from '../interfaces/IImplementation.sol';\\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\\nimport { Ownable } from '../utils/Ownable.sol';\\nimport { Implementation } from './Implementation.sol';\\n\\n/**\\n * @title Upgradable Contract\\n * @notice This contract provides an interface for upgradable smart contracts and includes the functionality to perform upgrades.\\n */\\nabstract contract Upgradable is Ownable, Implementation, IUpgradable {\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice Constructor sets the implementation address to the address of the contract itself\\n     * @dev This is used in the onlyProxy modifier to prevent certain functions from being called directly\\n     * on the implementation contract itself.\\n     * @dev The owner is initially set as address(1) because the actual owner is set within the proxy. It is not\\n     * set as the zero address because Ownable is designed to throw an error for ownership transfers to the zero address.\\n     */\\n    constructor() Ownable(address(1)) {}\\n\\n    /**\\n     * @notice Returns the address of the current implementation\\n     * @return implementation_ Address of the current implementation\\n     */\\n    function implementation() public view returns (address implementation_) {\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Upgrades the contract to a new implementation\\n     * @param newImplementation The address of the new implementation contract\\n     * @param newImplementationCodeHash The codehash of the new implementation contract\\n     * @param params Optional setup parameters for the new implementation contract\\n     * @dev This function is only callable by the owner.\\n     */\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external override onlyOwner {\\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(implementation()).contractId())\\n            revert InvalidImplementation();\\n\\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\\n\\n        emit Upgraded(newImplementation);\\n\\n        if (params.length > 0) {\\n            // slither-disable-next-line controlled-delegatecall\\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\\n\\n            if (!success) revert SetupFailed();\\n        }\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets up the contract with initial data\\n     * @param data Initialization data for the contract\\n     * @dev This function is only callable by the proxy contract.\\n     */\\n    function setup(bytes calldata data) external override(IImplementation, Implementation) onlyProxy {\\n        _setup(data);\\n    }\\n\\n    /**\\n     * @notice Internal function to set up the contract with initial data\\n     * @param data Initialization data for the contract\\n     * @dev This function should be implemented in derived contracts.\\n     */\\n    function _setup(bytes calldata data) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from '../interfaces/IOwnable.sol';\\n\\n/**\\n * @title Ownable\\n * @notice A contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The owner account is set through ownership transfer. This module makes\\n * it possible to transfer the ownership of the contract to a new account in one\\n * step, as well as to an interim pending owner. In the second flow the ownership does not\\n * change until the pending owner accepts the ownership transfer.\\n */\\nabstract contract Ownable is IOwnable {\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n    // keccak256('ownership-transfer')\\n    bytes32 internal constant _OWNERSHIP_TRANSFER_SLOT =\\n        0x9855384122b55936fbfb8ca5120e63c6537a1ac40caf6ae33502b3c5da8c87d1;\\n\\n    /**\\n     * @notice Initializes the contract by transferring ownership to the owner parameter.\\n     * @param _owner Address to set as the initial owner of the contract\\n     */\\n    constructor(address _owner) {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Modifier that throws an error if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert NotOwner();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return owner_ The current owner of the contract\\n     */\\n    function owner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pending owner of the contract.\\n     * @return owner_ The pending owner of the contract\\n     */\\n    function pendingOwner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNERSHIP_TRANSFER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Propose to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner. The ownership does not change\\n     * until the new owner accepts the ownership transfer.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external virtual onlyOwner {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferStarted(newOwner);\\n\\n        assembly {\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, newOwner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts ownership of the contract.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external virtual {\\n        address newOwner = pendingOwner();\\n        if (newOwner != msg.sender) revert InvalidOwner();\\n\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Called in the constructor to set the initial owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferred(newOwner);\\n\\n        assembly {\\n            sstore(_OWNER_SLOT, newOwner)\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IOjo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./OjoTypes.sol\\\";\\n\\n/// @title Call a contract method using price data relayed from the Ojo Network.\\n/// @author Ojo Network (https://docs.ojo.network/)\\n/// @notice Prices are relayed from the Ojo Network to the Ojo contract using Axelar's General Message Passing.\\n/// @dev See ./MockOjoContract.sol for an example of implenting this interface to call a contract method using price\\n/// data fetched from an Ojo contract.\\ninterface IOjo {\\n    /// @dev Emmited when new prices are posted to the Ojo Contract (can only be triggered by Axelar's General Message\\n    /// Passer).\\n    /// @param timestamp Time of price data being posted.\\n    event PriceDataPosted(uint256 indexed timestamp);\\n\\n    /// @notice Triggers the relaying of price data from the Ojo Network to the Ojo contract and uses said price data\\n    /// when calling the specified contract method at the specified contract address.\\n    /// @dev Reverts if contract method call does not succeed.\\n    /// @param assetNames List of assets to be relayed from the Ojo Network and used by the contract method.\\n    /// @param contractAddress Address of contract containing the contract method to be called.\\n    /// @param commandSelector First four bytes of the Keccak-256 hash of the contract method to be called.\\n    /// @param commandParams Abi encoded parameters to be used when calling the contract method (excluding assetNames\\n    /// parameter).\\n    function callContractMethodWithOjoPriceData(\\n        bytes32[] calldata assetNames,\\n        address contractAddress,\\n        bytes4 commandSelector,\\n        bytes calldata commandParams\\n    ) external payable;\\n\\n    /// @notice Triggers the relaying of price data from the Ojo Network to the Ojo contract with an ERC-20 token for\\n    /// and uses said price data when calling the specified contract method at the specified contract address.\\n    /// @dev Reverts if contract method call does not succeed.\\n    /// @param assetNames List of assets to be relayed from the Ojo Network and used by the contract method.\\n    /// @param contractAddress Address of contract containing the contract method to be called.\\n    /// @param commandSelector First four bytes of the Keccak-256 hash of the contract method to be called.\\n    /// @param commandParams Abi encoded parameters to be used when calling the contract method (excluding assetNames\\n    /// parameter).\\n    /// @param symbol The symbol of the token to be sent with the call.\\n    /// @param amount The amount of tokens to be sent with the call.\\n    function callContractMethodWithOjoPriceDataAndToken(\\n        bytes32[] calldata assetNames,\\n        address contractAddress,\\n        bytes4 commandSelector,\\n        bytes calldata commandParams,\\n        string memory symbol,\\n        uint256 amount\\n    ) external payable;\\n\\n    /// @notice Returns the price data of a specified asset.\\n    /// @dev Price data is stored in a mapping, so requesting the price data of a non existent asset will return the\\n    /// zero byte representation of OjoTypes.PriceData.\\n    /// @return _priceData See ./OjoTypes.sol for a description of the PriceData object.\\n    function getPriceData(\\n        bytes32 assetName\\n    ) external view returns (OjoTypes.PriceData memory _priceData);\\n\\n    /// @notice Returns a list of price data of specified assets.\\n    /// @dev Price data is stored in a mapping, so requesting the price data of non existent asset will return the\\n    /// zero byte representation of OjoTypes.PriceData.\\n    /// @return _priceData See ./OjoTypes.sol for a description of the PriceData object.\\n    function getPriceDataBulk(\\n        bytes32[] calldata assetNames\\n    ) external view returns (OjoTypes.PriceData[] memory _priceData);\\n\\n    /// @notice Returns the price of a specified base and quote asset pair.\\n    /// @dev Reverts if quoteAssetName is not an existent asset pair to avoid a divide by 0 error.\\n    /// @dev USD is used with a price of 1 when calculating price of an asset pair with USD.\\n    /// @return _priceData OjoTypes.Price See ./OjoTypes.sol for a description of the Price object.\\n    function getPrice(\\n        bytes32 baseAssetName,\\n        bytes32 quoteAssetName\\n    ) external view returns (OjoTypes.Price memory _priceData);\\n}\\n\"\r\n    },\r\n    \"contracts/Ojo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\\\";\\nimport \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\\\";\\nimport \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\\\";\\nimport \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\\\";\\nimport \\\"./IOjo.sol\\\";\\nimport \\\"./OjoTypes.sol\\\";\\n\\ncontract Ojo is IOjo, AxelarExecutable, Upgradable {\\n    IAxelarGasService public immutable gasReceiver;\\n\\n    string public ojoChain;\\n\\n    string public ojoAddress;\\n\\n    uint256 public resolveWindow;\\n\\n    uint16 public assetLimit;\\n\\n    mapping(bytes32 => OjoTypes.PriceData) public priceData;\\n\\n    error AlreadyInitialized();\\n\\n    constructor(address gateway_, address gasReceiver_) AxelarExecutable(gateway_) {\\n        gasReceiver = IAxelarGasService(gasReceiver_);\\n    }\\n\\n    function callContractMethodWithOjoPriceData(\\n        bytes32[] calldata assetNames,\\n        address contractAddress,\\n        bytes4 commandSelector,\\n        bytes calldata commandParams\\n    ) external payable {\\n        require(assetNames.length <= assetLimit, \\\"Number of assets requested is over limit\\\");\\n\\n        bytes memory payloadWithVersion = abi.encodePacked(\\n            bytes4(uint32(0)), // version number\\n            abi.encode(assetNames, contractAddress, commandSelector, commandParams, block.timestamp) // payload\\n        );\\n\\n        gasReceiver.payNativeGasForContractCall{value: msg.value}(\\n            address(this),\\n            ojoChain,\\n            ojoAddress,\\n            payloadWithVersion,\\n            msg.sender\\n        );\\n\\n        gateway.callContract(ojoChain, ojoAddress, payloadWithVersion);\\n    }\\n\\n    function callContractMethodWithOjoPriceDataAndToken(\\n        bytes32[] calldata assetNames,\\n        address contractAddress,\\n        bytes4 commandSelector,\\n        bytes calldata commandParams,\\n        string memory symbol,\\n        uint256 amount\\n    ) external payable {\\n        require(assetNames.length <= assetLimit, \\\"Number of assets requested is over limit\\\");\\n\\n        address tokenAddress = gateway.tokenAddresses(symbol);\\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\\n        IERC20(tokenAddress).approve(address(gateway), amount);\\n\\n        bytes memory payloadWithVersion = abi.encodePacked(\\n            bytes4(uint32(0)), // version number\\n            abi.encode(assetNames, contractAddress, commandSelector, commandParams, block.timestamp) // payload\\n        );\\n\\n        gasReceiver.payNativeGasForContractCallWithToken{value: msg.value}(\\n            address(this),\\n            ojoChain,\\n            ojoAddress,\\n            payloadWithVersion,\\n            symbol,\\n            amount,\\n            msg.sender\\n        );\\n\\n        gateway.callContractWithToken(ojoChain, ojoAddress, payloadWithVersion, symbol, amount);\\n    }\\n\\n    function _setup(bytes calldata data) internal override {\\n        (string memory ojoChain_, string memory ojoAddress_, uint256 resolveWindow_, uint16 assetLimit_) = abi.decode(\\n            data,\\n            (string, string, uint256, uint16)\\n        );\\n        if (bytes(ojoChain).length != 0) revert AlreadyInitialized();\\n        if (bytes(ojoAddress).length != 0) revert AlreadyInitialized();\\n        if (resolveWindow != 0) revert AlreadyInitialized();\\n        if (assetLimit != 0) revert AlreadyInitialized();\\n        ojoChain = ojoChain_;\\n        ojoAddress = ojoAddress_;\\n        resolveWindow = resolveWindow_;\\n        assetLimit = assetLimit_;\\n    }\\n\\n    function _execute(\\n        string calldata,\\n        string calldata,\\n        bytes calldata payload\\n    ) internal override {\\n        (\\n            OjoTypes.PriceData[] memory _priceData,\\n            bytes32[] memory assetNames,\\n            address contractAddress,\\n            bytes4 commandSelector,\\n            bytes memory commandParams\\n        ) = abi.decode(\\n            payload,\\n            (OjoTypes.PriceData[], bytes32[], address, bytes4, bytes)\\n        );\\n\\n        postPriceData(_priceData);\\n\\n        // Call contract only if command selector is non empty\\n        if (commandSelector != OjoTypes.EMPTY_COMMAND_SELECTOR) {\\n            (bool success, bytes memory result) = contractAddress.call(\\n                abi.encodeWithSelector(commandSelector, assetNames, commandParams)\\n            );\\n\\n            if (!success) {\\n                if (result.length == 0) {\\n                    require(success, 'Failed with no reason');\\n                } else {\\n                    // rethrow same error\\n                    assembly {\\n                        let start := add(result, 0x20)\\n                        let end := add(result, mload(result))\\n                        revert(start, end)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function postPriceData(OjoTypes.PriceData[] memory _priceData) internal {\\n        for(uint256 i = 0; i < _priceData.length; i++){\\n            if (_priceData[i].resolveTime + resolveWindow > block.timestamp) {\\n                priceData[_priceData[i].assetName] = _priceData[i];\\n            }\\n        }\\n\\n        emit PriceDataPosted(block.timestamp);\\n    }\\n\\n    function getPriceData(\\n        bytes32 assetName\\n    ) external view returns (OjoTypes.PriceData memory) {\\n        return priceData[assetName];\\n    }\\n\\n    function getPriceDataBulk(\\n        bytes32[] calldata assetNames\\n    ) external view returns (OjoTypes.PriceData[] memory _priceData) {\\n        _priceData = new OjoTypes.PriceData[](assetNames.length);\\n        for (uint256 i = 0; i < assetNames.length; i++) {\\n            _priceData[i] = priceData[assetNames[i]];\\n        }\\n\\n        return _priceData;\\n    }\\n\\n    function getPrice(\\n        bytes32 baseAssetName,\\n        bytes32 quoteAssetName\\n    ) external view returns (OjoTypes.Price memory) {\\n        (uint256 basePrice, uint256 baseResolveTime)\\n            = getPriceValueAndResolveTime(baseAssetName);\\n        (uint256 quotePrice, uint256 quoteResolveTime)\\n            = getPriceValueAndResolveTime(quoteAssetName);\\n\\n        require(quotePrice > 0, \\\"Quote price is 0\\\");\\n\\n        uint256 price = (basePrice * 10**18) / quotePrice;\\n\\n        return OjoTypes.Price({\\n            price: price,\\n            baseResolveTime: baseResolveTime,\\n            quoteResolveTime: quoteResolveTime\\n        });\\n    }\\n\\n    function getPriceValueAndResolveTime(\\n        bytes32 assetName\\n    ) internal view returns (uint256, uint256) {\\n        if (assetName == OjoTypes.USD) {\\n            return (OjoTypes.USD_PRICE, 0);\\n        }\\n\\n        return (priceData[assetName].price, priceData[assetName].resolveTime);\\n    }\\n\\n    function updateOjoChain(string calldata ojoChain_) external onlyOwner {\\n        ojoChain = ojoChain_;\\n    }\\n\\n    function updateOjoAddress(string calldata ojoAddress_) external onlyOwner {\\n        ojoAddress = ojoAddress_;\\n    }\\n\\n    function updateResolveWindow(uint256 resolveWindow_) external onlyOwner {\\n        resolveWindow = resolveWindow_;\\n    }\\n\\n    function updateAssetLimit(uint8 assetLimit_) external onlyOwner {\\n        assetLimit = assetLimit_;\\n    }\\n\\n    function contractId() external pure returns (bytes32) {\\n        return keccak256('ojo-v1');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OjoTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary OjoTypes {\\n    bytes32 constant USD = bytes32(\\\"USD\\\");\\n    uint256 constant USD_PRICE= 10**9;\\n\\n    bytes4 constant EMPTY_COMMAND_SELECTOR = bytes4(keccak256(bytes(\\\"\\\")));\\n\\n    struct PriceData {\\n        // Name of asset ex: ATOM\\n        bytes32 assetName;\\n        // Price in of asset in USD\\n        uint256 price;\\n        // Time request was sent to ojo for price data\\n        uint256 resolveTime;\\n        // Median data of asset\\n        MedianData medianData;\\n    }\\n\\n    struct MedianData {\\n        // Ojo block numbers medians were stamped on\\n        uint256[] blockNums;\\n        // Median prices\\n        uint256[] medians;\\n        // Standard deviatoins of median prices\\n        uint256[] deviations;\\n    }\\n\\n    struct Price {\\n        // Price of asset pair\\n        uint256 price;\\n        // Base asset resolve time of asset pair\\n        uint256 baseResolveTime;\\n        // Quote asset resolve time of asset pair\\n        uint256 quoteResolveTime;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pricefeed/CloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./PriceFeed.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/// @title Factory for creating PriceFeed contract clones.\\n/// @notice This contract will create a PriceFeed clone and map its address to the clone creator.\\n/// @dev Cloning is done with OpenZeppelin's Clones contract.\\ncontract CloneFactory {\\n    event PriceFeedCloneCreated(\\n        address _priceFeedCloneAddress\\n    );\\n\\n    mapping (address => address) public PriceFeedCloneAddresses;\\n    address public implementationAddress;\\n\\n    /// @param _implementationAddress Address of implementation contract to be cloned.\\n    constructor(address _implementationAddress) {\\n        implementationAddress = _implementationAddress;\\n    }\\n\\n    /// @notice Create clone of PriceFeed contract and initialize it.\\n    /// @dev Clone method returns address of created clone.\\n    /// @param _priceFeedDecimals Amount of decimals a PriceFeed is denominiated in.\\n    /// @param _priceFeedDescription Description of PriceFeed, should be set to asset symbol ticker.\\n    function createPriceFeed(uint8 _priceFeedDecimals, string calldata _priceFeedDescription) external {\\n        address priceFeedCloneAddress = Clones.clone(implementationAddress);\\n        PriceFeed(priceFeedCloneAddress).initialize(_priceFeedDecimals, _priceFeedDescription);\\n        PriceFeedCloneAddresses[msg.sender] = priceFeedCloneAddress;\\n        emit PriceFeedCloneCreated(priceFeedCloneAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pricefeed/PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../IOjo.sol\\\";\\nimport \\\"../OjoTypes.sol\\\";\\n\\n/// @title Contract for calling Ojo's oracle contract with chainlink's AggregatorV3Interface implemented.\\n/// @author Ojo Network (https://docs.ojo.network/)\\ncontract PriceFeed is Initializable, AggregatorV3Interface {\\n    uint8 private priceFeedDecimals;\\n\\n    string private priceFeedDescription;\\n\\n    IOjo public immutable ojo;\\n\\n    uint80 constant DEFAULT_ROUND = 1;\\n\\n    uint256 constant DEFAULT_VERSION = 1;\\n\\n    uint256 internal constant INT256_MAX = uint256(type(int256).max);\\n\\n    error GetRoundDataCanBeOnlyCalledWithLatestRound(uint80 requestedRoundId);\\n\\n    error UnsafeUintToIntConversion(uint256 value);\\n\\n    constructor(address ojo_) {\\n        ojo = IOjo(ojo_);\\n    }\\n\\n    /// @notice Initialize clone of this contract.\\n    /// @dev This function is used in place of a constructor in proxy contracts.\\n    /// @param _priceFeedDecimals Amount of decimals a PriceFeed is denominiated in.\\n    /// @param _priceFeedDescription Description of PriceFeed.\\n    function initialize(uint8 _priceFeedDecimals, string calldata _priceFeedDescription)\\n        external\\n        initializer {\\n        priceFeedDecimals = _priceFeedDecimals;\\n        priceFeedDescription = _priceFeedDescription;\\n    }\\n\\n    /// @notice Amount of decimals price is denominated in.\\n    function decimals() external view returns (uint8) {\\n        return priceFeedDecimals;\\n    }\\n\\n    /// @notice Asset that this proxy is tracking.\\n    /// @dev This should be set as the asset symbol ticker as it used to query the Ojo contract.\\n    function description() external view returns (string memory) {\\n        return priceFeedDescription;\\n    }\\n\\n    /// @notice Version always returns 1.\\n    function version() external view returns (uint256) {\\n        return DEFAULT_VERSION;\\n    }\\n\\n    /// @dev Latest round always returns 1 since this contract does not support rounds.\\n    function latestRound() public pure returns (uint80) {\\n        return DEFAULT_ROUND;\\n    }\\n\\n    /// @notice Fetches price data from Ojo contract from a specified round.\\n    /// @dev Even though rounds are not utilized in this contract getRoundData is implemented for contracts\\n    /// that still rely on it. Function will revert if specified round is not the latest round.\\n    /// @return roundId Round ID of price data, this is always set to 1.\\n    /// @return answer Price in USD of asset this contract is tracking.\\n    /// @return startedAt Timestamp relating to price update.\\n    /// @return updatedAt Timestamp relating to price update.\\n    /// @return answeredInRound Equal to round ID.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n        ) {\\n        if (_roundId != latestRound()) {\\n            revert GetRoundDataCanBeOnlyCalledWithLatestRound(_roundId);\\n        }\\n        return latestRoundData();\\n    }\\n\\n    /// @notice Fetches latest price data from Ojo contract.\\n    /// @return roundId Round ID of price data, this is always set to 1.\\n    /// @return answer Price in USD of asset this contract is tracking.\\n    /// @return startedAt Timestamp relating to price update.\\n    /// @return updatedAt Timestamp relating to price update.\\n    /// @return answeredInRound Equal to round ID.\\n    function latestRoundData()\\n        public\\n        view\\n        returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n        ) {\\n        roundId = latestRound();\\n        bytes32 assetName = bytes32(bytes(priceFeedDescription));\\n\\n        OjoTypes.PriceData memory priceData = ojo.getPriceData(assetName);\\n\\n        if (priceData.price > INT256_MAX) {\\n            revert UnsafeUintToIntConversion(priceData.price);\\n        }\\n\\n        // These values are equal after chainlink\u2019s OCR update\\n        startedAt = priceData.resolveTime;\\n        updatedAt = priceData.resolveTime;\\n\\n        // roundId is always equal to answeredInRound\\n        answeredInRound = roundId;\\n\\n        return (\\n            roundId,\\n            int256(priceData.price),\\n            startedAt,\\n            updatedAt,\\n            answeredInRound\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ojo_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"requestedRoundId\",\"type\":\"uint80\"}],\"name\":\"GetRoundDataCanBeOnlyCalledWithLatestRound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UnsafeUintToIntConversion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_priceFeedDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_priceFeedDescription\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ojo\",\"outputs\":[{\"internalType\":\"contract IOjo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PriceFeed", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000005bb3e85f91d08fe92a3d123ee35050b763d6e6a7", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a94425e3421539e8adaa3850dd288e087d1e7db7f2ace4b9fe2bceee3f1be0cf"}