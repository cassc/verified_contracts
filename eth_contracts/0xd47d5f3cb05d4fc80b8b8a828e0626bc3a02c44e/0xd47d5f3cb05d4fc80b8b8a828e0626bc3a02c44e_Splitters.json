{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/libraries/Splitters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nimport {PaymentConfig} from \\\"../Types.sol\\\";\\nimport {IAlbaDelegate} from \\\"../IAlbaDelegate.sol\\\";\\nimport {IPaymentSplitter} from \\\"../IPaymentSplitter.sol\\\";\\n\\nlibrary Splitters {\\n    error InvalidConfiguration();\\n\\n    /**\\n     * Setup the sales splitters.\\n     * @dev We expect an array of length 1 for a single user (if there's no Alba fee). This is less efficient\\n     * than just using the artist's address rather than a splitter, but it provides consistent UX for claiming.\\n     */\\n\\n    function setupPaymentSplitters(PaymentConfig calldata conf, IAlbaDelegate albaDelegate)\\n        public\\n        returns (IPaymentSplitter, IPaymentSplitter)\\n    {\\n        if (conf.primaryPayees.length == 0 || conf.primaryPayees.length != conf.primaryShareBasisPoints.length) {\\n            revert InvalidConfiguration();\\n        }\\n        IPaymentSplitter paymentSplitter;\\n        IPaymentSplitter paymentSplitterRoyalties;\\n\\n        address primary = albaDelegate.paymentSplitterFactory().deploy(conf.primaryPayees, conf.primaryShareBasisPoints);\\n        paymentSplitter = IPaymentSplitter(primary);\\n\\n        // Only deploy a contract for secondary payments if there are secondary payees.\\n        if (conf.secondaryPayees.length > 0) {\\n            if (conf.secondaryPayees.length != conf.secondaryShareBasisPoints.length) {\\n                revert InvalidConfiguration();\\n            }\\n\\n            address secondary =\\n                albaDelegate.paymentSplitterFactory().deploy(conf.secondaryPayees, conf.secondaryShareBasisPoints);\\n            paymentSplitterRoyalties = IPaymentSplitter(secondary);\\n        }\\n\\n        return (paymentSplitter, paymentSplitterRoyalties);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nstruct CollectionConfig {\\n    bytes16 uuid;\\n    string name;\\n    string token;\\n    string slug;\\n    bytes16[] dependencies;\\n    string[] metadataKeys;\\n    string[] metadataValues;\\n}\\n\\nenum SaleType {\\n    FixedPrice,\\n    DeprecatedReserved,\\n    ExponentialDutchAuction,\\n    FixedPriceTimeLimited\\n}\\n\\nstruct SaleConfig {\\n    SaleType saleType; // uint8 for packing\\n    uint32 maxSalePieces; // Maximum number of pieces to sell (including reserves)\\n    uint32 numReserved; // Number of pieces to reserve for specific wallets\\n    uint16 numRetained; // Number of pieces to retain for the artist\\n    uint16 numAlba; // Number of pieces to retain for Alba\\n    uint40 startTime; // Sale start time\\n    uint40 auctionEndTime; // Sale doesn't stop here, but price decay stops. Needed for rebate if non-sellout.\\n    bool hasRebate; // Whether or not to give a rebate to resting price\\n    uint256 initialPrice; // Starting price for Dutch Auction\\n    uint256 finalPrice; // Ending price for Dutch Auction\\n}\\n\\nstruct PaymentConfig {\\n    address[] primaryPayees; // Addresses for primary payment.\\n    uint256[] primaryShareBasisPoints; // Share of primary sales for each address (basis points).\\n    address[] secondaryPayees; // Addresses for secondary payment.\\n    uint256[] secondaryShareBasisPoints; // Share of secondary sales for each address (basis points).\\n    uint16 royaltyBasisPoints; // Total royalty basis points.\\n}\\n\\nstruct StoredScript {\\n    string fileName;\\n    uint256 wrappedLength;\\n}\\n\"\r\n    },\r\n    \"src/IAlbaDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IPaymentSplitterFactory} from \\\"ethier/factories/IPaymentSplitterFactory.sol\\\";\\n\\ninterface IAlbaDelegate {\\n    function tokenURI(uint256 tokenId, string memory slug) external view returns (string memory);\\n\\n    function verifyMintReserve(bytes32 message, bytes calldata signature) external view;\\n\\n    function verifyMint(bytes16 collectionId, address user, uint16 num, uint32 nonce, bytes calldata signature)\\n        external\\n        view;\\n\\n    function tokenHTML(bytes16 uuid, uint256 tokenId, bytes32 seed, bytes16[] memory deps)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    function paymentSplitterFactory() external view returns (IPaymentSplitterFactory);\\n\\n    function operatorFilterSubscription() external view returns (address);\\n\\n    function getAlbaFeeReceiver() external view returns (address);\\n\\n    function getMinSaleStartBuffer() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/IPaymentSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPaymentSplitter {\\n    function releasable(address account) external view returns (uint256);\\n    function releasable(IERC20 token, address account) external view returns (uint256);\\n\\n    function release(address payable account) external;\\n    function release(IERC20 token, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/ethier/contracts/factories/IPaymentSplitterFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IPaymentSplitterFactory {\\n    /// @notice Deploys a minimal contract proxy to a PaymentSplitter.\\n    function deploy(address[] memory payees, uint256[] memory shares)\\n        external\\n        returns (address);\\n\\n    /**\\n    @notice Deploys a minimal contract proxy to a PaymentSplitter, at a\\n    deterministic address.\\n    @dev Use predictDeploymentAddress() with the same salt to predit the address\\n    before calling deployDeterministic(). See OpenZeppelin's proxy/Clones.sol\\n    for details and caveats, primarily that this will revert if a salt is\\n    reused.\\n     */\\n    function deployDeterministic(\\n        bytes32 salt,\\n        address[] memory payees,\\n        uint256[] memory shares\\n    ) external returns (address);\\n\\n    /**\\n    @notice Returns the address at which a new PaymentSplitter will be deployed\\n    if using the same salt as passed to this function.\\n     */\\n    function predictDeploymentAddress(bytes32 salt)\\n        external\\n        view\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ethier/=lib/ethier/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidConfiguration\",\"type\":\"error\"}]", "ContractName": "Splitters", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}