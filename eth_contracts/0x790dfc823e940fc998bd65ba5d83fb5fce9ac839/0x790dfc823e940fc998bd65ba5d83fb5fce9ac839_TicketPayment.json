{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IMOSV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IMOSV3 {\\r\\n\\r\\n    enum ChainType{\\r\\n        NULL,\\r\\n        EVM,\\r\\n        NEAR\\r\\n    }\\r\\n\\r\\n    enum MessageType {\\r\\n        CALLDATA,\\r\\n        MESSAGE\\r\\n    }\\r\\n\\r\\n    // @notice This is the configuration you need across the chain.\\r\\n    // @param relay - When it is true, the relay chain is required to perform a special execution to continue across the chain.\\r\\n    // @param msgType - Different execution patterns of messages across chains.\\r\\n    // @param target - The contract address of the target chain.\\r\\n    // @param payload - Cross-chain content.\\r\\n    // @param gasLimit - The gasLimit allowed to be consumed by an operation performed on the target chain.\\r\\n    // @param value - Collateral value cross-chain, currently not supported, default is 0.\\r\\n    struct MessageData {\\r\\n        bool relay;\\r\\n        MessageType msgType;\\r\\n        bytes target;\\r\\n        bytes payload;\\r\\n        uint256 gasLimit;\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    // @notice Gets the fee to cross to the target chain.\\r\\n    // @param toChain - Target chain chainID.\\r\\n    // @param feeToken - Token address that supports payment fee,if it's native, it's address(0).\\r\\n    // @param gasLimit - The gasLimit allowed to be consumed by an operation performed on the target chain.\\r\\n    function getMessageFee(uint256 toChain, address feeToken, uint256 gasLimit) external view returns(uint256, address);\\r\\n\\r\\n\\r\\n    // @notice Initiate cross-chain transactions. Generate cross-chain logs.\\r\\n    // @param toChain - Target chain chainID.\\r\\n    // @param messageData - Structure MessageData encoding.\\r\\n    // @param feeToken - In what Token would you like to pay the fee.\\r\\n    function transferOut(uint256 toChain, bytes memory messageData, address feeToken) external payable  returns(bytes32);\\r\\n\\r\\n\\r\\n    // @notice Add the fromaddress permission.\\r\\n    // @param fromChain - The chainID of the source chain.\\r\\n    // @param fromAddress - The call address of the source chain.\\r\\n    // @param tag - Permission,false: revoke permission.\\r\\n    function addRemoteCaller(uint256 fromChain, bytes memory fromAddress, bool tag) external;\\r\\n\\r\\n    // @notice Query whether the contract has execution permission.\\r\\n    // @param mosAddress - This is the mos query address.\\r\\n    // @param fromChainId - The call chain id of the source chain.\\r\\n    // @param fromAddress - The call address of the source chain.\\r\\n    function getExecutePermission(address mosAddress,uint256 fromChainId,bytes memory fromAddress) external view returns(bool);\\r\\n\\r\\n    event mapMessageOut(uint256 indexed fromChain, uint256 indexed toChain, bytes32 orderId, bytes fromAddrss, bytes callData);\\r\\n\\r\\n    event mapMessageIn(uint256 indexed fromChain, uint256 indexed toChain, bytes32 orderId, bytes fromAddrss, bytes callData, bool result, bytes reason);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/TicketPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\r\\nimport \\\"./IMOSV3.sol\\\";\\r\\n\\r\\ncontract TicketPayment is Ownable {\\r\\n    uint256 public cumulativeResult;\\r\\n    address public treasuryAddress;\\r\\n    // id 1 -> revenueShareAddress A + treasuryAddress\\r\\n    // id 2 -> revenueShareAddress B + treasuryAddress\\r\\n    // id 1 -> revenue * revenuePercentage to treasuryAddress\\r\\n    // id 2 -> revenue * revenuePercentage to treasuryAddress\\r\\n    mapping(uint256 => address) public revenueAddress;\\r\\n    mapping(uint256 => uint256) public percentageOverride;\\r\\n    mapping(uint256 => bool) public pauseMint;\\r\\n    mapping(address => bool) public contractOperator;\\r\\n\\r\\n    IMOSV3 public mos;\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    constructor(address _treasuryAddress, address _mos, address _priceFeed) {\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n        mos = IMOSV3(_mos);\\r\\n        priceFeed = AggregatorV3Interface(_priceFeed);\\r\\n    }\\r\\n\\r\\n    function setupRevenue(\\r\\n        uint256 _id,\\r\\n        address _revenueAddress,\\r\\n        uint256 _percentageOverride\\r\\n    ) public onlyOwner {\\r\\n        revenueAddress[_id] = _revenueAddress;\\r\\n        percentageOverride[_id] = _percentageOverride;\\r\\n    }\\r\\n\\r\\n    function crossChainMint(\\r\\n        address _receiveAddress,\\r\\n        uint256 _id,\\r\\n        uint256 _quantity,\\r\\n        int _amount_USD_8DP\\r\\n    ) external {}\\r\\n\\r\\n    function _getMessageData(\\r\\n        address _receiveAddress,\\r\\n        uint256 _id,\\r\\n        uint256 _quantity,\\r\\n        int _amount_USD_8DP,\\r\\n        address _targetAddress\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        bytes memory messageByte;\\r\\n\\r\\n        bytes memory payload = abi.encodeWithSelector(\\r\\n            TicketPayment.crossChainMint.selector,\\r\\n            _receiveAddress,\\r\\n            _id,\\r\\n            _quantity,\\r\\n            _amount_USD_8DP\\r\\n        );\\r\\n        bytes memory _target = abi.encodePacked(_targetAddress);\\r\\n        IMOSV3.MessageData memory messageData = IMOSV3.MessageData(\\r\\n            false,\\r\\n            IMOSV3.MessageType.CALLDATA,\\r\\n            _target,\\r\\n            payload,\\r\\n            500000,\\r\\n            0\\r\\n        );\\r\\n\\r\\n        messageByte = abi.encode(messageData);\\r\\n\\r\\n        return messageByte;\\r\\n    }\\r\\n\\r\\n    function getTransferOutFee(\\r\\n        uint256 _toChainId\\r\\n    ) public view returns (uint256) {\\r\\n        (uint256 amount, ) = mos.getMessageFee(_toChainId, address(0), 500000);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function sendCrossChainMint(\\r\\n        uint256 _toChainId,\\r\\n        address _targetAddress,\\r\\n        address _receiveAddress,\\r\\n        uint256 _id,\\r\\n        uint256 _quantity,\\r\\n        uint256 _data\\r\\n    ) external payable returns (bytes32) {\\r\\n        require(!pauseMint[_id]);\\r\\n        uint256 fee = getTransferOutFee(_toChainId);\\r\\n        uint256 _amount = msg.value - fee;\\r\\n        int _amount_USD_8DP = ((int)(_amount) * getLatestPrice()) / 1e18;\\r\\n\\r\\n        uint256 _percentage = percentageOverride[_id];\\r\\n        uint256 _toTreasuryAmount = (_amount * _percentage) / 100;\\r\\n        uint256 _toRevenueAmount = _amount - _toTreasuryAmount;\\r\\n\\r\\n        address _revenueAddress = revenueAddress[_id] == address(0)\\r\\n            ? treasuryAddress\\r\\n            : revenueAddress[_id];\\r\\n\\r\\n        (bool success, ) = payable(treasuryAddress).call{\\r\\n            value: _toTreasuryAmount\\r\\n        }(\\\"\\\");\\r\\n        require(success, \\\"Failed to send revenue\\\");\\r\\n\\r\\n        (success, ) = payable(_revenueAddress).call{value: _toRevenueAmount}(\\r\\n            \\\"\\\"\\r\\n        );\\r\\n        require(success, \\\"Failed to send revenue\\\");\\r\\n\\r\\n        bytes memory messageData = _getMessageData(\\r\\n            _receiveAddress,\\r\\n            _id,\\r\\n            _quantity,\\r\\n            _amount_USD_8DP,\\r\\n            _targetAddress\\r\\n        );\\r\\n\\r\\n        bytes32 orderId = mos.transferOut{value: fee}(\\r\\n            _toChainId,\\r\\n            messageData,\\r\\n            address(0)\\r\\n        );\\r\\n\\r\\n        return orderId;\\r\\n    }\\r\\n\\r\\n    function setPauseMint(uint256 _id, bool _pauseMint) public {\\r\\n        require(contractOperator[msg.sender] == true || msg.sender == owner());\\r\\n        pauseMint[_id] = _pauseMint;\\r\\n    }\\r\\n\\r\\n    function setTreasuryAddress(address _treasuryAddress) public onlyOwner {\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n    }\\r\\n\\r\\n    function setContractOperator(\\r\\n        address _address,\\r\\n        bool _bool\\r\\n    ) public onlyOwner {\\r\\n        contractOperator[_address] = _bool;\\r\\n    }\\r\\n\\r\\n    function setMOSAddress(address _mosAddress) public onlyOwner {\\r\\n        mos = IMOSV3(_mosAddress);\\r\\n    }\\r\\n\\r\\n    function setPriceFeed(address _priceFeed) public onlyOwner {\\r\\n        priceFeed = AggregatorV3Interface(_priceFeed);\\r\\n    }\\r\\n\\r\\n    function getLatestPrice() public view returns (int) {\\r\\n        (, int _price, , , ) = priceFeed.latestRoundData();\\r\\n        return _price;\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 _amount) public onlyOwner {\\r\\n        require(_amount <= address(this).balance, \\\"Insufficient balance\\\");\\r\\n        payable(msg.sender).transfer(_amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mos\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiveAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_amount_USD_8DP\",\"type\":\"int256\"}],\"name\":\"crossChainMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumulativeResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"}],\"name\":\"getTransferOutFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mos\",\"outputs\":[{\"internalType\":\"contract IMOSV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauseMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percentageOverride\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revenueAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiveAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_data\",\"type\":\"uint256\"}],\"name\":\"sendCrossChainMint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setContractOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mosAddress\",\"type\":\"address\"}],\"name\":\"setMOSAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_pauseMint\",\"type\":\"bool\"}],\"name\":\"setPauseMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"setTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_revenueAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentageOverride\",\"type\":\"uint256\"}],\"name\":\"setupRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TicketPayment", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000ee41b36ed202dffb9a60b120c4467b093540a720000000000000000000000008c3ccc219721b206da4a2070fd96e4911a48cb4f0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}