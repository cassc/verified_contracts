{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Verifier16.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >= 0.8.0;\\n\\nlibrary Pairing {\\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    /*\\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero\\n     */\\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n        // The prime q in the base field F_q for G1\\n        if (p.X == 0 && p.Y == 0) {\\n            return G1Point(0, 0);\\n        } else {\\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\\n        }\\n    }\\n\\n    /*\\n     * @return r the sum of two points of G1\\n     */\\n    function plus(\\n        G1Point memory p1,\\n        G1Point memory p2\\n    ) internal view returns (G1Point memory r) {\\n        uint256[4] memory input = [\\n            p1.X, p1.Y,\\n            p2.X, p2.Y\\n        ];\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-add-failed\\\");\\n    }\\n\\n    /*\\n     * @return r the product of a point on G1 and a scalar, i.e.\\n     *         p == p.scalarMul(1) and p.plus(p) == p.scalarMul(2) for all\\n     *         points p.\\n     */\\n    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n        uint256[3] memory input = [p.X, p.Y, s];\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-mul-failed\\\");\\n    }\\n\\n    /* @return The result of computing the pairing check\\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\\n     *         For example,\\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\\n     */\\n    function pairing(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2,\\n        G1Point memory c1,\\n        G2Point memory c2,\\n        G1Point memory d1,\\n        G2Point memory d2\\n    ) internal view returns (bool) {\\n        uint256[24] memory input = [\\n            a1.X, a1.Y, a2.X[0], a2.X[1], a2.Y[0], a2.Y[1],\\n            b1.X, b1.Y, b2.X[0], b2.X[1], b2.Y[0], b2.Y[1],\\n            c1.X, c1.Y, c2.X[0], c2.X[1], c2.Y[0], c2.Y[1],\\n            d1.X, d1.Y, d2.X[0], d2.X[1], d2.Y[0], d2.Y[1]\\n        ];\\n        uint256[1] memory out;\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 8, input, mul(24, 0x20), out, 0x20)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-opcode-failed\\\");\\n        return out[0] != 0;\\n    }\\n}\\n\\ncontract Verifier16 {\\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    using Pairing for *;\\n\\n    struct VerifyingKey {\\n        Pairing.G1Point alfa1;\\n        Pairing.G2Point beta2;\\n        Pairing.G2Point gamma2;\\n        Pairing.G2Point delta2;\\n        Pairing.G1Point[22] IC;\\n    }\\n\\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\\n          vk.alfa1 = Pairing.G1Point(20491192805390485299153009773594534940189261866228447918068658471970481763042, 9383485363053290200918347156157836566562967994039712273449902621266178545958);\\n          vk.beta2 = Pairing.G2Point([4252822878758300859123897981450591353533073413197771768651442665752259397132, 6375614351688725206403948262868962793625744043794305715222011528459656738731], [21847035105528745403288232691147584728191162732299865338377159692350059136679, 10505242626370262277552901082094356697409835680220590971873171140371331206856]);\\n          vk.gamma2 = Pairing.G2Point([11559732032986387107991004021392285783925812861821192530917403151452391805634, 10857046999023057135944570762232829481370756359578518086990519993285655852781], [4082367875863433681332203403145435568316851327593401208105741076214120093531, 8495653923123431417604973247489272438418190587263600148770280649306958101930]);\\n          vk.delta2 = Pairing.G2Point([324972916483522516010841893854440411474408943481740310172418044857098157569, 16590838412156603698650805570179145135219779665457557755436225266168000520215], [19912865636111770273096857772087607367446154443804652158551511812140230258738, 18898587926326716523711659913325511398462111606177689192785674110087568301290]);\\n          \\n          vk.IC[0] = Pairing.G1Point(8162824753046488689222844442336456542944980721212018996068677568539865847154, 68336375415832493883025566755120742748798482990510659320020413671124263813);\\n          vk.IC[1] = Pairing.G1Point(13385354376895684738525372841721949351065825149323500998140479404598066177552, 774000488261771704340470900939335588684487496344699019509475341379762029129);\\n          vk.IC[2] = Pairing.G1Point(6164665196748670741899752062374578501377210204524027951283497047174090107246, 13351529164519819412353131530547733947982703129545003025403400316358274656788);\\n          vk.IC[3] = Pairing.G1Point(15104742904837652460462265915842022412444824796122190774339764905721700482560, 4107383152149384422330091248298605663526641070546552713882465516327776703261);\\n          vk.IC[4] = Pairing.G1Point(18366901277020281062829142947726999221803528473888834382987301539056310388198, 5333349927417288435079823170102412329053596039481494904019610845464451916013);\\n          vk.IC[5] = Pairing.G1Point(15144019168293260882890204437917061432607201193531878199588855851411671836990, 9199962718805558689877339890748747456497983224902748783054063600302475187118);\\n          vk.IC[6] = Pairing.G1Point(12932412046190985001634799103668548554685531827299748994405196266069688995300, 10707385832654340158097753876565803153424529579519847381719896096017984142855);\\n          vk.IC[7] = Pairing.G1Point(7873463149513870989676412812284917368468126532794981416350934761606567524843, 10551626841273973297626743592761621143570000591808384598686077407904408493715);\\n          vk.IC[8] = Pairing.G1Point(16330309240770105190370301439547519340044479001915708112706983827982163460017, 12081131625507604998280182669749391795983458657489782545040195538750651946124);\\n          vk.IC[9] = Pairing.G1Point(1486069644570530506797727349494718423674091557177309298286438544614346204559, 19068542263969674830554434464897443431780973146631164161756955717308558112924);\\n          vk.IC[10] = Pairing.G1Point(18165196001774567964616955584189507656261513190472427896752550419384758966691, 16796159367373466383825910380025416607566654235545375266211560712581123339182);\\n          vk.IC[11] = Pairing.G1Point(7702244265546664511114530563029335410706475541806258844500613119403482556550, 8421490039868200700842742081280486017442501955214960965178629429859318139466);\\n          vk.IC[12] = Pairing.G1Point(21533168749956447567623820727022320889977785105217674533707964479939315421389, 20990757469514606009942298510177311718926745465913790027983501547681486503793);\\n          vk.IC[13] = Pairing.G1Point(14086537948094970993757429932532766944637282946671958494213116659196031122003, 7264628236066322634169129816756173866315886403389425586068884061261732012319);\\n          vk.IC[14] = Pairing.G1Point(4596643281792400208072100409066534448711054609025119398815662174178561603755, 10470243072747854661455300802696788117003123410312327094696261791090027263451);\\n          vk.IC[15] = Pairing.G1Point(1377457640377164129625399203068204257242429546217779872826440508864115374445, 17678473175209576079964179439632589902291156513769306617595279474099092742971);\\n          vk.IC[16] = Pairing.G1Point(6524534722990878809215629883913646854554254420034788282335076727082972137974, 20710359632189449218857600301746089446929900309110260854400516032120292032109);\\n          vk.IC[17] = Pairing.G1Point(8775618449680312097927332900108214617465666059880169962714983692502761839447, 7832901087032835041518349666739617867806873187999646585625950272745991884535);\\n          vk.IC[18] = Pairing.G1Point(15272125225443524116484621460793891471637998802569450292108324586772911739775, 15100218088723873288253570050996356865732591286236923198056149054699499607708);\\n          vk.IC[19] = Pairing.G1Point(18549198365667742038316075418544371637005118777317512467423437225872443719168, 646571828569074486074328737548468391333720883444913718205087199318933546895);\\n          vk.IC[20] = Pairing.G1Point(4941632999276623391926232158297217976910386854420196125268268665091751838450, 4038152037297440755623963808450739736226866983969064111856714841509447530597);\\n          vk.IC[21] = Pairing.G1Point(16631203264272073726426971210200610614410225339638984617007677050270042928155, 14160608480694819975906557237853520366530021350289053491755603175103499124127);\\n    }\\n\\n    /*\\n     * @returns Whether the proof is valid given the hardcoded verifying key\\n     *          above and the public inputs\\n     */\\n    function verifyProof(\\n        bytes memory proof,\\n        uint256[21] memory input\\n    ) public view returns (bool) {\\n        uint256[8] memory p = abi.decode(proof, (uint256[8]));\\n        for (uint8 i = 0; i < p.length; i++) {\\n            // Make sure that each element in the proof is less than the prime q\\n            require(p[i] < PRIME_Q, \\\"verifier-proof-element-gte-prime-q\\\");\\n        }\\n        Pairing.G1Point memory proofA = Pairing.G1Point(p[0], p[1]);\\n        Pairing.G2Point memory proofB = Pairing.G2Point([p[2], p[3]], [p[4], p[5]]);\\n        Pairing.G1Point memory proofC = Pairing.G1Point(p[6], p[7]);\\n\\n        VerifyingKey memory vk = verifyingKey();\\n        // Compute the linear combination vkX\\n        Pairing.G1Point memory vkX = vk.IC[0];\\n        for (uint256 i = 0; i < input.length; i++) {\\n            // Make sure that every input is less than the snark scalar field\\n            require(input[i] < SNARK_SCALAR_FIELD, \\\"verifier-input-gte-snark-scalar-field\\\");\\n            vkX = Pairing.plus(vkX, Pairing.scalarMul(vk.IC[i + 1], input[i]));\\n        }\\n\\n        return Pairing.pairing(\\n            Pairing.negate(proofA),\\n            proofB,\\n            vk.alfa1,\\n            vk.beta2,\\n            vkX,\\n            vk.gamma2,\\n            proofC,\\n            vk.delta2\\n        );\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"uint256[21]\",\"name\":\"input\",\"type\":\"uint256[21]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Verifier16", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}