{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Airdrop2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface Token {\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ncontract AirDrop {\\n    address public owner;\\n    Token public token;\\n\\n    event TransferredToken(address indexed to, uint256 value);\\n    event FailedTransfer(address indexed to, uint256 value);\\n\\n    constructor(address _tokenAddr) {\\n        owner = msg.sender;\\n        token = Token(_tokenAddr);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"New owner is the zero address\\\");\\n        owner = newOwner;\\n    }\\n\\n    function sendTokens(address[] calldata dests, uint256[] calldata values) external onlyOwner {\\n        require(dests.length == values.length, \\\"Array lengths do not match\\\");\\n        \\n        for (uint256 i = 0; i < dests.length; i++) {\\n            require(dests[i] != address(0), \\\"Invalid address\\\");\\n            uint256 toSend = values[i];\\n            bool sent = token.transfer(dests[i], toSend);\\n            if (!sent) {\\n                emit FailedTransfer(dests[i], toSend);\\n            }\\n        }\\n        \\n    }\\n\\n    // Changed from 'view' to 'pure' as it does not read contract state\\n    function verifyBatch(address[] calldata recipients, uint256[] calldata amounts, bytes32[][] calldata proofs, bytes32 _merkleRoot) external pure returns (bool[] memory validities) {\\n        require(recipients.length == amounts.length && recipients.length == proofs.length, \\\"Array lengths do not match\\\");\\n        validities = new bool[](recipients.length);\\n\\n        for (uint256 i = 0; i < recipients.length; i++) {\\n            bytes32 leaf = keccak256(abi.encodePacked(recipients[i], amounts[i]));\\n            validities[i] = verifyProof(leaf, proofs[i], _merkleRoot);\\n        }\\n        return validities;\\n    }\\n\\n    // Changed from 'view' to 'pure' as it solely operates on function arguments\\n    function verifyProof(bytes32 leaf, bytes32[] memory proof, bytes32 _merkleRoot) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash < proofElement) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        return computedHash == _merkleRoot;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferredToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"proofs\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"verifyBatch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"validities\",\"type\":\"bool[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "AirDrop", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000090d82bb724516e7db97192a93c4c19a93504461b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}