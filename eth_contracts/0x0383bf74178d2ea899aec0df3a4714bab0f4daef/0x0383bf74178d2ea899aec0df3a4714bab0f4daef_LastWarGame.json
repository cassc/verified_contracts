{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/IWomanSeekersNewDawn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IWomanSeekersNewDawn {\\r\\n    function lastTokenIdTransfer() external view returns (uint);\\r\\n\\r\\n        function totalSupplyTR1() external view returns (uint);\\r\\n\\r\\n\\r\\n    function totalSupplyTR2() external view returns (uint);\\r\\n\\r\\n    function cost() external view returns(uint256);\\r\\n\\r\\n    function gameDiscount() external view returns(uint256);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function tokensOfOwner(\\r\\n        address owner\\r\\n    ) external view returns (uint256[] memory);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    function mintFromGame(uint256 _mintAmount) external;\\r\\n\\r\\n    function viewNFTCost() external view returns (uint256);\\r\\n\\r\\n    function viewNotTransferable(uint256 _tokenId) external view returns (bool);\\r\\n\\r\\n    function setNotTransferable(uint256 _tokendId, bool _value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/LastWarGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IWomanSeekersNewDawn.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract LastWarGame is Ownable {\\n    IWomanSeekersNewDawn Collection;\\n    IERC20 public LastToken;\\n\\n    uint256 public defEnergyAccrual = 90;\\n    uint256 public energyPriceInTokens = 2;\\n    uint256 public defaultDamage = 100;\\n\\n    function enterInGame(uint256[] calldata _tokenIds) public {\\n        Player storage Newplayer = players[msg.sender];\\n\\n        require(\\n            checkOwnershipOfTokens(_tokenIds),\\n            \\\"you're not owner of token Id\\\"\\n        );\\n\\n        Newplayer.qtyBossDefeated = 0;\\n        Newplayer.energyFactor = 10;\\n        Newplayer.energyBalance = 0;\\n        Newplayer.lastTimestampClaimedEnergy = 0;\\n        Newplayer.amountTokensInGame = _tokenIds.length;\\n        Newplayer.damage = 100;\\n        Newplayer.isPlaying = true;\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            Newplayer.playingTokenIds.push(_tokenIds[i]);\\n            require(\\n                !Collection.viewNotTransferable(_tokenIds[i]),\\n                \\\"This token already in game\\\"\\n            );\\n            Collection.setNotTransferable(_tokenIds[i], true);\\n        }\\n    }\\n\\n    event duelFinished(\\n        address indexed winner,\\n        uint256 _indexRoom,\\n        uint256[] damages,\\n        bool indexed _wasEnergyFactorIncreased\\n    );\\n\\n    event duelAttackLogs(\\n        address indexed player,\\n        uint256 indexed _indexRoom,\\n        uint256[] indexed damages\\n    );\\n\\n    event DiscountReceived(address indexed _player);\\n    event LastTokensGiven(address indexed _player, uint256 indexed _amount);\\n\\n    event BossDefeated(\\n        address indexed player,\\n        uint256 indexed bossLevel,\\n        uint256[] indexed damages\\n    );\\n    event BossLost(\\n        address indexed player,\\n        uint256 indexed bossLevel,\\n        uint256[] indexed damages\\n    );\\n\\n    mapping(address => Player) public players;\\n    mapping(uint256 => bossSpecs) public bosses;\\n\\n    struct Player {\\n        uint256 qtyBossDefeated;\\n        uint256 energyFactor;\\n        uint256 energyBalance;\\n        uint256 amountTokensInGame;\\n        uint256 lastTimestampClaimedEnergy;\\n        uint256[] playingTokenIds;\\n        uint256 damage;\\n        bool isPlaying;\\n    }\\n\\n    function getInfoPlayer(\\n        address _player\\n    ) public view returns (Player memory) {\\n        return players[_player];\\n    }\\n\\n    struct bossSpecs {\\n        uint256 health;\\n        uint256 dodgeChance;\\n        uint256 attackDamage;\\n    }\\n\\n    struct duelInfo {\\n        uint256 playersNow;\\n        address[2] players;\\n        uint256 totalDamagePlayer0;\\n        uint256 totalDamagePlayer1;\\n    }\\n\\n    duelInfo[] public duels;\\n\\n    constructor(address _collection, address _LastToken) {\\n        Collection = IWomanSeekersNewDawn(_collection);\\n        LastToken = IERC20(_LastToken);\\n        createBoss();\\n        createBoss();\\n        createBoss();\\n        createBoss();\\n        createNewDuelRoom();\\n        createNewDuelRoom();\\n        createNewDuelRoom();\\n    }\\n\\n    function createNewDuelRoom() public {\\n        address[2] memory emptyPlayers;\\n\\n        duels.push(duelInfo(0, emptyPlayers, 0, 0));\\n    }\\n\\n    function random(\\n        uint256 _value,\\n        uint256 _salt\\n    ) public view returns (uint256) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        block.timestamp,\\n                        block.difficulty,\\n                        blockhash(block.number - 1),\\n                        msg.sender,\\n                        _salt\\n                    )\\n                )\\n            ) % _value;\\n    }\\n\\n    function setDefEnergyAccrual(uint256 _value) public onlyOwner {\\n        defEnergyAccrual = _value;\\n    }\\n\\n    function setEnergyPriceInTokens(uint256 _value) public onlyOwner {\\n        energyPriceInTokens = _value;\\n    }\\n\\n    function setDefaultDamage(uint256 _value) public onlyOwner {\\n        defaultDamage = _value;\\n    }\\n\\n    function isPlayerInDuelAtIndexRoom(\\n        uint256 _indexRoom\\n    ) public view returns (bool) {\\n        require(_indexRoom < duels.length, \\\"Invalid duel index\\\");\\n\\n        duelInfo storage currentDuel = duels[_indexRoom];\\n        if (currentDuel.playersNow > 0) {\\n            if (\\n                currentDuel.players[0] == msg.sender ||\\n                currentDuel.players[1] == msg.sender\\n            ) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // function calculateTestDamage() public view returns(uint) {\\n    //     return  (defaultDamage * players[msg.sender].energyFactor) * ((random(20,1251250) + 100)/100 );\\n\\n    // }\\n\\n    function viewDuelInfo(\\n        uint256 _indexRoom\\n    ) public view returns (duelInfo memory) {\\n        return duels[_indexRoom];\\n    }\\n\\n    function doAttackInDuel(uint256 _indexRoom) public {\\n        duelInfo storage currentDuel = duels[_indexRoom];\\n\\n        require(isPlayerInDuelAtIndexRoom(_indexRoom), \\\"you're not in room\\\");\\n\\n        uint salt = 132601;\\n        uint256[] memory damages = new uint256[](3);\\n\\n        uint totalDamage;\\n\\n        for (uint i = 0; i <= 2; i++) {\\n            uint damage = ((random(10, 1251250) + 100) / 100) *\\n                players[msg.sender].damage *\\n                players[msg.sender].energyFactor;\\n            damages[i] = damage;\\n            salt += 126512;\\n            totalDamage += damage;\\n        }\\n\\n        if (currentDuel.players[0] == msg.sender) {\\n            require(\\n                currentDuel.totalDamagePlayer0 == 0,\\n                \\\"you're already attacked in duel\\\"\\n            );\\n\\n            currentDuel.totalDamagePlayer0 += totalDamage;\\n            emit duelAttackLogs(msg.sender, _indexRoom, damages);\\n        } else {\\n            require(\\n                currentDuel.totalDamagePlayer1 == 0,\\n                \\\"you're already attacked in duel\\\"\\n            );\\n\\n            currentDuel.totalDamagePlayer1 += totalDamage;\\n            emit duelAttackLogs(msg.sender, _indexRoom, damages);\\n        }\\n\\n        if (\\n            currentDuel.totalDamagePlayer0 != 0 &&\\n            currentDuel.totalDamagePlayer1 != 0\\n        ) {\\n            //\\n            uint salt1 = 2151256;\\n            uint chance = random(100, salt1);\\n            salt += 12723;\\n\\n            if (chance <= 5) {}\\n            bool wasEnergyFactorIncreased;\\n\\n            if (\\n                currentDuel.totalDamagePlayer0 > currentDuel.totalDamagePlayer1\\n            ) {\\n                LastToken.transfer(currentDuel.players[0], duelPrice * 2);\\n\\n                if (chance <= 5) {\\n                    players[currentDuel.players[0]].energyFactor += 1;\\n                    wasEnergyFactorIncreased = true;\\n                }\\n\\n                // \u043f\u043e\u0440\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0438\u0432\u0435\u043d\u0442\u0430 + \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0431\u044b\u043b \u043b\u0438 \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d \u043c\u0443\u043b\u044c\u0442\u0438\u043f\u043b\u0438\u043a\u0430\u0442\u043e\u0440 \u0438\u0433\u0440\u043e\u043a\u0430\\n\\n                emit duelFinished(\\n                    currentDuel.players[0],\\n                    _indexRoom,\\n                    damages,\\n                    wasEnergyFactorIncreased\\n                );\\n            } else {\\n                LastToken.transfer(currentDuel.players[1], duelPrice * 2);\\n\\n                if (chance <= 5) {\\n                    players[currentDuel.players[0]].energyFactor += 1;\\n                    wasEnergyFactorIncreased = true;\\n                }\\n                emit duelFinished(\\n                    currentDuel.players[1],\\n                    _indexRoom,\\n                    damages,\\n                    wasEnergyFactorIncreased\\n                );\\n            }\\n\\n            delete duels[_indexRoom];\\n        }\\n    }\\n\\n    uint256 public duelPrice = 1000;\\n\\n    function getActiveDuelForPlayer() public view returns (uint256) {\\n        for (uint i = 0; i < duels.length; i++) {\\n            if (\\n                duels[i].players[0] == msg.sender ||\\n                duels[i].players[1] == msg.sender\\n            ) {\\n                return i;\\n            }\\n        }\\n\\n        revert(\\\"could not find player in duel rooms\\\");\\n    }\\n\\n    function findAvailableDuel() public view returns (uint256) {\\n        for (uint i = 0; i < duels.length; i++) {\\n            if (duels[i].playersNow != 2) {\\n                return i;\\n            }\\n        }\\n\\n        revert(\\\"could not find available duel room\\\");\\n    }\\n\\n    function enterInDuel() public {\\n        duelInfo storage currentDuel = duels[findAvailableDuel()];\\n\\n        require(\\n            currentDuel.players[0] != msg.sender &&\\n                currentDuel.players[1] != msg.sender,\\n            \\\"you're already in this duel\\\"\\n        );\\n\\n        // \u0435\u0441\u043b\u0438 \u043c\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0438 currentDuel \u0437\u043d\u0430\u0447\u0438\u0442 \u0434\u0443\u044d\u043b\u044c \u0440\u0443\u043c \u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0438\u0433\u0440\u043e\u043a\u0430\\n\\n        if (currentDuel.players[0] == address(0)) {\\n            currentDuel.players[0] = msg.sender;\\n        } else {\\n            currentDuel.players[1] = msg.sender;\\n        }\\n\\n        LastToken.transferFrom(msg.sender, address(this), duelPrice);\\n\\n        currentDuel.playersNow++;\\n    }\\n\\n    uint bosscounter = 1;\\n\\n    function createBoss() internal {\\n        bossSpecs storage newBoss = bosses[bosscounter];\\n\\n        if (bosscounter == 1) {\\n            newBoss.health = 3000;\\n            newBoss.dodgeChance = 25;\\n            newBoss.attackDamage = 300;\\n        }\\n\\n        if (bosscounter == 2) {\\n            newBoss.health = 6000;\\n            newBoss.dodgeChance = 30;\\n            newBoss.attackDamage = 300;\\n        }\\n\\n        if (bosscounter == 3) {\\n            newBoss.health = 9000;\\n            newBoss.dodgeChance = 40;\\n            newBoss.attackDamage = 300;\\n        }\\n\\n        if (bosscounter == 4) {\\n            newBoss.health = 12000;\\n            newBoss.dodgeChance = 50;\\n            newBoss.attackDamage = 300;\\n        }\\n\\n        bosscounter++;\\n    }\\n\\n    function leaveGame() public {\\n        require(players[msg.sender].isPlaying == true, \\\"you're out of game\\\");\\n\\n        for (\\n            uint256 i = 0;\\n            i < players[msg.sender].playingTokenIds.length;\\n            i++\\n        ) {\\n            Collection.setNotTransferable(\\n                players[msg.sender].playingTokenIds[i],\\n                false\\n            );\\n        }\\n\\n        delete players[msg.sender];\\n    }\\n\\n    function claimDailyEnergy() public {\\n        require(players[msg.sender].energyFactor >= 1, \\\"you're out of game\\\");\\n        require(\\n            block.timestamp >=\\n                players[msg.sender].lastTimestampClaimedEnergy + 1 minutes,\\n            \\\"try later\\\"\\n        );\\n\\n        players[msg.sender].lastTimestampClaimedEnergy = block.timestamp;\\n        players[msg.sender].energyBalance +=\\n            100 +\\n            (defEnergyAccrual * players[msg.sender].energyFactor);\\n    }\\n\\n    function getLastTimestampClaimedEnergy(\\n        address _player\\n    ) public view returns (uint) {\\n        return players[_player].lastTimestampClaimedEnergy;\\n    }\\n\\n    function buyEnergyForTokens(uint256 _amountEnergy) public {\\n        uint256 amountToPayTokens = _amountEnergy * energyPriceInTokens;\\n\\n        LastToken.approve(address(this), amountToPayTokens);\\n\\n        LastToken.transferFrom(msg.sender, address(this), amountToPayTokens);\\n\\n        players[msg.sender].energyBalance += _amountEnergy;\\n    }\\n\\n    function setLastToken(address _lastToken) public onlyOwner {\\n        LastToken = IERC20(_lastToken);\\n    }\\n\\n    function withdrawGameTokens() public onlyOwner {\\n        LastToken.transfer(owner(), LastToken.balanceOf(address(this)));\\n    }\\n\\n    function withdraw() public onlyOwner {\\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\\\"\\\");\\n        require(os);\\n    }\\n\\n    function fightWithBoss(uint256 _bossLevel) public {\\n        require(\\n            _bossLevel - 1 == players[msg.sender].qtyBossDefeated,\\n            \\\"not corresponding boss for you\\\"\\n        );\\n\\n        require(\\n            players[msg.sender].energyBalance >= bosses[_bossLevel].health,\\n            \\\"you don't have enough energy for this boss\\\"\\n        );\\n        uint totalDamage;\\n        uint salt = 1255215;\\n        uint256[] memory damages = new uint256[](3);\\n\\n        for (uint i = 0; i <= 2; i++) {\\n            uint damage = (((random(10, salt) *\\n                players[msg.sender].damage *\\n                players[msg.sender].energyFactor) *\\n                bosses[_bossLevel].dodgeChance) / 100);\\n            damages[i] = damage;\\n            salt += 12551;\\n\\n            totalDamage += damage;\\n        }\\n\\n        if (totalDamage >= bosses[_bossLevel].health) {\\n            players[msg.sender].qtyBossDefeated = _bossLevel;\\n            emit BossDefeated(msg.sender, _bossLevel, damages);\\n            players[msg.sender].damage += 100;\\n        } else {\\n            unchecked {\\n                players[msg.sender].energyBalance -=\\n                    bosses[_bossLevel].attackDamage *\\n                    3;\\n            }\\n            emit BossLost(msg.sender, _bossLevel, damages);\\n        }\\n    }\\n\\n    function checkOwnershipOfTokens(\\n        uint256[] memory _tokenIds\\n    ) public view returns (bool) {\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            // tx origin or msg.sender ?\\n            if (Collection.ownerOf(_tokenIds[i]) != tx.origin) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    mapping(uint256 => bool) public isTokenIdClaimed;\\n\\n    function isTokensClaimedTreasures(\\n        uint256[] memory _tokenIds\\n    ) public view returns (bool) {\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            if (isTokenIdClaimed[_tokenIds[i]]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function getFinalTreasures(uint256[] memory _tokenIds, uint _salt) public {\\n        require(\\n            players[msg.sender].qtyBossDefeated == 4,\\n            \\\"you have to defeat all bosses\\\"\\n        );\\n        require(\\n            checkOwnershipOfTokens(_tokenIds),\\n            \\\"you're not owner of these tokenIds\\\"\\n        );\\n        require(!isTokensClaimedTreasures(_tokenIds), \\\"tokens were claimed\\\");\\n\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            isTokenIdClaimed[_tokenIds[i]] = true;\\n            uint chance = random(10, _salt);\\n            _salt += 16236;\\n\\n            if (chance <= 2) {\\n                amountDiscounts[msg.sender]++;\\n                emit DiscountReceived(msg.sender);\\n            } else {\\n                LastToken.transfer(msg.sender, 10000);\\n\\n                emit LastTokensGiven(msg.sender, 10000);\\n            }\\n        }\\n\\n        delete players[msg.sender];\\n    }\\n\\n    mapping(address => uint) public amountDiscounts;\\n\\n    function viewAmountDiscountForUser(\\n        address _player\\n    ) public view returns (uint) {\\n        return amountDiscounts[_player];\\n    }\\n\\n    function MintWithDiscountFromGame(uint256 _mintAmount) public payable {\\n        require(\\n            _mintAmount <= amountDiscounts[msg.sender],\\n            \\\"not enough discounts\\\"\\n        );\\n        uint requiredValue = ((Collection.cost() -\\n            (Collection.cost() * Collection.gameDiscount()) /\\n            100) * _mintAmount);\\n        require(msg.value == requiredValue, \\\"incorrect msgValue\\\");\\n\\n        amountDiscounts[msg.sender] -= _mintAmount;\\n        Collection.mintFromGame(_mintAmount);\\n    }\\n\\n    mapping(address => bool[5]) public RiseClaimMap;\\n\\n    function claimBonus(uint _ordinal) public {\\n        require(\\n            players[msg.sender].qtyBossDefeated >= _ordinal,\\n            \\\"before you need beat necessary boss\\\"\\n        );\\n        require(_ordinal <= 3, \\\"no more three bonuses now\\\");\\n\\n        require(\\n            !RiseClaimMap[msg.sender][_ordinal - 1],\\n            \\\"you're already claimed this bonus\\\"\\n        );\\n\\n        uint chance = random(10, 125125);\\n\\n        if (chance <= 2) {\\n            players[msg.sender].energyFactor += 10;\\n        } else {\\n            players[msg.sender].energyBalance += 1000;\\n        }\\n\\n        RiseClaimMap[msg.sender][_ordinal - 1] = true;\\n        amountBonusesClaimed[msg.sender]++;\\n    }\\n\\n    mapping(address => uint256) public amountBonusesClaimed;\\n    mapping(address => uint256) public amountEffectsClaimed;\\n\\n    function getAvailableBonusesToClaim()\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory bonusIndexes = new uint256[](\\n            3 - amountBonusesClaimed[msg.sender]\\n        );\\n        uint counter;\\n\\n        for (uint256 i = 0; i <= 2; i++) {\\n            if (\\n                players[msg.sender].qtyBossDefeated >= i + 1 &&\\n                !RiseClaimMap[msg.sender][i]\\n            ) {\\n                bonusIndexes[counter] = i;\\n                counter++;\\n            }\\n        }\\n\\n        return bonusIndexes;\\n    }\\n\\n    function getAvailableMysticEffects()\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory effectIndexes = new uint256[](\\n            2 - amountEffectsClaimed[msg.sender]\\n        );\\n        uint counter;\\n\\n        for (uint256 i = 3; i <= 4; i++) {\\n            if (\\n                players[msg.sender].qtyBossDefeated >= i - 1 &&\\n                !RiseClaimMap[msg.sender][i]\\n            ) {\\n                effectIndexes[counter] = i;\\n                counter++;\\n            }\\n        }\\n\\n        return effectIndexes;\\n    }\\n\\n    event BonusClaimed(uint indexed riseMapIndex);\\n\\n    function claimAvailableBonuses() public {\\n        uint256[] memory availableBonuses = getAvailableBonusesToClaim();\\n        bool wasZero;\\n\\n        for (uint256 i = 0; i < availableBonuses.length; i++) {\\n            if (availableBonuses[i] == 0 && wasZero) {\\n                break;\\n            }\\n\\n            if (!wasZero && availableBonuses[i] == 0) {\\n                wasZero = true;\\n            }\\n\\n            claimBonus(availableBonuses[i] + 1);\\n            emit BonusClaimed(i);\\n        }\\n    }\\n\\n    event EffectClaimed(uint indexed riseMapIndex);\\n\\n    function claimAvailableMysticEffects() public {\\n        uint256[] memory availableEffects = getAvailableMysticEffects();\\n        bool wasZero;\\n\\n        for (uint256 i = 0; i < availableEffects.length; i++) {\\n            if (availableEffects[i] == 0 && wasZero) {\\n                break;\\n            }\\n\\n            if (!wasZero && availableEffects[i] == 0) {\\n                wasZero = true;\\n            }\\n\\n            claimMysticEffect(availableEffects[i] - 1);\\n            emit EffectClaimed(i);\\n        }\\n    }\\n\\n    function claimMysticEffect(uint _ordinal) public {\\n        require(\\n            players[msg.sender].qtyBossDefeated + 1 >= _ordinal,\\n            \\\"before you need beat necessary boss\\\"\\n        );\\n        require(_ordinal >= 2 && _ordinal < 4, \\\"out of range\\\");\\n\\n        require(\\n            !RiseClaimMap[msg.sender][_ordinal + 1],\\n            \\\"you're already claimed this effect\\\"\\n        );\\n        uint chance = random(10, 125125);\\n\\n        if (chance <= 2) {\\n            players[msg.sender].energyFactor += 10;\\n        } else {\\n            players[msg.sender].energyFactor -= 1;\\n\\n            amountEffectsClaimed[msg.sender]++;\\n            RiseClaimMap[msg.sender][_ordinal + 1] = true;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LastToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"riseMapIndex\",\"type\":\"uint256\"}],\"name\":\"BonusClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bossLevel\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"damages\",\"type\":\"uint256[]\"}],\"name\":\"BossDefeated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bossLevel\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"damages\",\"type\":\"uint256[]\"}],\"name\":\"BossLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"DiscountReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"riseMapIndex\",\"type\":\"uint256\"}],\"name\":\"EffectClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LastTokensGiven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_indexRoom\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"damages\",\"type\":\"uint256[]\"}],\"name\":\"duelAttackLogs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_indexRoom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"damages\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_wasEnergyFactorIncreased\",\"type\":\"bool\"}],\"name\":\"duelFinished\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LastToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"MintWithDiscountFromGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RiseClaimMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountBonusesClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountDiscounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountEffectsClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bosses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"health\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dodgeChance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"attackDamage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountEnergy\",\"type\":\"uint256\"}],\"name\":\"buyEnergyForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkOwnershipOfTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAvailableBonuses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAvailableMysticEffects\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ordinal\",\"type\":\"uint256\"}],\"name\":\"claimBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDailyEnergy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ordinal\",\"type\":\"uint256\"}],\"name\":\"claimMysticEffect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createNewDuelRoom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defEnergyAccrual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultDamage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_indexRoom\",\"type\":\"uint256\"}],\"name\":\"doAttackInDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"duels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"playersNow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDamagePlayer0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDamagePlayer1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"energyPriceInTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterInDuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"enterInGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bossLevel\",\"type\":\"uint256\"}],\"name\":\"fightWithBoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"findAvailableDuel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveDuelForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableBonusesToClaim\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableMysticEffects\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"getFinalTreasures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getInfoPlayer\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"qtyBossDefeated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energyFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energyBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokensInGame\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestampClaimedEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"playingTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"damage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPlaying\",\"type\":\"bool\"}],\"internalType\":\"struct LastWarGame.Player\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getLastTimestampClaimedEnergy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_indexRoom\",\"type\":\"uint256\"}],\"name\":\"isPlayerInDuelAtIndexRoom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTokenIdClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"isTokensClaimedTreasures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaveGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qtyBossDefeated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energyFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energyBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokensInGame\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestampClaimedEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"damage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPlaying\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setDefEnergyAccrual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setDefaultDamage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setEnergyPriceInTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lastToken\",\"type\":\"address\"}],\"name\":\"setLastToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"viewAmountDiscountForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_indexRoom\",\"type\":\"uint256\"}],\"name\":\"viewDuelInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"playersNow\",\"type\":\"uint256\"},{\"internalType\":\"address[2]\",\"name\":\"players\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"totalDamagePlayer0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDamagePlayer1\",\"type\":\"uint256\"}],\"internalType\":\"struct LastWarGame.duelInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawGameTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LastWarGame", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000038a43458ee5b7a01a71edf0480f11faccc14d6c800000000000000000000000038d8afc209e64e5d48e8baba4fbeb85f5ce8c1e3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}