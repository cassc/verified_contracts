{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/TokenDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\npragma solidity ^0.8.23;\\n\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n//import \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport {AppStorage} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport { INewToken, IUniswapV2Router02 } from \\\"../interfaces/INewToken.sol\\\";\\n//import { NewTokenFacet } from \\\"./NewTokenFacet.sol\\\";\\n//import \\\"hardhat/console.sol\\\";\\n\\n/// @title TokenDiamond \\n/// @notice Diamond Proxy for a launched token\\n/// @dev \\ncontract TokenDiamond { \\n    AppStorage internal s;\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    //event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event IncreasedLimits(uint256 maxWallet, uint256 maxTx);\\n\\n    /// @notice Constructor of Diamond Proxy for a launched token\\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, INewToken.InitParams memory params) {\\n        require(params.owner != address(0));\\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\\n        LibDiamond.setContractOwner(params.owner);\\n\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        // adding ERC165 data\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        //ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC20).interfaceId] = true;\\n\\n        //init appStorage   \\n        //s.deployyyyer = msg.sender;\\n        //deployerWallet is always deployyyyer launcher\\n        s.deployyyyerCa = payable(msg.sender);\\n        s.isParent = false; \\n        s.tokenFacet = address(bytes20(ds.facets[IERC20.name.selector]));\\n\\n        s.stakingFacet = params.stakingFacet;\\n        s.minLiq = params.minLiq;\\n        s.taxBuy = params.maxBuyTax; //20%\\n        s.maxBuyTax = params.maxBuyTax;\\n        s.minBuyTax = params.minBuyTax;\\n        s.lpTax = params.lpTax;\\n        s.taxSell = params.maxSellTax; //20%\\n        s.maxSellTax = params.maxSellTax;\\n        s.minSellTax = params.minSellTax;\\n        \\n        s.initTaxType = params.initTaxType;\\n        s.initInterval = params.initInterval;\\n        s.countInterval = params.countInterval;\\n\\n        // Reduction Rules\\n        s.buyCount = 0; \\n    \\n\\n        // Token Information\\n        s.decimals = 18;\\n\\n        s.isFreeTier = params.isFreeTier;\\n        s.taxWallet = payable(params.taxWallet);\\n        \\n        s.name = params.name;\\n        s.symbol = params.symbol;\\n        s.tTotal = params.supply*10**18;\\n\\n        // Contract Swap Rules            \\n        s.taxSwapThreshold = params.taxSwapThreshold*10**18; //0.1%\\n        s.maxTaxSwap = params.maxSwap*10**18; //1%\\n        s.walletLimited = true;\\n        \\n        \\n        s.maxWallet = s.tTotal * params.maxWallet / 100;  //1% (allow 1 - 100)\\n        s.maxTx = s.tTotal * params.maxTx / 100;\\n        if (params.maxWallet == 100 && params.maxTx == 100) {\\n            s.walletLimited = false;\\n        }\\n        emit IncreasedLimits(params.maxWallet, params.maxTx);\\n        s.balances[address(this)] = s.tTotal;\\n        emit Transfer(address(0), address(this), s.tTotal);\\n\\n        s.preventSwap = params.preventSwap;\\n\\n        //s.uniswapV2Router = IUniswapV2Router02(params.v2router);\\n        //s.allowances[address(this)][address(s.uniswapV2Router)] = s.tTotal;\\n        //emit Approval(address(this), address(s.uniswapV2Router), s.tTotal);\\n\\n    }  \\n\\n    /// @notice fallback\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        //require(facet != address(0), \\\"T1\\\");\\n        require(facet != address(0), \\\"T1\\\");\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n    \\n    /// @notice receive eth\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    //event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/interfaces/INewToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\nimport { IPresale} from \\\"./IPresale.sol\\\";\\n\\ninterface INewToken {\\n    struct InitParams {\\n        address owner;\\n        address taxWallet;\\n        address stakingFacet;\\n        address v2router;\\n        bool isFreeTier;\\n        uint256 minLiq; \\n        uint256 supply;\\n        uint256 initTaxType; //0-time,1-buyCount,2-hybrid\\n        uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n        uint256 countInterval; //0-100 \\n        uint256  maxBuyTax; //40%\\n        uint256  minBuyTax; //0\\n        uint256  maxSellTax; //40%\\n        uint256  minSellTax; //0\\n        uint256  lpTax; //0-90 of buy or sell tax\\n        uint256 maxWallet;\\n        uint256 maxTx;\\n        uint256 preventSwap;\\n        uint256 maxSwap;\\n        uint256 taxSwapThreshold;\\n        string  name;\\n        string  symbol;\\n    }\\n    \\n    struct TeamParams {\\n        address team1;\\n        uint256 team1p; \\n        uint256 cliffPeriod; \\n        uint256 vestingPeriod;\\n        bool isAdd;\\n    }\\n\\n\\tfunction rescueERC20(address _address) external;\\n\\tfunction increaseLimits(uint256 maxwallet, uint256 maxtx) external;\\n\\tfunction startTrading(uint256 lockPeriod, bool shouldBurn, address router) external;\\n    //require trading and presale not started\\n    function addPresale(address presale, uint256 percent, IPresale.PresaleParams memory newdetails) external;\\n    //require caller to be presale address\\n    function finPresale() external;\\n    function refPresale() external;\\n    //requires presale not started and trading not started\\n    function addTeam(TeamParams memory params) external;\\n    //what if we remove team out from init?\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\ninterface IPresale {\\n    struct PresaleParams {\\n            address owner;\\n            address token;\\n            uint256 softcap;\\n            uint256 hardcap;\\n            uint256 startTs;\\n            uint256 finishTs;\\n            uint256 duration;\\n            uint256 liqPercent;\\n            uint256 cliffPeriod;\\n            uint256 vestingPeriod;\\n            uint256 status;\\n            uint256 sold;\\n            uint256 maxEth;\\n            uint256 maxBag;\\n            uint256 fee;\\n    }\\n\\n    function transferOwnership(address _newOwner) external;\\n    function owner() external view returns (address);\\n    function rescueERC20(address _address) external;\\n    function setupPresale(PresaleParams memory params) external;\\n    function buyTokens(uint256 _amount) external payable;\\n    //should we offer or force token vesting??\\n    function claimTokens() external;\\n    function getRefund() external;\\n    function getPresaleDetails() external view returns(PresaleParams memory); \\n    function finishPresale() external; \\n    function claimEth() external;\\n    function getClaimableTokens(address user) external view returns(uint256,uint256,uint256,uint256);\\n    function refundPresale() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibAppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\npragma solidity ^0.8.23;\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\n//import {LibMeta} from \\\"./LibMeta.sol\\\";\\nimport {IUniswapV2Factory, IUniswapV2Router02} from \\\"../interfaces/INewToken.sol\\\";\\n\\n\\n\\nstruct AppStorage {\\n    mapping(address => bool) validRouters; //parentOnly\\n    mapping(address => bool) allowedTokens; //parentOnly\\n    //this should be bool too\\n    mapping(address => address) launchedTokens; //parentOnly\\n    mapping(address => address) launchedPresale; //parentOnly\\n    //cost of launch, cost of promo, cost of setting socials is 2xpromoCostEth\\n    uint256 ethCost; //parentOnly\\n    uint256 deployyyyerCost; //parentOnly\\n    uint256 promoCostEth; //parentOnly\\n    uint256 promoCostDeployyyyer; //parentOnly\\n    address bridge; //parentOnly\\n\\n    //mapping of user address to score\\n    mapping(address => uint256) myScore; //parentOnly\\n\\n    //+1 for launch, +5 for liquidity add, +50 for lp burn, -100 for lp retrieve\\n    uint256 cScore; //cScore is transferred with ownership, cScore is deducted on lp retrieve\\n\\n    \\n    //address deployyyyer;\\n    bool isParent;\\n    uint256 minLiq;\\n    //this can be a map with share and clain in a structure\\n    mapping(address => uint256) teamShare;\\n    mapping(address => uint256) teamClaim;\\n    \\n    uint256 teamBalance;\\n\\n    uint256 cliffPeriod; //min 30days\\n    uint256 vestingPeriod;//min 1day max 10000 days avg 30days.\\n\\n\\n    mapping(address => bool)  isExTxLimit; //is excluded from transaction limit\\n    mapping(address => bool)  isExWaLimit; //is excluded from wallet limit\\n    mapping (address => uint256)  balances; //ERC20 balance\\n    mapping (address => mapping (address => uint256))  allowances; //ERC20 balance\\n\\n    address payable taxWallet; //tax wallet for the token\\n    address payable deployyyyerCa; //deployyyyer contract address\\n    address payable stakingContract; //address of staking contract for the token\\n    address stakingFacet; //facet address, used to launch a staking pool\\n    address presaleFacet; //facet address, used to launch a presale\\n    address tokenFacet; //facet address, used to launch a ERC20 token\\n    uint256 stakingShare; //share of tax sent to its staking pool\\n    \\n    \\n    // Reduction Rules\\n    uint256  buyCount; \\n\\n    uint256 initTaxType; //0-time,1-buyCount,2-hybrid,3-none\\n    //interval*1, lastIntEnd+(interval*2), lastIntEnd+(interval*3)\\n    uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n    uint256 countInterval; //0-100 \\n\\n    //current taxes\\n    uint256  taxBuy; \\n    uint256  maxBuyTax; //40%\\n    uint256  minBuyTax; //0\\n\\n    uint256  taxSell; \\n    uint256  maxSellTax; //40%\\n    uint256  minSellTax; //0\\n    \\n    \\n\\n\\n    uint256  tradingOpened;\\n\\n    // Token Information\\n    uint8   decimals;\\n    uint256   tTotal;\\n    string   name;\\n    string   symbol;\\n\\n    // Contract Swap Rules \\n    uint256 preventSwap; //50            \\n    uint256  taxSwapThreshold; //0.1%\\n    uint256  maxTaxSwap; //1%\\n    uint256  maxWallet; //1%\\n    uint256  maxTx;\\n\\n    IUniswapV2Router02  uniswapV2Router;\\n    address  uniswapV2Pair;\\n    \\n    bool  tradingOpen; //true if liquidity pool is created\\n    bool  inSwap;\\n    bool  walletLimited;\\n    bool isFreeTier;\\n    bool isBurnt;\\n    bool isRetrieved;\\n    uint256 lockPeriod;\\n    \\n    //buy back tax calculations\\n    uint256 lpTax; //0-50 percent of tax amount \\n    uint256 halfLp;\\n    uint256 lastSwap;\\n\\n    uint256 presaleTs;\\n    uint256 presaleSt;\\n    address presale;\\n\\n}\\n\\n/*\\nlibrary LibAppStorage {\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n}\\n*/\\n\\n\\ncontract Modifiers {\\n    AppStorage internal s;\\n\\n    modifier onlyOwner() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }  \\n    \\n}\\n\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/*********************************************************************************************\\\\\\n* Authors: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen), \\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/*********************************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"l0\\\");\\n    }\\n\\n    //event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    //bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    // also removed action on _calldata and _init is always address(0)\\n    // maintained same old signature\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\" \\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\" \\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        //emit DiamondCut(_diamondCut, _init, _calldata);\\n        //initializeDiamondCut(_init, _calldata);\\n        require(_init == address(0), \\\"l1\\\");\\n        require(_calldata.length == 0, \\\"l2\\\");\\n    }\\n\\n    //supports only add, maintaining lib fn name\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"l3\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"l4\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"l5\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\" \\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } \\n        else {\\n            revert(\\\"l6\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"v2router\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isFreeTier\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minLiq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initTaxType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBuyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBuyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preventSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxSwapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct INewToken.InitParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"}],\"name\":\"IncreasedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenDiamond", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000003600000000000000000000000005a99bf51b70636e60bb825e79b3ca0b3cec8b1fa00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000bf2fde38b000000000000000000000000000000000000000000000000000000008da5cb5b0000000000000000000000000000000000000000000000000000000044ee3a1c000000000000000000000000000000000000000000000000000000004839c8b30000000000000000000000000000000000000000000000000000000048c54b9d000000000000000000000000000000000000000000000000000000000d0da2d4000000000000000000000000000000000000000000000000000000005c89dfe1000000000000000000000000000000000000000000000000000000000b45260e00000000000000000000000000000000000000000000000000000000af66394d00000000000000000000000000000000000000000000000000000000dde070e80000000000000000000000000000000000000000000000000000000020ffb26d000000000000000000000000000000000000000000000000000000000000000000000000000000009c84288cb2c0fcad30f031ac1d4b1633ef994c63000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000005cdffacc60000000000000000000000000000000000000000000000000000000052ef6b2c00000000000000000000000000000000000000000000000000000000adfca15e000000000000000000000000000000000000000000000000000000007a0ed6270000000000000000000000000000000000000000000000000000000001ffc9a70000000000000000000000000000000000000000000000000000000000000000000000000000000076bfec03547673b84223d9fb4c02eb20ec021e0700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001006fdde030000000000000000000000000000000000000000000000000000000095d89b4100000000000000000000000000000000000000000000000000000000313ce5670000000000000000000000000000000000000000000000000000000018160ddd0000000000000000000000000000000000000000000000000000000070a082310000000000000000000000000000000000000000000000000000000023b872dd00000000000000000000000000000000000000000000000000000000a9059cbb00000000000000000000000000000000000000000000000000000000095ea7b300000000000000000000000000000000000000000000000000000000dd62ed3e00000000000000000000000000000000000000000000000000000000ccec37160000000000000000000000000000000000000000000000000000000078f8484b00000000000000000000000000000000000000000000000000000000db7c4dda000000000000000000000000000000000000000000000000000000001bbd3a240000000000000000000000000000000000000000000000000000000087fc38b000000000000000000000000000000000000000000000000000000000b5660a1800000000000000000000000000000000000000000000000000000000b39956360000000000000000000000000000000000000000000000000000000000000000000000000000000018a0639067cf4f0ca04877ce1c2378d01f5d846600000000000000000000000018a0639067cf4f0ca04877ce1c2378d01f5d8466000000000000000000000000f992610355f3c5fcc4bc300b0b9eb5b5ff037d2c0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000003c00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000098968000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000002c00000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000b5375706572204e6569726f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006534e4549524f0000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}