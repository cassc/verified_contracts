{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n   \r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n   \r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n   \r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n   \r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n   \r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n  \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n  \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n   \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n  \r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n   \r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  \r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function decimals() external returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n   \r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract IUCNcoinPresale is Ownable , ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n    IERC20 public IUCNcoin;\r\n    uint256 tokenPrice; // doller price with 8 Decimals\r\n\r\n    bool public paused;\r\n    uint256 public _raised;\r\n    uint256 public latestOrderId;\r\n\r\n    address public treasury;\r\n\r\n    struct OrderInfo {\r\n        address beneficiary;\r\n        uint256 amount;\r\n        uint256 time;\r\n        uint256 totalToken;\r\n    }\r\n    mapping(address => uint256[]) private  orderIds;\r\n    mapping(uint256 => OrderInfo) public orders;\r\n\r\n\r\n    IERC20 WBTC;\r\n    IERC20 WBNB;\r\n    IERC20 USDC;\r\n    IERC20 USDT;\r\n\r\n    AggregatorV3Interface internal BnbFeed;\r\n    AggregatorV3Interface internal BtcFeed;\r\n    AggregatorV3Interface internal EthFeed;\r\n    AggregatorV3Interface internal UsdtFeed;\r\n    AggregatorV3Interface internal UsdcFeed;\r\n    \r\n    constructor() {\r\n\r\n        IUCNcoin = IERC20(0x0B4663216B812e4a2f0Fc2029ff1232958f4bf8c);\r\n        paused = false;\r\n        tokenPrice = 300000000000000; //rate = $0,0003\r\n\r\n        treasury = address(0x79595b395bd606F175E2FeD0B3dc0Eb7610dE351);  //Presale Funds Receiver\r\n        \r\n        BnbFeed = AggregatorV3Interface(0x14e613AC84a31f709eadbdF89C6CC390fDc9540A);\r\n        BtcFeed = AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\r\n        EthFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n        UsdtFeed = AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n        UsdcFeed = AggregatorV3Interface(0xA2F78ab2355fe2f984D808B5CeE7FD0A93D5270E);\r\n\r\n        WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n        WBNB = IERC20(0x418D75f65a02b3D53B2418FB8E1fe493759c7605);\r\n        USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n        USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n\r\n    }\r\n\r\n    function investorOrderIds(address investor)\r\n        external\r\n        view\r\n        returns (uint256[] memory ids)\r\n    {\r\n        uint256[] memory arr = orderIds[investor];\r\n        return arr;\r\n    }\r\n\r\n    //1. ETH, \r\n    function BuyTokenNative() public nonReentrant payable {\r\n        address beneficiary = msg.sender;\r\n        uint256 _amount = msg.value;\r\n        _preValidatePurchase(beneficiary,_amount);\r\n        (bool os,) = payable(treasury).call{value: _amount}(\"\");\r\n        require(os,\"Transaction Failed\");\r\n        \r\n        (uint tokenAmount,uint totalUsd) = _getTokenAmount(_amount,1,18);\r\n          \r\n        _raised += totalUsd;\r\n\r\n        orders[++latestOrderId] = OrderInfo(\r\n             msg.sender,\r\n            _amount,\r\n            block.timestamp,\r\n            tokenAmount\r\n        );\r\n\r\n        orderIds[msg.sender].push(latestOrderId);\r\n        IUCNcoin.transferFrom(treasury, msg.sender, tokenAmount);\r\n    }\r\n\r\n    //2. Btc, 3. ETH, 4. Usdt, 5.Usdc\r\n    function BuyToken(uint _pid, uint _amount) public nonReentrant {\r\n        address beneficiary = msg.sender;\r\n        uint decimal;\r\n        uint tokenAmount;\r\n        uint totalUsd;\r\n        _preValidatePurchase(beneficiary,_amount);\r\n        if(_pid == 2) {\r\n            decimal = WBTC.decimals();\r\n            ( tokenAmount, totalUsd) = _getTokenAmount(_amount,_pid,decimal);\r\n            WBTC.transferFrom(beneficiary,treasury, _amount);\r\n        }\r\n        else if (_pid == 3) {\r\n            decimal = WBNB.decimals();\r\n            (tokenAmount,totalUsd) = _getTokenAmount(_amount,_pid,decimal);\r\n            WBNB.transferFrom(beneficiary,treasury, _amount);\r\n        }\r\n        else if (_pid == 4) {\r\n            decimal = USDT.decimals();\r\n            (tokenAmount,totalUsd) = _getTokenAmount(_amount,_pid,decimal);\r\n            USDT.transferFrom(beneficiary,treasury, _amount);\r\n        }\r\n        else if (_pid == 5) {\r\n            decimal = USDC.decimals();\r\n            (tokenAmount,totalUsd) = _getTokenAmount(_amount,_pid,decimal);\r\n            USDC.transferFrom(beneficiary,treasury, _amount);\r\n        }\r\n        else {\r\n            revert(\"Wrong ID Selected!!\");\r\n        }\r\n        _raised += totalUsd;\r\n\r\n        orders[++latestOrderId] = OrderInfo(\r\n             msg.sender,\r\n            _amount,\r\n            block.timestamp,\r\n            tokenAmount\r\n        );\r\n\r\n        orderIds[msg.sender].push(latestOrderId);\r\n           \r\n        IUCNcoin.transferFrom(treasury, msg.sender, tokenAmount);\r\n       \r\n    }\r\n\r\n    function _getTokenAmount(uint256 weiAmount,uint _pid,uint _cDecimal) public view returns (uint256,uint256) {\r\n        uint256 CurrencyDecimal = 18 - _cDecimal;\r\n        uint usd =  uint256(getLatestPrice(_pid));\r\n        usd = usd.mul(10**10);  \r\n        if(CurrencyDecimal > 0){\r\n            weiAmount = weiAmount * 10**CurrencyDecimal;\r\n        }\r\n        uint totalUsd = weiAmount * usd;\r\n        uint totalToken = weiAmount * usd / tokenPrice;\r\n        return (totalToken,totalUsd);\r\n    }\r\n\r\n    //@Param to get live price,\r\n    //1. ETH, 2. Btc, 3. BNB, 4. Usdt, 5.Usdc\r\n    function getLatestPrice(uint _pid) public view returns (int) {\r\n        int price;\r\n        if(_pid == 1) (,price,,,) = EthFeed.latestRoundData();   \r\n        if(_pid == 2) (,price,,,) = BtcFeed.latestRoundData();   \r\n        if(_pid == 3) (,price,,,) = BnbFeed.latestRoundData();   \r\n        if(_pid == 4) (,price,,,) = UsdtFeed.latestRoundData();  \r\n        if(_pid == 5) (,price,,,) = UsdcFeed.latestRoundData(); \r\n        return price;\r\n    }\r\n\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(!paused,\"Crowdsale: Paused!!\");\r\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\r\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\r\n    }\r\n\r\n    function setPauser(bool _status) public onlyOwner {\r\n        require(paused != _status,\"Status Not Changed!!\");\r\n        paused = _status;\r\n    }\r\n\r\n    function getAvailableBalance() public view returns (uint) {\r\n        return IUCNcoin.balanceOf(address(this));\r\n    }\r\n\r\n    function rescueFunds() public onlyOwner {\r\n        (bool os,) = payable(owner()).call{value: address(this).balance}(\"\");\r\n        require(os,\"Transaction Failed\");\r\n    }\r\n\r\n    function rescueTokens(IERC20 _token, uint _amount) public onlyOwner {\r\n        _token.transfer(owner(), _amount);\r\n    }\r\n\r\n    function setTreasuryWallet(address _adr) public onlyOwner {\r\n        treasury = _adr;\r\n    }\r\n\r\n    function setTokenPrice(uint _rate) public onlyOwner{\r\n        tokenPrice = _rate;\r\n    }\r\n\r\n    function setTokens(address _wbtc, address _wbnb , address _usdc , address _usdt) public onlyOwner{\r\n        WBTC = IERC20(_wbtc);\r\n        WBNB = IERC20(_wbnb);\r\n        USDC = IERC20(_usdc);\r\n        USDT = IERC20(_usdt);\r\n    }\r\n\r\n    function setTokenPrices(address _wbtc, address _wbnb , address _usdc , address _usdt , address _eth) public onlyOwner{\r\n        BnbFeed = AggregatorV3Interface(_wbnb);\r\n        BtcFeed = AggregatorV3Interface(_wbtc);\r\n        EthFeed = AggregatorV3Interface(_eth);\r\n        UsdtFeed = AggregatorV3Interface(_usdt);\r\n        UsdcFeed = AggregatorV3Interface(_usdc);\r\n    }\r\n\r\n    function setToken(address _token) public onlyOwner{\r\n        IUCNcoin = IERC20(_token);\r\n    }\r\n\r\n    \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BuyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyTokenNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IUCNcoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cDecimal\",\"type\":\"uint256\"}],\"name\":\"_getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_raised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"investorOrderIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wbtc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eth\",\"type\":\"address\"}],\"name\":\"setTokenPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wbtc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"setTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "IUCNcoinPresale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ad31dc0b83b1879f86343feeb440383bb12ac0506e50fc77fff3b5d9ea19d9b3"}