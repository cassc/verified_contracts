{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/zircuit/ZircuitPhantomToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IZircuitPool} from \\\"../../integrations/zircuit/IZircuitPool.sol\\\";\\nimport {PhantomERC20} from \\\"../PhantomERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IPhantomToken} from \\\"@gearbox-protocol/core-v3/contracts/interfaces/base/IPhantomToken.sol\\\";\\nimport {PhantomTokenType} from \\\"@gearbox-protocol/sdk-gov/contracts/Tokens.sol\\\";\\nimport {MultiCall} from \\\"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\\\";\\n\\n/// @title Convex staked position token\\n/// @notice Phantom ERC-20 token that represents the balance of the staking position in Convex pools\\ncontract ZircuitPhantomToken is PhantomERC20, IPhantomToken {\\n    PhantomTokenType public constant override _gearboxPhantomTokenType = PhantomTokenType.CONVEX_PHANTOM_TOKEN;\\n\\n    address public immutable zircuitPool;\\n\\n    /// @notice Constructor\\n    /// @param _pool The Zircuit staking pool\\n    /// @param _token The token to track\\n    constructor(address _pool, address _token)\\n        PhantomERC20(\\n            _token,\\n            string(abi.encodePacked(\\\"Zircuit staked position \\\", IERC20Metadata(_token).name())),\\n            string(abi.encodePacked(\\\"z\\\", IERC20Metadata(_token).symbol())),\\n            IERC20Metadata(_token).decimals()\\n        )\\n    {\\n        zircuitPool = _pool;\\n    }\\n\\n    /// @notice Returns the amount of token staked in the Zircuit pool by an account\\n    /// @param account The account for which the calculation is performed\\n    function balanceOf(address account) public view returns (uint256) {\\n        return IZircuitPool(zircuitPool).balance(underlying, account);\\n    }\\n\\n    /// @notice Returns the total amount of certain token staked in the Zircuit pool\\n    function totalSupply() public view override returns (uint256) {\\n        return IERC20(underlying).balanceOf(zircuitPool);\\n    }\\n\\n    /// @notice Returns the calls required to unwrap a Convex position into Curve LP before withdrawing from Gearbox\\n    function getWithdrawalMultiCall(address creditAccount, uint256 amount)\\n        external\\n        view\\n        returns (address tokenOut, uint256 amountOut, address targetContract, bytes memory callData)\\n    {\\n        tokenOut = underlying;\\n        amountOut = amount;\\n        targetContract = zircuitPool;\\n        callData = abi.encodeCall(IZircuitPool.withdraw, (underlying, amount));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/integrations/zircuit/IZircuitPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface IZircuitPool {\\n    function balance(address _token, address _account) external view returns (uint256);\\n\\n    function depositFor(address _token, address _for, uint256 _amount) external;\\n\\n    function withdraw(address _token, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/PhantomERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/// @dev PhantomERC20 is a pseudo-ERC20 that only implements totalSupply and balanceOf\\n/// @notice Used to track positions that do not issue an explicit share token\\n///         This is an abstract contract and balanceOf is implemented by concrete instances\\nabstract contract PhantomERC20 is IERC20Metadata {\\n    address public immutable underlying;\\n\\n    string public symbol;\\n    string public override name;\\n    uint8 public immutable override decimals;\\n\\n    constructor(address _underlying, string memory _name, string memory _symbol, uint8 _decimals) {\\n        symbol = _symbol;\\n        name = _name;\\n        decimals = _decimals;\\n        underlying = _underlying;\\n    }\\n\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return IERC20Metadata(underlying).totalSupply();\\n    }\\n\\n    function transfer(address, uint256) external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function allowance(address, address) external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function approve(address, uint256) external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function transferFrom(address, address, uint256) external pure override returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/base/IPhantomToken.sol\": {\r\n      \"content\": \"// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {PhantomTokenType} from \\\"@gearbox-protocol/sdk-gov/contracts/Tokens.sol\\\";\\nimport {MultiCall} from \\\"../ICreditFacadeV3.sol\\\";\\n\\ninterface IPhantomToken {\\n    function _gearboxPhantomTokenType() external view returns (PhantomTokenType);\\n\\n    function getWithdrawalMultiCall(address creditAccount, uint256 amount)\\n        external\\n        returns (address tokenOut, uint256 amountOut, address targetContract, bytes memory callData);\\n}\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/sdk-gov/contracts/Tokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\\n// (c) Gearbox Foundation, 2023\\npragma solidity ^0.8.17;\\n\\n/// @dev c-Tokens and LUNA are added for unit test purposes\\nenum Tokens {\\n    NO_TOKEN,\\n    LUNA,\\n    _1INCH,\\n    AAVE,\\n    COMP,\\n    CRV,\\n    DAI,\\n    DPI,\\n    FEI,\\n    LINK,\\n    SNX,\\n    UNI,\\n    USDC,\\n    USDC_e,\\n    USDT,\\n    WBTC,\\n    WETH,\\n    YFI,\\n    WLD,\\n    OP,\\n    STETH,\\n    CVX,\\n    FRAX,\\n    FXS,\\n    LDO,\\n    LUSD,\\n    sUSD,\\n    GUSD,\\n    LQTY,\\n    OHM,\\n    MIM,\\n    SPELL,\\n    GMX,\\n    ARB,\\n    RDNT,\\n    BAL,\\n    SHIB,\\n    crvUSD,\\n    MKR,\\n    RPL,\\n    APE,\\n    rETH,\\n    AURA,\\n    osETH,\\n    weETH,\\n    SWISE,\\n    ezETH,\\n    rsETH,\\n    frxETH,\\n    PENDLE,\\n    cbETH,\\n    rswETH,\\n    USDe,\\n    GHO,\\n    pufETH,\\n    wstETH,\\n    sfrxETH,\\n    _3Crv,\\n    crvFRAX,\\n    steCRV,\\n    crvPlain3andSUSD,\\n    crvCRVETH,\\n    crvCVXETH,\\n    crvUSDTWBTCWETH,\\n    LDOETH,\\n    crvUSDUSDC,\\n    crvUSDUSDT,\\n    crvUSDFRAX,\\n    crvUSDETHCRV,\\n    rETH_f,\\n    USDeUSDC,\\n    FRAXUSDe,\\n    USDecrvUSD,\\n    USDeDAI,\\n    MtEthena,\\n    GHOUSDe,\\n    pufETHwstE,\\n    wstETHCRV,\\n    _2CRV,\\n    _3c_crvUSD,\\n    crvUSDC,\\n    crvUSDT,\\n    crvUSDC_e,\\n    USDEUSDC,\\n    _3CRV,\\n    FRAX3CRV,\\n    LUSD3CRV,\\n    gusd3CRV,\\n    MIM_3LP3CRV,\\n    OHMFRAXBP,\\n    cvx3Crv,\\n    cvxcrvFRAX,\\n    cvxsteCRV,\\n    cvxFRAX3CRV,\\n    cvxLUSD3CRV,\\n    cvxcrvPlain3andSUSD,\\n    cvxgusd3CRV,\\n    cvxOHMFRAXBP,\\n    cvxMIM_3LP3CRV,\\n    cvxcrvCRVETH,\\n    cvxcrvCVXETH,\\n    cvxcrvUSDTWBTCWETH,\\n    cvxLDOETH,\\n    cvxcrvUSDUSDC,\\n    cvxcrvUSDUSDT,\\n    cvxcrvUSDFRAX,\\n    cvxcrvUSDETHCRV,\\n    stkcvx3Crv,\\n    stkcvxcrvFRAX,\\n    stkcvxsteCRV,\\n    stkcvxFRAX3CRV,\\n    stkcvxLUSD3CRV,\\n    stkcvxcrvPlain3andSUSD,\\n    stkcvxgusd3CRV,\\n    stkcvxOHMFRAXBP,\\n    stkcvxMIM_3LP3CRV,\\n    stkcvxcrvCRVETH,\\n    stkcvxcrvCVXETH,\\n    stkcvxcrvUSDTWBTCWETH,\\n    stkcvxLDOETH,\\n    stkcvxcrvUSDUSDC,\\n    stkcvxcrvUSDUSDT,\\n    stkcvxcrvUSDFRAX,\\n    stkcvxcrvUSDETHCRV,\\n    cvxcrvUSDT,\\n    yvDAI,\\n    yvUSDC,\\n    yvUSDC_e,\\n    yvWETH,\\n    yvWBTC,\\n    yvUSDT,\\n    yvOP,\\n    yvCurve_stETH,\\n    yvCurve_FRAX,\\n    _50WETH_50AURA,\\n    B_80BAL_20WETH,\\n    _50OHM_50DAI,\\n    _50OHM_50WETH,\\n    OHM_wstETH,\\n    USDC_DAI_USDT,\\n    B_rETH_STABLE,\\n    weETH_rETH,\\n    osETH_wETH_BPT,\\n    ezETH_WETH_BPT,\\n    weETH_ezETH_rswETH,\\n    GHO_USDT_USDC,\\n    rsETH_WETH,\\n    BPT_rETH_ETH,\\n    BPT_WSTETH_ETH,\\n    BPT_ROAD,\\n    ECLP_wstETH_WETH,\\n    wstETH_WETH_BPT,\\n    wstETH_rETH_sfrxETH,\\n    wstETH_rETH_cbETH,\\n    cbETH_rETH_wstETH,\\n    rETH_WETH_BPT,\\n    rETH_wETH_BPT,\\n    _33AURA_33ARB_33BAL,\\n    ezETH_wstETH,\\n    aDAI,\\n    aUSDC,\\n    aUSDT,\\n    aWETH,\\n    waDAI,\\n    waUSDC,\\n    waUSDT,\\n    waWETH,\\n    cDAI,\\n    cUSDC,\\n    cUSDT,\\n    cETH,\\n    cLINK,\\n    fUSDC,\\n    sDAI,\\n    YieldETH,\\n    sUSDe,\\n    auraB_rETH_STABLE,\\n    auraosETH_wETH_BPT,\\n    auraweETH_rETH,\\n    auraBPT_rETH_ETH,\\n    auraBPT_WSTETH_ETH,\\n    aurawstETH_WETH_BPT,\\n    aurawstETH_rETH_sfrxETH,\\n    auracbETH_rETH_wstETH,\\n    aurarETH_wETH_BPT,\\n    auraB_rETH_STABLE_vault,\\n    auraosETH_wETH_BPT_vault,\\n    auraweETH_rETH_vault,\\n    auraBPT_rETH_ETH_vault,\\n    auraBPT_WSTETH_ETH_vault,\\n    aurawstETH_WETH_BPT_vault,\\n    aurawstETH_rETH_sfrxETH_vault,\\n    auracbETH_rETH_wstETH_vault,\\n    aurarETH_wETH_BPT_vault,\\n    dDAI,\\n    dUSDC,\\n    dWBTC,\\n    dWETH,\\n    dwstETH,\\n    dFRAX,\\n    dUSDCV3,\\n    dWBTCV3,\\n    dWETHV3,\\n    dUSDTV3,\\n    dGHOV3,\\n    dDAIV3,\\n    sdUSDCV3,\\n    sdWBTCV3,\\n    sdWETHV3,\\n    sdUSDTV3,\\n    sdGHOV3,\\n    sdDAIV3,\\n    GEAR\\n}\\n\\nenum TokenType {\\n    NO_TOKEN,\\n    NORMAL_TOKEN,\\n    CURVE_LP_TOKEN,\\n    YEARN_ON_NORMAL_TOKEN,\\n    YEARN_ON_CURVE_TOKEN,\\n    CONVEX_LP_TOKEN,\\n    CONVEX_STAKED_TOKEN,\\n    DIESEL_LP_TOKEN,\\n    GEAR_TOKEN,\\n    COMPOUND_V2_C_TOKEN,\\n    BALANCER_LP_TOKEN,\\n    AAVE_V2_A_TOKEN,\\n    WRAPPED_AAVE_V2_TOKEN,\\n    ERC4626_VAULT_TOKEN,\\n    WRAPPED_TOKEN,\\n    AURA_LP_TOKEN,\\n    AURA_STAKED_TOKEN,\\n    CONVEX_L2_STAKED_TOKEN,\\n    ZIRCUIT_STAKED_TOKEN\\n}\\n\\nenum PhantomTokenType {\\n    NO_TOKEN,\\n    CONVEX_PHANTOM_TOKEN,\\n    ZIRCUIT_PHANTOM_TOKEN\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {AllowanceAction} from \\\"./ICreditConfiguratorV3.sol\\\";\\nimport \\\"./ICreditFacadeV3Multicall.sol\\\";\\nimport {PriceUpdate} from \\\"./IPriceOracleV3.sol\\\";\\nimport {IVersion} from \\\"./base/IVersion.sol\\\";\\n\\n/// @notice Multicall element\\n/// @param target Call target, which is either credit facade or adapter\\n/// @param callData Call data\\nstruct MultiCall {\\n    address target;\\n    bytes callData;\\n}\\n\\n/// @notice Debt limits packed into a single slot\\n/// @param minDebt Minimum debt amount per credit account\\n/// @param maxDebt Maximum debt amount per credit account\\nstruct DebtLimits {\\n    uint128 minDebt;\\n    uint128 maxDebt;\\n}\\n\\n/// @notice Info on bad debt liquidation losses packed into a single slot\\n/// @param currentCumulativeLoss Current cumulative loss from bad debt liquidations\\n/// @param maxCumulativeLoss Max cumulative loss incurred before the facade gets paused\\nstruct CumulativeLossParams {\\n    uint128 currentCumulativeLoss;\\n    uint128 maxCumulativeLoss;\\n}\\n\\n/// @notice Collateral check params\\n/// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\\n///        when known subset of account's collateral tokens covers all the debt\\n/// @param minHealthFactor Min account's health factor in bps in order not to revert\\nstruct FullCheckParams {\\n    uint256[] collateralHints;\\n    uint16 minHealthFactor;\\n}\\n\\ninterface ICreditFacadeV3Events {\\n    /// @notice Emitted when a new credit account is opened\\n    event OpenCreditAccount(\\n        address indexed creditAccount, address indexed onBehalfOf, address indexed caller, uint256 referralCode\\n    );\\n\\n    /// @notice Emitted when account is closed\\n    event CloseCreditAccount(address indexed creditAccount, address indexed borrower);\\n\\n    /// @notice Emitted when account is liquidated\\n    event LiquidateCreditAccount(\\n        address indexed creditAccount, address indexed liquidator, address to, uint256 remainingFunds\\n    );\\n\\n    /// @notice Emitted when account is partially liquidated\\n    event PartiallyLiquidateCreditAccount(\\n        address indexed creditAccount,\\n        address indexed token,\\n        address indexed liquidator,\\n        uint256 repaidDebt,\\n        uint256 seizedCollateral,\\n        uint256 fee\\n    );\\n\\n    /// @notice Emitted when collateral is added to account\\n    event AddCollateral(address indexed creditAccount, address indexed token, uint256 amount);\\n\\n    /// @notice Emitted when collateral is withdrawn from account\\n    event WithdrawCollateral(address indexed creditAccount, address indexed token, uint256 amount, address to);\\n\\n    /// @notice Emitted when a multicall is started\\n    event StartMultiCall(address indexed creditAccount, address indexed caller);\\n\\n    /// @notice Emitted when a call from account to an external contract is made during a multicall\\n    event Execute(address indexed creditAccount, address indexed targetContract);\\n\\n    /// @notice Emitted when a multicall is finished\\n    event FinishMultiCall();\\n}\\n\\n/// @title Credit facade V3 interface\\ninterface ICreditFacadeV3 is IVersion, ICreditFacadeV3Events {\\n    function creditManager() external view returns (address);\\n\\n    function underlying() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function degenNFT() external view returns (address);\\n\\n    function weth() external view returns (address);\\n\\n    function botList() external view returns (address);\\n\\n    function maxDebtPerBlockMultiplier() external view returns (uint8);\\n\\n    function maxQuotaMultiplier() external view returns (uint256);\\n\\n    function expirable() external view returns (bool);\\n\\n    function expirationDate() external view returns (uint40);\\n\\n    function debtLimits() external view returns (uint128 minDebt, uint128 maxDebt);\\n\\n    function lossParams() external view returns (uint128 currentCumulativeLoss, uint128 maxCumulativeLoss);\\n\\n    function forbiddenTokenMask() external view returns (uint256);\\n\\n    function emergencyLiquidators() external view returns (address[] memory);\\n\\n    function canLiquidateWhilePaused(address) external view returns (bool);\\n\\n    // ------------------ //\\n    // ACCOUNT MANAGEMENT //\\n    // ------------------ //\\n\\n    function openCreditAccount(address onBehalfOf, MultiCall[] calldata calls, uint256 referralCode)\\n        external\\n        payable\\n        returns (address creditAccount);\\n\\n    function closeCreditAccount(address creditAccount, MultiCall[] calldata calls) external payable;\\n\\n    function liquidateCreditAccount(address creditAccount, address to, MultiCall[] calldata calls) external;\\n\\n    function partiallyLiquidateCreditAccount(\\n        address creditAccount,\\n        address token,\\n        uint256 repaidAmount,\\n        uint256 minSeizedAmount,\\n        address to,\\n        PriceUpdate[] calldata priceUpdates\\n    ) external returns (uint256 seizedAmount);\\n\\n    function multicall(address creditAccount, MultiCall[] calldata calls) external payable;\\n\\n    function botMulticall(address creditAccount, MultiCall[] calldata calls) external;\\n\\n    // ------------- //\\n    // CONFIGURATION //\\n    // ------------- //\\n\\n    function setExpirationDate(uint40 newExpirationDate) external;\\n\\n    function setDebtLimits(uint128 newMinDebt, uint128 newMaxDebt, uint8 newMaxDebtPerBlockMultiplier) external;\\n\\n    function setBotList(address newBotList) external;\\n\\n    function setCumulativeLossParams(uint128 newMaxCumulativeLoss, bool resetCumulativeLoss) external;\\n\\n    function setTokenAllowance(address token, AllowanceAction allowance) external;\\n\\n    function setEmergencyLiquidator(address liquidator, AllowanceAction allowance) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/ICreditConfiguratorV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {IVersion} from \\\"./base/IVersion.sol\\\";\\n\\nenum AllowanceAction {\\n    FORBID,\\n    ALLOW\\n}\\n\\ninterface ICreditConfiguratorV3Events {\\n    // ------ //\\n    // TOKENS //\\n    // ------ //\\n\\n    /// @notice Emitted when a token is made recognizable as collateral in the credit manager\\n    event AddCollateralToken(address indexed token);\\n\\n    /// @notice Emitted when a new collateral token liquidation threshold is set\\n    event SetTokenLiquidationThreshold(address indexed token, uint16 liquidationThreshold);\\n\\n    /// @notice Emitted when a collateral token liquidation threshold ramping is scheduled\\n    event ScheduleTokenLiquidationThresholdRamp(\\n        address indexed token,\\n        uint16 liquidationThresholdInitial,\\n        uint16 liquidationThresholdFinal,\\n        uint40 timestampRampStart,\\n        uint40 timestampRampEnd\\n    );\\n\\n    /// @notice Emitted when a collateral token is forbidden\\n    event ForbidToken(address indexed token);\\n\\n    /// @notice Emitted when a previously forbidden collateral token is allowed\\n    event AllowToken(address indexed token);\\n\\n    // -------- //\\n    // ADAPTERS //\\n    // -------- //\\n\\n    /// @notice Emitted when a new adapter and its target contract are allowed in the credit manager\\n    event AllowAdapter(address indexed targetContract, address indexed adapter);\\n\\n    /// @notice Emitted when adapter and its target contract are forbidden in the credit manager\\n    event ForbidAdapter(address indexed targetContract, address indexed adapter);\\n\\n    // -------------- //\\n    // CREDIT MANAGER //\\n    // -------------- //\\n\\n    /// @notice Emitted when a new maximum number of enabled tokens is set in the credit manager\\n    event SetMaxEnabledTokens(uint8 maxEnabledTokens);\\n\\n    /// @notice Emitted when new fee parameters are set in the credit manager\\n    event UpdateFees(\\n        uint16 feeLiquidation, uint16 liquidationPremium, uint16 feeLiquidationExpired, uint16 liquidationPremiumExpired\\n    );\\n\\n    // -------- //\\n    // UPGRADES //\\n    // -------- //\\n\\n    /// @notice Emitted when a new price oracle is set in the credit manager\\n    event SetPriceOracle(address indexed priceOracle);\\n\\n    /// @notice Emitted when a new bot list is set in the credit facade\\n    event SetBotList(address indexed botList);\\n\\n    /// @notice Emitted when a new facade is connected to the credit manager\\n    event SetCreditFacade(address indexed creditFacade);\\n\\n    /// @notice Emitted when credit manager's configurator contract is upgraded\\n    event CreditConfiguratorUpgraded(address indexed creditConfigurator);\\n\\n    // ------------- //\\n    // CREDIT FACADE //\\n    // ------------- //\\n\\n    /// @notice Emitted when new debt principal limits are set\\n    event SetBorrowingLimits(uint256 minDebt, uint256 maxDebt);\\n\\n    /// @notice Emitted when a new max debt per block multiplier is set\\n    event SetMaxDebtPerBlockMultiplier(uint8 maxDebtPerBlockMultiplier);\\n\\n    /// @notice Emitted when a new max cumulative loss is set\\n    event SetMaxCumulativeLoss(uint128 maxCumulativeLoss);\\n\\n    /// @notice Emitted when cumulative loss is reset to zero in the credit facade\\n    event ResetCumulativeLoss();\\n\\n    /// @notice Emitted when a new expiration timestamp is set in the credit facade\\n    event SetExpirationDate(uint40 expirationDate);\\n\\n    /// @notice Emitted when an address is added to the list of emergency liquidators\\n    event AddEmergencyLiquidator(address indexed liquidator);\\n\\n    /// @notice Emitted when an address is removed from the list of emergency liquidators\\n    event RemoveEmergencyLiquidator(address indexed liquidator);\\n}\\n\\n/// @title Credit configurator V3 interface\\ninterface ICreditConfiguratorV3 is IVersion, ICreditConfiguratorV3Events {\\n    function creditManager() external view returns (address);\\n\\n    function creditFacade() external view returns (address);\\n\\n    function underlying() external view returns (address);\\n\\n    // ------ //\\n    // TOKENS //\\n    // ------ //\\n\\n    function addCollateralToken(address token, uint16 liquidationThreshold) external;\\n\\n    function setLiquidationThreshold(address token, uint16 liquidationThreshold) external;\\n\\n    function rampLiquidationThreshold(\\n        address token,\\n        uint16 liquidationThresholdFinal,\\n        uint40 rampStart,\\n        uint24 rampDuration\\n    ) external;\\n\\n    function forbidToken(address token) external;\\n\\n    function allowToken(address token) external;\\n\\n    // -------- //\\n    // ADAPTERS //\\n    // -------- //\\n\\n    function allowedAdapters() external view returns (address[] memory);\\n\\n    function allowAdapter(address adapter) external;\\n\\n    function forbidAdapter(address adapter) external;\\n\\n    // -------------- //\\n    // CREDIT MANAGER //\\n    // -------------- //\\n\\n    function setFees(\\n        uint16 feeLiquidation,\\n        uint16 liquidationPremium,\\n        uint16 feeLiquidationExpired,\\n        uint16 liquidationPremiumExpired\\n    ) external;\\n\\n    function setMaxEnabledTokens(uint8 newMaxEnabledTokens) external;\\n\\n    // -------- //\\n    // UPGRADES //\\n    // -------- //\\n\\n    function setPriceOracle(address newPriceOracle) external;\\n\\n    function setBotList(address newBotList) external;\\n\\n    function setCreditFacade(address newCreditFacade, bool migrateParams) external;\\n\\n    function upgradeCreditConfigurator(address newCreditConfigurator) external;\\n\\n    // ------------- //\\n    // CREDIT FACADE //\\n    // ------------- //\\n\\n    function setMinDebtLimit(uint128 newMinDebt) external;\\n\\n    function setMaxDebtLimit(uint128 newMaxDebt) external;\\n\\n    function setMaxDebtPerBlockMultiplier(uint8 newMaxDebtLimitPerBlockMultiplier) external;\\n\\n    function forbidBorrowing() external;\\n\\n    function setMaxCumulativeLoss(uint128 newMaxCumulativeLoss) external;\\n\\n    function resetCumulativeLoss() external;\\n\\n    function setExpirationDate(uint40 newExpirationDate) external;\\n\\n    function addEmergencyLiquidator(address liquidator) external;\\n\\n    function removeEmergencyLiquidator(address liquidator) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {BalanceDelta} from \\\"../libraries/BalancesLogic.sol\\\";\\nimport {PriceUpdate} from \\\"./IPriceOracleV3.sol\\\";\\n\\n// ----------- //\\n// PERMISSIONS //\\n// ----------- //\\n\\n// NOTE: permissions 1 << 3, 1 << 4 and 1 << 7 were used by now deprecated methods, thus non-consecutive values\\n\\nuint192 constant ADD_COLLATERAL_PERMISSION = 1 << 0;\\nuint192 constant INCREASE_DEBT_PERMISSION = 1 << 1;\\nuint192 constant DECREASE_DEBT_PERMISSION = 1 << 2;\\nuint192 constant WITHDRAW_COLLATERAL_PERMISSION = 1 << 5;\\nuint192 constant UPDATE_QUOTA_PERMISSION = 1 << 6;\\nuint192 constant SET_BOT_PERMISSIONS_PERMISSION = 1 << 8;\\nuint192 constant EXTERNAL_CALLS_PERMISSION = 1 << 16;\\n\\nuint192 constant ALL_PERMISSIONS = ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION | UPDATE_QUOTA_PERMISSION\\n    | INCREASE_DEBT_PERMISSION | DECREASE_DEBT_PERMISSION | SET_BOT_PERMISSIONS_PERMISSION | EXTERNAL_CALLS_PERMISSION;\\nuint192 constant OPEN_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~DECREASE_DEBT_PERMISSION;\\nuint192 constant CLOSE_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~INCREASE_DEBT_PERMISSION;\\nuint192 constant LIQUIDATE_CREDIT_ACCOUNT_PERMISSIONS =\\n    EXTERNAL_CALLS_PERMISSION | ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION;\\n\\n// ----- //\\n// FLAGS //\\n// ----- //\\n\\n/// @dev Indicates that collateral check after the multicall can be skipped, set to true on account closure or liquidation\\nuint256 constant SKIP_COLLATERAL_CHECK_FLAG = 1 << 192;\\n\\n/// @dev Indicates that external calls from credit account to adapters were made during multicall,\\n///      set to true on the first call to the adapter\\nuint256 constant EXTERNAL_CONTRACT_WAS_CALLED_FLAG = 1 << 193;\\n\\n/// @dev Indicates that the price updates call should be skipped, set to true on liquidation when the first call\\n///      of the multicall is `onDemandPriceUpdates`\\nuint256 constant SKIP_PRICE_UPDATES_CALL_FLAG = 1 << 194;\\n\\n/// @dev Indicates that collateral check must revert if any forbidden token is encountered on the account,\\n///      set to true after risky operations, such as `increaseDebt` or `withdrawCollateral`\\nuint256 constant REVERT_ON_FORBIDDEN_TOKENS_FLAG = 1 << 195;\\n\\n/// @dev Indicates that collateral check must be performed using safe prices, set to true on `withdrawCollateral`\\n///      or if account has enabled forbidden tokens\\nuint256 constant USE_SAFE_PRICES_FLAG = 1 << 196;\\n\\n/// @title Credit facade V3 multicall interface\\n/// @dev Unless specified otherwise, all these methods are only available in `openCreditAccount`,\\n///      `closeCreditAccount`, `multicall`, and, with account owner's permission, `botMulticall`\\ninterface ICreditFacadeV3Multicall {\\n    /// @notice Applies on-demand price feed updates\\n    /// @param updates Array of price updates, see `PriceUpdate` for details\\n    /// @dev Reverts if placed not at the first position in the multicall\\n    /// @dev This method is available in all kinds of multicalls\\n    function onDemandPriceUpdates(PriceUpdate[] calldata updates) external;\\n\\n    /// @notice Stores expected token balances (current balance + delta) after operations for a slippage check.\\n    ///         Normally, a check is performed automatically at the end of the multicall, but more fine-grained\\n    ///         behavior can be achieved by placing `storeExpectedBalances` and `compareBalances` where needed.\\n    /// @param balanceDeltas Array of (token, minBalanceDelta) pairs, deltas are allowed to be negative\\n    /// @dev Reverts if expected balances are already set\\n    /// @dev This method is available in all kinds of multicalls\\n    function storeExpectedBalances(BalanceDelta[] calldata balanceDeltas) external;\\n\\n    /// @notice Performs a slippage check ensuring that current token balances are greater than saved expected ones\\n    /// @dev Resets stored expected balances\\n    /// @dev Reverts if expected balances are not stored\\n    /// @dev This method is available in all kinds of multicalls\\n    function compareBalances() external;\\n\\n    /// @notice Adds collateral to account\\n    /// @param token Token to add\\n    /// @param amount Amount to add\\n    /// @dev Requires token approval from caller to the credit manager\\n    /// @dev This method can also be called during liquidation\\n    function addCollateral(address token, uint256 amount) external;\\n\\n    /// @notice Adds collateral to account using signed EIP-2612 permit message\\n    /// @param token Token to add\\n    /// @param amount Amount to add\\n    /// @param deadline Permit deadline\\n    /// @dev `v`, `r`, `s` must be a valid signature of the permit message from caller to the credit manager\\n    /// @dev This method can also be called during liquidation\\n    function addCollateralWithPermit(address token, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external;\\n\\n    /// @notice Increases account's debt\\n    /// @param amount Underlying amount to borrow\\n    /// @dev Increasing debt is prohibited when closing an account\\n    /// @dev Increasing debt is prohibited if it was previously updated in the same block\\n    /// @dev The resulting debt amount must be within allowed range\\n    /// @dev Increasing debt is prohibited if there are forbidden tokens enabled as collateral on the account\\n    /// @dev After debt increase, total amount borrowed by the credit manager in the current block must not exceed\\n    ///      the limit defined in the facade\\n    function increaseDebt(uint256 amount) external;\\n\\n    /// @notice Decreases account's debt\\n    /// @param amount Underlying amount to repay, value above account's total debt indicates full repayment\\n    /// @dev Decreasing debt is prohibited when opening an account\\n    /// @dev Decreasing debt is prohibited if it was previously updated in the same block\\n    /// @dev The resulting debt amount must be within allowed range or zero\\n    /// @dev Full repayment brings account into a special mode that skips collateral checks and thus requires\\n    ///      an account to have no potential debt sources, e.g., all quotas must be disabled\\n    function decreaseDebt(uint256 amount) external;\\n\\n    /// @notice Updates account's quota for a token\\n    /// @param token Token to update the quota for\\n    /// @param quotaChange Desired quota change in underlying token units (`type(int96).min` to disable quota)\\n    /// @param minQuota Minimum resulting account's quota for token required not to revert\\n    /// @dev Enables token as collateral if quota is increased from zero, disables if decreased to zero\\n    /// @dev Quota increase is prohibited for forbidden tokens\\n    /// @dev Quota update is prohibited if account has zero debt\\n    /// @dev Resulting account's quota for token must not exceed the limit defined in the facade\\n    function updateQuota(address token, int96 quotaChange, uint96 minQuota) external;\\n\\n    /// @notice Withdraws collateral from account\\n    /// @param token Token to withdraw\\n    /// @param amount Amount to withdraw, `type(uint256).max` to withdraw all balance\\n    /// @param to Token recipient\\n    /// @dev This method can also be called during liquidation\\n    /// @dev Withdrawals are prohibited in multicalls if there are forbidden tokens enabled as collateral on the account\\n    /// @dev Withdrawals activate safe pricing (min of main and reserve feeds) in collateral check\\n    function withdrawCollateral(address token, uint256 amount, address to) external;\\n\\n    /// @notice Sets advanced collateral check parameters\\n    /// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\\n    ///        when known subset of account's collateral tokens covers all the debt. Underlying token is always\\n    ///        checked last so it's forbidden to pass its mask.\\n    /// @param minHealthFactor Min account's health factor in bps in order not to revert, must be at least 10000\\n    /// @dev This method can't be called during closure or liquidation\\n    function setFullCheckParams(uint256[] calldata collateralHints, uint16 minHealthFactor) external;\\n\\n    /// @notice Sets `bot`'s permissions to manage account to `permissions`\\n    /// @param bot Bot to set permissions for\\n    /// @param permissions A bitmask encoding bot permissions\\n    /// @dev Reverts if `permissions` has unexpected bits enabled (including `SET_BOT_PERMISSIONS_PERMISSION`,\\n    ///      that would have been way too tricky) or some bits required by `bot` disabled\\n    /// @dev Reverts if account has more active bots than allowed after changing permissions\\n    /// @dev Changes account's `BOT_PERMISSIONS_SET_FLAG` in the credit manager if needed\\n    function setBotPermissions(address bot, uint192 permissions) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IPriceOracleV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {IVersion} from \\\"./base/IVersion.sol\\\";\\n\\n/// @notice Price feed params\\n/// @param priceFeed Price feed address\\n/// @param stalenessPeriod Period (in seconds) after which price feed's answer should be considered stale\\n/// @param skipCheck Whether price feed implements its own safety and staleness checks\\n/// @param tokenDecimals Token decimals\\nstruct PriceFeedParams {\\n    address priceFeed;\\n    uint32 stalenessPeriod;\\n    bool skipCheck;\\n    uint8 tokenDecimals;\\n}\\n\\n/// @notice On-demand price update params\\n/// @param priceFeed Price feed to update, must be in the set of updatable feeds in the price oracle\\n/// @param data Update data\\nstruct PriceUpdate {\\n    address priceFeed;\\n    bytes data;\\n}\\n\\ninterface IPriceOracleV3Events {\\n    /// @notice Emitted when new price feed is set for token\\n    event SetPriceFeed(address indexed token, address indexed priceFeed, uint32 stalenessPeriod, bool skipCheck);\\n\\n    /// @notice Emitted when new reserve price feed is set for token\\n    event SetReservePriceFeed(address indexed token, address indexed priceFeed, uint32 stalenessPeriod, bool skipCheck);\\n\\n    /// @notice Emitted when new updatable price feed is added\\n    event AddUpdatablePriceFeed(address indexed priceFeed);\\n}\\n\\n/// @title Price oracle V3 interface\\ninterface IPriceOracleV3 is IVersion, IPriceOracleV3Events {\\n    function getTokens() external view returns (address[] memory);\\n\\n    function priceFeeds(address token) external view returns (address priceFeed);\\n\\n    function reservePriceFeeds(address token) external view returns (address);\\n\\n    function priceFeedParams(address token) external view returns (PriceFeedParams memory);\\n\\n    function reservePriceFeedParams(address token) external view returns (PriceFeedParams memory);\\n\\n    // ---------- //\\n    // CONVERSION //\\n    // ---------- //\\n\\n    function getPrice(address token) external view returns (uint256);\\n\\n    function getSafePrice(address token) external view returns (uint256);\\n\\n    function getReservePrice(address token) external view returns (uint256);\\n\\n    function convertToUSD(uint256 amount, address token) external view returns (uint256);\\n\\n    function convertFromUSD(uint256 amount, address token) external view returns (uint256);\\n\\n    function convert(uint256 amount, address tokenFrom, address tokenTo) external view returns (uint256);\\n\\n    function safeConvertToUSD(uint256 amount, address token) external view returns (uint256);\\n\\n    // ------------- //\\n    // PRICE UPDATES //\\n    // ------------- //\\n\\n    function getUpdatablePriceFeeds() external view returns (address[] memory);\\n\\n    function updatePrices(PriceUpdate[] calldata updates) external;\\n\\n    // ------------- //\\n    // CONFIGURATION //\\n    // ------------- //\\n\\n    function setPriceFeed(address token, address priceFeed, uint32 stalenessPeriod) external;\\n\\n    function setReservePriceFeed(address token, address priceFeed, uint32 stalenessPeriod) external;\\n\\n    function addUpdatablePriceFeed(address priceFeed) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\n/// @title Version interface\\n/// @notice Defines contract version\\ninterface IVersion {\\n    /// @notice Contract version\\n    function version() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/libraries/BalancesLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {SafeERC20} from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\nimport {BitMask} from \\\"./BitMask.sol\\\";\\n\\nstruct Balance {\\n    address token;\\n    uint256 balance;\\n}\\n\\nstruct BalanceWithMask {\\n    address token;\\n    uint256 tokenMask;\\n    uint256 balance;\\n}\\n\\nstruct BalanceDelta {\\n    address token;\\n    int256 amount;\\n}\\n\\nenum Comparison {\\n    GREATER,\\n    LESS\\n}\\n\\n/// @title Balances logic library\\n/// @notice Implements functions for before-and-after balance comparisons\\nlibrary BalancesLogic {\\n    using BitMask for uint256;\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Compares current `token` balance with `value`\\n    /// @param token Token to check balance for\\n    /// @param value Value to compare current token balance with\\n    /// @param comparison Whether current balance must be greater/less than or equal to `value`\\n    function checkBalance(address creditAccount, address token, uint256 value, Comparison comparison)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        uint256 current = IERC20(token).safeBalanceOf(creditAccount);\\n        return (comparison == Comparison.GREATER && current >= value)\\n            || (comparison == Comparison.LESS && current <= value); // U:[BLL-1]\\n    }\\n\\n    /// @dev Returns an array of expected token balances after operations\\n    /// @param creditAccount Credit account to compute balances for\\n    /// @param deltas Array of expected token balance changes\\n    function storeBalances(address creditAccount, BalanceDelta[] memory deltas)\\n        internal\\n        view\\n        returns (Balance[] memory balances)\\n    {\\n        uint256 len = deltas.length;\\n        balances = new Balance[](len); // U:[BLL-2]\\n        for (uint256 i = 0; i < len;) {\\n            int256 balance = IERC20(deltas[i].token).safeBalanceOf(creditAccount).toInt256();\\n            balances[i] = Balance({token: deltas[i].token, balance: (balance + deltas[i].amount).toUint256()}); // U:[BLL-2]\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Compares current balances with the previously stored ones\\n    /// @param creditAccount Credit account to compare balances for\\n    /// @param balances Array of previously stored balances\\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\\n    function compareBalances(address creditAccount, Balance[] memory balances, Comparison comparison)\\n        internal\\n        view\\n        returns (address failedToken)\\n    {\\n        unchecked {\\n            uint256 len = balances.length;\\n            for (uint256 i; i < len; ++i) {\\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\\n                    return balances[i].token; // U:[BLL-3]\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns balances of specified tokens on the credit account\\n    /// @param creditAccount Credit account to compute balances for\\n    /// @param tokensMask Bit mask of tokens to compute balances for\\n    /// @param getTokenByMaskFn Function that returns token's address by its mask\\n    function storeBalances(\\n        address creditAccount,\\n        uint256 tokensMask,\\n        function (uint256) view returns (address) getTokenByMaskFn\\n    ) internal view returns (BalanceWithMask[] memory balances) {\\n        if (tokensMask == 0) return balances;\\n\\n        balances = new BalanceWithMask[](tokensMask.calcEnabledTokens()); // U:[BLL-4]\\n        unchecked {\\n            uint256 i;\\n            while (tokensMask != 0) {\\n                uint256 tokenMask = tokensMask & uint256(-int256(tokensMask));\\n                tokensMask ^= tokenMask;\\n\\n                address token = getTokenByMaskFn(tokenMask);\\n                balances[i] = BalanceWithMask({\\n                    token: token,\\n                    tokenMask: tokenMask,\\n                    balance: IERC20(token).safeBalanceOf(creditAccount)\\n                }); // U:[BLL-4]\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Compares current balances of specified tokens with the previously stored ones\\n    /// @param creditAccount Credit account to compare balances for\\n    /// @param tokensMask Bit mask of tokens to compare balances for\\n    /// @param balances Array of previously stored balances\\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\\n    /// @dev This function assumes that `tokensMask` encodes a subset of tokens from `balances`\\n    function compareBalances(\\n        address creditAccount,\\n        uint256 tokensMask,\\n        BalanceWithMask[] memory balances,\\n        Comparison comparison\\n    ) internal view returns (address failedToken) {\\n        if (tokensMask == 0) return address(0);\\n\\n        unchecked {\\n            uint256 len = balances.length;\\n            for (uint256 i; i < len; ++i) {\\n                if (tokensMask & balances[i].tokenMask == 0) continue;\\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\\n                    return balances[i].token; // U:[BLL-5]\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/**\\n * @title Implements efficient safe methods for ERC20 interface.\\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\\n * 1. more gas-efficient, providing significant savings in transaction costs.\\n * 2. support for different permit implementations\\n * 3. forceApprove functionality\\n * 4. support for WETH deposit and withdraw\\n */\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    // Uniswap Permit2 address\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n\\n    /**\\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\\n     * Consumes less gas then regular `ERC20.balanceOf`.\\n     * @param token The IERC20 token contract for which the balance will be fetched.\\n     * @param account The address of the account whose token balance will be fetched.\\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\\n     */\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another.\\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom. \\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\\n     */\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(_PERMIT2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens to another address.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely increases the allowance of a spender.\\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to increase the allowance by.\\n     */\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /**\\n     * @notice Safely decreases the allowance of a spender.\\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to decrease the allowance by.\\n     */\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters. \\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param owner The owner of the tokens for which the permit is made.\\n     * @param spender The spender allowed to spend the tokens by the permit.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\\n     */\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    /**\\n     * @notice The function attempts to call the permit function on a given ERC20 token.\\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, and IPermit2.\\n     * It accommodates both Compact and Full formats of these permit types.\\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter \\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and \\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\\n     * before invocation for optimized performance.\\n     * @param token The address of the ERC20 token on which to call the permit function.\\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\\n     * @param spender The address which will be approved for transfer of tokens.\\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\\n     * @return success A boolean indicating whether the permit call was successful.\\n     */\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        // load function selectors for different permit standards\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // Switch case for different permit lengths, indicating different permit standards\\n            switch permit.length\\n            // Compact IERC20Permit\\n            case 100 {\\n                mstore(ptr, permitSelector)     // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // Compact IDaiLikePermit\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)  // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // IERC20Permit\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // IDaiLikePermit\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // Compact IPermit2\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)  // store selector\\n                mstore(add(ptr, 0x04), owner) // store owner\\n                mstore(add(ptr, 0x24), token) // store token\\n\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\\n                // and(0xffffffffffff, ...) - conversion to uint48 \\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\\n                mstore(add(ptr, 0xa4), spender)                               // store spender\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // IPermit2\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // Unknown\\n            default {\\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\\n                revert(ptr, 4)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param selector The function signature that is to be called on the token contract.\\n     * @param to The address to which the token amount will be transferred.\\n     * @param amount The token amount to be transferred.\\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure. \\n     * In case of success but no returned data, validates that the contract code exists.\\n     * In case of returned data, ensures that it's a boolean `true`.\\n     */\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of Ether to deposit into the IWETH contract.\\n     */\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        if (amount > 0) {\\n            bytes4 selector = IWETH.deposit.selector;\\n            assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                mstore(0, selector)\\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\\n     * @dev Uses inline assembly to interact with the IWETH contract.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     */\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\\n     * Consumes less gas then regular `IWETH.withdraw`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     * @param to The recipient of the withdrawn Ether.\\n     */\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\nimport {IncorrectParameterException} from \\\"../interfaces/IExceptions.sol\\\";\\n\\n/// @title Bit mask library\\n/// @notice Implements functions that manipulate bit masks\\n///         Bit masks are utilized extensively by Gearbox to efficiently store token sets (enabled tokens on accounts\\n///         or forbidden tokens) and check for set inclusion. A mask is a uint256 number that has its i-th bit set to\\n///         1 if i-th item is included into the set. For example, each token has a mask equal to 2**i, so set inclusion\\n///         can be checked by checking tokenMask & setMask != 0.\\nlibrary BitMask {\\n    /// @dev Calculates an index of an item based on its mask (using a binary search)\\n    /// @dev The input should always have only 1 bit set, otherwise the result may be unpredictable\\n    function calcIndex(uint256 mask) internal pure returns (uint8 index) {\\n        if (mask == 0) revert IncorrectParameterException(); // U:[BM-1]\\n        uint16 lb = 0; // U:[BM-2]\\n        uint16 ub = 256; // U:[BM-2]\\n        uint16 mid = 128; // U:[BM-2]\\n\\n        unchecked {\\n            while (true) {\\n                uint256 newMask = 1 << mid;\\n                if (newMask & mask != 0) return uint8(mid); // U:[BM-2]\\n\\n                if (newMask > mask) ub = mid; // U:[BM-2]\\n\\n                else lb = mid; // U:[BM-2]\\n                mid = (lb + ub) >> 1; // U:[BM-2]\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates the number of `1` bits\\n    /// @param enabledTokensMask Bit mask to compute the number of `1` bits in\\n    function calcEnabledTokens(uint256 enabledTokensMask) internal pure returns (uint256 totalTokensEnabled) {\\n        unchecked {\\n            while (enabledTokensMask > 0) {\\n                enabledTokensMask &= enabledTokensMask - 1; // U:[BM-3]\\n                ++totalTokensEnabled; // U:[BM-3]\\n            }\\n        }\\n    }\\n\\n    /// @dev Enables bits from the second mask in the first mask\\n    /// @param enabledTokenMask The initial mask\\n    /// @param bitsToEnable Mask of bits to enable\\n    function enable(uint256 enabledTokenMask, uint256 bitsToEnable) internal pure returns (uint256) {\\n        return enabledTokenMask | bitsToEnable; // U:[BM-4]\\n    }\\n\\n    /// @dev Disables bits from the second mask in the first mask\\n    /// @param enabledTokenMask The initial mask\\n    /// @param bitsToDisable Mask of bits to disable\\n    function disable(uint256 enabledTokenMask, uint256 bitsToDisable) internal pure returns (uint256) {\\n        return enabledTokenMask & ~bitsToDisable; // U:[BM-4]\\n    }\\n\\n    /// @dev Computes a new mask with sets of new enabled and disabled bits\\n    /// @dev bitsToEnable and bitsToDisable are applied sequentially to original mask\\n    /// @param enabledTokensMask The initial mask\\n    /// @param bitsToEnable Mask with bits to enable\\n    /// @param bitsToDisable Mask with bits to disable\\n    function enableDisable(uint256 enabledTokensMask, uint256 bitsToEnable, uint256 bitsToDisable)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (enabledTokensMask | bitsToEnable) & (~bitsToDisable); // U:[BM-5]\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDaiLikePermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPermit2 {\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n    /// @notice The permit message signed for a single token allownce\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n    /// @notice Packed allowance\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    event Deposit(address indexed dst, uint wad);\\n\\n    event Withdrawal(address indexed src, uint wad);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Revert reason forwarder.\\nlibrary RevertReasonForwarder {\\n    /// @dev Forwards latest externall call revert.\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2024.\\npragma solidity ^0.8.17;\\n\\n// ------- //\\n// GENERAL //\\n// ------- //\\n\\n/// @notice Thrown on attempting to set an important address to zero address\\nerror ZeroAddressException();\\n\\n/// @notice Thrown when attempting to pass a zero amount to a funding-related operation\\nerror AmountCantBeZeroException();\\n\\n/// @notice Thrown on incorrect input parameter\\nerror IncorrectParameterException();\\n\\n/// @notice Thrown when balance is insufficient to perform an operation\\nerror InsufficientBalanceException();\\n\\n/// @notice Thrown if parameter is out of range\\nerror ValueOutOfRangeException();\\n\\n/// @notice Thrown when trying to send ETH to a contract that is not allowed to receive ETH directly\\nerror ReceiveIsNotAllowedException();\\n\\n/// @notice Thrown on attempting to set an EOA as an important contract in the system\\nerror AddressIsNotContractException(address);\\n\\n/// @notice Thrown on attempting to receive a token that is not a collateral token or was forbidden\\nerror TokenNotAllowedException();\\n\\n/// @notice Thrown on attempting to add a token that is already in a collateral list\\nerror TokenAlreadyAddedException();\\n\\n/// @notice Thrown when attempting to use quota-related logic for a token that is not quoted in quota keeper\\nerror TokenIsNotQuotedException();\\n\\n/// @notice Thrown on attempting to interact with an address that is not a valid target contract\\nerror TargetContractNotAllowedException();\\n\\n/// @notice Thrown if function is not implemented\\nerror NotImplementedException();\\n\\n// ------------------ //\\n// CONTRACTS REGISTER //\\n// ------------------ //\\n\\n/// @notice Thrown when an address is expected to be a registered credit manager, but is not\\nerror RegisteredCreditManagerOnlyException();\\n\\n/// @notice Thrown when an address is expected to be a registered pool, but is not\\nerror RegisteredPoolOnlyException();\\n\\n// ---------------- //\\n// ADDRESS PROVIDER //\\n// ---------------- //\\n\\n/// @notice Reverts if address key isn't found in address provider\\nerror AddressNotFoundException();\\n\\n// ----------------- //\\n// POOL, PQK, GAUGES //\\n// ----------------- //\\n\\n/// @notice Thrown by pool-adjacent contracts when a credit manager being connected has a wrong pool address\\nerror IncompatibleCreditManagerException();\\n\\n/// @notice Thrown when attempting to set an incompatible successor staking contract\\nerror IncompatibleSuccessorException();\\n\\n/// @notice Thrown when attempting to vote in a non-approved contract\\nerror VotingContractNotAllowedException();\\n\\n/// @notice Thrown when attempting to unvote more votes than there are\\nerror InsufficientVotesException();\\n\\n/// @notice Thrown when attempting to borrow more than the second point on a two-point curve\\nerror BorrowingMoreThanU2ForbiddenException();\\n\\n/// @notice Thrown when a credit manager attempts to borrow more than its limit in the current block, or in general\\nerror CreditManagerCantBorrowException();\\n\\n/// @notice Thrown when attempting to connect a quota keeper to an incompatible pool\\nerror IncompatiblePoolQuotaKeeperException();\\n\\n/// @notice Thrown when the quota is outside of min/max bounds\\nerror QuotaIsOutOfBoundsException();\\n\\n// -------------- //\\n// CREDIT MANAGER //\\n// -------------- //\\n\\n/// @notice Thrown on failing a full collateral check after multicall\\nerror NotEnoughCollateralException();\\n\\n/// @notice Thrown if an attempt to approve a collateral token to adapter's target contract fails\\nerror AllowanceFailedException();\\n\\n/// @notice Thrown on attempting to perform an action for a credit account that does not exist\\nerror CreditAccountDoesNotExistException();\\n\\n/// @notice Thrown on configurator attempting to add more than 255 collateral tokens\\nerror TooManyTokensException();\\n\\n/// @notice Thrown if more than the maximum number of tokens were enabled on a credit account\\nerror TooManyEnabledTokensException();\\n\\n/// @notice Thrown when attempting to execute a protocol interaction without active credit account set\\nerror ActiveCreditAccountNotSetException();\\n\\n/// @notice Thrown when trying to update credit account's debt more than once in the same block\\nerror DebtUpdatedTwiceInOneBlockException();\\n\\n/// @notice Thrown when trying to repay all debt while having active quotas\\nerror DebtToZeroWithActiveQuotasException();\\n\\n/// @notice Thrown when a zero-debt account attempts to update quota\\nerror UpdateQuotaOnZeroDebtAccountException();\\n\\n/// @notice Thrown when attempting to close an account with non-zero debt\\nerror CloseAccountWithNonZeroDebtException();\\n\\n/// @notice Thrown when value of funds remaining on the account after liquidation is insufficient\\nerror InsufficientRemainingFundsException();\\n\\n/// @notice Thrown when Credit Facade tries to write over a non-zero active Credit Account\\nerror ActiveCreditAccountOverridenException();\\n\\n// ------------------- //\\n// CREDIT CONFIGURATOR //\\n// ------------------- //\\n\\n/// @notice Thrown on attempting to use a non-ERC20 contract or an EOA as a token\\nerror IncorrectTokenContractException();\\n\\n/// @notice Thrown if the newly set LT if zero or greater than the underlying's LT\\nerror IncorrectLiquidationThresholdException();\\n\\n/// @notice Thrown if borrowing limits are incorrect: minLimit > maxLimit or maxLimit > blockLimit\\nerror IncorrectLimitsException();\\n\\n/// @notice Thrown if the new expiration date is less than the current expiration date or current timestamp\\nerror IncorrectExpirationDateException();\\n\\n/// @notice Thrown if a contract returns a wrong credit manager or reverts when trying to retrieve it\\nerror IncompatibleContractException();\\n\\n/// @notice Thrown if attempting to forbid an adapter that is not registered in the credit manager\\nerror AdapterIsNotRegisteredException();\\n\\n// ------------- //\\n// CREDIT FACADE //\\n// ------------- //\\n\\n/// @notice Thrown when attempting to perform an action that is forbidden in whitelisted mode\\nerror ForbiddenInWhitelistedModeException();\\n\\n/// @notice Thrown if credit facade is not expirable, and attempted aciton requires expirability\\nerror NotAllowedWhenNotExpirableException();\\n\\n/// @notice Thrown if a selector that doesn't match any allowed function is passed to the credit facade in a multicall\\nerror UnknownMethodException(bytes4 selector);\\n\\n/// @notice Thrown if a liquidator tries to liquidate an account with a health factor above 1\\nerror CreditAccountNotLiquidatableException();\\n\\n/// @notice Thrown if too much new debt was taken within a single block\\nerror BorrowedBlockLimitException();\\n\\n/// @notice Thrown if the new debt principal for a credit account falls outside of borrowing limits\\nerror BorrowAmountOutOfLimitsException();\\n\\n/// @notice Thrown if a user attempts to open an account via an expired credit facade\\nerror NotAllowedAfterExpirationException();\\n\\n/// @notice Thrown if expected balances are attempted to be set twice without performing a slippage check\\nerror ExpectedBalancesAlreadySetException();\\n\\n/// @notice Thrown if attempting to perform a slippage check when excepted balances are not set\\nerror ExpectedBalancesNotSetException();\\n\\n/// @notice Thrown if balance of at least one token is less than expected during a slippage check\\nerror BalanceLessThanExpectedException(address token);\\n\\n/// @notice Thrown when trying to perform an action that is forbidden when credit account has enabled forbidden tokens\\nerror ForbiddenTokensException(uint256 forbiddenTokensMask);\\n\\n/// @notice Thrown when forbidden token quota is increased during the multicall\\nerror ForbiddenTokenQuotaIncreasedException(address token);\\n\\n/// @notice Thrown when enabled forbidden token balance is increased during the multicall\\nerror ForbiddenTokenBalanceIncreasedException(address token);\\n\\n/// @notice Thrown when the remaining token balance is increased during the liquidation\\nerror RemainingTokenBalanceIncreasedException(address token);\\n\\n/// @notice Thrown if `botMulticall` is called by an address that is not approved by account owner or is forbidden\\nerror NotApprovedBotException(address bot);\\n\\n/// @notice Thrown when attempting to perform a multicall action with no permission for it\\nerror NoPermissionException(uint256 permission);\\n\\n/// @notice Thrown when attempting to give a bot unexpected permissions\\nerror UnexpectedPermissionsException(uint256 permissions);\\n\\n/// @notice Thrown when a custom HF parameter lower than 10000 is passed into the full collateral check\\nerror CustomHealthFactorTooLowException();\\n\\n/// @notice Thrown when submitted collateral hint is not a valid token mask\\nerror InvalidCollateralHintException(uint256 mask);\\n\\n/// @notice Thrown when trying to seize underlying token during partial liquidation\\nerror UnderlyingIsNotLiquidatableException();\\n\\n/// @notice Thrown when amount of collateral seized during partial liquidation is less than required\\nerror SeizedLessThanRequiredException(uint256 seizedAmount);\\n\\n// ------ //\\n// ACCESS //\\n// ------ //\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit account owner\\nerror CallerNotCreditAccountOwnerException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as configurator\\nerror CallerNotConfiguratorException();\\n\\n/// @notice Thrown on attempting to call an access-restructed function not as account factory\\nerror CallerNotAccountFactoryException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit manager\\nerror CallerNotCreditManagerException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit facade\\nerror CallerNotCreditFacadeException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as controller or configurator\\nerror CallerNotControllerException();\\n\\n/// @notice Thrown on attempting to pause a contract without pausable admin rights\\nerror CallerNotPausableAdminException();\\n\\n/// @notice Thrown on attempting to unpause a contract without unpausable admin rights\\nerror CallerNotUnpausableAdminException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as gauge\\nerror CallerNotGaugeException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as quota keeper\\nerror CallerNotPoolQuotaKeeperException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as voter\\nerror CallerNotVoterException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as allowed adapter\\nerror CallerNotAdapterException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as migrator\\nerror CallerNotMigratorException();\\n\\n/// @notice Thrown when an address that is not the designated executor attempts to execute a transaction\\nerror CallerNotExecutorException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as veto admin\\nerror CallerNotVetoAdminException();\\n\\n// ------------------- //\\n// CONTROLLER TIMELOCK //\\n// ------------------- //\\n\\n/// @notice Thrown when the new parameter values do not satisfy required conditions\\nerror ParameterChecksFailedException();\\n\\n/// @notice Thrown when attempting to execute a non-queued transaction\\nerror TxNotQueuedException();\\n\\n/// @notice Thrown when attempting to execute a transaction that is either immature or stale\\nerror TxExecutedOutsideTimeWindowException();\\n\\n/// @notice Thrown when execution of a transaction fails\\nerror TxExecutionRevertedException();\\n\\n/// @notice Thrown when the value of a parameter on execution is different from the value on queue\\nerror ParameterChangedAfterQueuedTxException();\\n\\n// -------- //\\n// BOT LIST //\\n// -------- //\\n\\n/// @notice Thrown when attempting to set non-zero permissions for a forbidden bot\\nerror InvalidBotException();\\n\\n/// @notice Thrown when attempting to set permissions for a bot that don't meet its requirements\\nerror InsufficientBotPermissionsException();\\n\\n// --------------- //\\n// ACCOUNT FACTORY //\\n// --------------- //\\n\\n/// @notice Thrown when trying to deploy second master credit account for a credit manager\\nerror MasterCreditAccountAlreadyDeployedException();\\n\\n/// @notice Thrown when trying to rescue funds from a credit account that is currently in use\\nerror CreditAccountIsInUseException();\\n\\n// ------------ //\\n// PRICE ORACLE //\\n// ------------ //\\n\\n/// @notice Thrown on attempting to set a token price feed to an address that is not a correct price feed\\nerror IncorrectPriceFeedException();\\n\\n/// @notice Thrown on attempting to interact with a price feed for a token not added to the price oracle\\nerror PriceFeedDoesNotExistException();\\n\\n/// @notice Thrown when trying to apply an on-demand price update to a non-updatable price feed\\nerror PriceFeedIsNotUpdatableException();\\n\\n/// @notice Thrown when price feed returns incorrect price for a token\\nerror IncorrectPriceException();\\n\\n/// @notice Thrown when token's price feed becomes stale\\nerror StalePriceException();\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@1inch/=node_modules/@1inch/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@gearbox-protocol/=node_modules/@gearbox-protocol/\",\r\n      \"@redstone-finance/=node_modules/@redstone-finance/\",\r\n      \"@pythnetwork/=node_modules/@pythnetwork/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_gearboxPhantomTokenType\",\"outputs\":[{\"internalType\":\"enum PhantomTokenType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creditAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalMultiCall\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zircuitPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZircuitPhantomToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000f047ab4c75cebf0eb9ed34ae2c186f3611aeafa6000000000000000000000000d9a442856c234a39a81a089c06451ebaa4306a72", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}