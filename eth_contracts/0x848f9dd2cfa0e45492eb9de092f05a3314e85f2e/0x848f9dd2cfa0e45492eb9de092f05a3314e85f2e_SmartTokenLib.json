{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"CanReclaimToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n/**\\n * @title Contracts that should be able to recover tokens\\n * @author SylTi\\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\\n * This will prevent any accidental loss of tokens.\\n */\\ncontract CanReclaimToken is Ownable {\\n    using SafeERC20 for ERC20Basic;\\n\\n    /**\\n     * @dev Reclaim all ERC20Basic compatible tokens\\n     * @param _token ERC20Basic The address of the token contract\\n     */\\n    function reclaimToken(ERC20Basic _token) external onlyOwner {\\n        uint256 balance = _token.balanceOf(address(this));\\n        _token.safeTransfer(owner, balance);\\n    }\\n}\\n\"},\"Claimable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\nabstract contract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    /**\\n     * @dev emitted when the pendingOwner address is changed\\n     * @param previousPendingOwner previous pendingOwner address\\n     * @param newPendingOwner new pendingOwner address\\n     */\\n    event OwnershipTransferPending(\\n        address indexed previousPendingOwner,\\n        address indexed newPendingOwner\\n    );\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingOwner.\\n     */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to set the pendingOwner address.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public virtual override onlyOwner {\\n        emit OwnershipTransferPending(pendingOwner, newOwner);\\n        pendingOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\n     */\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs \\u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) \\u003e\\u003e 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function balanceOf(address _who) public view virtual returns (uint256);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public virtual returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"ERC20Lib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./TokenStorage.sol\\\";\\n\\n/**\\n * @title ERC20Lib\\n * @dev Standard ERC20 token functionality.\\n * https://github.com/ethereum/EIPs/issues/20\\n */\\nlibrary ERC20Lib {\\n    /**\\n     * @dev Transfers tokens [ERC20].\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transfer(\\n        TokenStorage db,\\n        address caller,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        db.subBalance(caller, amount);\\n        db.addBalance(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from a specific address [ERC20].\\n     * The address owner has to approve the spender beforehand.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param from Address to debet the tokens from.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transferFrom(\\n        TokenStorage db,\\n        address caller,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        uint256 allowance_ = db.getAllowed(from, caller);\\n        db.subBalance(from, amount);\\n        db.addBalance(to, amount);\\n        db.setAllowed(from, caller, allowance_ - amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a spender [ERC20].\\n     * Note that using the approve/transferFrom presents a possible\\n     * security vulnerability described in:\\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\\n     * Use transferAndCall to mitigate.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param spender The address of the future spender.\\n     * @param amount The allowance of the spender.\\n     */\\n    function approve(\\n        TokenStorage db,\\n        address caller,\\n        address spender,\\n        uint256 amount\\n    ) public returns (bool success) {\\n        db.setAllowed(caller, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the number tokens associated with an address.\\n     * @param db Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return balance Balance of address.\\n     */\\n    function balanceOf(\\n        TokenStorage db,\\n        address who\\n    ) external view returns (uint256 balance) {\\n        return db.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender\\n     * @param db Token storage to operate on.\\n     * @param owner The address of the owner of the tokens.\\n     * @param spender The address of the spender.\\n     * @return remaining Number of tokens the spender is allowed to spend.\\n     */\\n    function allowance(\\n        TokenStorage db,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256 remaining) {\\n        return db.getAllowed(owner, spender);\\n    }\\n}\\n\"},\"HasNoContracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Contracts\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\\n * of this contract to reclaim ownership of the contracts.\\n */\\ncontract HasNoContracts is Ownable {\\n    /**\\n     * @dev Reclaim ownership of Ownable contracts\\n     * @param _contractAddr The address of the Ownable to be reclaimed.\\n     */\\n    function reclaimContract(address _contractAddr) external onlyOwner {\\n        Ownable contractInst = Ownable(_contractAddr);\\n        contractInst.transferOwnership(owner);\\n    }\\n}\\n\"},\"HasNoEther.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Ether\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\\n * in the contract, it will allow the owner to reclaim this Ether.\\n * @notice Ether can still be sent to this contract by:\\n * calling functions labeled `payable`\\n * `selfdestruct(contract_address)`\\n * mining directly to the contract address\\n */\\ncontract HasNoEther is Ownable {\\n    /**\\n     * @dev Constructor that rejects incoming Ether\\n     * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\\n     * leave out payable, then Solidity will allow inheriting contracts to implement a payable\\n     * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\\n     * we could use assembly to access msg.value.\\n     */\\n    constructor() payable {\\n        require(msg.value == 0);\\n    }\\n\\n    /**\\n     * @dev Disallows direct send by setting a default function without the `payable` flag.\\n     */\\n    fallback() external {}\\n\\n    /**\\n     * @dev Transfer all Ether held by the contract to the owner.\\n     */\\n    function reclaimEther() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"},\"HasNoTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./CanReclaimToken.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Tokens\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\\n * owner to reclaim the tokens.\\n */\\ncontract HasNoTokens is CanReclaimToken {\\n    /**\\n     * @dev Reject all ERC223 compatible tokens\\n     * @param _from address The address that is transferring the tokens\\n     * @param _value uint256 the amount of the specified token\\n     * @param _data Bytes The data passed from the caller.\\n     */\\n    function tokenFallback(\\n        address _from,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external pure {\\n        _from;\\n        _value;\\n        _data;\\n        revert();\\n    }\\n}\\n\"},\"IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"IValidator.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\n/**\\n * @title IValidator\\n * @dev Contracts implementing this interface validate token transfers.\\n */\\ninterface IValidator {\\n    /**\\n     * @dev Emitted when a validator makes a decision.\\n     * @param from Sender address.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens.\\n     * @param valid True if transfer approved, false if rejected.\\n     */\\n    event Decision(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bool valid\\n    );\\n\\n    /**\\n     * @dev Validates token transfer.\\n     * If the sender is on the blacklist the transfer is denied.\\n     * @param from Sender address.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens.\\n     */\\n    function validate(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool valid);\\n}\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a \\u0026 b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator \\u003e prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always \\u003e= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator \\u0026 (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\\u0027s lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don\\u0027t need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up \\u0026\\u0026 mulmod(x, y, denominator) \\u003e 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.\\u0027s \\\"Hacker\\u0027s Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) \\u003c= a \\u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) \\u003c= a \\u003c 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) \\u003c= sqrt(a) \\u003c sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) \\u003c= sqrt(a) \\u003c 2**((k+1)/2) \\u003c= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 \\u003c\\u003c (log2(a) \\u003e\\u003e 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton\\u0027s method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            result = (result + a / result) \\u003e\\u003e 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up \\u0026\\u0026 result * result \\u003c a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\n                value \\u003e\\u003e= 128;\\n                result += 128;\\n            }\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\n                value \\u003e\\u003e= 64;\\n                result += 64;\\n            }\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\n                value \\u003e\\u003e= 32;\\n                result += 32;\\n            }\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\n                value \\u003e\\u003e= 16;\\n                result += 16;\\n            }\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\n                value \\u003e\\u003e= 8;\\n                result += 8;\\n            }\\n            if (value \\u003e\\u003e 4 \\u003e 0) {\\n                value \\u003e\\u003e= 4;\\n                result += 4;\\n            }\\n            if (value \\u003e\\u003e 2 \\u003e 0) {\\n                value \\u003e\\u003e= 2;\\n                result += 2;\\n            }\\n            if (value \\u003e\\u003e 1 \\u003e 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up \\u0026\\u0026 1 \\u003c\\u003c result \\u003c value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value \\u003e= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value \\u003e= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value \\u003e= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value \\u003e= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value \\u003e= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value \\u003e= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value \\u003e= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up \\u0026\\u0026 10**result \\u003c value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\n                value \\u003e\\u003e= 128;\\n                result += 16;\\n            }\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\n                value \\u003e\\u003e= 64;\\n                result += 8;\\n            }\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\n                value \\u003e\\u003e= 32;\\n                result += 4;\\n            }\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\n                value \\u003e\\u003e= 16;\\n                result += 2;\\n            }\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up \\u0026\\u0026 1 \\u003c\\u003c (result * 8) \\u003c value ? 1 : 0);\\n        }\\n    }\\n}\\n\"},\"MintableTokenLib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./SignatureChecker.sol\\\";\\nimport \\\"./ERC20Lib.sol\\\";\\nimport \\\"./TokenStorage.sol\\\";\\n\\n/**\\n * @title Mintable token\\n * @dev Simple ERC20 Token example, with mintable token creation\\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\\n */\\n\\nlibrary MintableTokenLib {\\n    using SignatureChecker for address;\\n\\n    /**\\n     * @dev Mints new tokens.\\n     * @param db Token storage to operate on.\\n     * @param to The address that will recieve the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     */\\n    function mint(\\n        TokenStorage db,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool) {\\n        db.addBalance(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burns tokens.\\n     * @param db Token storage to operate on.\\n     * @param from The address holding tokens.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(\\n        TokenStorage db,\\n        address from,\\n        uint256 amount\\n    ) public returns (bool) {\\n        db.subBalance(from, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burns tokens from a specific address.\\n     * To burn the tokens the caller needs to provide a signature\\n     * proving that the caller is authorized by the token owner to do so.\\n     * @param db Token storage to operate on.\\n     * @param from The address holding tokens.\\n     * @param amount The amount of tokens to burn.\\n     * @param h Hash which the token owner signed.\\n     * @param v Signature component.\\n     * @param r Signature component.\\n     * @param s Sigature component.\\n     */\\n    function burn(\\n        TokenStorage db,\\n        address from,\\n        uint256 amount,\\n        bytes32 h,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (bool) {\\n        bytes memory signature;\\n        if (r != bytes32(0) || s != bytes32(0)) {\\n            signature = bytes(abi.encodePacked(r, s, v));\\n        }\\n        require(\\n            from.isValidSignatureNow(h, signature),\\n            \\\"signature/hash does not match\\\"\\n        );\\n        return burn(db, from, amount);\\n    }\\n}\\n\"},\"NoOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./HasNoEther.sol\\\";\\nimport \\\"./HasNoTokens.sol\\\";\\nimport \\\"./HasNoContracts.sol\\\";\\n\\n/**\\n * @title Base contract for contracts that should not own things.\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\\n * Owned contracts. See respective base contracts for details.\\n */\\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0));\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20Basic _token,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        require(_token.transfer(_to, _value));\\n    }\\n}\\n\"},\"SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it\\u0027s validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError \\u0026\\u0026 recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success \\u0026\\u0026\\n            result.length == 32 \\u0026\\u0026\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"},\"SmartTokenLib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./ERC20Lib.sol\\\";\\nimport \\\"./MintableTokenLib.sol\\\";\\nimport \\\"./IValidator.sol\\\";\\nimport \\\"./SignatureChecker.sol\\\";\\n\\n/**\\n * @title SmartTokenLib\\n * @dev This library provides functionality which is required from a regulatory perspective.\\n */\\nlibrary SmartTokenLib {\\n    using ERC20Lib for TokenStorage;\\n    using MintableTokenLib for TokenStorage;\\n    using SignatureChecker for address;\\n\\n    struct SmartStorage {\\n        IValidator validator;\\n    }\\n\\n    /**\\n     * @dev Emitted when the contract owner recovers tokens.\\n     * @param from Sender address.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens.\\n     */\\n    event Recovered(address indexed from, address indexed to, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when updating the validator.\\n     * @param old Address of the old validator.\\n     * @param current Address of the new validator.\\n     */\\n    event Validator(address indexed old, address indexed current);\\n\\n    /**\\n     * @dev Sets a new validator.\\n     * @param self Smart storage to operate on.\\n     * @param validator Address of validator.\\n     */\\n    function setValidator(\\n        SmartStorage storage self,\\n        address validator\\n    ) external {\\n        emit Validator(address(self.validator), validator);\\n        self.validator = IValidator(validator);\\n    }\\n\\n    /**\\n     * @dev Approves or rejects a transfer request.\\n     * The request is forwarded to a validator which implements\\n     * the actual business logic.\\n     * @param self Smart storage to operate on.\\n     * @param from Sender address.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens.\\n     */\\n    function validate(\\n        SmartStorage storage self,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool valid) {\\n        return self.validator.validate(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Recovers tokens from an address and reissues them to another address.\\n     * In case a user loses its private key the tokens can be recovered by burning\\n     * the tokens from that address and reissuing to a new address.\\n     * To recover tokens the contract owner needs to provide a signature\\n     * proving that the token owner has authorized the owner to do so.\\n     * @param from Address to burn tokens from.\\n     * @param to Address to mint tokens to.\\n     * @param h Hash which the token owner signed.\\n     * @param v Signature component.\\n     * @param r Signature component.\\n     * @param s Sigature component.\\n     * @return Amount recovered.\\n     */\\n    function recover(\\n        TokenStorage token,\\n        address from,\\n        address to,\\n        bytes32 h,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256) {\\n        bytes memory signature;\\n        if (r != bytes32(0) || s != bytes32(0)) {\\n            signature = bytes(abi.encodePacked(r, s, v));\\n        }\\n        require(\\n            from.isValidSignatureNow(h, signature),\\n            \\\"signature/hash does not recover from address\\\"\\n        );\\n        uint256 amount = token.balanceOf(from);\\n        require(token.burn(from, amount), \\\"burn failed\\\");\\n        require(token.mint(to, amount), \\\"mint failed\\\");\\n        emit Recovered(from, to, amount);\\n        return amount;\\n    }\\n\\n    /**\\n     * @dev Gets the current validator.\\n     * @param self Smart storage to operate on.\\n     * @return Address of validator.\\n     */\\n    function getValidator(\\n        SmartStorage storage self\\n    ) external view returns (address) {\\n        return address(self.validator);\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"},\"TokenStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./Claimable.sol\\\";\\nimport \\\"./CanReclaimToken.sol\\\";\\nimport \\\"./NoOwner.sol\\\";\\nimport \\\"./TokenStorageLib.sol\\\";\\n\\n/**\\n * @title TokenStorage\\n * @dev External storage for tokens.\\n * The storage is implemented in a separate contract to maintain state\\n * between token upgrades.\\n */\\ncontract TokenStorage is Claimable, CanReclaimToken, NoOwner {\\n    using TokenStorageLib for TokenStorageLib.TokenStorage;\\n\\n    TokenStorageLib.TokenStorage internal tokenStorage;\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(address to, uint256 amount) external onlyOwner {\\n        tokenStorage.addBalance(to, amount);\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(address from, uint256 amount) external onlyOwner {\\n        tokenStorage.subBalance(from, amount);\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Quantity of allowance.\\n     */\\n    function setAllowed(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external onlyOwner {\\n        tokenStorage.setAllowed(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @return Total supply.\\n     */\\n    function getSupply() external view returns (uint256) {\\n        return tokenStorage.getSupply();\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(address who) external view returns (uint256) {\\n        return tokenStorage.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256) {\\n        return tokenStorage.getAllowed(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Explicit override of transferOwnership from Claimable and Ownable\\n     * @param newOwner Address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public override(Claimable, Ownable) {\\n        Claimable.transferOwnership(newOwner);\\n    }\\n}\\n\"},\"TokenStorageLib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\n/*\\n * @title TokenStorageLib\\n * @dev Implementation of an[external storage for tokens.\\n */\\nlibrary TokenStorageLib {\\n    struct TokenStorage {\\n        mapping(address =\\u003e uint) balances;\\n        mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n        uint256 totalSupply;\\n    }\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(\\n        TokenStorage storage self,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply + amount;\\n        self.balances[to] = self.balances[to] + amount;\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(\\n        TokenStorage storage self,\\n        address from,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply - amount;\\n        self.balances[from] = self.balances[from] - amount;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Qunatity of allowance.\\n     */\\n    function setAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external {\\n        self.allowed[owner][spender] = amount;\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @param self Token storage to operate on.\\n     * @return Total supply.\\n     */\\n    function getSupply(TokenStorage storage self) external view returns (uint) {\\n        return self.totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(\\n        TokenStorage storage self,\\n        address who\\n    ) external view returns (uint) {\\n        return self.balances[who];\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender\\n    ) external view returns (uint) {\\n        return self.allowed[owner][spender];\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"Validator\",\"type\":\"event\"}]", "ContractName": "SmartTokenLib", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "ERC20Lib:e75f9618bfc1772a35568bd95ed1a0b57a13297b;MintableTokenLib:094c57f773a7f821ba5e2b1c9912bdfec6ab1864", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e9747acd23a7bfd2a8c89a32091d446d180758eccde262d7695a84bd0f125c80"}