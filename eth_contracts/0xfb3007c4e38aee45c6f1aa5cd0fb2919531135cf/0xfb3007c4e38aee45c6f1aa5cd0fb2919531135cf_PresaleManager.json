{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PresaleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./PresaleV4.sol\\\";\\nimport \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\ncontract PresaleManager is Ownable {\\n    address public poolCreationFeeRecipient;\\n    uint256 public poolCreationFeeAmount;\\n    address public presaleTemplateContractAddress;\\n\\n    uint8 public tokensPercentageForFee = 2;\\n    uint8 public minLiquidityPercent = 30;\\n\\n    mapping(address => bool) public poolCreationFeePaid;\\n    mapping(address => bool) public operators;\\n    mapping(address => address) public poolAddress;\\n\\n    struct Presale {\\n        uint256 uid;\\n        address tokenAddress;\\n        address presaleAddress;\\n        address owner;\\n    }\\n\\n    Presale[] public presales;\\n\\n    event PresaleContractShadowDeployed(address indexed presaleAddress);\\n    event PresaleContractTemplateAddressChanged(address indexed presaleTemplateContractAddress);\\n\\n    event PoolDeployed(address indexed tokenAddress, address indexed presaleAddress, address indexed owner);\\n\\n    constructor() {\\n        poolCreationFeeRecipient = msg.sender;\\n        poolCreationFeeAmount = 0 ether;\\n        operators[msg.sender] = true;\\n        operators[0x1934971a280F8f60057c4b87d0189E407dBb1c5C] = true; //jimango test\\n        operators[0x45Be1c5f509FEbF4DFE291c98450B4278D3D44Ef] = true; // presale deployer\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender] == true || msg.sender == owner(), \\\"Not operator\\\");\\n        _;\\n    }\\n\\n    event FeePaid(address indexed tokenAddress, address indexed buyer, uint256 amount);\\n\\n    event OperatorAccessModified(address indexed operator, bool access);\\n\\n    event FeeOptionsChanged(address poolCreationFeeRecipient, uint256 poolCreationFeeAmount);\\n\\n\\n    function changeTokensForFee(uint8 _tokensPercentageForFee) public onlyOwner {\\n        tokensPercentageForFee = _tokensPercentageForFee;\\n    }\\n\\n    function changeMinLiquidityPercent(uint8 _minLiquidityPercent) public onlyOwner {\\n        minLiquidityPercent = _minLiquidityPercent;\\n    }\\n\\n    function changeOperatorAccess(address operator, bool access) public onlyOwner {\\n        operators[operator] = access;\\n\\n        emit OperatorAccessModified(operator, access);\\n    }\\n\\n    function setPoolCreationFeePaid(address tokenAddress, bool paid) public onlyOperator {\\n        poolCreationFeePaid[tokenAddress] = paid;\\n    }\\n\\n    function changeFeeOptions(address _poolCreationFeeRecipient, uint256 _poolCreationFeeAmount) public onlyOwner {\\n        poolCreationFeeRecipient = _poolCreationFeeRecipient;\\n        poolCreationFeeAmount = _poolCreationFeeAmount;\\n\\n        emit FeeOptionsChanged(poolCreationFeeRecipient, poolCreationFeeAmount);\\n    }\\n\\n    function _sendEtherUsingCall(address payable _to, uint256 _amount, string memory _errorMessage) internal {\\n        (bool success,) = _to.call{value: _amount}(\\\"\\\");\\n        require(success, _errorMessage);\\n    }\\n\\n    function createPool(\\n        uint8 _paymentMethod,\\n        address _routerAddress,\\n        address _tokenAddress,\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 totalSaleAmount,\\n        uint256 softCap, // 100\\n        uint256 hardCap, // 1000\\n        uint256 _minContribution,\\n        uint256 _maxContribution,\\n        uint256 _liquidityPercent\\n    ) public payable {\\n        uint256 _totalTokensForSale = totalSaleAmount;\\n\\n        // Payment method 1 - flat BASE fee\\n        // Payment method 2 - 2% of total tokens being sold\\n\\n        bool _isOperator = operators[msg.sender];\\n        if(!_isOperator && _liquidityPercent < minLiquidityPercent) {\\n            revert(\\\"Liquidity percent is lower than min\\\");  \\n        }\\n\\n\\n        if (_paymentMethod == 1) {\\n            require(msg.value >= poolCreationFeeAmount, \\\"InsuffEthFee\\\");\\n\\n            // Transfer the fee to the fee collector wallet\\n            _sendEtherUsingCall(payable(poolCreationFeeRecipient), msg.value, \\\"EFTF\\\");\\n\\n        } else if (_paymentMethod == 2) {\\n            uint256 _fee = (_totalTokensForSale * tokensPercentageForFee) / 100;\\n            _totalTokensForSale = _totalTokensForSale - _fee;\\n\\n            require(\\n                IERC20(_tokenAddress).transferFrom(msg.sender, poolCreationFeeRecipient, _fee), \\\"TFTF\\\"\\n            );\\n\\n        } else {\\n            revert(\\\"Invalid payment method\\\");\\n        }\\n        // // Only allow creating a pool once per token\\n        require(poolCreationFeePaid[_tokenAddress] == false, \\\"PoolExists\\\");\\n\\n        poolCreationFeePaid[_tokenAddress] = true;\\n\\n        // Create the presale\\n        PresaleV4 presale = new PresaleV4(\\n            _routerAddress,\\n            _tokenAddress,\\n            _start,\\n            _end,\\n            _totalTokensForSale,\\n            softCap,\\n            hardCap,\\n            _minContribution,\\n            _maxContribution,\\n            _liquidityPercent,\\n            msg.sender\\n        );\\n\\n        // Transfer the tokens to the presale\\n        IERC20(_tokenAddress).transferFrom(msg.sender, address(presale), _totalTokensForSale);\\n\\n        // Create an item in the presales array\\n        presales.push(\\n            Presale({\\n                uid: presales.length,\\n                tokenAddress: _tokenAddress,\\n                presaleAddress: address(presale),\\n                owner: msg.sender\\n            })\\n        );\\n\\n        poolAddress[_tokenAddress] = address(presale);\\n\\n        emit PoolDeployed(_tokenAddress, address(presale), msg.sender);\\n\\n        emit FeePaid(_tokenAddress, msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/PresaleV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\n\\ninterface IERC20 {\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n}\\n\\ncontract PresaleV4 is Ownable {\\n    error InvalidStartTime();\\n    error InvalidEndTime();\\n    error ZeroSaleAmount();\\n    error ZeroSoftCap();\\n    error InvalidHardCap();\\n    error SaleNotStarted();\\n    error SaleEndedError();\\n    error SaleAlreadyEnded();\\n    error ZeroContribution();\\n    error HardCapReached();\\n    error ZeroTokensBought();\\n    error SaleCancelled();\\n    error SaleNotCancelled();\\n    error NoMultipleClaims();\\n    error SaleNotEndedYet();\\n    error InvalidRefundAmount();\\n    error ZeroUnsoldTokens();\\n    error TransferFailed();\\n    error AlreadySetup();\\n    error ContractNotSetup();\\n    error MinContributionNotMet();\\n    error MaxContributionExceeded();\\n    error InvalidContributionDefiningBounds();\\n    error NotWhitelisted();\\n\\n    address public routerAddress;\\n\\n    address public tokenAddress;\\n    uint8 public tokenDecimals;\\n    uint256 public totalSaleAmount;\\n    uint256 public tokenPrice;\\n    uint256 public softCap;\\n    uint256 public hardCap;\\n\\n    uint256 public minContribution;\\n    uint256 public maxContribution;\\n\\n    uint256 public liquidityPercent;\\n    uint256 public liquidityTokens;\\n\\n    bool public softCapReached;\\n    bool public saleFinished;\\n    bool public saleCancelled;\\n    bool public whitelistEnabled = false;\\n\\n    bool public hasOwnerFinishedSale = false;\\n\\n    uint256 public totalTokensBought;\\n    uint256 public startTimestamp;\\n    uint256 public endTimestamp;\\n\\n\\n    mapping(address => uint256) public contribution;\\n    mapping(address => uint256) public unclaimedTokens;\\n    mapping(address => uint256) public claimedTokens;\\n\\n    mapping(address => bool) public hasRefunded;\\n    mapping(address => bool) public hasClaimedTokens;\\n\\n    address[] public buyers;\\n\\n    uint256 public totalContributionsETH;\\n    address public presaleWithdrawDestination;\\n\\n    event TokensBought(address indexed buyer, uint256 amount);\\n    event TokensClaimed(address indexed claimer, uint256 amount);\\n    event SaleEnded(uint256 totalAmountBought, bool softCapReached);\\n    event SaleHasCancelled(address indexed owner, uint256 totalAmountBought, uint256 totalContributionsETH);\\n    event EmergencyWithdrawTokens(uint256 amount);\\n    event ContributionRefunded(address indexed buyer, uint256 amount);\\n\\n    bytes32 public merkleRoot;\\n\\n    function setWhitelistEnabled(bool _whitelistEnabled) external onlyOwner {\\n        whitelistEnabled = _whitelistEnabled;\\n    }\\n\\n    function updateMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\\n        merkleRoot = _merkleRoot;\\n        whitelistEnabled = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    constructor(\\n        address _routerAddress,\\n        address _tokenAddress,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp,\\n        uint256 _totalSaleAmount,\\n        uint256 _softCap, // 100\\n        uint256 _hardCap, // 1000\\n        uint256 _minContribution,\\n        uint256 _maxContribution,\\n        uint256 _liquidityPercent,\\n        address _presaleWithdrawDestination\\n    ) {\\n        routerAddress = _routerAddress;\\n        liquidityPercent = _liquidityPercent;\\n\\n        if (_startTimestamp < block.timestamp) {\\n            _startTimestamp = block.timestamp;\\n        }\\n\\n        if (_endTimestamp <= _startTimestamp) revert InvalidEndTime();\\n\\n        if (_totalSaleAmount == 0) revert ZeroSaleAmount();\\n\\n        if (_softCap == 0) revert ZeroSoftCap();\\n\\n        if (_hardCap <= _softCap) revert InvalidHardCap();\\n\\n        if (_minContribution != 0 && _maxContribution != 0) {\\n            if (_minContribution > _maxContribution) {\\n                revert InvalidContributionDefiningBounds();\\n            }\\n\\n            minContribution = _minContribution;\\n            maxContribution = _maxContribution;\\n        }\\n\\n        tokenDecimals = IERC20(_tokenAddress).decimals();\\n        uint256 normalise_multiplier = 10 ** uint256(18 - tokenDecimals);\\n\\n        liquidityTokens = (_totalSaleAmount * liquidityPercent) / 100;\\n        uint256 saleTokens = _totalSaleAmount - liquidityTokens;\\n\\n        endTimestamp = _endTimestamp;\\n        tokenAddress = _tokenAddress;\\n        softCap = _softCap;\\n        hardCap = _hardCap;\\n        totalSaleAmount = saleTokens;\\n        tokenPrice = (totalSaleAmount * normalise_multiplier) / hardCap;\\n        presaleWithdrawDestination = _presaleWithdrawDestination;\\n\\n        transferOwnership(presaleWithdrawDestination);\\n    }\\n\\n    /**\\n     * @notice Buys tokens with ETH.\\n     */\\n    function buy(bytes32[] memory proof) external payable {\\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(msg.sender, 0))));\\n\\n        if (block.timestamp < startTimestamp) revert SaleNotStarted();\\n        if (block.timestamp > endTimestamp) revert SaleEndedError();\\n        if (msg.value == 0) revert ZeroContribution();\\n        if (saleFinished) revert SaleEndedError();\\n        if (whitelistEnabled && !MerkleProof.verify(proof, merkleRoot, leaf)) {\\n            revert NotWhitelisted();\\n        }\\n\\n        if (minContribution != 0 && maxContribution != 0) {\\n            if (msg.value < minContribution) revert MinContributionNotMet();\\n            if (msg.value > maxContribution) revert MaxContributionExceeded();\\n        }\\n\\n        if (totalContributionsETH + msg.value > hardCap) {\\n            revert HardCapReached();\\n        }\\n\\n        uint256 normalise_multiplier = 10 ** uint256(18 - tokenDecimals);\\n\\n        // Compute the amount of tokens bought\\n        uint256 tokensBought = (msg.value * tokenPrice) / normalise_multiplier;\\n\\n        // Update the storage variables\\n        unclaimedTokens[msg.sender] += tokensBought;\\n        contribution[msg.sender] += msg.value;\\n        totalContributionsETH += msg.value;\\n\\n        // Check if the user's total contribution is not over the max contribution\\n        if (maxContribution != 0) {\\n            if (contribution[msg.sender] > maxContribution) {\\n                revert MaxContributionExceeded();\\n            }\\n        }\\n\\n        totalTokensBought += tokensBought;\\n\\n        emit TokensBought(msg.sender, tokensBought);\\n    }\\n\\n    function claimRewards() external returns (bool result) {\\n        uint256 boughtTokens = unclaimedTokens[msg.sender];\\n        uint256 userContribution = contribution[msg.sender];\\n\\n        if (!saleFinished) revert SaleNotEndedYet();\\n        if (boughtTokens == 0) revert ZeroTokensBought();\\n        if (saleCancelled) revert SaleCancelled();\\n        if (hasClaimedTokens[msg.sender]) revert NoMultipleClaims();\\n\\n        // If the soft cap is not reached, send the user their contribution back\\n        if (!softCapReached) {\\n            // Reset the user's data\\n            contribution[msg.sender] = 0;\\n            unclaimedTokens[msg.sender] = 0;\\n            hasClaimedTokens[msg.sender] = true;\\n\\n            // Send the contribution back to the user\\n            (bool sc,) = payable(msg.sender).call{value: userContribution}(\\\"\\\");\\n            if (!sc) revert TransferFailed();\\n\\n            emit TokensClaimed(msg.sender, 0);\\n            return true;\\n        } else {\\n            unclaimedTokens[msg.sender] = 0;\\n            hasClaimedTokens[msg.sender] = true;\\n\\n            claimedTokens[msg.sender] = boughtTokens;\\n\\n            // If the soft cap is reached, send the tokens they bought to the user\\n            IERC20 tokenContract = IERC20(tokenAddress);\\n\\n            // Send the tokens to the user\\n            tokenContract.transfer(msg.sender, boughtTokens);\\n\\n            emit TokensClaimed(msg.sender, boughtTokens);\\n            return true;\\n        }\\n    }\\n\\n    function claimETHWhenSaleIsCancelled() external {\\n        if (!saleCancelled) revert SaleNotCancelled();\\n\\n        uint256 amountToRefund = contribution[msg.sender];\\n\\n        if (amountToRefund == 0) revert InvalidRefundAmount();\\n\\n        // Reset the user's data\\n        contribution[msg.sender] = 0;\\n\\n        // Send the sender their contribution back\\n        (bool sc,) = payable(msg.sender).call{value: amountToRefund}(\\\"\\\");\\n\\n        if (!sc) revert TransferFailed();\\n\\n        hasRefunded[msg.sender] = true;\\n\\n        emit ContributionRefunded(msg.sender, amountToRefund);\\n    }\\n\\n    /**\\n     * @notice Ends the sale.\\n     */\\n    function finishSale() external onlyOwner {\\n        require(block.timestamp > endTimestamp || address(this).balance >= softCap, \\\"Sale has not ended yet\\\");\\n\\n        require(!saleFinished, \\\"Sale has already ended\\\");\\n\\n        // Mark the sale as ended\\n        saleFinished = true;\\n\\n        hasOwnerFinishedSale = true;\\n\\n        // If the soft cap is reached, send the raised ETH and the unsold tokens to the owner\\n        if (address(this).balance >= softCap) {\\n            softCapReached = true;\\n\\n            // Check if pair exists\\n            IDEXFactory factory = IDEXFactory(IDEXRouter(routerAddress).factory());\\n            address pairAddress = factory.getPair(tokenAddress, IDEXRouter(routerAddress).WETH());\\n\\n            if (pairAddress == address(0)) {\\n                // Create a pair if it doesn't exist\\n                pairAddress = factory.createPair(tokenAddress, IDEXRouter(routerAddress).WETH());\\n            }\\n\\n            uint256 liquidityEth = (address(this).balance * liquidityPercent) / 100;\\n\\n            // Approve the router to spend any of the tokens\\n            IERC20 tokenContract = IERC20(tokenAddress);\\n            tokenContract.approve(routerAddress, type(uint256).max);\\n\\n            if (liquidityTokens > 0) {\\n                // Add liquidity\\n                IDEXRouter(routerAddress).addLiquidityETH{value: liquidityEth}(\\n                    tokenAddress, liquidityTokens, 0, 0, address(this), block.timestamp + 1 hours\\n                );\\n\\n                uint256 remainingEth = address(this).balance;\\n                // Send the raised ETH to the owner\\n                (bool sc,) = payable(presaleWithdrawDestination).call{value: remainingEth}(\\\"\\\");\\n                require(sc, \\\"Transfer failed\\\");\\n            } else {\\n                // Send the raised ETH to the owner\\n                (bool sc,) = payable(presaleWithdrawDestination).call{value: address(this).balance}(\\\"\\\");\\n                require(sc, \\\"Transfer failed\\\");\\n            }\\n        } else {\\n            softCapReached = false;\\n\\n            // Send the tokens back to the owner\\n            IERC20 tokenContract = IERC20(tokenAddress);\\n            tokenContract.transfer(owner(), totalSaleAmount);\\n\\n            // The users now will be able to claim their ETH back\\n        }\\n\\n        emit SaleEnded(totalTokensBought, softCapReached);\\n    }\\n\\n    function cancelSale() external onlyOwner {\\n        if (saleFinished) revert SaleAlreadyEnded();\\n\\n        saleCancelled = true;\\n        saleFinished = true;\\n\\n        // Send the tokens back to the owner\\n        IERC20 tokenContract = IERC20(tokenAddress);\\n        // Also send the liquidity tokens back\\n        uint256 balance = tokenContract.balanceOf(address(this));\\n        tokenContract.transfer(owner(), balance);\\n\\n        emit SaleHasCancelled(owner(), totalTokensBought, totalContributionsETH);\\n    }\\n\\n    function emergencyWithdrawTokens() external onlyOwner {\\n        require(saleFinished || saleCancelled, \\\"Sale has not ended yet\\\");\\n\\n        uint256 unsoldTokensBalance = totalSaleAmount - totalTokensBought;\\n\\n        require(unsoldTokensBalance > 0, \\\"Token contract balance must be greater than 0\\\");\\n\\n        IERC20 tokenContract = IERC20(tokenAddress);\\n        tokenContract.transfer(owner(), unsoldTokensBalance);\\n\\n        emit EmergencyWithdrawTokens(unsoldTokensBalance);\\n    }\\n\\n    \\n    function emergencyWithdrawEther() external onlyOwner {\\n        require(saleFinished || saleCancelled, \\\"Sale has not ended yet\\\");\\n\\n        uint256 balance = address(this).balance;\\n\\n        require(balance > 0, \\\"Contract balance must be greater than 0\\\");\\n\\n        (bool sc,) = payable(owner()).call{value: balance}(\\\"\\\");\\n        require(sc, \\\"Transfer failed\\\");\\n    }\\n\\n    function changeStartDates(uint256 _startTimestamp, uint256 _endTimestamp) external onlyOwner {\\n        // Only allow if sale not started yet\\n        if (block.timestamp > startTimestamp) revert AlreadySetup();\\n\\n        if (_startTimestamp < block.timestamp) {\\n            _startTimestamp = block.timestamp;\\n        }\\n\\n        if (_endTimestamp <= _startTimestamp) revert InvalidEndTime();\\n\\n        startTimestamp = _startTimestamp;\\n        endTimestamp = _endTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/MerkleProof.sol\": {\r\n      \"content\": \"// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n *\\n *\\n * PENGY-NOTE: We have stripped this contract of non-essential functions to our use case to optimize gas usage.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolCreationFeeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolCreationFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FeeOptionsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"OperatorAccessModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"presaleAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"presaleAddress\",\"type\":\"address\"}],\"name\":\"PresaleContractShadowDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"presaleTemplateContractAddress\",\"type\":\"address\"}],\"name\":\"PresaleContractTemplateAddressChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolCreationFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolCreationFeeAmount\",\"type\":\"uint256\"}],\"name\":\"changeFeeOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_minLiquidityPercent\",\"type\":\"uint8\"}],\"name\":\"changeMinLiquidityPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"changeOperatorAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_tokensPercentageForFee\",\"type\":\"uint8\"}],\"name\":\"changeTokensForFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_paymentMethod\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSaleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxContribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityPercent\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minLiquidityPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCreationFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolCreationFeePaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCreationFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleTemplateContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"presales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"presaleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paid\",\"type\":\"bool\"}],\"name\":\"setPoolCreationFeePaid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPercentageForFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PresaleManager", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}