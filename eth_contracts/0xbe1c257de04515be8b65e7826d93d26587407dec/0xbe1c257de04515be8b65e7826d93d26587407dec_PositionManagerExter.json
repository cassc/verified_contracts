{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gammaswap/v1-core/contracts/interfaces/IGammaPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IGammaPoolEvents.sol\\\";\\nimport \\\"./IProtocol.sol\\\";\\nimport \\\"./strategies/events/IGammaPoolERC20Events.sol\\\";\\nimport \\\"./rates/IRateModel.sol\\\";\\n\\n/// @title Interface for GammaPool\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface used for GammaPool implementations\\ninterface IGammaPool is IProtocol, IGammaPoolEvents, IGammaPoolERC20Events, IRateModel {\\n    /// @dev Struct containing Loan data plus tokenId\\n    struct LoanData {\\n        /// @dev Loan counter, used to generate unique tokenId which indentifies the loan in the GammaPool\\n        uint256 id;\\n\\n        /// @dev Loan tokenId\\n        uint256 tokenId;\\n\\n        // 1x256 bits\\n        /// @dev GammaPool address loan belongs to\\n        address poolId; // 160 bits\\n        /// @dev Index of GammaPool interest rate at time loan is created/updated, max 7.9% trillion\\n        uint96 rateIndex; // 96 bits\\n\\n        // 1x256 bits\\n        /// @dev Initial loan debt in liquidity invariant units. Only increase when more liquidity is borrowed, decreases when liquidity is paid\\n        uint128 initLiquidity; // 128 bits\\n        /// @dev Loan debt in liquidity invariant units in last update\\n        uint128 lastLiquidity; // 128 bits\\n        /// @dev Loan debt in liquidity invariant units, increases with every update according to how many blocks have passed\\n        uint128 liquidity; // 128 bits\\n        /// @dev Collateral in terms of liquidity invariant units, increases with every update according to how many blocks have passed\\n        uint256 collateral;\\n\\n        /// @dev Initial loan debt in terms of LP tokens at time liquidity was borrowed, updates along with initLiquidity\\n        uint256 lpTokens;\\n        /// @dev Reserve tokens held as collateral for the liquidity debt, indices match GammaPool's tokens[] array indices\\n        uint128[] tokensHeld; // array of 128 bit numbers\\n\\n        /// @dev reference address of contract holding additional collateral for loan (e.g. CollateralManager)\\n        address refAddr;\\n        /// @dev reference fee of contract holding additional collateral for loan (e.g. CollateralManager)\\n        uint16 refFee;\\n        /// @dev reference type of contract holding additional collateral for loan (e.g. CollateralManager)\\n        uint8 refType;\\n\\n        /// @dev price at which loan was opened\\n        uint256 px;\\n        /// @dev if true loan can be liquidated\\n        bool canLiquidate;\\n\\n        /// @dev names of ERC20 tokens of CFMM\\n        uint256 accFeeIndex;\\n        /// @dev Percent accrual in CFMM invariant since last update\\n        uint256 lastCFMMFeeIndex;\\n        /// @dev names of ERC20 tokens of CFMM\\n        uint256 LAST_BLOCK_NUMBER;\\n\\n        /// @dev ERC20 tokens of CFMM\\n        address[] tokens;\\n        /// @dev decimals of ERC20 tokens of CFMM\\n        uint8[] decimals;\\n        /// @dev symbols of ERC20 tokens of CFMM\\n        string[] symbols;\\n        /// @dev names of ERC20 tokens of CFMM\\n        string[] names;\\n\\n        /// @dev interest rate model parameter store\\n        address paramsStore;\\n        /// @dev address of short strategy\\n        address shortStrategy;\\n\\n        /// @dev borrowed liquidity invariant of the pool\\n        uint256 BORROWED_INVARIANT;\\n        /// @dev Quantity of CFMM's liquidity invariant held in GammaPool as LP tokens\\n        uint256 LP_INVARIANT;\\n        /// @dev balance of CFMM LP tokens in the pool\\n        uint256 LP_TOKEN_BALANCE;\\n        /// @dev last CFMM liquidity invariant\\n        uint256 lastCFMMInvariant;\\n        /// @dev last CFMM total supply of LP tokens\\n        uint256 lastCFMMTotalSupply;\\n        /// @dev LTV liquidation threshold\\n        uint256 ltvThreshold;\\n        /// @dev Liquidation fee\\n        uint256 liquidationFee;\\n    }\\n\\n    /// @dev Struct returned in getLatestRates function. Contains all relevant global state variables\\n    struct RateData {\\n        /// @dev GammaPool's ever increasing interest rate index, tracks interest accrued through CFMM and liquidity loans, max 7.9% trillion\\n        uint256 accFeeIndex;\\n        /// @dev Percent accrual in CFMM invariant since last update\\n        uint256 lastCFMMFeeIndex;\\n        /// @dev Percent accrual in CFMM invariant and GammaPool interest since last update\\n        uint256 lastFeeIndex;\\n        /// @dev Borrow APR of LP tokens in GammaPool\\n        uint256 borrowRate;\\n        /// @dev Utilization rate of GammaPool\\n        uint256 utilizationRate;\\n        /// @dev last block an update to the GammaPool's global storage variables happened\\n        uint256 lastBlockNumber;\\n        /// @dev Current block number when requesting pool data\\n        uint256 currBlockNumber;\\n        /// @dev Last Price in CFMM\\n        uint256 lastPrice;\\n        /// @dev Supply APR of LP tokens in GammaPool\\n        uint256 supplyRate;\\n        /// @dev names of ERC20 tokens of CFMM\\n        uint256 BORROWED_INVARIANT;\\n        /// @dev Quantity of CFMM's liquidity invariant held in GammaPool as LP tokens\\n        uint256 LP_INVARIANT;\\n        /// @dev EMA of utilization Rate\\n        uint256 emaUtilRate;\\n        /// @dev Minimum Utilization Rate 1\\n        uint256 minUtilRate1;\\n        /// @dev Minimum Utilization Rate 2\\n        uint256 minUtilRate2;\\n        /// @dev Dynamic origination fee divisor\\n        uint256 feeDivisor;\\n        /// @dev Loan opening origination fee in basis points\\n        uint256 origFee; // 16 bits\\n        /// @dev LTV liquidation threshold\\n        uint256 ltvThreshold;\\n        /// @dev Liquidation fee\\n        uint256 liquidationFee;\\n        /// @dev Short Strategy implementation address\\n        address shortStrategy;\\n        /// @dev Interest Rate Parameters Store contract\\n        address paramsStore;\\n    }\\n\\n    /// @dev Struct returned in getPoolData function. Contains all relevant global state variables\\n    struct PoolData {\\n        /// @dev GammaPool address\\n        address poolId;\\n        /// @dev Protocol id of the implementation contract for this GammaPool\\n        uint16 protocolId;\\n        /// @dev Borrow Strategy implementation contract for this GammaPool\\n        address borrowStrategy;\\n        /// @dev Repay Strategy implementation contract for this GammaPool\\n        address repayStrategy;\\n        /// @dev Rebalance Strategy implementation contract for this GammaPool\\n        address rebalanceStrategy;\\n        /// @dev Short Strategy implementation contract for this GammaPool\\n        address shortStrategy;\\n        /// @dev Single Liquidation Strategy implementation contract for this GammaPool\\n        address singleLiquidationStrategy;\\n        /// @dev Batch Liquidation Strategy implementation contract for this GammaPool\\n        address batchLiquidationStrategy;\\n\\n        /// @dev factory - address of factory contract that instantiated this GammaPool\\n        address factory;\\n        /// @dev paramsStore - interest rate model parameters store contract\\n        address paramsStore;\\n\\n        // LP Tokens\\n        /// @dev Quantity of CFMM's LP tokens deposited in GammaPool by liquidity providers\\n        uint256 LP_TOKEN_BALANCE;// LP Tokens in GS, LP_TOKEN_TOTAL = LP_TOKEN_BALANCE + LP_TOKEN_BORROWED_PLUS_INTEREST\\n        /// @dev Quantity of CFMM's LP tokens that have been borrowed by liquidity borrowers excluding accrued interest (principal)\\n        uint256 LP_TOKEN_BORROWED;//LP Tokens that have been borrowed (Principal)\\n        /// @dev Quantity of CFMM's LP tokens that have been borrowed by liquidity borrowers including accrued interest\\n        uint256 LP_TOKEN_BORROWED_PLUS_INTEREST;//LP Tokens that have been borrowed (principal) plus interest in LP Tokens\\n\\n        // Invariants\\n        /// @dev Quantity of CFMM's liquidity invariant that has been borrowed including accrued interest, maps to LP_TOKEN_BORROWED_PLUS_INTEREST\\n        uint128 BORROWED_INVARIANT;\\n        /// @dev Quantity of CFMM's liquidity invariant held in GammaPool as LP tokens, maps to LP_TOKEN_BALANCE\\n        uint128 LP_INVARIANT;//Invariant from LP Tokens, TOTAL_INVARIANT = BORROWED_INVARIANT + LP_INVARIANT\\n\\n        // Rates\\n        /// @dev cfmm - address of CFMM this GammaPool is for\\n        address cfmm;\\n        /// @dev GammaPool's ever increasing interest rate index, tracks interest accrued through CFMM and liquidity loans, max 30.9% billion\\n        uint80 accFeeIndex;\\n        /// @dev External swap fee in basis points, max 255 basis points = 2.55%\\n        uint8 extSwapFee; // 8 bits\\n        /// @dev Loan opening origination fee in basis points\\n        uint16 origFee; // 16 bits\\n        /// @dev LAST_BLOCK_NUMBER - last block an update to the GammaPool's global storage variables happened\\n        uint40 LAST_BLOCK_NUMBER;\\n        /// @dev Percent accrual in CFMM invariant since last update\\n        uint64 lastCFMMFeeIndex; // 64 bits\\n        /// @dev Total liquidity invariant amount in CFMM (from GammaPool and others), read in last update to GammaPool's storage variables\\n        uint128 lastCFMMInvariant;\\n        /// @dev Total LP token supply from CFMM (belonging to GammaPool and others), read in last update to GammaPool's storage variables\\n        uint256 lastCFMMTotalSupply;\\n\\n        // ERC20 fields\\n        /// @dev Total supply of GammaPool's own ERC20 token representing the liquidity of depositors to the CFMM through the GammaPool\\n        uint256 totalSupply;\\n\\n        // tokens and balances\\n        /// @dev ERC20 tokens of CFMM\\n        address[] tokens;\\n        /// @dev symbols of ERC20 tokens of CFMM\\n        string[] symbols;\\n        /// @dev names of ERC20 tokens of CFMM\\n        string[] names;\\n        /// @dev Decimals of CFMM tokens, indices match tokens[] array\\n        uint8[] decimals;\\n        /// @dev Amounts of ERC20 tokens from the CFMM held as collateral in the GammaPool. Equals to the sum of all tokensHeld[] quantities in all loans\\n        uint128[] TOKEN_BALANCE;\\n        /// @dev Amounts of ERC20 tokens from the CFMM held in the CFMM as reserve quantities. Used to log prices in the CFMM during updates to the GammaPool\\n        uint128[] CFMM_RESERVES; //keeps track of price of CFMM at time of update\\n\\n        /// @dev Last Price in CFMM\\n        uint256 lastPrice;\\n        /// @dev Percent accrual in CFMM invariant and GammaPool interest since last update\\n        uint256 lastFeeIndex;\\n        /// @dev Borrow rate of LP tokens in GammaPool\\n        uint256 borrowRate;\\n        /// @dev Utilization rate of GammaPool\\n        uint256 utilizationRate;\\n        /// @dev Current block number when requesting pool data\\n        uint40 currBlockNumber;\\n        /// @dev LTV liquidation threshold\\n        uint8 ltvThreshold;\\n        /// @dev Liquidation fee\\n        uint8 liquidationFee;\\n        /// @dev Supply APR of LP tokens in GammaPool\\n        uint256 supplyRate;\\n        /// @dev EMA of utilization Rate\\n        uint40 emaUtilRate;\\n        /// @dev Multiplier of EMA Utilization Rate\\n        uint8 emaMultiplier;\\n        /// @dev Minimum Utilization Rate 1\\n        uint8 minUtilRate1;\\n        /// @dev Minimum Utilization Rate 2\\n        uint8 minUtilRate2;\\n        /// @dev Dynamic origination fee divisor\\n        uint16 feeDivisor;\\n        /// @dev Minimum liquidity amount that can be borrowed\\n        uint72 minBorrow;\\n    }\\n\\n    /// @dev cfmm - address of CFMM this GammaPool is for\\n    function cfmm() external view returns(address);\\n\\n    /// @dev ERC20 tokens of CFMM\\n    function tokens() external view returns(address[] memory);\\n\\n    /// @dev address of factory contract that instantiated this GammaPool\\n    function factory() external view returns(address);\\n\\n    /// @dev viewer contract to implement complex view functions for data in this GammaPool\\n    function viewer() external view returns(address);\\n\\n    /// @dev Borrow Strategy implementation contract for this GammaPool\\n    function borrowStrategy() external view returns(address);\\n\\n    /// @dev Repay Strategy implementation contract for this GammaPool\\n    function repayStrategy() external view returns(address);\\n\\n    /// @dev Rebalance Strategy implementation contract for this GammaPool\\n    function rebalanceStrategy() external view returns(address);\\n\\n    /// @dev Short Strategy implementation contract for this GammaPool\\n    function shortStrategy() external view returns(address);\\n\\n    /// @dev Single Loan Liquidation Strategy implementation contract for this GammaPool\\n    function singleLiquidationStrategy() external view returns(address);\\n\\n    /// @dev Batch Liquidations Strategy implementation contract for this GammaPool\\n    function batchLiquidationStrategy() external view returns(address);\\n\\n    /// @dev Set parameters to calculate origination fee, liquidation fee, and ltv threshold\\n    /// @param origFee - loan opening origination fee in basis points\\n    /// @param extSwapFee - external swap fee in basis points, max 255 basis points = 2.55%\\n    /// @param emaMultiplier - multiplier used in EMA calculation of utilization rate\\n    /// @param minUtilRate1 - minimum utilization rate to calculate dynamic origination fee in exponential model\\n    /// @param minUtilRate2 - minimum utilization rate to calculate dynamic origination fee in linear model\\n    /// @param feeDivisor - fee divisor for calculating origination fee, based on 2^(maxUtilRate - minUtilRate1)\\n    /// @param liquidationFee - liquidation fee to charge during liquidations in basis points (1 - 255 => 0.01% to 2.55%)\\n    /// @param ltvThreshold - ltv threshold (1 - 255 => 0.1% to 25.5%)\\n    /// @param minBorrow - minimum liquidity amount that can be borrowed or left unpaid in a loan\\n    function setPoolParams(uint16 origFee, uint8 extSwapFee, uint8 emaMultiplier, uint8 minUtilRate1, uint8 minUtilRate2, uint16 feeDivisor, uint8 liquidationFee, uint8 ltvThreshold, uint72 minBorrow) external;\\n\\n    /// @dev Balances in the GammaPool of collateral tokens, CFMM LP tokens, and invariant amounts at last update\\n    /// @return tokenBalances - balances of collateral tokens in GammaPool\\n    /// @return lpTokenBalance - CFMM LP token balance of GammaPool\\n    /// @return lpTokenBorrowed - CFMM LP token principal amounts borrowed from GammaPool\\n    /// @return lpTokenBorrowedPlusInterest - CFMM LP token amounts borrowed from GammaPool including accrued interest\\n    /// @return borrowedInvariant - invariant amount borrowed from GammaPool including accrued interest, maps to lpTokenBorrowedPlusInterest\\n    /// @return lpInvariant - invariant of CFMM LP tokens in GammaPool not borrowed, maps to lpTokenBalance\\n    function getPoolBalances() external view returns(uint128[] memory tokenBalances, uint256 lpTokenBalance, uint256 lpTokenBorrowed,\\n        uint256 lpTokenBorrowedPlusInterest, uint256 borrowedInvariant, uint256 lpInvariant);\\n\\n    /// @dev Balances in CFMM at last update of GammaPool\\n    /// @return cfmmReserves - total reserve tokens in CFMM last time GammaPool was updated\\n    /// @return cfmmInvariant - total liquidity invariant of CFMM last time GammaPool was updated\\n    /// @return cfmmTotalSupply - total CFMM LP tokens in existence last time GammaPool was updated\\n    function getCFMMBalances() external view returns(uint128[] memory cfmmReserves, uint256 cfmmInvariant, uint256 cfmmTotalSupply);\\n\\n    /// @dev Interest rate information in GammaPool at last update\\n    /// @return accFeeIndex - total accrued interest in GammaPool at last update\\n    /// @return lastCFMMFeeIndex - total accrued CFMM fee since last update\\n    /// @return lastBlockNumber - last block GammaPool was updated\\n    function getRates() external view returns(uint256 accFeeIndex, uint256 lastCFMMFeeIndex, uint256 lastBlockNumber);\\n\\n    /// @return data - struct containing all relevant global state variables and descriptive information of GammaPool. Used to avoid making multiple calls\\n    function getPoolData() external view returns(PoolData memory data);\\n\\n    // Short Gamma\\n\\n    /// @dev Deposit CFMM LP token and get GS LP token, without doing a transferFrom transaction. Must have sent CFMM LP token first\\n    /// @param to - address of receiver of GS LP token\\n    /// @return shares - quantity of GS LP tokens received for CFMM LP tokens\\n    function depositNoPull(address to) external returns(uint256 shares);\\n\\n    /// @dev Withdraw CFMM LP token, by burning GS LP token, without doing a transferFrom transaction. Must have sent GS LP token first\\n    /// @param to - address of receiver of CFMM LP tokens\\n    /// @return assets - quantity of CFMM LP tokens received for GS LP tokens\\n    function withdrawNoPull(address to) external returns(uint256 assets);\\n\\n    /// @dev Withdraw reserve token quantities of CFMM (instead of CFMM LP tokens), by burning GS LP token\\n    /// @param to - address of receiver of reserve token quantities\\n    /// @return reserves - quantity of reserve tokens withdrawn from CFMM and sent to receiver\\n    /// @return assets - quantity of CFMM LP tokens representing reserve tokens withdrawn\\n    function withdrawReserves(address to) external returns (uint256[] memory reserves, uint256 assets);\\n\\n    /// @dev Deposit reserve token quantities to CFMM (instead of CFMM LP tokens) to get CFMM LP tokens, store them in GammaPool and receive GS LP tokens\\n    /// @param to - address of receiver of GS LP tokens\\n    /// @param amountsDesired - desired amounts of reserve tokens to deposit\\n    /// @param amountsMin - minimum amounts of reserve tokens to deposit\\n    /// @param data - information identifying request to deposit\\n    /// @return reserves - quantity of actual reserve tokens deposited in CFMM\\n    /// @return shares - quantity of GS LP tokens received for reserve tokens deposited\\n    function depositReserves(address to, uint256[] calldata amountsDesired, uint256[] calldata amountsMin, bytes calldata data) external returns(uint256[] memory reserves, uint256 shares);\\n\\n    /// @return cfmmReserves - latest token reserves in the CFMM\\n    function getLatestCFMMReserves() external view returns(uint128[] memory cfmmReserves);\\n\\n    /// @return cfmmReserves - latest token reserves in the CFMM\\n    /// @return cfmmInvariant - latest total invariant in the CFMM\\n    /// @return cfmmTotalSupply - latest total supply of LP tokens in CFMM\\n    function getLatestCFMMBalances() external view returns(uint128[] memory cfmmReserves, uint256 cfmmInvariant, uint256 cfmmTotalSupply);\\n\\n    /// @return lastPrice - calculates and gets current price at CFMM\\n    function getLastCFMMPrice() external view returns(uint256);\\n\\n    // Long Gamma\\n\\n    /// @dev Create a new Loan struct\\n    /// @param refId - Reference id of post transaction activities attached to this loan\\n    /// @return tokenId - unique id of loan struct created\\n    function createLoan(uint16 refId) external returns(uint256 tokenId);\\n\\n    /// @dev Get loan from storage and convert to LoanData struct\\n    /// @param _tokenId - tokenId of loan to convert\\n    /// @return _loanData - loan data struct (same as Loan + tokenId)\\n    function getLoanData(uint256 _tokenId) external view returns(LoanData memory _loanData);\\n\\n    /// @dev Get loan with its most updated information\\n    /// @param _tokenId - unique id of loan, used to look up loan in GammaPool\\n    /// @return _loanData - loan data struct (same as Loan + tokenId)\\n    function loan(uint256 _tokenId) external view returns(LoanData memory _loanData);\\n\\n    /// @dev Get list of loans and their corresponding tokenIds created in GammaPool. Capped at s.tokenIds.length.\\n    /// @param start - index from where to start getting tokenIds from array\\n    /// @param end - end index of array wishing to get tokenIds. If end > s.tokenIds.length, end is s.tokenIds.length\\n    /// @param active - if true, return loans that have an outstanding liquidity debt\\n    /// @return _loans - list of loans created in GammaPool\\n    function getLoans(uint256 start, uint256 end, bool active) external view returns(LoanData[] memory _loans);\\n\\n    /// @dev calculate liquidity invariant from collateral tokens\\n    /// @param tokensHeld - loan's collateral tokens\\n    /// @return collateralInvariant - invariant calculated from loan's collateral tokens\\n    function calcInvariant(uint128[] memory tokensHeld) external view returns(uint256);\\n\\n    /// @dev Get list of loans mapped to tokenIds in array `tokenIds`\\n    /// @param tokenIds - list of loan tokenIds\\n    /// @param active - if true, return loans that have an outstanding liquidity debt\\n    /// @return _loans - list of loans created in GammaPool\\n    function getLoansById(uint256[] calldata tokenIds, bool active) external view returns(LoanData[] memory _loans);\\n\\n    /// @return loanCount - total number of loans opened\\n    function getLoanCount() external view returns(uint256);\\n\\n    /// @dev Deposit more collateral in loan identified by tokenId\\n    /// @param tokenId - unique id identifying loan\\n    /// @param ratio - ratio to rebalance collateral after increasing collateral\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function increaseCollateral(uint256 tokenId, uint256[] calldata ratio) external returns(uint128[] memory tokensHeld);\\n\\n    /// @dev Withdraw collateral from loan identified by tokenId\\n    /// @param tokenId - unique id identifying loan\\n    /// @param amounts - amounts of collateral tokens requested to withdraw\\n    /// @param to - destination address of receiver of collateral withdrawn\\n    /// @param ratio - ratio to rebalance collateral after withdrawing collateral\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function decreaseCollateral(uint256 tokenId, uint128[] memory amounts, address to, uint256[] calldata ratio) external returns(uint128[] memory tokensHeld);\\n\\n    /// @dev Borrow liquidity from the CFMM and add it to the debt and collateral of loan identified by tokenId\\n    /// @param tokenId - unique id identifying loan\\n    /// @param lpTokens - quantity of CFMM LP tokens requested to short\\n    /// @param ratio - ratio to rebalance collateral after borrowing\\n    /// @return liquidityBorrowed - liquidity amount that has been borrowed\\n    /// @return amounts - reserves quantities withdrawn from CFMM that correspond to the LP tokens shorted, now used as collateral\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function borrowLiquidity(uint256 tokenId, uint256 lpTokens, uint256[] calldata ratio) external returns(uint256 liquidityBorrowed, uint256[] memory amounts, uint128[] memory tokensHeld);\\n\\n    /// @dev Repay liquidity debt of loan identified by tokenId, debt is repaid using available collateral in loan\\n    /// @param tokenId - unique id identifying loan\\n    /// @param liquidity - liquidity debt being repaid, capped at actual liquidity owed. Can't repay more than you owe\\n    /// @param collateralId - index of collateral token + 1\\n    /// @param to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n    /// @return liquidityPaid - liquidity amount that has been repaid\\n    /// @return amounts - collateral amounts consumed in repaying liquidity debt\\n    function repayLiquidity(uint256 tokenId, uint256 liquidity, uint256 collateralId, address to) external returns(uint256 liquidityPaid, uint256[] memory amounts);\\n\\n    /// @dev Repay liquidity debt of loan identified by tokenId, debt is repaid using available collateral in loan\\n    /// @param tokenId - unique id identifying loan\\n    /// @param liquidity - liquidity debt being repaid, capped at actual liquidity owed. Can't repay more than you owe\\n    /// @param ratio - weights of collateral after repaying liquidity\\n    /// @return liquidityPaid - liquidity amount that has been repaid\\n    /// @return amounts - collateral amounts consumed in repaying liquidity debt\\n    function repayLiquiditySetRatio(uint256 tokenId, uint256 liquidity, uint256[] calldata ratio) external returns(uint256 liquidityPaid, uint256[] memory amounts);\\n\\n    /// @dev Repay liquidity debt of loan identified by tokenId, using CFMM LP token\\n    /// @param tokenId - unique id identifying loan\\n    /// @param collateralId - index of collateral token to rebalance to + 1\\n    /// @param to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n    /// @return liquidityPaid - liquidity amount that has been repaid\\n    /// @return tokensHeld - remaining token amounts collateralizing loan\\n    function repayLiquidityWithLP(uint256 tokenId, uint256 collateralId, address to) external returns(uint256 liquidityPaid, uint128[] memory tokensHeld);\\n\\n    /// @dev Rebalance collateral amounts of loan identified by tokenId by purchasing or selling some of the collateral\\n    /// @param tokenId - unique id identifying loan\\n    /// @param deltas - collateral amounts being bought or sold (>0 buy, <0 sell), index matches tokensHeld[] index. Only n-1 tokens can be traded\\n    /// @param ratio - ratio to rebalance collateral\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function rebalanceCollateral(uint256 tokenId, int256[] memory deltas, uint256[] calldata ratio) external returns(uint128[] memory tokensHeld);\\n\\n    /// @dev Update pool liquidity debt and optinally also loan liquidity debt\\n    /// @param tokenId - (optional) unique ids identifying loan, pass zero to ignore this parameter\\n    /// @return loanLiquidityDebt - updated liquidity debt amount of loan\\n    /// @return poolLiquidityDebt - updated liquidity debt amount of pool\\n    function updatePool(uint256 tokenId) external returns(uint256 loanLiquidityDebt, uint256 poolLiquidityDebt);\\n\\n    /// @notice When calling this function and adding additional collateral it is assumed that you have sent the collateral first\\n    /// @dev Function to liquidate a loan using its own collateral or depositing additional tokens. Seeks full liquidation\\n    /// @param tokenId - tokenId of loan being liquidated\\n    /// @return loanLiquidity - loan liquidity liquidated (after write down)\\n    /// @return refund - amount of CFMM LP tokens being refunded to liquidator\\n    function liquidate(uint256 tokenId) external returns(uint256 loanLiquidity, uint256 refund);\\n\\n    /// @dev Function to liquidate a loan using external LP tokens. Allows partial liquidation\\n    /// @param tokenId - tokenId of loan being liquidated\\n    /// @return loanLiquidity - loan liquidity liquidated (after write down)\\n    /// @return refund - amounts from collateral tokens being refunded to liquidator\\n    function liquidateWithLP(uint256 tokenId) external returns(uint256 loanLiquidity, uint256[] memory refund);\\n\\n    /// @dev Function to liquidate multiple loans in batch.\\n    /// @param tokenIds - list of tokenIds of loans to liquidate\\n    /// @return totalLoanLiquidity - total loan liquidity liquidated (after write down)\\n    /// @return refund - amounts from collateral tokens being refunded to liquidator\\n    function batchLiquidations(uint256[] calldata tokenIds) external returns(uint256 totalLoanLiquidity, uint256[] memory refund);\\n\\n    // Sync functions\\n\\n    /// @dev Skim excess collateral tokens or CFMM LP tokens from GammaPool and send them to receiver (`to`) address\\n    /// @param to - address receiving excess tokens\\n    function skim(address to) external;\\n\\n    /// @dev Synchronize LP_TOKEN_BALANCE with actual CFMM LP tokens deposited in GammaPool\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/IGammaPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./strategies/events/ILiquidationStrategyEvents.sol\\\";\\nimport \\\"./strategies/events/IShortStrategyEvents.sol\\\";\\nimport \\\"./strategies/events/IExternalStrategyEvents.sol\\\";\\n\\n/// @title GammaPool Events Interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events emitted by all GammaPool implementations (contains all strategy events)\\ninterface IGammaPoolEvents is IShortStrategyEvents, ILiquidationStrategyEvents, IExternalStrategyEvents {\\n    /// @dev Event emitted when a Loan is created\\n    /// @param caller - address that created the loan\\n    /// @param tokenId - unique id that identifies the loan in question\\n    /// @param refId - Reference id of post transaction activities attached to this loan\\n    event LoanCreated(address indexed caller, uint256 tokenId, uint16 refId);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/IGammaPoolExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IGammaPool.sol\\\";\\n\\n/// @title Interface for GammaPoolExternal\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface used for GammaPool implementations that have flash loan functionality\\ninterface IGammaPoolExternal {\\n\\n    /// @dev External Rebalance Strategy implementation contract for this GammaPool\\n    function externalRebalanceStrategy() external view returns(address);\\n\\n    /// @dev External Liquidation Strategy implementation contract for this GammaPool\\n    function externalLiquidationStrategy() external view returns(address);\\n\\n    /// @dev Flash loan pool's collateral and/or lp tokens to external address. Rebalanced loan collateral is acceptable in  repayment of flash loan\\n    /// @param tokenId - unique id identifying loan\\n    /// @param amounts - collateral amounts being flash loaned\\n    /// @param lpTokens - amount of CFMM LP tokens being flash loaned\\n    /// @param to - address that will receive flash loan swaps and potentially rebalance loan's collateral\\n    /// @param data - optional bytes parameter for custom user defined data\\n    /// @return loanLiquidity - updated loan liquidity, includes flash loan fees\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function rebalanceExternally(uint256 tokenId, uint128[] calldata amounts, uint256 lpTokens, address to, bytes calldata data) external returns(uint256 loanLiquidity, uint128[] memory tokensHeld);\\n\\n    /// @notice The entire pool's collateral is available in the flash loan. Flash loan must result in a net CFMM LP token deposit that repays loan's liquidity debt\\n    /// @dev Function to liquidate a loan using using a flash loan of collateral tokens from the pool and/or CFMM LP tokens. Seeks full liquidation\\n    /// @param tokenId - tokenId of loan being liquidated\\n    /// @param amounts - amount collateral tokens from the pool to flash loan\\n    /// @param lpTokens - amount of CFMM LP tokens being flash loaned\\n    /// @param to - address that will receive the collateral tokens and/or lpTokens in flash loan\\n    /// @param data - optional bytes parameter for custom user defined data\\n    /// @return loanLiquidity - loan liquidity liquidated (after write down if there's bad debt), flash loan fees added after write down\\n    /// @return refund - amounts from collateral tokens being refunded to liquidator\\n    function liquidateExternally(uint256 tokenId, uint128[] calldata amounts, uint256 lpTokens, address to, bytes calldata data) external returns(uint256 loanLiquidity, uint256[] memory refund);\\n\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/IGammaPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Interface for factory contract to create more GammaPool contracts.\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev All instantiated GammaPoolFactory contracts must implement this interface\\ninterface IGammaPoolFactory {\\n    /// @dev Event emitted when a new GammaPool is instantiated\\n    /// @param pool - address of new pool that is created\\n    /// @param cfmm - address of CFMM the GammaPool is created for\\n    /// @param protocolId - id identifier of GammaPool protocol (can be thought of as version)\\n    /// @param implementation - implementation address of GammaPool proxy contract. Because all GammaPools are created as proxy contracts\\n    /// @param tokens - ERC20 tokens of CFMM\\n    /// @param count - number of GammaPools instantiated including this contract\\n    event PoolCreated(address indexed pool, address indexed cfmm, uint16 indexed protocolId, address implementation, address[] tokens, uint256 count);\\n\\n    /// @dev Event emitted when a GammaPool fee is updated\\n    /// @param pool - address of new pool whose fee is updated (zero address is default params)\\n    /// @param to - receiving address of protocol fees\\n    /// @param protocolFee - protocol fee share charged from interest rate accruals\\n    /// @param origFeeShare - protocol fee share charged on origination fees\\n    /// @param isSet - bool flag, true use fee information, false use GammaSwap default fees\\n    event FeeUpdate(address indexed pool, address indexed to, uint16 protocolFee, uint16 origFeeShare, bool isSet);\\n\\n    /// @dev Event emitted when a GammaPool parameters are updated\\n    /// @param pool - address of GammaPool whose origination fee parameters will be updated\\n    /// @param origFee - loan opening origination fee in basis points\\n    /// @param extSwapFee - external swap fee in basis points, max 255 basis points = 2.55%\\n    /// @param emaMultiplier - multiplier used in EMA calculation of utilization rate\\n    /// @param minUtilRate1 - minimum utilization rate to calculate dynamic origination fee using exponential model\\n    /// @param minUtilRate2 - minimum utilization rate to calculate dynamic origination fee using linear model\\n    /// @param feeDivisor - fee divisor for calculating origination fee, based on 2^(maxUtilRate - minUtilRate1)\\n    /// @param liquidationFee - liquidation fee to charge during liquidations in basis points (1 - 255 => 0.01% to 2.55%)\\n    /// @param ltvThreshold - ltv threshold (1 - 255 => 0.1% to 25.5%)\\n    /// @param minBorrow - minimum liquidity amount that can be borrowed or left unpaid in a loan\\n    event PoolParamsUpdate(address indexed pool, uint16 origFee, uint8 extSwapFee, uint8 emaMultiplier, uint8 minUtilRate1, uint8 minUtilRate2, uint16 feeDivisor, uint8 liquidationFee, uint8 ltvThreshold, uint72 minBorrow);\\n\\n    /// @dev Check if protocol is restricted. Which means only owner of GammaPoolFactory is allowed to instantiate GammaPools using this protocol\\n    /// @param _protocolId - id identifier of GammaPool protocol (can be thought of as version) that is being checked\\n    /// @return _isRestricted - true if protocol is restricted, false otherwise\\n    function isProtocolRestricted(uint16 _protocolId) external view returns(bool);\\n\\n    /// @dev Set a protocol to be restricted or unrestricted. That means only owner of GammaPoolFactory is allowed to instantiate GammaPools using this protocol\\n    /// @param _protocolId - id identifier of GammaPool protocol (can be thought of as version) that is being restricted\\n    /// @param _isRestricted - set to true for restricted, set to false for unrestricted\\n    function setIsProtocolRestricted(uint16 _protocolId, bool _isRestricted) external;\\n\\n    /// @notice Only owner of GammaPoolFactory can call this function\\n    /// @dev Add a protocol implementation to GammaPoolFactory contract. Which means GammaPoolFactory can create GammaPools with this implementation (protocol)\\n    /// @param _implementation - implementation address of GammaPool proxy contract. Because all GammaPools are created as proxy contracts\\n    function addProtocol(address _implementation) external;\\n\\n    /// @notice Only owner of GammaPoolFactory can call this function\\n    /// @dev Update protocol implementation for a protocol.\\n    /// @param _protocolId - id identifier of GammaPool implementation\\n    /// @param _newImplementation - implementation address of GammaPool proxy contract. Because all GammaPools are created as proxy contracts\\n    function updateProtocol(uint16 _protocolId, address _newImplementation) external;\\n\\n    /// @notice Only owner of GammaPoolFactory can call this function\\n    /// @dev Locks protocol implementation for upgradable protocols (<10000) so GammaPoolFactory can no longer update the implementation contract for this upgradable protocol\\n    /// @param _protocolId - id identifier of GammaPool implementation\\n    function lockProtocol(uint16 _protocolId) external;\\n\\n    /// @dev Get implementation address that maps to protocolId. This is the actual implementation code that a GammaPool implements for a protocolId\\n    /// @param _protocolId - id identifier of GammaPool implementation (can be thought of as version)\\n    /// @return _address - implementation address of GammaPool proxy contract. Because all GammaPools are created as proxy contracts\\n    function getProtocol(uint16 _protocolId) external view returns (address);\\n\\n    /// @dev Get beacon address that maps to protocolId. This beacon contract contains the implementation address of the GammaPool proxy\\n    /// @param _protocolId - id identifier of GammaPool implementation (can be thought of as version)\\n    /// @return _address - address of beacon of GammaPool proxy contract. Because all GammaPools are created as proxy contracts if there is one\\n    function getProtocolBeacon(uint16 _protocolId) external view returns (address);\\n\\n    /// @dev Instantiate a new GammaPool for a CFMM based on an existing implementation (protocolId)\\n    /// @param _protocolId - id identifier of GammaPool protocol (can be thought of as version)\\n    /// @param _cfmm - address of CFMM the GammaPool is created for\\n    /// @param _tokens - addresses of ERC20 tokens in CFMM, used for validation during runtime of function\\n    /// @param _data - custom struct containing additional information used to verify the `_cfmm`\\n    /// @return _address - address of new GammaPool proxy contract that was instantiated\\n    function createPool(uint16 _protocolId, address _cfmm, address[] calldata _tokens, bytes calldata _data) external returns(address);\\n\\n    /// @dev Mapping of bytes32 salts (key) to GammaPool addresses. The salt is predetermined and used to instantiate a GammaPool with a unique address\\n    /// @param _salt - the bytes32 key that is unique to the GammaPool and therefore also used as a unique identifier of the GammaPool\\n    /// @return _address - address of GammaPool that maps to bytes32 salt (key)\\n    function getPool(bytes32 _salt) external view returns(address);\\n\\n    /// @dev Mapping of bytes32 salts (key) to GammaPool addresses. The salt is predetermined and used to instantiate a GammaPool with a unique address\\n    /// @param _pool - address of GammaPool that maps to bytes32 salt (key)\\n    /// @return _salt - the bytes32 key that is unique to the GammaPool and therefore also used as a unique identifier of the GammaPool\\n    function getKey(address _pool) external view returns(bytes32);\\n\\n    /// @return count - number of GammaPools that have been instantiated through this GammaPoolFactory contract\\n    function allPoolsLength() external view returns (uint256);\\n\\n    /// @dev Get pool fee parameters used to calculate protocol fees\\n    /// @param _pool - pool address identifier\\n    /// @return _to - address receiving fee\\n    /// @return _protocolFee - protocol fee share charged from interest rate accruals\\n    /// @return _origFeeShare - protocol fee share charged on origination fees\\n    /// @return _isSet - bool flag, true use fee information, false use GammaSwap default fees\\n    function getPoolFee(address _pool) external view returns (address _to, uint256 _protocolFee, uint256 _origFeeShare, bool _isSet);\\n\\n    /// @dev Set pool fee parameters used to calculate protocol fees\\n    /// @param _pool - id identifier of GammaPool protocol (can be thought of as version)\\n    /// @param _to - address receiving fee\\n    /// @param _protocolFee - protocol fee share charged from interest rate accruals\\n    /// @param _origFeeShare - protocol fee share charged on origination fees\\n    /// @param _isSet - bool flag, true use fee information, false use GammaSwap default fees\\n    function setPoolFee(address _pool, address _to, uint16 _protocolFee, uint16 _origFeeShare, bool _isSet) external;\\n\\n    /// @dev Call admin function in GammaPool contract\\n    /// @param _pool - address of GammaPool whose admin function will be called\\n    /// @param _data - custom struct containing information to execute in pool contract\\n    function execute(address _pool, bytes calldata _data) external;\\n\\n    /// @dev Pause a GammaPool's function identified by a `_functionId`\\n    /// @param _pool - address of GammaPool whose functions we will pause\\n    /// @param _functionId - id of function in GammaPool we want to pause\\n    /// @return _functionIds - uint256 number containing all turned on (paused) function ids\\n    function pausePoolFunction(address _pool, uint8 _functionId) external returns(uint256 _functionIds) ;\\n\\n    /// @dev Unpause a GammaPool's function identified by a `_functionId`\\n    /// @param _pool - address of GammaPool whose functions we will unpause\\n    /// @param _functionId - id of function in GammaPool we want to unpause\\n    /// @return _functionIds - uint256 number containing all turned on (paused) function ids\\n    function unpausePoolFunction(address _pool, uint8 _functionId) external returns(uint256 _functionIds) ;\\n\\n    /// @return fee - protocol fee charged by GammaPool to liquidity borrowers in terms of basis points\\n    function fee() external view returns(uint16);\\n\\n    /// @return origFeeShare - protocol fee share charged on origination fees\\n    function origFeeShare() external view returns(uint16);\\n\\n    /// @return feeTo - address that receives protocol fees\\n    function feeTo() external view returns(address);\\n\\n    /// @return feeToSetter - address that has the power to set protocol fees\\n    function feeToSetter() external view returns(address);\\n\\n    /// @return feeTo - address that receives protocol fees\\n    /// @return fee - protocol fee charged by GammaPool to liquidity borrowers in terms of basis points\\n    /// @return origFeeShare - protocol fee share charged on origination fees\\n    function feeInfo() external view returns(address,uint256,uint256);\\n\\n    /// @dev Get list of pools from start index to end index. If it goes over index it returns up to the max size of allPools array\\n    /// @param start - start index of pools to search\\n    /// @param end - end index of pools to search\\n    /// @return _pools - all pools requested\\n    function getPools(uint256 start, uint256 end) external view returns(address[] memory _pools);\\n\\n    /// @dev See {IGammaPoolFactory-setFee}\\n    function setFee(uint16 _fee) external;\\n\\n    /// @dev See {IGammaPoolFactory-setFeeTo}\\n    function setFeeTo(address _feeTo) external;\\n\\n    /// @dev See {IGammaPoolFactory-setOrigFeeShare}\\n    function setOrigFeeShare(uint16 _origFeeShare) external;\\n\\n    /// @dev See {IGammaPoolFactory-setFeeToSetter}\\n    function setFeeToSetter(address _feeToSetter) external;\\n\\n}\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/IProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Interface for Protocol\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface used to add protocols and initialize them in GammaPoolFactory\\ninterface IProtocol {\\n    /// @dev Protocol id of the implementation contract for this GammaPool\\n    function protocolId() external view returns(uint16);\\n\\n    /// @dev Check GammaPool for CFMM and tokens can be created with this implementation\\n    /// @param _tokens - assumed tokens of CFMM, validate function should check CFMM is indeed for these tokens\\n    /// @param _cfmm - address of CFMM GammaPool will be for\\n    /// @param _data - custom struct containing additional information used to verify the `_cfmm`\\n    /// @return _tokensOrdered - tokens ordered to match the same order as in CFMM\\n    function validateCFMM(address[] calldata _tokens, address _cfmm, bytes calldata _data) external view returns(address[] memory _tokensOrdered);\\n\\n    /// @dev Function to initialize state variables GammaPool, called usually from GammaPoolFactory contract right after GammaPool instantiation\\n    /// @param _cfmm - address of CFMM GammaPool is for\\n    /// @param _tokens - ERC20 tokens of CFMM\\n    /// @param _decimals - decimals of CFMM tokens, indices must match _tokens[] array\\n    /// @param _data - custom struct containing additional information used to verify the `_cfmm`\\n    /// @param _minBorrow - minimum amount of liquidity that can be borrowed or left unpaid in a loan\\n    function initialize(address _cfmm, address[] calldata _tokens, uint8[] calldata _decimals, uint72 _minBorrow, bytes calldata _data) external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/IRefunds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Interface for Refunds abstract contract\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface used to clear tokens from a contract\\ninterface IRefunds {\\n    /// @dev Withdraw ERC20 tokens from contract\\n    /// @param token - address of ERC20 token that will be withdrawn\\n    /// @param to - destination address where withdrawn quantity will be sent to\\n    /// @param minAmt - threshold balance before token can be withdrawn\\n    function clearToken(address token, address to, uint256 minAmt) external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/periphery/ISendTokensCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title ISendTokensCallback interface to handle callbacks to send tokens\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Used by periphery contracts to transfer token amounts requested by a GammaPool\\n/// @dev Verifies sender is GammaPool by hashing SendTokensCallbackData contents into msg.sender\\ninterface ISendTokensCallback {\\n\\n    /// @dev Struct received in sendTokensCallback (`data`) used to identify caller as GammaPool\\n    struct SendTokensCallbackData {\\n        /// @dev sender of tokens\\n        address payer;\\n\\n        /// @dev address of CFMM that will be used to identify GammaPool\\n        address cfmm;\\n\\n        /// @dev protocolId that will be used to identify GammaPool\\n        uint16 protocolId;\\n    }\\n\\n    /// @dev Transfer token `amounts` after verifying identity of caller using `data` is a GammaPool\\n    /// @param tokens - address of ERC20 tokens that will be transferred\\n    /// @param amounts - token amounts to be transferred\\n    /// @param payee - receiver of token `amounts`\\n    /// @param data - struct used to verify the function caller\\n    function sendTokensCallback(address[] calldata tokens, uint256[] calldata amounts, address payee, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/rates/IRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Interface of Interest Rate Model Store\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Interface of contract that saves and retrieves interest rate model parameters\\ninterface IRateModel {\\n    /// @dev Function to validate interest rate model parameters\\n    /// @param _data - bytes parameters containing interest rate model parameters\\n    /// @return validation - true if parameters passed validation\\n    function validateParameters(bytes calldata _data) external view returns(bool);\\n\\n    /// @dev Gets address of contract containing parameters for interest rate model\\n    /// @return address - address of smart contract that stores interest rate parameters\\n    function rateParamsStore() external view returns(address);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/IExternalStrategyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IStrategyEvents.sol\\\";\\n\\n/// @title External Strategy Events Interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events emitted by external strategy (flash loans) implementations\\ninterface IExternalStrategyEvents is IStrategyEvents {\\n    /// @dev Event emitted when a flash loan is made. Purpose of flash loan is for external swaps/rebalance of loan collateral\\n    /// @param tokenId - unique id that identifies the loan in question\\n    /// @param amounts - amounts of tokens held as collateral in pool that were swapped\\n    /// @param lpTokens - LP tokens swapped externally\\n    /// @param liquidity - total liquidity externally swapped in flash loan (amounts + lpTokens)\\n    /// @param txType - transaction type. Possible values come from enum TX_TYPE\\n    event ExternalSwap(uint256 indexed tokenId, uint128[] amounts, uint256 lpTokens, uint128 liquidity, TX_TYPE indexed txType);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/IGammaPoolERC20Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title GammaPool ERC20 Events\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events that should be emitted by all strategy implementations (root of all strategy events interfaces)\\ninterface IGammaPoolERC20Events {\\n    /// @dev Emitted when `amount` GS LP tokens are moved from account `from` to account `to`.\\n    /// @param from - address sending GS LP tokens\\n    /// @param to - address receiving GS LP tokens\\n    /// @param amount - amount of GS LP tokens being sent\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by a call to approve function. `amount` is the new allowance.\\n    /// @param owner - address which owns the GS LP tokens spender is being given permission to spend\\n    /// @param spender - address given permission to spend owner's GS LP tokens\\n    /// @param amount - amount of GS LP tokens spender is given permission to spend\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/ILiquidationStrategyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ILongStrategyEvents.sol\\\";\\n\\n/// @title Liquidation Strategy Events Interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events emitted by all liquidation strategy implementations\\ninterface ILiquidationStrategyEvents is ILongStrategyEvents {\\n    /// @dev Event emitted when liquidating through _liquidate or _liquidateWithLP functions\\n    /// @param tokenId - id identifier of loan being liquidated\\n    /// @param collateral - collateral of loan being liquidated\\n    /// @param liquidity - liquidity debt being repaid\\n    /// @param writeDownAmt - amount of liquidity invariant being written down\\n    /// @param fee - liquidation fee paid to liquidator in liquidity invariant units\\n    /// @param txType - type of liquidation. Possible values come from enum TX_TYPE\\n    event Liquidation(uint256 indexed tokenId, uint128 collateral, uint128 liquidity, uint128 writeDownAmt, uint128 fee, TX_TYPE txType);\\n}\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/ILongStrategyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IStrategyEvents.sol\\\";\\n\\n/// @title Long Strategy Events Interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events emitted by all long strategy implementations\\ninterface ILongStrategyEvents is IStrategyEvents {\\n    /// @dev Event emitted when a Loan is updated\\n    /// @param tokenId - unique id that identifies the loan in question\\n    /// @param tokensHeld - amounts of tokens held as collateral against the loan\\n    /// @param liquidity - liquidity invariant that was borrowed including accrued interest\\n    /// @param initLiquidity - initial liquidity borrowed excluding interest (principal)\\n    /// @param lpTokens - LP tokens borrowed excluding interest (principal)\\n    /// @param rateIndex - interest rate index of GammaPool at time loan is updated\\n    /// @param txType - transaction type. Possible values come from enum TX_TYPE\\n    event LoanUpdated(uint256 indexed tokenId, uint128[] tokensHeld, uint128 liquidity, uint128 initLiquidity, uint256 lpTokens, uint96 rateIndex, TX_TYPE indexed txType);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/IShortStrategyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IStrategyEvents.sol\\\";\\n\\n/// @title Short Strategy Events Interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events emitted by all short strategy implementations\\ninterface IShortStrategyEvents is IStrategyEvents {\\n    /// @dev Event emitted when a deposit of CFMM LP tokens in exchange of GS LP tokens happens (e.g. _deposit, _mint, _depositReserves, _depositNoPull)\\n    /// @param caller - address calling the function to deposit CFMM LP tokens\\n    /// @param to - address receiving GS LP tokens\\n    /// @param assets - amount CFMM LP tokens deposited\\n    /// @param shares - amount GS LP tokens minted\\n    event Deposit(address indexed caller, address indexed to, uint256 assets, uint256 shares);\\n\\n    /// @dev Event emitted when a withdrawal of CFMM LP tokens happens (e.g. _withdraw, _redeem, _withdrawReserves, _withdrawNoPull)\\n    /// @param caller - address calling the function to withdraw CFMM LP tokens\\n    /// @param to - address receiving CFMM LP tokens\\n    /// @param from - address redeeming/burning GS LP tokens\\n    /// @param assets - amount of CFMM LP tokens withdrawn\\n    /// @param shares - amount of GS LP tokens redeemed\\n    event Withdraw(address indexed caller, address indexed to, address indexed from, uint256 assets, uint256 shares);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/interfaces/strategies/events/IStrategyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Strategy Events interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Events that should be emitted by all strategy implementations (root of all strategy events interfaces)\\ninterface IStrategyEvents {\\n    enum TX_TYPE {\\n        DEPOSIT_LIQUIDITY,      // 0\\n        WITHDRAW_LIQUIDITY,     // 1\\n        DEPOSIT_RESERVES,       // 2\\n        WITHDRAW_RESERVES,      // 3\\n        INCREASE_COLLATERAL,    // 4\\n        DECREASE_COLLATERAL,    // 5\\n        REBALANCE_COLLATERAL,   // 6\\n        BORROW_LIQUIDITY,       // 7\\n        REPAY_LIQUIDITY,        // 8\\n        REPAY_LIQUIDITY_SET_RATIO,// 9\\n        REPAY_LIQUIDITY_WITH_LP,// 10\\n        LIQUIDATE,              // 11\\n        LIQUIDATE_WITH_LP,      // 12\\n        BATCH_LIQUIDATION,      // 13\\n        SYNC,                   // 14\\n        EXTERNAL_REBALANCE,     // 15\\n        EXTERNAL_LIQUIDATION,   // 16\\n        UPDATE_POOL }           // 17\\n\\n    /// @dev Event emitted when the Pool's global state variables is updated\\n    /// @param lpTokenBalance - quantity of CFMM LP tokens deposited in the pool\\n    /// @param lpTokenBorrowed - quantity of CFMM LP tokens that have been borrowed from the pool (principal)\\n    /// @param lastBlockNumber - last block the Pool's where updated\\n    /// @param accFeeIndex - interest of total accrued interest in the GammaPool until current update\\n    /// @param lpTokenBorrowedPlusInterest - quantity of CFMM LP tokens that have been borrowed from the pool including interest\\n    /// @param lpInvariant - lpTokenBalance as invariant units\\n    /// @param borrowedInvariant - lpTokenBorrowedPlusInterest as invariant units\\n    /// @param cfmmReserves - reserves in CFMM. Used to track price\\n    /// @param txType - transaction type. Possible values come from enum TX_TYPE\\n    event PoolUpdated(uint256 lpTokenBalance, uint256 lpTokenBorrowed, uint40 lastBlockNumber, uint80 accFeeIndex,\\n        uint256 lpTokenBorrowedPlusInterest, uint128 lpInvariant, uint128 borrowedInvariant, uint128[] cfmmReserves, TX_TYPE indexed txType);\\n}\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/libraries/AddressCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\nimport \\\"../interfaces/IGammaPoolFactory.sol\\\";\\n\\n/// @title Library used calculate the deterministic addresses used to instantiate GammaPools\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev These algorithms are based on EIP-1014 (https://eips.ethereum.org/EIPS/eip-1014)\\nlibrary AddressCalculator {\\n\\n    /// @dev calculate salt used to create deterministic address, the salt is also used as unique key identifier for the GammaPool\\n    /// @param cfmm - address of CFMM the GammaPool is for\\n    /// @param protocolId - protocol id of instance address the GammaPool will use (version of GammaPool for this CFMM)\\n    /// @return key - key/salt used as unique identifier of GammaPool\\n    function getGammaPoolKey(address cfmm, uint16 protocolId) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(cfmm, protocolId)); // key is hash of CFMM address and protocolId\\n    }\\n\\n    /// @dev calculate deterministic address to instantiate GammaPool minimal beacon proxy or minimal proxy contract\\n    /// @param factory - address of factory that will instantiate GammaPool proxy contract\\n    /// @param protocolId - protocol id of instance address the GammaPool will use (version of this GammaPool)\\n    /// @param key - salt used in address generation to assure its uniqueness\\n    /// @return _address - address of GammaPool that maps to protocolId and key\\n    function calcAddress(address factory, uint16 protocolId, bytes32 key) internal view returns (address) {\\n        if (protocolId < 10000) {\\n            return predictDeterministicAddress(IGammaPoolFactory(factory).getProtocolBeacon(protocolId), protocolId, key, factory);\\n        } else {\\n            return predictDeterministicAddress2(IGammaPoolFactory(factory).getProtocol(protocolId), key, factory);\\n        }\\n    }\\n\\n    /// @dev calculate a deterministic address based on init code hash\\n    /// @param factory - address of factory that instantiated or will instantiate this contract\\n    /// @param salt - salt used in address generation to assure its uniqueness\\n    /// @param initCodeHash - init code hash of template contract which will be used to instantiate contract with deterministic address\\n    /// @return _address - address of contract that maps to salt and init code hash that is created by factory contract\\n    function calcAddress(address factory, bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\\n        return address(uint160(uint256(keccak256(abi.encodePacked(hex\\\"ff\\\",factory,salt,initCodeHash)))));\\n    }\\n\\n    /// @dev Compute bytecode of a minimal beacon proxy contract, excluding bytecode metadata hash\\n    /// @param beacon - address of beacon of minimal beacon proxy\\n    /// @param protocolId - id of protocol\\n    /// @param factory - address of factory that instantiated or will instantiate this contract\\n    /// @return bytecode - the calculated bytecode for minimal beacon proxy contract\\n    function calcMinimalBeaconProxyBytecode(\\n        address beacon,\\n        uint16 protocolId,\\n        address factory\\n    ) internal pure returns(bytes memory) {\\n        return abi.encodePacked(\\n            hex\\\"608060405234801561001057600080fd5b5073\\\",\\n            beacon,\\n            hex\\\"7f\\\",\\n            hex\\\"a3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\\\",\\n            hex\\\"5560\\\",\\n            protocolId < 256 ? hex\\\"6c\\\" : hex\\\"6d\\\",\\n            hex\\\"806100566000396000f3fe\\\",\\n            hex\\\"608060408190526334b1f0a960e21b8152\\\",\\n            protocolId < 256 ? hex\\\"60\\\" : hex\\\"61\\\",\\n            protocolId < 256 ? abi.encodePacked(uint8(protocolId)) : abi.encodePacked(protocolId),\\n            hex\\\"60845260208160248173\\\",\\n            factory,\\n            hex\\\"5afa60\\\",\\n            protocolId < 256 ? hex\\\"3a\\\" : hex\\\"3b\\\",\\n            hex\\\"573d6000fd5b5060805160003681823780813683855af491503d81823e81801560\\\",\\n            protocolId < 256 ? hex\\\"5b\\\" : hex\\\"5c\\\",\\n            hex\\\"573d82f35b3d82fdfea164736f6c6343000815000a\\\"\\n        );\\n    }\\n\\n    /// @dev Computes the address of a minimal beacon proxy contract\\n    /// @param protocolId - id of protocol\\n    /// @param salt - salt used in address generation to assure its uniqueness\\n    /// @param factory - address of factory that instantiated or will instantiate this contract\\n    /// @return predicted - the calculated address\\n    function predictDeterministicAddress(\\n        address beacon,\\n        uint16 protocolId,\\n        bytes32 salt,\\n        address factory\\n    ) internal pure returns (address) {\\n        bytes memory bytecode = calcMinimalBeaconProxyBytecode(beacon, protocolId, factory);\\n\\n        // Compute the hash of the initialization code.\\n        bytes32 bytecodeHash = keccak256(bytecode);\\n\\n        // Compute the final CREATE2 address\\n        bytes32 data = keccak256(abi.encodePacked(bytes1(0xff), factory, salt, bytecodeHash));\\n        return address(uint160(uint256(data)));\\n    }\\n\\n    /// @dev Computes the address of a minimal proxy contract\\n    /// @param implementation - address of implementation contract of this minimal proxy contract\\n    /// @param salt - salt used in address generation to assure its uniqueness\\n    /// @param factory - address of factory that instantiated or will instantiate this contract\\n    /// @return predicted - the calculated address\\n    function predictDeterministicAddress2(\\n        address implementation,\\n        bytes32 salt,\\n        address factory\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), factory)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/libraries/GammaSwapLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Library used to perform common ERC20 transactions\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Library performs approvals, transfers and views ERC20 state fields\\nlibrary GammaSwapLibrary {\\n\\n    error ST_Fail();\\n    error STF_Fail();\\n    error SA_Fail();\\n    error STE_Fail();\\n\\n    /// @dev Check the ERC20 balance of an address\\n    /// @param _token - address of ERC20 token we're checking the balance of\\n    /// @param _address - Ethereum address we're checking for balance of ERC20 token\\n    /// @return balanceOf - amount of _token held in _address\\n    function balanceOf(address _token, address _address) internal view returns (uint256) {\\n        (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20.balanceOf, _address));\\n\\n        require(success && data.length >= 32);\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    /// @dev Get how much of an ERC20 token is in existence (minted)\\n    /// @param _token - address of ERC20 token we're checking the total minted amount of\\n    /// @return totalSupply - total amount of _token that is in existence (minted and not burned)\\n    function totalSupply(address _token) internal view returns (uint256) {\\n        (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20.totalSupply,()));\\n\\n        require(success && data.length >= 32);\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    /// @dev Get decimals of ERC20 token\\n    /// @param _token - address of ERC20 token we are getting the decimal information from\\n    /// @return decimals - decimals of ERC20 token\\n    function decimals(address _token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature(\\\"decimals()\\\")); // requesting via ERC20 decimals implementation\\n\\n        require(success && data.length >= 1);\\n\\n        return abi.decode(data, (uint8));\\n    }\\n\\n    /// @dev Get symbol of ERC20 token\\n    /// @param _token - address of ERC20 token we are getting the symbol information from\\n    /// @return symbol - symbol of ERC20 token\\n    function symbol(address _token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature(\\\"symbol()\\\")); // requesting via ERC20 symbol implementation\\n\\n        require(success && data.length >= 1);\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @dev Get name of ERC20 token\\n    /// @param _token - address of ERC20 token we are getting the name information from\\n    /// @return name - name of ERC20 token\\n    function name(address _token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature(\\\"name()\\\")); // requesting via ERC20 name implementation\\n\\n        require(success && data.length >= 1);\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @dev Safe transfer any ERC20 token, only used internally\\n    /// @param _token - address of ERC20 token that will be transferred\\n    /// @param _to - destination address where ERC20 token will be sent to\\n    /// @param _amount - quantity of ERC20 token to be transferred\\n    function safeTransfer(address _token, address _to, uint256 _amount) internal {\\n        (bool success, bytes memory data) = _token.call(abi.encodeCall(IERC20.transfer, (_to, _amount)));\\n\\n        if(!(success && (data.length == 0 || abi.decode(data, (bool))))) revert ST_Fail();\\n    }\\n\\n    /// @dev Moves `amount` of ERC20 token `_token` from `_from` to `_to` using the allowance mechanism. `_amount` is then deducted from the caller's allowance.\\n    /// @param _token - address of ERC20 token that will be transferred\\n    /// @param _from - address sending _token (not necessarily caller's address)\\n    /// @param _to - address receiving _token\\n    /// @param _amount - amount of _token being sent\\n    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal {\\n        (bool success, bytes memory data) = _token.call(abi.encodeCall(IERC20.transferFrom, (_from, _to, _amount)));\\n\\n        if(!(success && (data.length == 0 || abi.decode(data, (bool))))) revert STF_Fail();\\n    }\\n\\n    /// @dev Safe approve any ERC20 token to be spent by another address (`_spender`), only used internally\\n    /// @param _token - address of ERC20 token that will be approved\\n    /// @param _spender - address that will be granted approval to spend msg.sender tokens\\n    /// @param _amount - quantity of ERC20 token that `_spender` will be approved to spend\\n    function safeApprove(address _token, address _spender, uint256 _amount) internal {\\n        (bool success, bytes memory data) = _token.call(abi.encodeCall(IERC20.approve, (_spender, _amount)));\\n\\n        if(!(success && (data.length == 0 || abi.decode(data, (bool))))) revert SA_Fail();\\n    }\\n\\n    /// @dev Safe transfer any ERC20 token, only used internally\\n    /// @param _to - destination address where ETH will be sent to\\n    /// @param _amount - quantity of ERC20 token to be transferred\\n    function safeTransferETH(address _to, uint256 _amount) internal {\\n        (bool success, ) = _to.call{value: _amount}(\\\"\\\");\\n\\n        if(!success) revert STE_Fail();\\n    }\\n\\n    /// @dev Check if `account` is a smart contract's address and it has been instantiated (has code)\\n    /// @param account - Ethereum address to check if it's a smart contract address\\n    /// @return bool - true if it is a smart contract address\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function convertUint128ToUint256Array(uint128[] memory arr) internal pure returns(uint256[] memory res) {\\n        res = new uint256[](arr.length);\\n        for(uint256 i = 0; i < arr.length;) {\\n            res[i] = uint256(arr[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function convertUint128ToRatio(uint128[] memory arr) internal pure returns(uint256[] memory res) {\\n        res = new uint256[](arr.length);\\n        for(uint256 i = 0; i < arr.length;) {\\n            res[i] = uint256(arr[i]) * 1000;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@gammaswap/v1-core/contracts/utils/TwoStepOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.0;\\n\\n/// @title Two Step Ownership Contract implementation\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Transfers ownership of contract to another address using a two step method\\ncontract TwoStepOwnable {\\n    /// @dev Event emitted when ownership of GammaPoolFactory contract is transferred to a new address\\n    /// @param previousOwner - previous address that owned factory contract\\n    /// @param newOwner - new address that owns factory contract\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @dev Event emitted when change of ownership of GammaPoolFactory contract is started\\n    /// @param currentOwner - current address that owns factory contract\\n    /// @param newOwner - new address that will own factory contract\\n    event OwnershipTransferStarted(address indexed currentOwner, address indexed newOwner);\\n\\n    /// @dev Owner of contract\\n    address public owner;\\n\\n    /// @dev Pending owner to implement transfer of ownership in two steps\\n    address public pendingOwner;\\n\\n    /// @dev Initialize `owner` of smart contract\\n    constructor(address _owner) {\\n        owner = _owner;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        require(owner == msg.sender, \\\"Forbidden\\\");\\n    }\\n\\n    /// @dev Starts ownership transfer to new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\\n    /// @param newOwner - new address that will have the owner privileges over the factory contract\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(newOwner != address(0), \\\"ZeroAddress\\\");// not allow to transfer ownership to zero address (renounce ownership forever)\\n        pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner, newOwner);\\n    }\\n\\n    /// @notice The new owner accepts the ownership transfer.\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n    function acceptOwnership() external virtual {\\n        address newOwner = msg.sender;\\n        require(pendingOwner == newOwner, \\\"NotNewOwner\\\");\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        delete pendingOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/base/GammaPoolERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract GammaPoolERC721 is Context, ERC165, IERC721, IERC721Metadata  {\\n\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    error ERC721Forbidden();\\n    error ERC721ApproveOwner();\\n    error ERC721ZeroAddress();\\n    error ERC721InvalidTokenID();\\n    error ERC721TransferToNonReceiver();\\n    error ERC721MintToZeroAddress();\\n    error ERC721TokenExists();\\n    error ERC721TransferFromWrongOwner();\\n    error ERC721TransferToZeroAddress();\\n    error ERC721ApproveToCaller();\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Revert ERC721 transaction if msg.sender is not authorized perform ERC721 transaction\\n     */\\n    function isForbidden(uint256 tokenId) internal virtual view {\\n        if(!_isApprovedOrOwner(_msgSender(), tokenId)) {\\n            revert ERC721Forbidden();\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        isForbidden(tokenId);\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        isForbidden(tokenId);\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = GammaPoolERC721.ownerOf(tokenId);\\n\\n        if(to == owner) {\\n            revert ERC721ApproveOwner();\\n        }\\n\\n        if(_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\\n            revert ERC721Forbidden();\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n        interfaceId == type(IERC721).interfaceId ||\\n        interfaceId == type(IERC721Metadata).interfaceId ||\\n        super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if(owner == address(0)) {\\n            revert ERC721ZeroAddress();\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        if(owner == address(0)) {\\n            revert ERC721InvalidTokenID();\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if(!_checkOnERC721Received(from, to, tokenId, data)) {\\n            revert ERC721TransferToNonReceiver();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = GammaPoolERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        if(!_checkOnERC721Received(address(0), to, tokenId, data)) {\\n            revert ERC721TransferToNonReceiver();\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        if(to == address(0)) {\\n            revert ERC721MintToZeroAddress();\\n        }\\n        if(_exists(tokenId)) {\\n            revert ERC721TokenExists();\\n        }\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = GammaPoolERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        if(GammaPoolERC721.ownerOf(tokenId) != from) {\\n            revert ERC721TransferFromWrongOwner();\\n        }\\n        if(to == address(0)) {\\n            revert ERC721TransferToZeroAddress();\\n        }\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(GammaPoolERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        if(owner == operator) {\\n            revert ERC721ApproveToCaller();\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        if(!_exists(tokenId)) {\\n            revert ERC721InvalidTokenID();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    //revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                    revert ERC721TransferToNonReceiver();\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/base/GammaPoolQueryableLoans.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\n\\nimport \\\"../interfaces/ILoanStore.sol\\\";\\nimport \\\"./GammaPoolERC721.sol\\\";\\n\\n/// @title GammaPoolQueryableLoans\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Makes ERC721 loans queryable by PositionManager\\nabstract contract GammaPoolQueryableLoans is GammaPoolERC721 {\\n\\n    /// @dev Database where it will store loan information. dataStore has to know this address though to accept messages\\n    address public dataStore;\\n\\n    /// @dev Mint tokenId of loan as ERC721 NFT and store in mappings so that it can be queried\\n    /// @param pool - pool loan identified by `tokenId` belongs to\\n    /// @param tokenId - unique identifier of loan\\n    /// @param owner - owner of loan\\n    function mintQueryableLoan(address pool, uint256 tokenId, address owner) internal virtual {\\n        _safeMint(owner, tokenId);\\n        if(dataStore != address(0)) {\\n            ILoanStore(dataStore).addLoanToOwner(pool, tokenId, owner);\\n        }\\n    }\\n\\n    /// @dev See {GammaPoolERC721-_transfer}.\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._transfer(from, to, tokenId);\\n        if(dataStore != address(0)) {\\n            ILoanStore(dataStore).transferLoan(from, to, tokenId);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/base/Transfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\n\\nimport \\\"@gammaswap/v1-core/contracts/libraries/GammaSwapLibrary.sol\\\";\\nimport \\\"../interfaces/ITransfers.sol\\\";\\nimport \\\"../interfaces/external/IWETH.sol\\\";\\n\\n/// @title Transfers abstract contract implementation of ITransfers\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Clears tokens and Ether from PositionManager and simplifies token transfer functions\\n/// @dev PositionManager is not supposed to hold any tokens or Ether\\nabstract contract Transfers is ITransfers {\\n\\n    error NotWETH();\\n    error NotEnoughWETH();\\n    error NotEnoughTokens();\\n    error NotGammaPool();\\n\\n    /// @dev See {ITransfers-WETH}\\n    address public immutable override WETH;\\n\\n    /// @dev Initialize the contract by setting `WETH`\\n    constructor(address _WETH) {\\n        WETH = _WETH;\\n    }\\n\\n    /// @dev Do not accept any Ether unless it comes from Wrapped Ether (WETH) contract\\n    receive() external payable {\\n        if(msg.sender != WETH) {\\n          revert NotWETH();\\n        }\\n    }\\n\\n    /// @dev See {ITransfers-unwrapWETH}\\n    function unwrapWETH(uint256 minAmt, address to) public payable override {\\n        uint256 wethBal = IERC20(WETH).balanceOf(address(this));\\n        if(wethBal < minAmt) {\\n            revert NotEnoughWETH();\\n        }\\n\\n        if (wethBal > 0) {\\n            IWETH(WETH).withdraw(wethBal);\\n            GammaSwapLibrary.safeTransferETH(to, wethBal);\\n        }\\n    }\\n\\n    /// @dev See {ITransfers-refundETH}\\n    function refundETH() external payable override {\\n        if (address(this).balance > 0) GammaSwapLibrary.safeTransferETH(msg.sender, address(this).balance);\\n    }\\n\\n    /// @dev See {ITransfers-clearToken}\\n    function clearToken(address token, address to, uint256 minAmt) public virtual override {\\n        uint256 tokenBal = IERC20(token).balanceOf(address(this));\\n        if(tokenBal < minAmt) {\\n            revert NotEnoughTokens();\\n        }\\n\\n        if (tokenBal > 0) GammaSwapLibrary.safeTransfer(token, to, tokenBal);\\n    }\\n\\n    /// @dev Used to abstract token transfer functions into one function call\\n    /// @param token - ERC20 token to transfer\\n    /// @param sender - address sending the token\\n    /// @param to - recipient of token `amount` from sender\\n    /// @param amount - quantity of `token` that will be sent to recipient `to`\\n    function send(address token, address sender, address to, uint256 amount) internal {\\n        if (token == WETH && address(this).balance >= amount) {\\n            IWETH(WETH).deposit{value: amount}(); // wrap only what is needed\\n            GammaSwapLibrary.safeTransfer(WETH, to, amount);\\n        } else if (sender == address(this)) {\\n            // send with tokens already in the contract\\n            GammaSwapLibrary.safeTransfer(token, to, amount);\\n        } else {\\n            // pull transfer\\n            GammaSwapLibrary.safeTransferFrom(token, sender, to, amount);\\n        }\\n    }\\n\\n    /// @dev Used to transfer multiple tokens in one function call\\n    /// @param tokens - ERC20 tokens to transfer\\n    /// @param sender - address sending the token\\n    /// @param to - recipient of token `amount` from sender\\n    /// @param amounts - quantity of `token` that will be sent to recipient `to`\\n    function sendTokens(address[] memory tokens, address sender, address to, uint256[] calldata amounts) internal {\\n        uint256 len = tokens.length;\\n        for (uint256 i; i < len;) {\\n            if (amounts[i] > 0 ) send(tokens[i], sender, to, amounts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Retrieves GammaPool address using cfmm address and protocolId\\n    /// @param cfmm - address of CFMM of GammaPool whose address we want to calculate\\n    /// @param protocolId - identifier of GammaPool implementation for the `cfmm`\\n    /// @return pool - address of GammaPool\\n    function getGammaPoolAddress(address cfmm, uint16 protocolId) internal virtual view returns(address);\\n\\n    /// @dev See {ISendTokensCallback-sendTokensCallback}.\\n    function sendTokensCallback(address[] calldata tokens, uint256[] calldata amounts, address payee, bytes calldata data) external virtual override {\\n        SendTokensCallbackData memory decoded = abi.decode(data, (SendTokensCallbackData));\\n\\n        // Revert if msg.sender is not GammaPool for CFMM and protocolId\\n        if(msg.sender != getGammaPoolAddress(decoded.cfmm, decoded.protocolId)) {\\n            revert NotGammaPool();\\n        }\\n\\n        // Transfer tokens from decoded.payer to payee\\n        sendTokens(tokens, decoded.payer, payee, amounts);\\n    }\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/external/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Wrapped Ether interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Used to interact with Wrapped Ether contract\\n/// @dev Only defines functions we\\ninterface IWETH is IERC20 {\\n    /// @dev Emitted when Ether is deposited into Wrapped Ether contract to issue Wrapped Ether\\n    /// @param to - receiver of wrapped ether\\n    /// @param amount - amount of wrapped ether issued to receiver\\n    event Deposit(address indexed to, uint amount);\\n\\n    /// @dev Emitted when Ether is withdrawn from Wrapped Ether contract by burning Wrapped Ether\\n    /// @param from - receiver of ether\\n    /// @param amount - amount of ether sent to `from`\\n    event Withdrawal(address indexed from, uint amount);\\n\\n    /// @dev Deposit ether to issue Wrapped Ether\\n    function deposit() external payable;\\n\\n    /// @dev Withdraw ether by burning Wrapped Ether\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/IAutoStakable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IPositionManager.sol\\\";\\n\\n/// @title Interface for extending PositionManager with auto stake/unstake capability\\n/// @author Simon Mall\\n/// @dev This should be used along with IPositionManager to define a contract\\ninterface IAutoStakable {\\n  /// @dev error to emit when trying to use staking router and router is not set\\n  error StakingRouterNotSet();\\n\\n  /// @dev Set staking router contract address\\n  /// @dev Requires admin permission\\n  /// @param _stakingRouter Staking Router contract address\\n  function setStakingRouter(address _stakingRouter) external;\\n\\n  /// @dev Deposit reserve tokens into a GammaPool and stake GS LP tokens\\n  /// @dev See more {IPositionManager-depositReserves}\\n  /// @param params - struct containing parameters to identify a GammaPool to deposit reserve tokens to\\n  /// @param esToken - address of escrow token of staking contract\\n  /// @return reserves - reserve tokens deposited into GammaPool\\n  /// @return shares - GS LP token shares minted for depositing\\n  function depositReservesAndStake(IPositionManager.DepositReservesParams calldata params, address esToken) external returns(uint256[] memory reserves, uint256 shares);\\n\\n  /// @dev Unstake GS LP tokens from staking router and withdraw reserve tokens from a GammaPool\\n  /// @dev See more {IPositionManager-withdrawReserves}\\n  /// @param params - struct containing parameters to identify a GammaPool to withdraw reserve tokens from\\n  /// @param esToken - address of escrow token of staking contract\\n  /// @return reserves - reserve tokens withdrawn from GammaPool\\n  /// @return assets - CFMM LP token shares equivalent of reserves withdrawn from GammaPool\\n  function withdrawReservesAndUnstake(IPositionManager.WithdrawReservesParams calldata params, address esToken) external returns (uint256[] memory reserves, uint256 assets);\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/ILoanStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Interface for Loan Store\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface to interact with contract that stores all loans on chain, if enabled in PositionManager\\ninterface ILoanStore {\\n\\n    /// @dev Struct to store identifiable information about loan to perform queries in PositionManager\\n    struct LoanInfo {\\n        /// @dev Address of pool loan belongs to\\n        address pool;\\n        /// @dev Add loan to mappings by user\\n        uint256 byOwnerAndPoolIdx;\\n        /// @dev Add loan to mappings by user\\n        uint256 byOwnerIdx;\\n    }\\n\\n    /// @dev Add loan to mappings by user so that they can be queried\\n    /// @param pool - pool loan identified by `tokenId` belongs to\\n    /// @param tokenId - unique identifier of loan\\n    /// @param owner - owner of loan\\n    function addLoanToOwner(address pool, uint256 tokenId, address owner) external;\\n\\n    /// @dev Transfer loan identified by `tokenId` from address `from` to another address `to`\\n    /// @param from - address transferring loan\\n    /// @param to - address receiving loan\\n    /// @param tokenId - unique identifier of loan\\n    function transferLoan(address from, address to, uint256 tokenId) external;\\n\\n    /// @param _source - address supplying loan information\\n    function setSource(address _source) external;\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/IPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"@gammaswap/v1-core/contracts/interfaces/IGammaPoolEvents.sol\\\";\\nimport \\\"./ITransfers.sol\\\";\\n\\n/// @title Interface for PositionManager\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Defines external functions and events emitted by PositionManager\\n/// @dev Interface also defines all GammaPool events through inheritance of IGammaPoolEvents\\ninterface IPositionManager is IGammaPoolEvents, ITransfers {\\n    /// @dev Emitted when depositing CFMM LP tokens as liquidity in a pool\\n    /// @param pool - address of pool minting GS LP tokens\\n    /// @param shares - minted quantity of pool's GS LP tokens\\n    event DepositNoPull(address indexed pool, uint256 shares);\\n\\n    /// @dev Emitted when withdrawing CFMM LP tokens previously provided as liquidity from a pool\\n    /// @param pool - address of pool redeeming GS LP tokens for CFMM LP tokens\\n    /// @param assets - quantity of CFMM LP tokens withdrawn from pool\\n    event WithdrawNoPull(address indexed pool, uint256 assets);\\n\\n    /// @dev Emitted when depositing reserve tokens as liquidity in a pool\\n    /// @param pool - address of pool redeeming GS LP tokens for CFMM LP tokens\\n    /// @param reserves - quantity of reserve tokens deposited in pool\\n    /// @param shares - minted quantity of pool's GS LP tokens representing the reserves deposit\\n    event DepositReserve(address indexed pool, uint256[] reserves, uint256 shares);\\n\\n    /// @dev Emitted when withdrawing reserve tokens previously provided as liquidity from a pool\\n    /// @param pool - address of pool redeeming GS LP tokens for CFMM LP tokens\\n    /// @param reserves - quantity of reserve tokens withdrawn from pool\\n    /// @param assets - reserve tokens withdrawn from pool in terms of CFMM LP tokens\\n    event WithdrawReserve(address indexed pool, uint256[] reserves, uint256 assets);\\n\\n    /// @dev Emitted when new loan in a pool is created. PositionManager owns new loan, owner owns new NFT that manages loan\\n    /// @param pool - address of pool where loan will be created\\n    /// @param owner - address of owner of newly minted NFT that manages newly created loan\\n    /// @param tokenId - unique id that identifies new loan in GammaPool\\n    /// @param refId - Reference id of post transaction activities attached to this loan\\n    event CreateLoan(address indexed pool, address indexed owner, uint256 tokenId, uint16 refId);\\n\\n    /// @dev Emitted when increasing a loan's collateral amounts\\n    /// @param pool - address of pool collateral amounts are deposited to\\n    /// @param tokenId - id identifying loan in pool\\n    /// @param tokensHeld - new loan collateral amounts\\n    /// @param amounts - collateral amounts being deposited\\n    event IncreaseCollateral(address indexed pool, uint256 tokenId, uint128[] tokensHeld, uint256[] amounts);\\n\\n    /// @dev Emitted when decreasing a loan's collateral amounts\\n    /// @param pool - address of pool collateral amounts are withdrawn from\\n    /// @param tokenId - id identifying loan in pool\\n    /// @param tokensHeld - new loan collateral amounts\\n    /// @param amounts - amounts of reserve tokens withdraws from loan\\n    event DecreaseCollateral(address indexed pool, uint256 tokenId, uint128[] tokensHeld, uint128[] amounts);\\n\\n    /// @dev Emitted when re-balancing a loan's collateral amounts (swapping one collateral token for another)\\n    /// @param pool - loan's pool address\\n    /// @param tokenId - id identifying loan in pool\\n    /// @param tokensHeld - new loan collateral amounts\\n    event RebalanceCollateral(address indexed pool, uint256 tokenId, uint128[] tokensHeld);\\n\\n    /// @dev Emitted when borrowing liquidity from a pool\\n    /// @param pool - address of pool whose liquidity was borrowed\\n    /// @param tokenId - id identifying loan in pool that will track liquidity debt\\n    /// @param liquidityBorrowed - liquidity borrowed in invariant terms\\n    /// @param amounts - liquidity borrowed in terms of reserve token amounts\\n    event BorrowLiquidity(address indexed pool, uint256 tokenId, uint256 liquidityBorrowed, uint256[] amounts);\\n\\n    /// @dev Emitted when repaying liquidity debt from a pool\\n    /// @param pool - address of pool whose liquidity debt was paid\\n    /// @param tokenId - id identifying loan in pool that will track liquidity debt\\n    /// @param liquidityPaid - liquidity repaid in invariant terms\\n    /// @param amounts - liquidity repaid in terms of reserve token amounts\\n    event RepayLiquidity(address indexed pool, uint256 tokenId, uint256 liquidityPaid, uint256[] amounts);\\n\\n    /// @dev Emitted when repaying liquidity debt from a pool\\n    /// @param pool - address of pool whose liquidity debt was paid\\n    /// @param tokenId - id identifying loan in pool that will track liquidity debt\\n    /// @param liquidityPaid - liquidity repaid in invariant terms\\n    /// @param amounts - liquidity repaid in terms of reserve token amounts\\n    event RepayLiquiditySetRatio(address indexed pool, uint256 tokenId, uint256 liquidityPaid, uint256[] amounts);\\n\\n    /// @dev Emitted when repaying liquidity debt from a pool\\n    /// @param pool - address of pool whose liquidity debt was paid\\n    /// @param tokenId - id identifying loan in pool that will track liquidity debt\\n    /// @param liquidityPaid - liquidity repaid in invariant terms\\n    /// @param tokensHeld - new loan collateral amounts\\n    /// @param lpTokens - CFMM LP tokens used to repay liquidity debt\\n    event RepayLiquidityWithLP(address indexed pool, uint256 tokenId, uint256 liquidityPaid, uint128[] tokensHeld, uint256 lpTokens);\\n\\n    event LoanUpdate(uint256 indexed tokenId, address indexed poolId, address indexed owner, uint128[] tokensHeld,\\n        uint256 liquidity, uint256 lpTokens, uint256 initLiquidity, uint128[] cfmmReserves);\\n\\n    /// @dev Struct parameters for `depositNoPull` and `withdrawNoPull` functions. Depositing/Withdrawing CFMM LP tokens\\n    struct DepositWithdrawParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of GS LP tokens when depositing or of CFMM LP tokens when withdrawing\\n        address to;\\n        /// @dev CFMM LP tokens requesting to deposit or withdraw\\n        uint256 lpTokens;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n    }\\n\\n    /// @dev Struct parameters for `depositReserves` function. Depositing reserve tokens\\n    struct DepositReservesParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of GS LP tokens when depositing\\n        address to;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens caller desires to deposit\\n        uint256[] amountsDesired;\\n        /// @dev minimum amounts of reserve tokens expected to have been deposited. Slippage protection\\n        uint256[] amountsMin;\\n    }\\n\\n    /// @dev Struct parameters for `withdrawReserves` function. Withdrawing reserve tokens\\n    struct WithdrawReservesParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of reserve tokens when withdrawing\\n        address to;\\n        /// @dev amount of GS LP tokens that will be burned in the withdrawal\\n        uint256 amount;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn. Slippage protection\\n        uint256[] amountsMin;\\n    }\\n\\n    /// @dev Struct parameters for `borrowLiquidity` function. Borrowing liquidity\\n    struct BorrowLiquidityParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan to which liquidity borrowed will be credited to\\n        uint256 tokenId;\\n        /// @dev CFMM LP tokens requesting to borrow to short\\n        uint256 lpTokens;\\n        /// @dev Ratio to rebalance collateral to\\n        uint256[] ratio;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn representing the `lpTokens`. Slippage protection\\n        uint256[] minBorrowed;\\n        /// @dev max borrowed liquidity\\n        uint256 maxBorrowed;\\n        /// @dev minimum amounts of reserve tokens expected to have been used to repay the liquidity debt. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `repayLiquidity` function. Repaying liquidity\\n    struct RepayLiquidityParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan whose liquidity debt will be paid\\n        uint256 tokenId;\\n        /// @dev liquidity debt to pay\\n        uint256 liquidity;\\n        /// @dev if true re-balance collateral to `ratio`\\n        bool isRatio;\\n        /// @dev If re-balancing to a desired ratio set this to the ratio you'd like, otherwise leave as an empty array\\n        uint256[] ratio;\\n        /// @dev collateralId - index of collateral token + 1\\n        uint256 collateralId;\\n        /// @dev to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n        address to;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of reserve tokens expected to have been used to repay the liquidity debt. Slippage protection\\n        uint256[] minRepaid;\\n    }\\n\\n    /// @dev Struct parameters for `repayLiquidityWithLP` function. Repaying liquidity with CFMM LP tokens\\n    struct RepayLiquidityWithLPParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan whose liquidity debt will be paid\\n        uint256 tokenId;\\n        /// @dev if using LP tokens to repay liquidity set this to > 0\\n        uint256 lpTokens;\\n        /// @dev collateralId - index of collateral token + 1\\n        uint256 collateralId;\\n        /// @dev to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n        address to;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of reserve tokens expected to have been used to repay the liquidity debt. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `increaseCollateral` and `decreaseCollateral` function.\\n    struct AddCollateralParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of reserve tokens when withdrawing collateral\\n        address to;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens requesting to deposit as collateral for a loan or withdraw from a loan's collateral\\n        uint256[] amounts;\\n        /// @dev ratio - ratio of loan collateral to be maintained after increasing collateral\\n        uint256[] ratio;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `increaseCollateral` and `decreaseCollateral` function.\\n    struct RemoveCollateralParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of reserve tokens when withdrawing collateral\\n        address to;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens requesting to deposit as collateral for a loan or withdraw from a loan's collateral\\n        uint128[] amounts;\\n        /// @dev ratio - ratio of loan collateral to be maintained after decreasing collateral\\n        uint256[] ratio;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `rebalanceCollateral` function.\\n    struct RebalanceCollateralParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev amounts of reserve tokens to swap (>0 buy token, <0 sell token). At least one index value must be set to zero\\n        int256[] deltas;\\n        /// @dev Ratio to rebalance collateral to\\n        uint256[] ratio;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `borrowAndRebalance` function.\\n    struct CreateLoanBorrowAndRebalanceParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev owner of NFT created by PositionManager. Owns loan through PositionManager\\n        address to;\\n        /// @dev reference id of loan observer to track loan\\n        uint16 refId;\\n        /// @dev amounts of requesting to deposit as collateral for a loan or withdraw from a loan's collateral\\n        uint256[] amounts;\\n        /// @dev CFMM LP tokens requesting to borrow to short\\n        uint256 lpTokens;\\n        /// @dev Ratio to rebalance collateral to\\n        uint256[] ratio;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn representing the `lpTokens`. Slippage protection\\n        uint256[] minBorrowed;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev max borrowed liquidity\\n        uint256 maxBorrowed;\\n    }\\n\\n    /// @dev Struct parameters for `createLoanBorrowAndRebalance` function.\\n    struct BorrowAndRebalanceParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of reserve tokens when withdrawing collateral\\n        address to;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev CFMM LP tokens requesting to borrow to short\\n        uint256 lpTokens;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens requesting to deposit as collateral for a loan\\n        uint256[] amounts;\\n        /// @dev Ratio to rebalance collateral to\\n        uint256[] ratio;\\n        /// @dev amounts of reserve tokens requesting to withdraw from a loan's collateral\\n        uint128[] withdraw;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn representing the `lpTokens` (borrowing). Slippage protection\\n        uint256[] minBorrowed;\\n        /// @dev amounts of reserve tokens to swap (>0 buy token, <0 sell token). At least one index value must be set to zero\\n        uint128[] minCollateral;\\n        /// @dev max borrowed liquidity\\n        uint256 maxBorrowed;\\n    }\\n\\n    /// @return factory - factory contract that creates all GammaPools this PositionManager interacts with\\n    function factory() external view returns (address);\\n\\n    // Short Gamma\\n\\n    /// @dev Deposit CFMM LP tokens into a GammaPool and receive GS LP tokens\\n    /// @param params - struct containing parameters to identify a GammaPool to deposit CFMM LP tokens for GS LP tokens\\n    /// @return shares - GS LP token shares minted for depositing\\n    function depositNoPull(DepositWithdrawParams calldata params) external returns(uint256 shares);\\n\\n    /// @dev Redeem GS LP tokens for CFMM LP tokens\\n    /// @param params - struct containing parameters to identify a GammaPool to redeem GS LP tokens for CFMM LP tokens\\n    /// @return assets - CFMM LP tokens received for GS LP tokens\\n    function withdrawNoPull(DepositWithdrawParams calldata params) external returns(uint256 assets);\\n\\n    /// @dev Deposit reserve tokens into a GammaPool to receive GS LP tokens\\n    /// @param params - struct containing parameters to identify a GammaPool to deposit reserve tokens to\\n    /// @return reserves - reserve tokens deposited into GammaPool\\n    /// @return shares - GS LP token shares minted for depositing\\n    function depositReserves(DepositReservesParams calldata params) external returns (uint256[] memory reserves, uint256 shares);\\n\\n    /// @dev Withdraw reserve tokens from a GammaPool\\n    /// @param params - struct containing parameters to identify a GammaPool to withdraw reserve tokens from\\n    /// @return reserves - reserve tokens withdrawn from GammaPool\\n    /// @return assets - CFMM LP token shares equivalent of reserves withdrawn from GammaPool\\n    function withdrawReserves(WithdrawReservesParams calldata params) external returns (uint256[] memory reserves, uint256 assets);\\n\\n    // Long Gamma\\n\\n    /// @notice Create a loan in GammaPool and turn it into an NFT issued to address `to`\\n    /// @dev Loans created here are actually owned by PositionManager and wrapped as an NFT issued to address `to`. But whoever holds NFT controls loan\\n    /// @param protocolId - protocolId (version) of GammaPool where loan will be created (used with `cfmm` to calculate GammaPool address)\\n    /// @param cfmm - address of CFMM, GammaPool is for (used with `protocolId` to calculate GammaPool address)\\n    /// @param to - recipient of NFT token that will be created\\n    /// @param refId - reference Id of loan observer to track loan lifecycle\\n    /// @param deadline - timestamp after which transaction expires. Can't be executed anymore. Removes stale transactions\\n    /// @return tokenId - tokenId of newly created loan\\n    function createLoan(uint16 protocolId, address cfmm, address to, uint16 refId, uint256 deadline) external returns(uint256 tokenId);\\n\\n    /// @dev Borrow liquidity from GammaPool, can be used with a newly created loan or a loan already holding some liquidity debt\\n    /// @param params - struct containing params to identify a GammaPool and borrow liquidity from it\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for liquidity borrowed\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function borrowLiquidity(BorrowLiquidityParams calldata params) external returns (uint256 liquidityBorrowed, uint256[] memory amounts, uint128[] memory tokensHeld);\\n\\n    /// @dev Repay liquidity debt from GammaPool\\n    /// @param params - struct containing params to identify a GammaPool and loan to pay its liquidity debt\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return amounts - reserve tokens used to pay liquidity debt\\n    function repayLiquidity(RepayLiquidityParams calldata params) external returns (uint256 liquidityPaid, uint256[] memory amounts);\\n\\n    /// @dev Repay liquidity debt from GammaPool using CFMM LP tokens\\n    /// @param params - struct containing params to identify a GammaPool and loan to pay its liquidity debt\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return tokensHeld - reserve tokens used to pay liquidity debt\\n    function repayLiquidityWithLP(RepayLiquidityWithLPParams calldata params) external returns (uint256 liquidityPaid, uint128[] memory tokensHeld);\\n\\n    /// @dev Increase loan collateral by depositing more reserve tokens\\n    /// @param params - struct containing params to identify a GammaPool and loan to add collateral to\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function increaseCollateral(AddCollateralParams calldata params) external returns(uint128[] memory tokensHeld);\\n\\n    /// @dev Decrease loan collateral by withdrawing reserve tokens\\n    /// @param params - struct containing params to identify a GammaPool and loan to remove collateral from\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function decreaseCollateral(RemoveCollateralParams calldata params) external returns(uint128[] memory tokensHeld);\\n\\n    /// @dev Re-balance loan collateral tokens by swapping one for another\\n    /// @param params - struct containing params to identify a GammaPool and loan to re-balance its collateral\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function rebalanceCollateral(RebalanceCollateralParams calldata params) external returns(uint128[] memory tokensHeld);\\n\\n    /// @notice Aggregate create loan, increase collateral, borrow collateral, and re-balance collateral into one transaction\\n    /// @dev Only create loan must be performed, the other transactions are optional but must happen in the order described\\n    /// @param params - struct containing params to identify GammaPool to perform transactions on\\n    /// @return tokenId - tokenId of newly created loan\\n    /// @return tokensHeld - new loan collateral token amounts\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for liquidity borrowed\\n    function createLoanBorrowAndRebalance(CreateLoanBorrowAndRebalanceParams calldata params) external returns(uint256 tokenId, uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts);\\n\\n    /// @notice Aggregate increase collateral, borrow collateral, re-balance collateral, and decrease collateral into one transaction\\n    /// @dev All transactions are optional but must happen in the order described\\n    /// @param params - struct containing params to identify GammaPool to perform transactions on\\n    /// @return tokensHeld - new loan collateral token amounts\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for liquidity borrowed\\n    function borrowAndRebalance(BorrowAndRebalanceParams calldata params) external returns(uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/IPositionManagerExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPositionManager.sol\\\";\\n\\n/// @title Interface for PositionManagerExternal\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Defines external functions and events emitted by PositionManagerExternal\\n/// @dev Interface also defines all GammaPool events through inheritance of IGammaPool and IGammaPoolEvents\\ninterface IPositionManagerExternal is IPositionManager {\\n\\n    /// @dev Emitted when re-balancing a loan's collateral amounts (swapping one collateral token for another) using an external contract\\n    /// @param pool - loan's pool address\\n    /// @param tokenId - id identifying loan in pool\\n    /// @param loanLiquidity - liquidity borrowed in invariant terms\\n    /// @param tokensHeld - new loan collateral amounts\\n    event RebalanceCollateralExternally(address indexed pool, uint256 tokenId, uint256 loanLiquidity, uint128[] tokensHeld);\\n\\n    /// @dev Struct parameters for `rebalanceCollateralExternally` function.\\n    struct RebalanceCollateralExternallyParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev amounts of reserve tokens to send to the rebalancer contract\\n        uint128[] amounts;\\n        /// @dev CFMM LP tokens requesting to borrow during external rebalancing. Must be returned at function call end\\n        uint256 lpTokens;\\n        /// @dev address of contract that will rebalance collateral. This address must return collateral back to GammaPool\\n        address rebalancer;\\n        /// @dev data - optional bytes parameter to pass data to the rebalancer contract with rebalancing instructions\\n        bytes data;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n    }\\n\\n    /// @dev Struct parameters for `createLoanBorrowAndRebalanceExternally` function.\\n    struct CreateLoanBorrowAndRebalanceExternallyParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev owner of NFT created by PositionManager. Owns loan through PositionManager\\n        address to;\\n        /// @dev reference id of loan observer to track loan\\n        uint16 refId;\\n        /// @dev amounts of requesting to deposit as collateral for a loan or withdraw from a loan's collateral\\n        uint256[] amounts;\\n        /// @dev CFMM LP tokens requesting to borrow to short\\n        uint256 lpTokens;\\n        /// @dev address of contract that will rebalance collateral. This address must return collateral back to GammaPool\\n        address rebalancer;\\n        /// @dev data - optional bytes parameter to pass data to the rebalancer contract with rebalancing instructions\\n        bytes data;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn representing the `lpTokens`. Slippage protection\\n        uint256[] minBorrowed;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev max borrowed liquidity\\n        uint256 maxBorrowed;\\n    }\\n\\n    /// @dev Struct parameters for `rebalanceExternallyAndRepayLiquidity` function.\\n    struct RebalanceExternallyAndRepayLiquidityParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev tokenId of loan whose liquidity debt will be paid\\n        uint256 tokenId;\\n        /// @dev liquidity debt to pay\\n        uint256 liquidity;\\n        /// @dev amounts to send to rebalancer contract to rebalance for liquidity repayment\\n        uint128[] amounts;\\n        /// @dev address of contract that will rebalance collateral. This address must return collateral back to GammaPool\\n        address rebalancer;\\n        /// @dev data - optional bytes parameter to pass data to the rebalancer contract with instructions to rebalancer\\n        bytes data;\\n        /// @dev collateralId - index of collateral token + 1 that remaining collateral after repayment will be converted to\\n        uint256 collateralId;\\n        /// @dev to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n        address to;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens requesting to withdraw from a loan's collateral\\n        uint128[] withdraw;\\n        /// @dev minimum amounts of collateral expected to have after re-balancing collateral. Slippage protection\\n        uint128[] minCollateral;\\n        /// @dev minimum amounts of reserve tokens expected to have been used to repay the liquidity debt. Slippage protection\\n        uint256[] minRepaid;\\n    }\\n\\n    /// @dev Struct parameters for `borrowAndRebalanceExternally` function.\\n    struct BorrowAndRebalanceExternallyParams {\\n        /// @dev protocolId of GammaPool (e.g. version of GammaPool)\\n        uint16 protocolId;\\n        /// @dev address of CFMM, along with protocolId can be used to calculate GammaPool address\\n        address cfmm;\\n        /// @dev receiver of reserve tokens when withdrawing collateral\\n        address to;\\n        /// @dev tokenId of loan whose collateral will change\\n        uint256 tokenId;\\n        /// @dev CFMM LP tokens requesting to borrow to short\\n        uint256 lpTokens;\\n        /// @dev address of contract that will rebalance collateral. This address must return collateral back to GammaPool\\n        address rebalancer;\\n        /// @dev data - optional bytes parameter to pass data to the rebalancer contract\\n        bytes data;\\n        /// @dev timestamp after which the transaction expires. Used to prevent stale transactions from executing\\n        uint256 deadline;\\n        /// @dev amounts of reserve tokens requesting to deposit as collateral for a loan\\n        uint256[] amounts;\\n        /// @dev amounts of reserve tokens requesting to withdraw from a loan's collateral\\n        uint128[] withdraw;\\n        /// @dev minimum amounts of reserve tokens expected to have been withdrawn representing the `lpTokens` (borrowing). Slippage protection\\n        uint256[] minBorrowed;\\n        /// @dev amounts of reserve tokens to swap (>0 buy token, <0 sell token). At least one index value must be set to zero\\n        uint128[] minCollateral;\\n        /// @dev max borrowed liquidity\\n        uint256 maxBorrowed;\\n    }\\n\\n    /// @dev Re-balance loan collateral tokens by swapping one for another using an external source\\n    /// @param params - struct containing params to identify a GammaPool and loan with information to re-balance its collateral\\n    /// @return loanLiquidity - updated loan liquidity, includes flash loan fees\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function rebalanceCollateralExternally(RebalanceCollateralExternallyParams calldata params) external returns(uint256 loanLiquidity, uint128[] memory tokensHeld);\\n\\n    /// @notice Aggregate create loan, increase collateral, borrow collateral, and re-balance collateral externally into one transaction\\n    /// @dev Only create loan must be performed, the other transactions are optional but must happen in the order described\\n    /// @param params - struct containing params to identify GammaPool to perform transactions on\\n    /// @return tokenId - tokenId of newly created loan\\n    /// @return tokensHeld - new loan collateral token amounts\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for liquidity borrowed\\n    function createLoanBorrowAndRebalanceExternally(CreateLoanBorrowAndRebalanceExternallyParams calldata params) external returns(uint256 tokenId, uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts);\\n\\n    /// @dev Repay liquidity debt from GammaPool rebalancing collateral externally to pay the debt in the proper ratio\\n    /// @param params - struct containing params to identify a GammaPool and loan to pay its liquidity debt\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return amounts - reserve tokens used to pay liquidity debt\\n    function rebalanceExternallyAndRepayLiquidity(RebalanceExternallyAndRepayLiquidityParams calldata params) external returns (uint256 liquidityPaid, uint256[] memory amounts);\\n\\n    /// @notice Aggregate increase collateral, borrow collateral, re-balance collateral externally, and decrease collateral into one transaction\\n    /// @dev All transactions are optional but must happen in the order described\\n    /// @param params - struct containing params to identify GammaPool to perform transactions on\\n    /// @return tokensHeld - new loan collateral token amounts\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for liquidity borrowed\\n    function borrowAndRebalanceExternally(BorrowAndRebalanceExternallyParams calldata params) external returns(uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/IPriceStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title IPriceStore interface\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @dev Interface of PriceStore contract that will store price information for historical price queries\\ninterface IPriceStore {\\n\\n    /// @dev Struct to store identifiable information about loan to perform queries in PositionManager\\n    struct PriceInfo {\\n        /// @dev Timestamp of datapoint\\n        uint32 timestamp;\\n        /// @dev block number of datapoint\\n        uint32 blockNumber;\\n        /// @dev Utilization rate of GammaPool\\n        uint16 utilRate;\\n        /// @dev Yield in CFMM since last update (cfmmRate = 1 + yield), 281k with 9 decimals at uint48\\n        uint16 borrowRate;\\n        /// @dev YIeld of GammaPool since last update (feeIndex = (1 + borrowRate) * (1 + cfmmRate)\\n        uint64 accFeeIndex;\\n        /// @dev Add loan to mappings by user\\n        uint96 lastPrice; // 340 billion billion is uint128, 79 billion is uint96, 309 million is uint88, 1.2 million is uint80\\n    }\\n\\n    /// @dev Set address that will supply the PriceStore with price information about a GammaPool\\n    /// @notice This is the address that can call the addPriceInfo() function to store price information\\n    /// @param _source - Address that calls addPrice() function to store price information\\n    function setSource(address _source) external;\\n\\n    /// @dev Add price information from GammaPool. This calls the GammaPool with address `pool` to get the latest price information from it\\n    /// @notice Price information is added at frequency set by frequency state variable.\\n    /// @param pool - Address of GammaPoool to retrieve and store price information for in a price series array for it.\\n    function addPriceInfo(address pool) external;\\n\\n    /// @dev Set the maximum length to store information for the price series of a GammaPool\\n    /// @notice If array of price series grows past _maxLen, values older than _maxLen spots back will be deleted with every update\\n    /// @param _maxLen - the maximum length of the price series array to hold information\\n    function setMaxLen(uint256 _maxLen) external;\\n\\n    /// @dev Set the frequency at which to store information in seconds.\\n    /// @notice If set to zero the frequency is 1 hour in seconds (3600 seconds).\\n    /// @param _frequency - frequency to store information in seconds (e.g. 1 hour - 3600 seconds)\\n    function setFrequency(uint256 _frequency) external;\\n\\n    /// @dev Get length of price series array of GammaPool with address `_pool`\\n    /// @param _pool - address of GammaPool to retrieve information for\\n    /// @return size - size of price series array of `_pool`\\n    function size(address _pool) external view returns(uint256);\\n\\n    /// @dev Get price information at index of PriceInfo array of GammaPool with address `pool`\\n    /// @param pool - address of the GammaPool to get price information from\\n    /// @param index - index of price series array to retrieve information from\\n    /// @return data - PriceInfo struct containing price information at `index` of price series array of `pool`\\n    function getPriceAt(address pool, uint256 index) external view returns(PriceInfo memory data);\\n\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/IStakingPoolRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/// @title Interface for Staking Router contract\\n/// @author Simon Mall\\n/// @dev Interface for staking router contract that deposits and withdraws from GammaSwap staking pools\\ninterface IStakingPoolRouter {\\n  /// @dev Stake GS_LP tokens on behalf of user\\n  /// @param _account User address for query\\n  /// @param _gsPool GammaPool address\\n  /// @param _esToken Escrow token address\\n  /// @param _amount Amount of GS_LP tokens to stake\\n  function stakeLpForAccount(address _account, address _gsPool, address _esToken, uint256 _amount) external;\\n\\n  /// @dev Stake loan on behalf of user\\n  /// @param _account User address for query\\n  /// @param _gsPool GammaPool address\\n  /// @param _loanId NFT loan id\\n  function stakeLoanForAccount(address _account, address _gsPool, uint256 _loanId) external;\\n\\n  /// @dev Unstake GS_LP tokens on behalf of user\\n  /// @param _account User address for query\\n  /// @param _gsPool GammaPool address\\n  /// @param _esToken Escrow token address\\n  /// @param _amount Amount of GS_LP tokens to unstake\\n  function unstakeLpForAccount(address _account, address _gsPool, address _esToken, uint256 _amount) external;\\n\\n  /// @dev Unstake loan on behalf of user\\n  /// @param _account User address for query\\n  /// @param _gsPool GammaPool address\\n  /// @param _loanId NFT loan id\\n  function unstakeLoanForAccount(address _account, address _gsPool, uint256 _loanId) external;\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/interfaces/ITransfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"@gammaswap/v1-core/contracts/interfaces/IRefunds.sol\\\";\\nimport \\\"@gammaswap/v1-core/contracts/interfaces/periphery/ISendTokensCallback.sol\\\";\\n\\n/// @title Interface for Transfers abstract contract\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Interface used to send tokens and clear tokens and Ether from a contract\\ninterface ITransfers is ISendTokensCallback, IRefunds {\\n\\n    /// @return WETH - address of Wrapped Ethereum contract\\n    function WETH() external view returns (address);\\n\\n    /// @dev Refund ETH balance to caller\\n    function refundETH() external payable;\\n\\n    /// @dev Unwrap Wrapped ETH in contract and send ETH to recipient `to`\\n    /// @param minAmt - threshold balance of WETH which must be crossed before ETH can be refunded\\n    /// @param to - destination address where ETH will be sent to\\n    function unwrapWETH(uint256 minAmt, address to) external payable;\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/PositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@gammaswap/v1-core/contracts/utils/TwoStepOwnable.sol\\\";\\nimport \\\"@gammaswap/v1-core/contracts/interfaces/IGammaPool.sol\\\";\\nimport \\\"@gammaswap/v1-core/contracts/libraries/AddressCalculator.sol\\\";\\n\\nimport \\\"./interfaces/IPositionManager.sol\\\";\\nimport \\\"./interfaces/IPriceStore.sol\\\";\\nimport \\\"./base/Transfers.sol\\\";\\nimport \\\"./base/GammaPoolERC721.sol\\\";\\nimport \\\"./base/GammaPoolQueryableLoans.sol\\\";\\n\\n/// @title PositionManager, concrete implementation of IPositionManager\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Periphery contract used to aggregate function calls to a GammaPool and give NFT (ERC721) functionality to loans\\n/// @notice Loans created through PositionManager become NFTs and can only be managed through PositionManager\\n/// @dev PositionManager is owner of loan and user is owner of NFT that represents loan in a GammaPool\\ncontract PositionManager is Initializable, UUPSUpgradeable, TwoStepOwnable, IPositionManager, Transfers, GammaPoolQueryableLoans {\\n\\n    error Forbidden();\\n    error Expired();\\n    error AmountsMin(uint8 id);\\n\\n    string constant private _name = \\\"PositionManager\\\";\\n    string constant private _symbol = \\\"PM-V1\\\";\\n\\n    /// @dev See {IPositionManager-factory}.\\n    address public immutable override factory;\\n\\n    address public priceStore;\\n\\n    /// @dev Initializes the contract by setting `factory`, `WETH`.\\n    constructor(address _factory, address _WETH) TwoStepOwnable(msg.sender) Transfers(_WETH) {\\n        factory = _factory;\\n    }\\n\\n    function initialize(address _dataStore, address) public virtual initializer {\\n        owner = msg.sender;\\n        dataStore = _dataStore;\\n        priceStore = address(0);\\n    }\\n\\n    modifier isAuthorizedForToken(uint256 tokenId) {\\n        checkAuthorization(tokenId);\\n        _;\\n    }\\n\\n    modifier isExpired(uint256 deadline) {\\n        checkDeadline(deadline);\\n        _;\\n    }\\n\\n    /// @dev Revert if msg.sender is not owner of loan or does not have permission to manage loan by checking NFT that represents loan\\n    /// @param tokenId - id that identifies loan\\n    function checkAuthorization(uint256 tokenId) internal view {\\n        if(!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Forbidden();\\n        }\\n    }\\n\\n    /// @dev Revert if transaction already expired\\n    /// @param deadline - timestamp after which transaction is considered expired\\n    function checkDeadline(uint256 deadline) internal view {\\n        if(deadline < block.timestamp) {\\n            revert Expired();\\n        }\\n    }\\n\\n    /// @dev See {IERC721Metadata-name}.\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @dev See {IERC721Metadata-symbol}.\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// @dev Clear data store contract from PositionManager. PM will no longer update dataStore if cleared\\n    function removeDataStore() external virtual onlyOwner {\\n        dataStore = address(0);\\n    }\\n\\n    /// @dev Clear price store contract from PositionManager. PM will no longer update priceStore if cleared\\n    function removePriceStore() external virtual onlyOwner {\\n        priceStore = address(0);\\n    }\\n\\n    /// @dev See {ITransfers-getGammaPoolAddress}.\\n    function getGammaPoolAddress(address cfmm, uint16 protocolId) internal virtual override view returns(address) {\\n        return AddressCalculator.calcAddress(factory, protocolId, AddressCalculator.getGammaPoolKey(cfmm, protocolId));\\n    }\\n\\n    // **** Short Gamma **** //\\n\\n    /// @dev See {IPositionManager-depositNoPull}.\\n    function depositNoPull(DepositWithdrawParams calldata params) external virtual override isExpired(params.deadline) returns(uint256 shares) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        send(params.cfmm, msg.sender, gammaPool, params.lpTokens); // send lp tokens to pool\\n        shares = IGammaPool(gammaPool).depositNoPull(params.to);\\n        emit DepositNoPull(gammaPool, shares);\\n    }\\n\\n    /// @dev See {IPositionManager-withdrawNoPull}.\\n    function withdrawNoPull(DepositWithdrawParams calldata params) external virtual override isExpired(params.deadline) returns(uint256 assets) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        send(gammaPool, msg.sender, gammaPool, params.lpTokens); // send gs tokens to pool\\n        assets = IGammaPool(gammaPool).withdrawNoPull(params.to);\\n        emit WithdrawNoPull(gammaPool, assets);\\n    }\\n\\n    /// @dev See {IPositionManager-depositReserves}.\\n    function depositReserves(DepositReservesParams calldata params) external virtual override isExpired(params.deadline) returns(uint256[] memory reserves, uint256 shares) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        (reserves, shares) = IGammaPool(gammaPool)\\n        .depositReserves(params.to, params.amountsDesired, params.amountsMin,\\n            abi.encode(SendTokensCallbackData({cfmm: params.cfmm, protocolId: params.protocolId, payer: msg.sender})));\\n        emit DepositReserve(gammaPool, reserves, shares);\\n    }\\n\\n    /// @dev See {IPositionManager-withdrawReserves}.\\n    function withdrawReserves(WithdrawReservesParams calldata params) external virtual override isExpired(params.deadline) returns (uint256[] memory reserves, uint256 assets) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        send(gammaPool, msg.sender, gammaPool, params.amount); // send gs tokens to pool\\n        (reserves, assets) = IGammaPool(gammaPool).withdrawReserves(params.to);\\n        checkMinReserves(reserves, params.amountsMin);\\n        emit WithdrawReserve(gammaPool, reserves, assets);\\n    }\\n\\n    // **** LONG GAMMA **** //\\n\\n    /// @notice Slippage protection for uint256[] array. If amounts < amountsMin, less was obtained than expected\\n    /// @dev Used to check quantities of tokens not used as collateral\\n    /// @param amounts - array containing uint256 amounts received from GammaPool\\n    /// @param amountsMin - minimum amounts acceptable to be received from uint256 before reverting transaction\\n    function checkMinReserves(uint256[] memory amounts, uint256[] memory amountsMin) internal virtual pure {\\n        uint256 len = amounts.length;\\n        uint256 len2 = amountsMin.length;\\n        if(len!=len2) return;\\n        for (uint256 i; i < len;) {\\n            if(amounts[i] < amountsMin[i]) {\\n                revert AmountsMin(1);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Slippage protection for uint128[] array. If amounts < amountsMin, less was obtained than expected\\n    /// @dev Used to check quantities of tokens used as collateral\\n    /// @param amounts - array containing uint128 amounts received from GammaPool\\n    /// @param amountsMin - minimum amounts acceptable to be received from uint128 before reverting transaction\\n    function checkMinCollateral(uint128[] memory amounts, uint128[] memory amountsMin) internal virtual pure {\\n        uint256 len = amounts.length;\\n        uint256 len2 = amountsMin.length;\\n        if(len!=len2) return;\\n        for (uint256 i; i < len;) {\\n            if(amounts[i] < amountsMin[i]) {\\n                revert AmountsMin(2);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Create a loan in GammaPool and turn it into an NFT issued to address `to`\\n    /// @dev Loans created here are actually owned by PositionManager and wrapped as an NFT issued to address `to`\\n    /// @param gammaPool - address of GammaPool we are creating gammaloan for\\n    /// @param to - recipient of NFT token\\n    /// @param refId - reference Id of loan observer\\n    /// @return tokenId - tokenId from creation of loan\\n    function createLoan(address gammaPool, address to, uint16 refId) internal virtual returns(uint256 tokenId) {\\n        tokenId = IGammaPool(gammaPool).createLoan(refId);\\n        mintQueryableLoan(gammaPool, tokenId, to);\\n        emit CreateLoan(gammaPool, to, tokenId, refId);\\n    }\\n\\n    /// @dev Increase loan collateral by depositing more reserve tokens\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param amounts - amounts of reserve tokens sent to gammaPool\\n    /// @param ratio - ratio of loan collateral to be maintained after increasing collateral\\n    /// @param minCollateral - minimum amount of expected collateral after re-balancing. Used for slippage control\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function increaseCollateral(address gammaPool, uint256 tokenId, uint256[] calldata amounts, uint256[] memory ratio, uint128[] memory minCollateral) internal virtual returns(uint128[] memory tokensHeld) {\\n        sendTokens(IGammaPool(gammaPool).tokens(), msg.sender, gammaPool, amounts);\\n        tokensHeld = IGammaPool(gammaPool).increaseCollateral(tokenId, ratio);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit IncreaseCollateral(gammaPool, tokenId, tokensHeld, amounts);\\n    }\\n\\n    /// @dev Decrease loan collateral by withdrawing reserve tokens\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param to - address of recipient of amounts withdrawn from GammaPool\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param amounts - amounts of reserve tokens requesting to withdraw from loan\\n    /// @param ratio - ratio of loan collateral to be maintained after decreasing collateral\\n    /// @param minCollateral - minimum amount of expected collateral after re-balancing. Used for slippage control\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function decreaseCollateral(address gammaPool, address to, uint256 tokenId, uint128[] memory amounts, uint256[] memory ratio, uint128[] memory minCollateral) internal virtual returns(uint128[] memory tokensHeld) {\\n        tokensHeld = IGammaPool(gammaPool).decreaseCollateral(tokenId, amounts, to, ratio);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit DecreaseCollateral(gammaPool, tokenId, tokensHeld, amounts);\\n    }\\n\\n    /// @dev Re-balance loan collateral tokens by swapping one for another\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param deltas - amount to swap of one token at index for another (>0 buy, <0 sell). Must have at least one index field be 0\\n    /// @param ratio - ratio to rebalance collateral\\n    /// @param minCollateral - minimum amount of expected collateral after re-balancing. Used for slippage control\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function rebalanceCollateral(address gammaPool, uint256 tokenId, int256[] memory deltas, uint256[] calldata ratio, uint128[] memory minCollateral) internal virtual returns(uint128[] memory tokensHeld) {\\n        tokensHeld = IGammaPool(gammaPool).rebalanceCollateral(tokenId, deltas, ratio);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit RebalanceCollateral(gammaPool, tokenId, tokensHeld);\\n    }\\n\\n    /// @dev Borrow liquidity from GammaPool, can be used with a newly created loan or a loan already holding some liquidity debt\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param lpTokens - amount of CFMM LP tokens to short (borrow liquidity)\\n    /// @param ratio - ratio to rebalance collateral after borrowing\\n    /// @param minBorrowed - minimum expected amounts of reserve tokens to receive as collateral for `lpTokens` short. Used for slippage control\\n    /// @param maxBorrowed - max borrowed liquidity\\n    /// @param minCollateral - minimum amount of expected collateral after re-balancing. Used for slippage control\\n    /// @return liquidityBorrowed - liquidity borrowed in exchange for CFMM LP tokens (`lpTokens`)\\n    /// @return amounts - amounts of reserve tokens received to hold as collateral for shorting `lpTokens`\\n    /// @return tokensHeld - new loan collateral token amounts\\n    function borrowLiquidity(address gammaPool, uint256 tokenId, uint256 lpTokens, uint256[] memory ratio, uint256[] calldata minBorrowed, uint256 maxBorrowed, uint128[] memory minCollateral) internal virtual returns(uint256 liquidityBorrowed, uint256[] memory amounts, uint128[] memory tokensHeld) {\\n        (liquidityBorrowed, amounts, tokensHeld) = IGammaPool(gammaPool).borrowLiquidity(tokenId, lpTokens, ratio);\\n        require(liquidityBorrowed <= maxBorrowed, \\\"MAX_BORROWED\\\");\\n        checkMinReserves(amounts, minBorrowed);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit BorrowLiquidity(gammaPool, tokenId, liquidityBorrowed, amounts);\\n    }\\n\\n    /// @dev Repay liquidity debt from GammaPool\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param liquidity - desired liquidity to pay\\n    /// @param collateralId - index of collateral token + 1\\n    /// @param to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n    /// @param minRepaid - minimum amount of expected collateral to have used as payment. Used for slippage control\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return amounts - reserve tokens used to pay liquidity debt\\n    function repayLiquidity(address gammaPool, uint256 tokenId, uint256 liquidity, uint256 collateralId, address to, uint256[] calldata minRepaid) internal virtual returns (uint256 liquidityPaid, uint256[] memory amounts) {\\n        (liquidityPaid, amounts) = IGammaPool(gammaPool).repayLiquidity(tokenId, liquidity, collateralId, to);\\n        checkMinReserves(amounts, minRepaid);\\n        emit RepayLiquidity(gammaPool, tokenId, liquidityPaid, amounts);\\n    }\\n\\n    /// @dev Repay liquidity debt from GammaPool\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param liquidity - desired liquidity to pay\\n    /// @param ratio - weights of collateral after repaying liquidity\\n    /// @param minRepaid - minimum amount of expected collateral to have used as payment. Used for slippage control\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return amounts - reserve tokens used to pay liquidity debt\\n    function repayLiquiditySetRatio(address gammaPool, uint256 tokenId, uint256 liquidity, uint256[] calldata ratio, uint256[] calldata minRepaid) internal virtual returns (uint256 liquidityPaid, uint256[] memory amounts) {\\n        (liquidityPaid, amounts) = IGammaPool(gammaPool).repayLiquiditySetRatio(tokenId, liquidity, ratio);\\n        checkMinReserves(amounts, minRepaid);\\n        emit RepayLiquiditySetRatio(gammaPool, tokenId, liquidityPaid, amounts);\\n    }\\n\\n    /// @dev Repay liquidity debt from GammaPool with LP Tokens\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - id to identify the loan in the GammaPool\\n    /// @param collateralId - index of collateral token + 1\\n    /// @param to - if repayment type requires withdrawal, the address that will receive the funds. Otherwise can be zero address\\n    /// @param minCollateral - minimum collateral amounts in loan after repayment\\n    /// @param lpTokens - CFMM LP tokens used to repay liquidity debt\\n    /// @return liquidityPaid - actual liquidity debt paid\\n    /// @return tokensHeld - reserve tokens used to pay liquidity debt\\n    function repayLiquidityWithLP(address gammaPool, uint256 tokenId, uint256 collateralId, address to, uint128[] memory minCollateral, uint256 lpTokens) internal virtual returns (uint256 liquidityPaid, uint128[] memory tokensHeld) {\\n        (liquidityPaid, tokensHeld) = IGammaPool(gammaPool).repayLiquidityWithLP(tokenId, collateralId, to);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit RepayLiquidityWithLP(gammaPool, tokenId, liquidityPaid, tokensHeld, lpTokens);\\n    }\\n\\n    // Individual Function Calls\\n\\n    /// @dev See {IPositionManager-createLoan}.\\n    function createLoan(uint16 protocolId, address cfmm, address to, uint16 refId, uint256 deadline) external virtual override isExpired(deadline) returns(uint256 tokenId) {\\n        address gammaPool = getGammaPoolAddress(cfmm, protocolId);\\n        tokenId = createLoan(gammaPool, to, refId);\\n    }\\n\\n    /// @dev See {IPositionManager-borrowLiquidity}.\\n    function borrowLiquidity(BorrowLiquidityParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns (uint256 liquidityBorrowed, uint256[] memory amounts, uint128[] memory tokensHeld) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        (liquidityBorrowed, amounts, tokensHeld) = borrowLiquidity(gammaPool, params.tokenId, params.lpTokens, params.ratio, params.minBorrowed, params.maxBorrowed, params.minCollateral);\\n    }\\n\\n    /// @dev See {IPositionManager-repayLiquidity}.\\n    function repayLiquidity(RepayLiquidityParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns (uint256 liquidityPaid, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        if(params.isRatio) {\\n            (liquidityPaid, amounts) = repayLiquiditySetRatio(gammaPool, params.tokenId, params.liquidity, params.ratio, params.minRepaid);\\n        } else {\\n            (liquidityPaid, amounts) = repayLiquidity(gammaPool, params.tokenId, params.liquidity, params.collateralId, params.to, params.minRepaid);\\n        }\\n    }\\n\\n    /// @dev See {IPositionManager-repayLiquidityWithLP}.\\n    function repayLiquidityWithLP(RepayLiquidityWithLPParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns (uint256 liquidityPaid, uint128[] memory tokensHeld) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        send(params.cfmm, msg.sender, gammaPool, params.lpTokens);\\n        (liquidityPaid, tokensHeld) = repayLiquidityWithLP(gammaPool, params.tokenId, params.collateralId, params.to, params.minCollateral, params.lpTokens);\\n    }\\n\\n    /// @dev See {IPositionManager-increaseCollateral}.\\n    function increaseCollateral(AddCollateralParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint128[] memory tokensHeld) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        tokensHeld = increaseCollateral(gammaPool, params.tokenId, params.amounts, params.ratio, params.minCollateral);\\n    }\\n\\n    /// @dev See {IPositionManager-decreaseCollateral}.\\n    function decreaseCollateral(RemoveCollateralParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint128[] memory tokensHeld){\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        tokensHeld = decreaseCollateral(gammaPool, params.to, params.tokenId, params.amounts, params.ratio, params.minCollateral);\\n    }\\n\\n    /// @dev See {IPositionManager-rebalanceCollateral}.\\n    function rebalanceCollateral(RebalanceCollateralParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint128[] memory tokensHeld) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        tokensHeld = rebalanceCollateral(gammaPool, params.tokenId, params.deltas, params.ratio, params.minCollateral);\\n    }\\n\\n    // Multi Function Calls\\n\\n    /// @dev See {IPositionManager-createLoanBorrowAndRebalance}.\\n    function createLoanBorrowAndRebalance(CreateLoanBorrowAndRebalanceParams calldata params) external virtual override isExpired(params.deadline) returns(uint256 tokenId, uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        tokenId = createLoan(gammaPool, params.to, params.refId);\\n        tokensHeld = increaseCollateral(gammaPool, tokenId, params.amounts, new uint256[](0), new uint128[](0));\\n        if(params.lpTokens != 0) {\\n            (liquidityBorrowed, amounts, tokensHeld) = borrowLiquidity(gammaPool, tokenId, params.lpTokens, params.ratio, params.minBorrowed, params.maxBorrowed, params.minCollateral);\\n        }\\n    }\\n\\n    /// @dev See {IPositionManager-borrowAndRebalance}.\\n    function borrowAndRebalance(BorrowAndRebalanceParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        bool isWithdrawCollateral = params.withdraw.length != 0;\\n        if(params.amounts.length != 0) {\\n            tokensHeld = increaseCollateral(gammaPool, params.tokenId, params.amounts,\\n                params.lpTokens != 0 || isWithdrawCollateral ? new uint256[](0) : params.ratio,\\n                params.lpTokens != 0 || isWithdrawCollateral ? new uint128[](0) : params.minCollateral);\\n        }\\n        if(params.lpTokens != 0) {\\n            (liquidityBorrowed, amounts, tokensHeld) = borrowLiquidity(gammaPool, params.tokenId, params.lpTokens,\\n                isWithdrawCollateral ? new uint256[](0) : params.ratio, params.minBorrowed, params.maxBorrowed,\\n                isWithdrawCollateral ? new uint128[](0) : params.minCollateral);\\n        }\\n        if(isWithdrawCollateral) {\\n            tokensHeld = decreaseCollateral(gammaPool, params.to, params.tokenId, params.withdraw, params.ratio, params.minCollateral);\\n        }\\n    }\\n\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n}\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/PositionManagerExternalWithStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@gammaswap/v1-core/contracts/interfaces/IGammaPoolExternal.sol\\\";\\n\\nimport \\\"./interfaces/IPositionManagerExternal.sol\\\";\\nimport \\\"./PositionManagerWithStaking.sol\\\";\\n\\n/// @title PositionManagerExternalWithStaking, concrete implementation of IPositionManagerExternal\\n/// @author Daniel D. Alcarraz (https://github.com/0xDanr)\\n/// @notice Inherits PositionManager functionality from PositionManagerWithStaking and defines functionality to rebalance\\n/// @notice loan collateral using external contracts by calling GammaPool::rebalanceExternally()\\ncontract PositionManagerExternalWithStaking is PositionManagerWithStaking, IPositionManagerExternal {\\n\\n    /// @dev Constructs the PositionManagerWithStaking contract.\\n    /// @param _factory Address of the contract factory.\\n    /// @param _WETH Address of the Wrapped Ether (WETH) contract.\\n    constructor(address _factory, address _WETH) PositionManagerWithStaking(_factory, _WETH) {}\\n\\n    /// @dev Flash loan pool's collateral and/or lp tokens to external address. Rebalanced loan collateral is acceptable\\n    /// @dev in  repayment of flash loan. Function can be used for other purposes besides rebalancing collateral.\\n    /// @param gammaPool - address of GammaPool of the loan\\n    /// @param tokenId - unique id identifying loan\\n    /// @param amounts - collateral amounts being flash loaned\\n    /// @param lpTokens - amount of CFMM LP tokens being flash loaned\\n    /// @param to - address that will receive flash loan swaps and potentially rebalance loan's collateral\\n    /// @param data - optional bytes parameter for custom user defined data\\n    /// @param minCollateral - minimum amount of expected collateral after re-balancing. Used for slippage control\\n    /// @return loanLiquidity - updated loan liquidity, includes flash loan fees\\n    /// @return tokensHeld - updated collateral token amounts backing loan\\n    function rebalanceCollateralExternally(address gammaPool, uint256 tokenId, uint128[] memory amounts, uint256 lpTokens, address to, bytes calldata data, uint128[] memory minCollateral) internal virtual returns(uint256 loanLiquidity, uint128[] memory tokensHeld) {\\n        (loanLiquidity, tokensHeld) = IGammaPoolExternal(gammaPool).rebalanceExternally(tokenId, amounts, lpTokens, to, data);\\n        checkMinCollateral(tokensHeld, minCollateral);\\n        emit RebalanceCollateralExternally(gammaPool, tokenId, loanLiquidity, tokensHeld);\\n    }\\n\\n    /// @dev See {IPositionManagerExternal-rebalanceCollateralExternally}.\\n    function rebalanceCollateralExternally(RebalanceCollateralExternallyParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint256 loanLiquidity, uint128[] memory tokensHeld) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        (loanLiquidity,tokensHeld) = rebalanceCollateralExternally(gammaPool, params.tokenId, params.amounts, params.lpTokens, params.rebalancer, params.data, params.minCollateral);\\n    }\\n\\n    /// @dev See {IPositionManagerExternal-createLoanBorrowAndRebalanceExternally}.\\n    function createLoanBorrowAndRebalanceExternally(CreateLoanBorrowAndRebalanceExternallyParams calldata params) external virtual override isExpired(params.deadline) returns(uint256 tokenId, uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        tokenId = createLoan(gammaPool, params.to, params.refId);\\n        tokensHeld = increaseCollateral(gammaPool, tokenId, params.amounts, new uint256[](0), new uint128[](0));\\n        if(params.lpTokens != 0) {\\n            (liquidityBorrowed, amounts, tokensHeld) = borrowLiquidity(gammaPool, tokenId, params.lpTokens, new uint256[](0), params.minBorrowed, params.maxBorrowed, new uint128[](0));\\n        }\\n        if(params.rebalancer != address(0)) {\\n            (,tokensHeld) = rebalanceCollateralExternally(gammaPool, tokenId, tokensHeld, 0, params.rebalancer, params.data, params.minCollateral);\\n        }\\n    }\\n\\n    /// @dev See {IPositionManagerExternal-rebalanceExternallyAndRepayLiquidity}.\\n    function rebalanceExternallyAndRepayLiquidity(RebalanceExternallyAndRepayLiquidityParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns (uint256 liquidityPaid, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        if(params.rebalancer != address(0)) {\\n            rebalanceCollateralExternally(gammaPool, params.tokenId, params.amounts, 0, params.rebalancer, params.data, params.minCollateral);\\n        }\\n        if(params.withdraw.length > 0) {\\n            // if partial repay\\n            (liquidityPaid, amounts) = repayLiquidity(gammaPool, params.tokenId, params.liquidity, 0, address(0), params.minRepaid);\\n            decreaseCollateral(gammaPool, params.to, params.tokenId, params.withdraw, new uint256[](0), new uint128[](0));\\n        } else {\\n            // if full repay\\n            (liquidityPaid, amounts) = repayLiquidity(gammaPool, params.tokenId, params.liquidity, params.collateralId, params.to, params.minRepaid);\\n        }\\n    }\\n\\n    /// @dev See {IPositionManagerExternal-borrowAndRebalanceExternally}.\\n    function borrowAndRebalanceExternally(BorrowAndRebalanceExternallyParams calldata params) external virtual override isAuthorizedForToken(params.tokenId) isExpired(params.deadline) returns(uint128[] memory tokensHeld, uint256 liquidityBorrowed, uint256[] memory amounts) {\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        bool isWithdrawCollateral = params.withdraw.length != 0;\\n        if(params.amounts.length != 0) {\\n            tokensHeld = increaseCollateral(gammaPool, params.tokenId, params.amounts, new uint256[](0), new uint128[](0));\\n        }\\n        if(params.lpTokens != 0) {\\n            (liquidityBorrowed, amounts, tokensHeld) = borrowLiquidity(gammaPool, params.tokenId, params.lpTokens, new uint256[](0), params.minBorrowed, params.maxBorrowed, new uint128[](0));\\n        }\\n        if(params.rebalancer != address(0) && tokensHeld.length != 0) {\\n            (,tokensHeld) = rebalanceCollateralExternally(gammaPool, params.tokenId, tokensHeld, 0, params.rebalancer, params.data, params.minCollateral);\\n        }\\n        if(isWithdrawCollateral) {\\n            tokensHeld = decreaseCollateral(gammaPool, params.to, params.tokenId, params.withdraw, new uint256[](0), new uint128[](0));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gammaswap/v1-periphery/contracts/PositionManagerWithStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.21;\\n\\nimport \\\"./interfaces/IStakingPoolRouter.sol\\\";\\nimport \\\"./interfaces/IAutoStakable.sol\\\";\\nimport \\\"./PositionManager.sol\\\";\\n\\n/// @title PositionManagerWithStaking\\n/// @author Simon Mall\\n/// @dev Extension of PositionManager that adds staking and unstaking functionality for automated operations.\\ncontract PositionManagerWithStaking is PositionManager, IAutoStakable {\\n    IStakingPoolRouter stakingRouter;\\n\\n    /// @dev Constructs the PositionManagerWithStaking contract.\\n    /// @param _factory Address of the contract factory.\\n    /// @param _WETH Address of the Wrapped Ether (WETH) contract.\\n    constructor(address _factory, address _WETH) PositionManager(_factory, _WETH) {}\\n\\n    /// @dev See {IAutoStakable-setStakingRouter}\\n    function setStakingRouter(address _stakingRouter) external onlyOwner {\\n        stakingRouter = IStakingPoolRouter(_stakingRouter);\\n    }\\n\\n    /// @dev See {IAutoStakable-depositReservesAndStake}.\\n    function depositReservesAndStake(DepositReservesParams calldata params, address esToken) external isExpired(params.deadline) returns(uint256[] memory reserves, uint256 shares) {\\n        if(address(stakingRouter) == address(0) && esToken != address(0)) revert StakingRouterNotSet();\\n\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n        address receiver = esToken != address(0) ? address(stakingRouter) : params.to;\\n        (reserves, shares) = IGammaPool(gammaPool)\\n        .depositReserves(receiver, params.amountsDesired, params.amountsMin,\\n            abi.encode(SendTokensCallbackData({cfmm: params.cfmm, protocolId: params.protocolId, payer: msg.sender})));\\n\\n        if(esToken != address(0)) {\\n            stakingRouter.stakeLpForAccount(params.to, gammaPool, esToken, shares);\\n        }\\n\\n        emit DepositReserve(gammaPool, reserves, shares);\\n    }\\n\\n    /// @dev See {IAutoStakable-withdrawReservesAndUnstake}.\\n    function withdrawReservesAndUnstake(WithdrawReservesParams calldata params, address esToken) external isExpired(params.deadline) returns (uint256[] memory reserves, uint256 assets) {\\n        address user = msg.sender;\\n\\n        address gammaPool = getGammaPoolAddress(params.cfmm, params.protocolId);\\n\\n        if(esToken != address(0)) {\\n            if(address(stakingRouter) == address(0)) revert StakingRouterNotSet();\\n\\n            stakingRouter.unstakeLpForAccount(user, gammaPool, esToken, params.amount);\\n        }\\n\\n        send(gammaPool, msg.sender, gammaPool, params.amount);\\n        (reserves, assets) = IGammaPool(gammaPool).withdrawReserves(params.to);\\n        checkMinReserves(reserves, params.amountsMin);\\n        emit WithdrawReserve(gammaPool, reserves, assets);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1967.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"AmountsMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ApproveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Forbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721InvalidTokenID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TokenExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferFromWrongOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferToNonReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Forbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughWETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGammaPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STE_Fail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STF_Fail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ST_Fail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingRouterNotSet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"BorrowLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"refId\",\"type\":\"uint16\"}],\"name\":\"CreateLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"name\":\"DecreaseCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"DepositNoPull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"DepositReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"enum IStrategyEvents.TX_TYPE\",\"name\":\"txType\",\"type\":\"uint8\"}],\"name\":\"ExternalSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"IncreaseCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"collateral\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"writeDownAmt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"fee\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"enum IStrategyEvents.TX_TYPE\",\"name\":\"txType\",\"type\":\"uint8\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"refId\",\"type\":\"uint16\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"cfmmReserves\",\"type\":\"uint128[]\"}],\"name\":\"LoanUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"initLiquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"rateIndex\",\"type\":\"uint96\"},{\"indexed\":true,\"internalType\":\"enum IStrategyEvents.TX_TYPE\",\"name\":\"txType\",\"type\":\"uint8\"}],\"name\":\"LoanUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenBorrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"lastBlockNumber\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"accFeeIndex\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenBorrowedPlusInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lpInvariant\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"borrowedInvariant\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"cfmmReserves\",\"type\":\"uint128[]\"},{\"indexed\":true,\"internalType\":\"enum IStrategyEvents.TX_TYPE\",\"name\":\"txType\",\"type\":\"uint8\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"name\":\"RebalanceCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"name\":\"RebalanceCollateralExternally\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"RepayLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"RepayLiquiditySetRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"RepayLiquidityWithLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"WithdrawNoPull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"WithdrawReserve\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"withdraw\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minBorrowed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowed\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManager.BorrowAndRebalanceParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"borrowAndRebalance\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"withdraw\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minBorrowed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowed\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManagerExternal.BorrowAndRebalanceExternallyParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"borrowAndRebalanceExternally\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minBorrowed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManager.BorrowLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"borrowLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmt\",\"type\":\"uint256\"}],\"name\":\"clearToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"refId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"refId\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minBorrowed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowed\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManager.CreateLoanBorrowAndRebalanceParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createLoanBorrowAndRebalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"refId\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"minBorrowed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowed\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManagerExternal.CreateLoanBorrowAndRebalanceExternallyParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createLoanBorrowAndRebalanceExternally\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataStore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManager.RemoveCollateralParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"decreaseCollateral\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManager.DepositWithdrawParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"depositNoPull\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsDesired\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsMin\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManager.DepositReservesParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"depositReserves\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsDesired\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsMin\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManager.DepositReservesParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"esToken\",\"type\":\"address\"}],\"name\":\"depositReservesAndStake\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManager.AddCollateralParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"increaseCollateral\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dataStore\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceStore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"deltas\",\"type\":\"int256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManager.RebalanceCollateralParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"rebalanceCollateral\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManagerExternal.RebalanceCollateralExternallyParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"rebalanceCollateralExternally\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"collateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"withdraw\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minRepaid\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManagerExternal.RebalanceExternallyAndRepayLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"rebalanceExternallyAndRepayLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDataStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removePriceStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRatio\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"collateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minRepaid\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManager.RepayLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"repayLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"minCollateral\",\"type\":\"uint128[]\"}],\"internalType\":\"struct IPositionManager.RepayLiquidityWithLPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"repayLiquidityWithLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"tokensHeld\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendTokensCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingRouter\",\"type\":\"address\"}],\"name\":\"setStakingRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"unwrapWETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IPositionManager.DepositWithdrawParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"withdrawNoPull\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsMin\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManager.WithdrawReservesParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"withdrawReserves\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"protocolId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"cfmm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsMin\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IPositionManager.WithdrawReservesParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"esToken\",\"type\":\"address\"}],\"name\":\"withdrawReservesAndUnstake\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"reserves\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PositionManagerExternalWithStaking", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fd513630f697a9c1731f196185fb9eba6eaac20b000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}