{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/1_Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        if (_status == _ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\\ncontract Staking is ReentrancyGuard {\\n    address public owner;\\n    address public dead = 0x000000000000000000000000000000000000dEaD;\\n\\n    IERC20 public token;\\n    IERC20 public rewardsToken;\\n\\n    uint256 public rewardsPerSecond;\\n    uint256 public rewardsDenominator;\\n    uint256 public totalStaked;\\n    uint256 public totalRewardsDistributed;\\n\\n    mapping(address => uint256) public userStaked;\\n    mapping(address => uint256) public userStakedTimestamp;\\n    mapping(address => uint256) public userCollectedRewards;\\n    mapping(address => uint256) public userCurrentRewards;\\n\\n    modifier moreThanZero(uint256 amount) {\\n        require(amount > 0, 'Amount should be greater than zero!');\\n        _;\\n    }\\n\\n    modifier onlyOwner(){\\n        require(msg.sender == owner, 'Only owner can use this function.');\\n        _;\\n    }\\n\\n    constructor(address stakingToken, address rewardToken, uint _rewardsPerSecond, uint _rewardsDenominator) {\\n        owner = msg.sender;\\n        token = IERC20(stakingToken);\\n        rewardsToken = IERC20(rewardToken);\\n        rewardsPerSecond = _rewardsPerSecond;\\n        rewardsDenominator = _rewardsDenominator;\\n    }\\n\\n    function stake(uint256 amount) external moreThanZero(amount) nonReentrant {\\n        if(userStakedTimestamp[msg.sender] == 0) userStakedTimestamp[msg.sender] = block.timestamp;\\n        calculateRewards(msg.sender);\\n\\n        userStaked[msg.sender] += (amount * 95) / 100;\\n        totalStaked += (amount * 95) / 100;\\n        token.transferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function withdrawAll() external nonReentrant {\\n        require(userStaked[msg.sender] > 0, \\\"You don't have any tokens to withdraw!\\\");\\n        uint userLastStakeTime = userStakedTimestamp[msg.sender];\\n        calculateRewards(msg.sender);\\n        if(userCurrentRewards[msg.sender] > 0) distributeRewards(msg.sender);\\n        uint amount = userStaked[msg.sender];\\n        userStaked[msg.sender] = 0;\\n        totalStaked -= amount;\\n        //if user withdraws before 15 days of staking, penalize for 20% and burn the penalty fee, otherwise send the full amount\\n        if(block.timestamp < userLastStakeTime + 15 days){\\n            token.transfer(msg.sender, amount * 80 / 100);\\n            token.transfer(dead, amount * 20 / 100);\\n        }else token.transfer(msg.sender, amount);\\n    }\\n\\n    function calculateRewards(address userAddress) internal returns(uint){\\n        if(userStaked[userAddress] == 0){\\n            userCurrentRewards[userAddress] = 0;\\n        }else{\\n            userCurrentRewards[userAddress] += (userStaked[userAddress] * rewardsPerSecond * (block.timestamp - userStakedTimestamp[userAddress])) / rewardsDenominator;\\n        }\\n        userStakedTimestamp[userAddress] = block.timestamp;\\n        return userCurrentRewards[userAddress];\\n    }\\n\\n    function claimRewards() public nonReentrant {\\n        distributeRewards(msg.sender);\\n    }\\n\\n    function distributeRewards(address userAddress) private {\\n        uint userRewards = calculateRewards(userAddress);\\n        require(userRewards > 0, 'You have no rewards to claim!');\\n        userStakedTimestamp[userAddress] = block.timestamp;\\n        userCollectedRewards[userAddress] += userRewards;\\n        totalRewardsDistributed += userRewards;\\n        userCurrentRewards[userAddress] = 0;\\n        rewardsToken.transfer(userAddress, userRewards);\\n    }\\n\\n    function viewRewards() public view returns (uint){\\n        if(userStaked[msg.sender] == 0) return 0;\\n        return (userCurrentRewards[msg.sender] + ((userStaked[msg.sender] * rewardsPerSecond * (block.timestamp - userStakedTimestamp[msg.sender])) / rewardsDenominator));\\n    }\\n\\n    function rescueStakeTokens() external onlyOwner{\\n        token.transfer(owner, token.balanceOf(address(this)));\\n    }\\n\\n    function rescueRewardsTokens() external onlyOwner{\\n        rewardsToken.transfer(owner, rewardsToken.balanceOf(address(this)));\\n    }\\n\\n    function setRewardsPerSecond(uint newRewardsPerSecond) external onlyOwner{\\n        rewardsPerSecond = newRewardsPerSecond;\\n    }\\n\\n    function setRewardsDenominator(uint newRewardsDenominator) external onlyOwner{\\n        rewardsDenominator = newRewardsDenominator;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyOwner{\\n        owner = _newOwner;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsDenominator\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueRewardsTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueStakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardsDenominator\",\"type\":\"uint256\"}],\"name\":\"setRewardsDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardsPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardsPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCollectedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCurrentRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000039f7a065382b064c95f8409b7eff4a45cea3e23000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000003e8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4d5d16cb7284549a715c116cf7db5064d43810dd5f37c906c93f4a3a89da343"}