{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MapleTokenProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport { IMapleTokenInitializerLike, IGlobalsLike } from \\\"./interfaces/Interfaces.sol\\\";\\nimport { IMapleTokenProxy }                         from \\\"./interfaces/IMapleTokenProxy.sol\\\";\\n\\ncontract MapleTokenProxy is IMapleTokenProxy {\\n\\n    bytes32 internal constant GLOBALS_SLOT        = bytes32(uint256(keccak256(\\\"eip1967.proxy.globals\\\")) - 1);\\n    bytes32 internal constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1);\\n\\n    constructor(address globals_, address implementation_, address initializer_, address tokenMigrator_) {\\n        _setAddress(GLOBALS_SLOT, globals_);\\n        _setAddress(IMPLEMENTATION_SLOT, implementation_);\\n\\n        ( bool success_, ) = initializer_.delegatecall(abi.encodeWithSelector(\\n            IMapleTokenInitializerLike(initializer_).initialize.selector,\\n            tokenMigrator_,\\n            IGlobalsLike(globals_).mapleTreasury()\\n        ));\\n\\n        require(success_, \\\"MTP:INIT_FAILED\\\");\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** Overridden Functions                                                                                                           ***/\\n    /**************************************************************************************************************************************/\\n\\n    function setImplementation(address newImplementation_) override external {\\n        IGlobalsLike globals_ = IGlobalsLike(_globals());\\n\\n        require(msg.sender == globals_.governor(), \\\"MTP:SI:NOT_GOVERNOR\\\");\\n\\n        bool isScheduledCall_ = globals_.isValidScheduledCall(msg.sender, address(this), \\\"MTP:SET_IMPLEMENTATION\\\", msg.data);\\n\\n        require(isScheduledCall_, \\\"MTP:SI:NOT_SCHEDULED\\\");\\n\\n        globals_.unscheduleCall(msg.sender, \\\"MTP:SET_IMPLEMENTATION\\\", msg.data);\\n\\n        _setAddress(IMPLEMENTATION_SLOT, newImplementation_);\\n\\n        emit ImplementationSet(newImplementation_);\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** View Functions                                                                                                                 ***/\\n    /**************************************************************************************************************************************/\\n\\n    function _globals() internal view returns (address globals_) {\\n        globals_ = _getAddress(GLOBALS_SLOT);\\n    }\\n\\n    function _implementation() internal view returns (address implementation_) {\\n        implementation_ = _getAddress(IMPLEMENTATION_SLOT);\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** Utility Functions                                                                                                              ***/\\n    /**************************************************************************************************************************************/\\n\\n    function _setAddress(bytes32 slot_, address value_) internal {\\n        assembly {\\n            sstore(slot_, value_)\\n        }\\n    }\\n\\n    function _getAddress(bytes32 slot_) internal view returns (address value_) {\\n        assembly {\\n            value_ := sload(slot_)\\n        }\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** Fallback Function                                                                                                              ***/\\n    /**************************************************************************************************************************************/\\n\\n    fallback() external {\\n        address implementation_ = _implementation();\\n\\n        require(implementation_.code.length != 0, \\\"MTP:F:NO_CODE_ON_IMPLEMENTATION\\\");\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n\\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\\n\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IERC20Like {\\n\\n    function burn(address from, uint256 value) external;\\n\\n    function mint(address to, uint256 value) external;\\n\\n    function totalSupply() external view returns (uint256 totalSupply);\\n\\n}\\n\\ninterface IGlobalsLike {\\n\\n    function governor() external view returns (address governor);\\n\\n    function isInstanceOf(bytes32 instanceKey, address instance) external view returns (bool isInstance);\\n\\n    function isValidScheduledCall(\\n        address          caller,\\n        address          target,\\n        bytes32          functionId,\\n        bytes   calldata callData\\n    ) external view returns (bool isValidScheduledCall);\\n\\n    function mapleTreasury() external view returns (address mapleTreasury);\\n\\n    function unscheduleCall(address caller, bytes32 functionId, bytes calldata callData) external;\\n\\n}\\n\\ninterface IMapleTokenInitializerLike {\\n\\n    function initialize(address migrator, address treasury) external;\\n\\n}\\n\\ninterface IMapleTokenLike is IERC20Like {\\n\\n    function globals() external view returns (address globals);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMapleTokenProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IMapleTokenProxy {\\n\\n    /**\\n     *  @dev   Emitted when the implementation address is set.\\n     *  @param implementation The address of the new implementation.\\n     */\\n    event ImplementationSet(address indexed implementation);\\n\\n    /**\\n     *  @dev   Sets the implementation address.\\n     *  @param newImplementation The address to set the implementation to.\\n     */\\n    function setImplementation(address newImplementation) external;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"address-registry/=modules/address-registry/contracts/\",\r\n      \"contract-test-utils/=modules/globals/modules/contract-test-utils/contracts/\",\r\n      \"ds-test/=modules/forge-std/lib/ds-test/src/\",\r\n      \"erc20/=modules/erc20/\",\r\n      \"forge-std/=modules/forge-std/src/\",\r\n      \"globals/=modules/globals/\",\r\n      \"migrator/=modules/migrator/modules/erc20-helper/src/\",\r\n      \"non-transparent-proxy/=modules/globals/modules/non-transparent-proxy/\",\r\n      \"ntp/=modules/ntp/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"globals_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initializer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenMigrator_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ImplementationSet\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MapleTokenProxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000804a6f5f667170f545bf14e5ddb48c70b788390c0000000000000000000000002feb650302d54c227bb56361005ca3ec7265a40d0000000000000000000000007f3c3636208a18c7941bf051807db568640614650000000000000000000000007b0267c13b994cdb58b8ed3a65b7a09a07432a76", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x2feb650302d54c227bb56361005ca3ec7265a40d", "SwarmSource": ""}