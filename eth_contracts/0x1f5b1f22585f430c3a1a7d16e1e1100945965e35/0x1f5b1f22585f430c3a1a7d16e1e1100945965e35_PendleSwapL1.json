{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // BulkSeller\\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error BulkNotMaintainer();\\n    error BulkNotAdmin();\\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\\n    error BulkSellerInvalidToken(address token, address SY);\\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\\n\\n    // APPROX\\n    error ApproxFail();\\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\\n    error ApproxBinarySearchInputInvalid(\\n        uint256 approxGuessMin,\\n        uint256 approxGuessMax,\\n        uint256 minGuessMin,\\n        uint256 maxGuessMax\\n    );\\n\\n    // MARKET + MARKET MATH CORE\\n    error MarketExpired();\\n    error MarketZeroAmountsInput();\\n    error MarketZeroAmountsOutput();\\n    error MarketZeroLnImpliedRate();\\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\\n    error MarketProportionMustNotEqualOne();\\n    error MarketRateScalarBelowZero(int256 rateScalar);\\n    error MarketScalarRootBelowZero(int256 scalarRoot);\\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\\n\\n    error OracleUninitialized();\\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\\n    error OracleZeroCardinality();\\n\\n    error MarketFactoryExpiredPt();\\n    error MarketFactoryInvalidPt();\\n    error MarketFactoryMarketExists();\\n\\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\\n    error MarketFactoryOverriddenFeeTooHigh(uint80 overriddenFee, uint256 marketLnFeeRateRoot);\\n    error MarketFactoryReserveFeePercentTooHigh(uint8 reserveFeePercent, uint8 maxReserveFeePercent);\\n    error MarketFactoryZeroTreasury();\\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\\n    error MFNotPendleMarket(address addr);\\n\\n    // ROUTER\\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\\n\\n    error RouterTimeRangeZero();\\n    error RouterCallbackNotPendleMarket(address caller);\\n    error RouterInvalidAction(bytes4 selector);\\n    error RouterInvalidFacet(address facet);\\n\\n    error RouterKyberSwapDataZero();\\n\\n    error SimulationResults(bool success, bytes res);\\n\\n    // YIELD CONTRACT\\n    error YCExpired();\\n    error YCNotExpired();\\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\\n    error YCNothingToRedeem();\\n    error YCPostExpiryDataNotSet();\\n    error YCNoFloatingSy();\\n\\n    // YieldFactory\\n    error YCFactoryInvalidExpiry();\\n    error YCFactoryYieldContractExisted();\\n    error YCFactoryZeroExpiryDivisor();\\n    error YCFactoryZeroTreasury();\\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\\n\\n    // SY\\n    error SYInvalidTokenIn(address token);\\n    error SYInvalidTokenOut(address token);\\n    error SYZeroDeposit();\\n    error SYZeroRedeem();\\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n\\n    // SY-specific\\n    error SYQiTokenMintFailed(uint256 errCode);\\n    error SYQiTokenRedeemFailed(uint256 errCode);\\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\\n\\n    error SYCurveInvalidPid();\\n    error SYCurve3crvPoolNotFound();\\n\\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\\n    error SYBalancerInvalidPid();\\n    error SYInvalidRewardToken(address token);\\n\\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\\n\\n    error SYBalancerReentrancy();\\n\\n    error NotFromTrustedRemote(uint16 srcChainId, bytes path);\\n\\n    // Liquidity Mining\\n    error VCInactivePool(address pool);\\n    error VCPoolAlreadyActive(address pool);\\n    error VCZeroVePendle(address user);\\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\\n    error VCEpochNotFinalized(uint256 wTime);\\n    error VCPoolAlreadyAddAndRemoved(address pool);\\n\\n    error VEInvalidNewExpiry(uint256 newExpiry);\\n    error VEExceededMaxLockTime();\\n    error VEInsufficientLockTime();\\n    error VENotAllowedReduceExpiry();\\n    error VEZeroAmountLocked();\\n    error VEPositionNotExpired();\\n    error VEZeroPosition();\\n    error VEZeroSlope(uint128 bias, uint128 slope);\\n    error VEReceiveOldSupply(uint256 msgTime);\\n\\n    error GCNotPendleMarket(address caller);\\n    error GCNotVotingController(address caller);\\n\\n    error InvalidWTime(uint256 wTime);\\n    error ExpiryInThePast(uint256 expiry);\\n    error ChainNotSupported(uint256 chainId);\\n\\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\\n    error FDEpochLengthMismatch();\\n    error FDInvalidPool(address pool);\\n    error FDPoolAlreadyExists(address pool);\\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\\n    error FDInvalidStartEpoch(uint256 startEpoch);\\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\\n\\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\\n\\n    // Cross-Chain\\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\\n    error MsgNotFromReceiveEndpoint(address sender);\\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\\n    error ApproxDstExecutionGasNotSet();\\n    error InvalidRetryData();\\n\\n    // GENERIC MSG\\n    error ArrayLengthMismatch();\\n    error ArrayEmpty();\\n    error ArrayOutOfBounds();\\n    error ZeroAddress();\\n    error FailedToSendEther();\\n    error InvalidMerkleProof();\\n\\n    error OnlyLayerZeroEndpoint();\\n    error OnlyYT();\\n    error OnlyYCFactory();\\n    error OnlyWhitelisted();\\n\\n    // Swap Aggregator\\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/TokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/IWETH.sol\\\";\\n\\nabstract contract TokenHelper {\\n    using SafeERC20 for IERC20;\\n\\n    address internal constant NATIVE = address(0);\\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\\n\\n    function _transferIn(address token, address from, uint256 amount) internal {\\n        if (token == NATIVE) require(msg.value == amount, \\\"eth mismatch\\\");\\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\\n    }\\n\\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    function _transferOut(address token, address to, uint256 amount) internal {\\n        if (amount == 0) return;\\n        if (token == NATIVE) {\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\n            require(success, \\\"eth send failed\\\");\\n        } else {\\n            IERC20(token).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\\n        uint256 numTokens = tokens.length;\\n        require(numTokens == amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < numTokens; ) {\\n            _transferOut(tokens[i], to, amounts[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _selfBalance(address token) internal view returns (uint256) {\\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\\n    function _safeApprove(address token, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Safe Approve\\\");\\n    }\\n\\n    function _safeApproveInf(address token, address to) internal {\\n        if (token == NATIVE) return;\\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\\n            _safeApprove(token, to, 0);\\n            _safeApprove(token, to, type(uint256).max);\\n        }\\n    }\\n\\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\\n        else IWETH(tokenIn).withdraw(netTokenIn);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/IPSwapAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nstruct SwapData {\\n    SwapType swapType;\\n    address extRouter;\\n    bytes extCalldata;\\n    bool needScale;\\n}\\n\\nenum SwapType {\\n    NONE,\\n    KYBERSWAP,\\n    ONE_INCH,\\n    // ETH_WETH not used in Aggregator\\n    ETH_WETH\\n}\\n\\ninterface IPSwapAggregator {\\n    function swap(address tokenIn, uint256 amountIn, SwapData calldata swapData) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/interfaces/IAggregationExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IAggregationExecutor {\\n    function callBytes(bytes calldata data) external payable; // 0xd9c45357\\n\\n    // callbytes per swap sequence\\n    function swapSingleSequence(bytes calldata data) external;\\n\\n    function finalTransactionProcessing(\\n        address tokenIn,\\n        address tokenOut,\\n        address to,\\n        bytes calldata destTokenFeeData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/interfaces/IAggregationExecutorOptimistic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IAggregationExecutorOptimistic {\\n    event Exchange(address pair, uint256 amountOut, address output);\\n\\n    struct Swap {\\n        bytes data;\\n        bytes4 functionSelector;\\n    }\\n\\n    struct SwapCallbackData {\\n        bytes path;\\n        address payer;\\n    }\\n\\n    struct SwapCallbackDataPath {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct PositiveSlippageFeeData {\\n        uint256 partnerPSInfor; // [partnerReceiver (160 bit) + partnerPercent(96bits)]\\n        uint256 expectedReturnAmount; // [minimumPSAmount (128 bits) + expectedReturnAmount (128 bits)]\\n    }\\n\\n    struct SwapExecutorDescription {\\n        Swap[][] swapSequences;\\n        address tokenIn;\\n        address tokenOut;\\n        address to;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    function rescueFunds(address token, uint256 amount) external;\\n\\n    function callBytes(bytes calldata data) external payable;\\n\\n    function swapSingleSequence(bytes calldata data) external;\\n\\n    function multihopBatchSwapExactIn(\\n        Swap[][] memory swapSequences,\\n        address tokenIn,\\n        address tokenOut,\\n        address to,\\n        uint256 deadline,\\n        bytes memory positiveSlippageData\\n    ) external payable;\\n\\n    function finalTransactionProcessing(\\n        address tokenIn,\\n        address tokenOut,\\n        address to,\\n        bytes calldata destTokenFeeData\\n    ) external;\\n\\n    function updateExecutor(bytes4 functionSelector, address executor) external;\\n\\n    function updateBatchExecutors(bytes4[] memory functionSelectors, address[] memory executors) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/interfaces/IExecutorHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface IExecutorHelper {\\n    struct Swap {\\n        bytes data;\\n        bytes32 selectorAndFlags; // [selector (32 bits) + flags (224 bits)]; selector is 4 most significant bytes; flags are stored in 4 least significant bytes.\\n    }\\n\\n    struct SwapExecutorDescription {\\n        Swap[][] swapSequences;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 minTotalAmountOut;\\n        address to;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    struct UniSwap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 collectAmount; // amount that should be transferred to the pool\\n        uint32 swapFee;\\n        uint32 feePrecision;\\n        uint32 tokenWeightInput;\\n    }\\n\\n    struct StableSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint8 tokenIndexFrom;\\n        uint8 tokenIndexTo;\\n        uint256 dx;\\n        uint256 poolLength;\\n        address poolLp;\\n        bool isSaddle; // true: saddle, false: stable\\n    }\\n\\n    struct CurveSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        int128 tokenIndexFrom;\\n        int128 tokenIndexTo;\\n        uint256 dx;\\n        bool usePoolUnderlying;\\n        bool useTriCrypto;\\n    }\\n\\n    struct UniswapV3KSElastic {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        uint160 sqrtPriceLimitX96;\\n        bool isUniV3; // true = UniV3, false = KSElastic\\n    }\\n\\n    struct BalancerV2 {\\n        address vault;\\n        bytes32 poolId;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n    }\\n\\n    struct DODO {\\n        address recipient;\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint256 amount;\\n        address sellHelper;\\n        bool isSellBase;\\n        bool isVersion2;\\n    }\\n\\n    struct GMX {\\n        address vault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        address receiver;\\n    }\\n\\n    struct Synthetix {\\n        address synthetixProxy;\\n        address tokenIn;\\n        address tokenOut;\\n        bytes32 sourceCurrencyKey;\\n        uint256 sourceAmount;\\n        bytes32 destinationCurrencyKey;\\n        bool useAtomicExchange;\\n    }\\n\\n    struct Platypus {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 collectAmount; // amount that should be transferred to the pool\\n    }\\n\\n    struct PSM {\\n        address router;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        address recipient;\\n    }\\n\\n    struct WSTETH {\\n        address pool;\\n        uint256 amount;\\n        bool isWrapping;\\n    }\\n\\n    struct Maverick {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 swapAmount;\\n        uint256 sqrtPriceLimitD18;\\n    }\\n\\n    struct SyncSwap {\\n        bytes _data;\\n        address vault;\\n        address tokenIn;\\n        address pool;\\n        uint256 collectAmount;\\n    }\\n\\n    struct AlgebraV1 {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        uint160 sqrtPriceLimitX96;\\n        uint256 senderFeeOnTransfer; // [ FoT_FLAG(1 bit) ... SENDER_ADDRESS(160 bits) ]\\n    }\\n\\n    struct BalancerBatch {\\n        address vault;\\n        bytes32[] poolIds;\\n        address[] path; // swap path from assetIn to assetOut\\n        bytes[] userDatas;\\n        uint256 amountIn; // assetIn amount\\n    }\\n\\n    struct Mantis {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    struct IziSwap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 swapAmount;\\n        int24 limitPoint;\\n    }\\n\\n    struct TraderJoeV2 {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 collectAmount; // most significant 1 bit is to determine whether pool is v2.1, else v2.0\\n    }\\n\\n    struct LevelFiV2 {\\n        address pool;\\n        address fromToken;\\n        address toToken;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        address recipient; // receive token out\\n    }\\n\\n    struct GMXGLP {\\n        address rewardRouter;\\n        address stakedGLP;\\n        address glpManager;\\n        address yearnVault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        address recipient;\\n    }\\n\\n    struct Vooi {\\n        address pool;\\n        address fromToken;\\n        address toToken;\\n        uint256 fromID;\\n        uint256 toID;\\n        uint256 fromAmount;\\n        address to;\\n    }\\n\\n    struct VelocoreV2 {\\n        address vault;\\n        uint256 amount;\\n        address tokenIn;\\n        address tokenOut;\\n        address stablePool; // if not empty then use stable pool\\n        address wrapToken;\\n        bool isConvertFirst;\\n    }\\n\\n    struct MaticMigrate {\\n        address pool;\\n        address tokenAddress; // should be POL\\n        uint256 amount;\\n        address recipient; // empty if migrate\\n    }\\n\\n    struct Kokonut {\\n        address pool;\\n        uint256 dx;\\n        uint256 tokenIndexFrom;\\n        address fromToken;\\n        address toToken;\\n    }\\n\\n    struct BalancerV1 {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n    }\\n\\n    struct SwaapV2 {\\n        address router;\\n        uint256 amount;\\n        bytes data;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n    }\\n\\n    struct ArbswapStable {\\n        address pool;\\n        uint256 dx;\\n        uint256 tokenIndexFrom;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct BancorV2 {\\n        address pool;\\n        address[] swapPath;\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    struct Ambient {\\n        address pool;\\n        uint128 qty;\\n        address base;\\n        address quote;\\n        uint256 poolIdx;\\n        uint8 settleFlags;\\n    }\\n\\n    function executeUniswap(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeStableSwap(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeCurve(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeKSClassic(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeUniV3KSElastic(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeRfq(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeBalV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeDODO(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeVelodrome(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeGMX(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executePlatypus(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeWrappedstETH(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeStEth(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeSynthetix(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeHashflow(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executePSM(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeFrax(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeCamelot(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeKyberLimitOrder(\\n        bytes memory data,\\n        uint256 flagsAndPrevAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeMaverick(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeSyncSwap(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeAlgebraV1(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeBalancerBatch(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeWombat(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeMantis(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeIziSwap(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeWooFiV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeTraderJoeV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executePancakeStableSwap(\\n        bytes memory data,\\n        uint256 flagsAndPrevAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeLevelFiV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeGMXGLP(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeVooi(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeVelocoreV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeMaticMigrate(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeSmardex(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeSolidlyV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeKokonut(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeBalancerV1(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeSwaapV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeNomiswapStable(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeArbswapStable(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeBancorV2(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeBancorV3(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n\\n    function executeAmbient(bytes memory data, uint256 flagsAndPrevAmountOut) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/interfaces/IExecutorHelperL2.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\ninterface IExecutorHelperL2 {\\n    struct Swap {\\n        bytes data;\\n        bytes4 functionSelector;\\n    }\\n\\n    struct SwapExecutorDescription {\\n        Swap[][] swapSequences;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 minTotalAmountOut;\\n        address to;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    struct UniSwap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 collectAmount; // amount that should be transferred to the pool\\n        uint32 swapFee;\\n        uint32 feePrecision;\\n        uint32 tokenWeightInput;\\n    }\\n\\n    struct StableSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint8 tokenIndexFrom;\\n        uint8 tokenIndexTo;\\n        uint256 dx;\\n        uint256 poolLength;\\n        address poolLp;\\n        bool isSaddle; // true: saddle, false: stable\\n    }\\n\\n    struct CurveSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        int128 tokenIndexFrom;\\n        int128 tokenIndexTo;\\n        uint256 dx;\\n        bool usePoolUnderlying;\\n        bool useTriCrypto;\\n    }\\n\\n    struct UniswapV3KSElastic {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        uint160 sqrtPriceLimitX96;\\n        bool isUniV3; // true = UniV3, false = KSElastic\\n    }\\n\\n    struct SwapCallbackData {\\n        bytes path;\\n        address payer;\\n    }\\n\\n    struct SwapCallbackDataPath {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct BalancerV2 {\\n        address vault;\\n        bytes32 poolId;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n    }\\n\\n    struct DODO {\\n        address recipient;\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint256 amount;\\n        address sellHelper;\\n        bool isSellBase;\\n        bool isVersion2;\\n    }\\n\\n    struct GMX {\\n        address vault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        address receiver;\\n    }\\n\\n    struct Synthetix {\\n        address synthetixProxy;\\n        address tokenIn;\\n        address tokenOut;\\n        bytes32 sourceCurrencyKey;\\n        uint256 sourceAmount;\\n        bytes32 destinationCurrencyKey;\\n        bool useAtomicExchange;\\n    }\\n\\n    struct WSTETH {\\n        address pool;\\n        uint256 amount;\\n        bool isWrapping;\\n    }\\n\\n    struct Platypus {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 collectAmount; // amount that should be transferred to the pool\\n    }\\n\\n    struct PSM {\\n        address router;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        address recipient;\\n    }\\n\\n    struct Maverick {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 swapAmount;\\n        uint256 sqrtPriceLimitD18;\\n    }\\n\\n    /// @notice Struct for Sync Swap\\n    /// @param _data encode of (address, address, uint8) : (tokenIn, recipient, withdrawMode)\\n    ///  Withdraw with mode.\\n    // 0 = DEFAULT\\n    // 1 = UNWRAPPED\\n    // 2 = WRAPPED\\n    /// @param vault vault contract\\n    /// @param tokenIn token input to swap\\n    /// @param pool pool of SyncSwap\\n    /// @param collectAmount amount that should be transferred to the pool\\n    struct SyncSwap {\\n        bytes _data;\\n        address vault;\\n        address tokenIn;\\n        address pool;\\n        uint256 collectAmount;\\n    }\\n\\n    struct AlgebraV1 {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        uint160 sqrtPriceLimitX96;\\n        uint256 senderFeeOnTransfer; // [ FoT_FLAG(1 bit) ... SENDER_ADDRESS(160 bits) ]\\n    }\\n\\n    struct BalancerBatch {\\n        address vault;\\n        bytes32[] poolIds;\\n        address[] path; // swap path from assetIn to assetOut\\n        bytes[] userDatas;\\n        uint256 amountIn; // assetIn amount\\n    }\\n\\n    struct Mantis {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    struct IziSwap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 swapAmount;\\n        int24 limitPoint;\\n    }\\n\\n    struct TraderJoeV2 {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 collectAmount; // most significant 1 bit is to determine whether pool is v2.0, else v2.1\\n    }\\n\\n    struct LevelFiV2 {\\n        address pool;\\n        address fromToken;\\n        address toToken;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        address recipient; // receive token out\\n    }\\n\\n    struct GMXGLP {\\n        address rewardRouter;\\n        address stakedGLP;\\n        address glpManager;\\n        address yearnVault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        address recipient;\\n    }\\n\\n    struct Vooi {\\n        address pool;\\n        address fromToken;\\n        address toToken;\\n        uint256 fromID;\\n        uint256 toID;\\n        uint256 fromAmount;\\n        address to;\\n    }\\n\\n    struct VelocoreV2 {\\n        address vault;\\n        uint256 amount;\\n        address tokenIn;\\n        address tokenOut;\\n        address stablePool; // if not empty then use stable pool\\n        address wrapToken;\\n        bool isConvertFirst;\\n    }\\n\\n    struct MaticMigrate {\\n        address pool;\\n        address tokenAddress; // should be POL\\n        uint256 amount;\\n        address recipient; // empty if migrate\\n    }\\n\\n    struct Kokonut {\\n        address pool;\\n        uint256 dx;\\n        uint256 tokenIndexFrom;\\n        address fromToken;\\n        address toToken;\\n    }\\n\\n    struct BalancerV1 {\\n        address pool;\\n        uint256 amount;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct SwaapV2 {\\n        address router;\\n        uint256 amount;\\n        bytes data;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n    }\\n\\n    struct ArbswapStable {\\n        address pool;\\n        uint256 dx;\\n        uint256 tokenIndexFrom;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct BancorV2 {\\n        address pool;\\n        address[] swapPath;\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    struct Ambient {\\n        address pool;\\n        uint128 qty;\\n        address base;\\n        address quote;\\n        uint256 poolIdx;\\n        uint8 settleFlags;\\n    }\\n\\n    function executeUniswap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeKSClassic(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeVelodrome(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeFrax(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeCamelot(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeKyberLimitOrder(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeRfq(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeHashflow(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeStableSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeCurve(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeUniV3KSElastic(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeBalV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeDODO(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeGMX(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeSynthetix(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeWrappedstETH(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeStEth(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executePlatypus(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executePSM(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeMaverick(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeSyncSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeAlgebraV1(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeBalancerBatch(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeWombat(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeMantis(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeIziSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeTraderJoeV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeLevelFiV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeGMXGLP(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeVooi(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeVelocoreV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeSmardex(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeSolidlyV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeKokonut(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeBalancerV1(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeSwaapV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeNomiswapStable(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeArbswapStable(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeBancorV2(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeBancorV3(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n\\n    function executeAmbient(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut,\\n        address tokenIn,\\n        bool getPoolOnly,\\n        address nextPool\\n    ) external payable returns (address tokenOut, uint256 tokenAmountOut, address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/interfaces/IMetaAggregationRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IAggregationExecutor} from \\\"./IAggregationExecutor.sol\\\";\\n\\ninterface IMetaAggregationRouterV2 {\\n    struct SwapDescriptionV2 {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address[] srcReceivers; // transfer src token to these addresses, default\\n        uint256[] srcAmounts;\\n        address[] feeReceivers;\\n        uint256[] feeAmounts;\\n        address dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n        bytes permit;\\n    }\\n\\n    /// @dev  use for swapGeneric and swap to avoid stack too deep\\n    struct SwapExecutionParams {\\n        address callTarget; // call this address\\n        address approveTarget; // approve this address if _APPROVE_FUND set\\n        bytes targetData;\\n        SwapDescriptionV2 desc;\\n        bytes clientData;\\n    }\\n\\n    struct SimpleSwapData {\\n        address[] firstPools;\\n        uint256[] firstSwapAmounts;\\n        bytes[] swapDatas;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    function swap(SwapExecutionParams calldata execution) external payable returns (uint256, uint256);\\n\\n    function swapSimpleMode(\\n        IAggregationExecutor caller,\\n        SwapDescriptionV2 memory desc,\\n        bytes calldata executorData,\\n        bytes calldata clientData\\n    ) external returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l1-contracts/InputScalingHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IExecutorHelper} from \\\"../interfaces/IExecutorHelper.sol\\\";\\nimport {IMetaAggregationRouterV2} from \\\"../interfaces/IMetaAggregationRouterV2.sol\\\";\\nimport {ScalingDataLib} from \\\"./ScalingDataLib.sol\\\";\\n\\n/* ----------------------------------------\\n.__   __.   ______   .___________. _______\\n|  \\\\ |  |  /  __  \\\\  |           ||   ____|\\n|   \\\\|  | |  |  |  | `---|  |----`|  |__\\n|  . `  | |  |  |  |     |  |     |   __|\\n|  |\\\\   | |  `--'  |     |  |     |  |____\\n|__| \\\\__|  \\\\______/      |__|     |_______|\\n\\n\\nPlease use InputScalingHelperL2 contract for scaling data on Arbitrum, Optimism, Base\\n\\n---------------------------------------- */\\n\\nlibrary InputScalingHelper {\\n    uint256 private constant _PARTIAL_FILL = 0x01;\\n    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;\\n    uint256 private constant _SHOULD_CLAIM = 0x04;\\n    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;\\n    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;\\n    uint256 private constant _SIMPLE_SWAP = 0x20;\\n\\n    // fee data in case taking in dest token\\n    struct PositiveSlippageFeeData {\\n        uint256 partnerPSInfor; // [partnerReceiver (160 bit) + partnerPercent(96bits)]\\n        uint256 expectedReturnAmount;\\n    }\\n\\n    struct Swap {\\n        bytes data;\\n        bytes32 selectorAndFlags; // [selector (32 bits) + flags (224 bits)]; selector is 4 most significant bytes; flags are stored in 4 least significant bytes.\\n    }\\n\\n    struct SimpleSwapData {\\n        address[] firstPools;\\n        uint256[] firstSwapAmounts;\\n        bytes[] swapDatas;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    struct SwapExecutorDescription {\\n        Swap[][] swapSequences;\\n        address tokenIn;\\n        address tokenOut;\\n        address to;\\n        uint256 deadline;\\n        bytes positiveSlippageData;\\n    }\\n\\n    function _getScaledInputData(bytes calldata inputData, uint256 newAmount) internal pure returns (bytes memory) {\\n        bytes4 selector = bytes4(inputData[:4]);\\n        bytes calldata dataToDecode = inputData[4:];\\n\\n        if (selector == IMetaAggregationRouterV2.swap.selector) {\\n            IMetaAggregationRouterV2.SwapExecutionParams memory params = abi.decode(\\n                dataToDecode,\\n                (IMetaAggregationRouterV2.SwapExecutionParams)\\n            );\\n\\n            (params.desc, params.targetData) = _getScaledInputDataV2(\\n                params.desc,\\n                params.targetData,\\n                newAmount,\\n                _flagsChecked(params.desc.flags, _SIMPLE_SWAP)\\n            );\\n            return abi.encodeWithSelector(selector, params);\\n        } else if (selector == IMetaAggregationRouterV2.swapSimpleMode.selector) {\\n            (\\n                address callTarget,\\n                IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n                bytes memory targetData,\\n                bytes memory clientData\\n            ) = abi.decode(dataToDecode, (address, IMetaAggregationRouterV2.SwapDescriptionV2, bytes, bytes));\\n\\n            (desc, targetData) = _getScaledInputDataV2(desc, targetData, newAmount, true);\\n            return abi.encodeWithSelector(selector, callTarget, desc, targetData, clientData);\\n        } else {\\n            revert(\\\"InputScalingHelper: Invalid selector\\\");\\n        }\\n    }\\n\\n    function _getScaledInputDataV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        bytes memory executorData,\\n        uint256 newAmount,\\n        bool isSimpleMode\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory, bytes memory) {\\n        uint256 oldAmount = desc.amount;\\n        if (oldAmount == newAmount) {\\n            return (desc, executorData);\\n        }\\n\\n        // simple mode swap\\n        if (isSimpleMode) {\\n            return (\\n                _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n                _scaledSimpleSwapData(executorData, oldAmount, newAmount)\\n            );\\n        }\\n\\n        //normal mode swap\\n        return (\\n            _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n            _scaledExecutorCallBytesData(executorData, oldAmount, newAmount)\\n        );\\n    }\\n\\n    /// @dev Scale the swap description\\n    function _scaledSwapDescriptionV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory) {\\n        desc.minReturnAmount = (desc.minReturnAmount * newAmount) / oldAmount;\\n        if (desc.minReturnAmount == 0) desc.minReturnAmount = 1;\\n        desc.amount = newAmount;\\n\\n        uint256 nReceivers = desc.srcReceivers.length;\\n        for (uint256 i = 0; i < nReceivers; ) {\\n            desc.srcAmounts[i] = (desc.srcAmounts[i] * newAmount) / oldAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return desc;\\n    }\\n\\n    /// @dev Scale the executorData in case swapSimpleMode\\n    function _scaledSimpleSwapData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        SimpleSwapData memory swapData = abi.decode(data, (SimpleSwapData));\\n\\n        uint256 nPools = swapData.firstPools.length;\\n        for (uint256 i = 0; i < nPools; ) {\\n            swapData.firstSwapAmounts[i] = (swapData.firstSwapAmounts[i] * newAmount) / oldAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        swapData.positiveSlippageData = _scaledPositiveSlippageFeeData(\\n            swapData.positiveSlippageData,\\n            oldAmount,\\n            newAmount\\n        );\\n        return abi.encode(swapData);\\n    }\\n\\n    /// @dev Scale the executorData in case normal swap\\n    function _scaledExecutorCallBytesData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        SwapExecutorDescription memory executorDesc = abi.decode(data, (SwapExecutorDescription));\\n        executorDesc.positiveSlippageData = _scaledPositiveSlippageFeeData(\\n            executorDesc.positiveSlippageData,\\n            oldAmount,\\n            newAmount\\n        );\\n\\n        uint256 nSequences = executorDesc.swapSequences.length;\\n        for (uint256 i = 0; i < nSequences; ) {\\n            Swap memory swap = executorDesc.swapSequences[i][0];\\n            bytes4 functionSelector = bytes4(swap.selectorAndFlags);\\n\\n            if (functionSelector == IExecutorHelper.executeUniswap.selector) {\\n                swap.data = ScalingDataLib.newUniSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeStableSwap.selector) {\\n                swap.data = ScalingDataLib.newStableSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeCurve.selector) {\\n                swap.data = ScalingDataLib.newCurveSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeKSClassic.selector) {\\n                swap.data = ScalingDataLib.newKyberDMM(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeUniV3KSElastic.selector) {\\n                swap.data = ScalingDataLib.newUniV3ProMM(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeRfq.selector) {\\n                revert(\\\"InputScalingHelper: Can not scale RFQ swap\\\");\\n            } else if (functionSelector == IExecutorHelper.executeBalV2.selector) {\\n                swap.data = ScalingDataLib.newBalancerV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeWrappedstETH.selector) {\\n                swap.data = ScalingDataLib.newWrappedstETHSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeStEth.selector) {\\n                swap.data = ScalingDataLib.newStETHSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeDODO.selector) {\\n                swap.data = ScalingDataLib.newDODO(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeVelodrome.selector) {\\n                swap.data = ScalingDataLib.newVelodrome(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeGMX.selector) {\\n                swap.data = ScalingDataLib.newGMX(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeSynthetix.selector) {\\n                swap.data = ScalingDataLib.newSynthetix(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeHashflow.selector) {\\n                revert(\\\"InputScalingHelper: Can not scale Hasflow swap\\\");\\n            } else if (functionSelector == IExecutorHelper.executeCamelot.selector) {\\n                swap.data = ScalingDataLib.newCamelot(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeKyberLimitOrder.selector) {\\n                revert(\\\"InputScalingHelper: Can not scale KyberLO swap\\\");\\n            } else if (functionSelector == IExecutorHelper.executePSM.selector) {\\n                swap.data = ScalingDataLib.newPSM(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeFrax.selector) {\\n                swap.data = ScalingDataLib.newFrax(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executePlatypus.selector) {\\n                swap.data = ScalingDataLib.newPlatypus(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeMaverick.selector) {\\n                swap.data = ScalingDataLib.newMaverick(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeSyncSwap.selector) {\\n                swap.data = ScalingDataLib.newSyncSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeAlgebraV1.selector) {\\n                swap.data = ScalingDataLib.newAlgebraV1(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeBalancerBatch.selector) {\\n                swap.data = ScalingDataLib.newBalancerBatch(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeWombat.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev struct Mantis is used for both Wombat and Mantis because of same fields\\n            } else if (functionSelector == IExecutorHelper.executeMantis.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeIziSwap.selector) {\\n                swap.data = ScalingDataLib.newIziSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeWooFiV2.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev using Mantis struct because WooFiV2 and Mantis have same fields\\n            } else if (functionSelector == IExecutorHelper.executeTraderJoeV2.selector) {\\n                swap.data = ScalingDataLib.newTraderJoeV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executePancakeStableSwap.selector) {\\n                swap.data = ScalingDataLib.newCurveSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeLevelFiV2.selector) {\\n                swap.data = ScalingDataLib.newLevelFiV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeGMXGLP.selector) {\\n                swap.data = ScalingDataLib.newGMXGLP(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeVooi.selector) {\\n                swap.data = ScalingDataLib.newVooi(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeVelocoreV2.selector) {\\n                swap.data = ScalingDataLib.newVelocoreV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeMaticMigrate.selector) {\\n                swap.data = ScalingDataLib.newMaticMigrate(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeSmardex.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev using Mantis struct because Smardex and Mantis have same fields\\n            } else if (functionSelector == IExecutorHelper.executeSolidlyV2.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev using Mantis struct because Solidly V2 and Mantis have same fields\\n            } else if (functionSelector == IExecutorHelper.executeKokonut.selector) {\\n                swap.data = ScalingDataLib.newKokonut(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeBalancerV1.selector) {\\n                swap.data = ScalingDataLib.newBalancerV1(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeSwaapV2.selector) {\\n                revert(\\\"InputScalingHelper: Can not scale SwaapV2 swap\\\");\\n            } else if (functionSelector == IExecutorHelper.executeNomiswapStable.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev using Mantis struct because NomiswapV2 and Mantis have same fields\\n            } else if (functionSelector == IExecutorHelper.executeArbswapStable.selector) {\\n                swap.data = ScalingDataLib.newArbswapStable(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeBancorV2.selector) {\\n                swap.data = ScalingDataLib.newBancorV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper.executeBancorV3.selector) {\\n                swap.data = ScalingDataLib.newMantis(swap.data, oldAmount, newAmount); // @dev using Mantis struct because Bancor V3 and Mantis have same fields\\n            } else if (functionSelector == IExecutorHelper.executeAmbient.selector) {\\n                swap.data = ScalingDataLib.newAmbient(swap.data, oldAmount, newAmount);\\n            } else {\\n                revert(\\\"AggregationExecutor: Dex type not supported\\\");\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return abi.encode(executorDesc);\\n    }\\n\\n    function _scaledPositiveSlippageFeeData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory newData) {\\n        if (data.length > 32) {\\n            PositiveSlippageFeeData memory psData = abi.decode(data, (PositiveSlippageFeeData));\\n            uint256 left = uint256(psData.expectedReturnAmount >> 128);\\n            uint256 right = (uint256(uint128(psData.expectedReturnAmount)) * newAmount) / oldAmount;\\n            require(right <= type(uint128).max, \\\"Exceeded type range\\\");\\n            psData.expectedReturnAmount = right | (left << 128);\\n            data = abi.encode(psData);\\n        } else if (data.length == 32) {\\n            uint256 expectedReturnAmount = abi.decode(data, (uint256));\\n            uint256 left = uint256(expectedReturnAmount >> 128);\\n            uint256 right = (uint256(uint128(expectedReturnAmount)) * newAmount) / oldAmount;\\n            require(right <= type(uint128).max, \\\"Exceeded type range\\\");\\n            expectedReturnAmount = right | (left << 128);\\n            data = abi.encode(expectedReturnAmount);\\n        }\\n        return data;\\n    }\\n\\n    function _flagsChecked(uint256 number, uint256 flag) internal pure returns (bool) {\\n        return number & flag != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l1-contracts/ScalingDataLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IExecutorHelper} from \\\"../interfaces/IExecutorHelper.sol\\\";\\n\\nlibrary ScalingDataLib {\\n    function newUniSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniSwap memory uniSwap = abi.decode(data, (IExecutorHelper.UniSwap));\\n        uniSwap.collectAmount = (uniSwap.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(uniSwap);\\n    }\\n\\n    function newStableSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.StableSwap memory stableSwap = abi.decode(data, (IExecutorHelper.StableSwap));\\n        stableSwap.dx = (stableSwap.dx * newAmount) / oldAmount;\\n        return abi.encode(stableSwap);\\n    }\\n\\n    function newCurveSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.CurveSwap memory curveSwap = abi.decode(data, (IExecutorHelper.CurveSwap));\\n        curveSwap.dx = (curveSwap.dx * newAmount) / oldAmount;\\n        return abi.encode(curveSwap);\\n    }\\n\\n    function newKyberDMM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniSwap memory kyberDMMSwap = abi.decode(data, (IExecutorHelper.UniSwap));\\n        kyberDMMSwap.collectAmount = (kyberDMMSwap.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(kyberDMMSwap);\\n    }\\n\\n    function newUniV3ProMM(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniswapV3KSElastic memory uniSwapV3ProMM = abi.decode(\\n            data,\\n            (IExecutorHelper.UniswapV3KSElastic)\\n        );\\n        uniSwapV3ProMM.swapAmount = (uniSwapV3ProMM.swapAmount * newAmount) / oldAmount;\\n\\n        return abi.encode(uniSwapV3ProMM);\\n    }\\n\\n    function newBalancerV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.BalancerV2 memory balancerV2 = abi.decode(data, (IExecutorHelper.BalancerV2));\\n        balancerV2.amount = (balancerV2.amount * newAmount) / oldAmount;\\n        return abi.encode(balancerV2);\\n    }\\n\\n    function newDODO(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.DODO memory dodo = abi.decode(data, (IExecutorHelper.DODO));\\n        dodo.amount = (dodo.amount * newAmount) / oldAmount;\\n        return abi.encode(dodo);\\n    }\\n\\n    function newVelodrome(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniSwap memory velodrome = abi.decode(data, (IExecutorHelper.UniSwap));\\n        velodrome.collectAmount = (velodrome.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(velodrome);\\n    }\\n\\n    function newGMX(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.GMX memory gmx = abi.decode(data, (IExecutorHelper.GMX));\\n        gmx.amount = (gmx.amount * newAmount) / oldAmount;\\n        return abi.encode(gmx);\\n    }\\n\\n    function newSynthetix(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.Synthetix memory synthetix = abi.decode(data, (IExecutorHelper.Synthetix));\\n        synthetix.sourceAmount = (synthetix.sourceAmount * newAmount) / oldAmount;\\n        return abi.encode(synthetix);\\n    }\\n\\n    function newCamelot(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniSwap memory camelot = abi.decode(data, (IExecutorHelper.UniSwap));\\n        camelot.collectAmount = (camelot.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(camelot);\\n    }\\n\\n    function newPlatypus(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Platypus memory platypus = abi.decode(data, (IExecutorHelper.Platypus));\\n        platypus.collectAmount = (platypus.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(platypus);\\n    }\\n\\n    function newWrappedstETHSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.WSTETH memory wstEthData = abi.decode(data, (IExecutorHelper.WSTETH));\\n        wstEthData.amount = (wstEthData.amount * newAmount) / oldAmount;\\n        return abi.encode(wstEthData);\\n    }\\n\\n    function newPSM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.PSM memory psm = abi.decode(data, (IExecutorHelper.PSM));\\n        psm.amountIn = (psm.amountIn * newAmount) / oldAmount;\\n        return abi.encode(psm);\\n    }\\n\\n    function newFrax(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.UniSwap memory frax = abi.decode(data, (IExecutorHelper.UniSwap));\\n        frax.collectAmount = (frax.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(frax);\\n    }\\n\\n    function newStETHSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 amount = abi.decode(data, (uint256));\\n        amount = (amount * newAmount) / oldAmount;\\n        return abi.encode(amount);\\n    }\\n\\n    function newMaverick(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Maverick memory maverick = abi.decode(data, (IExecutorHelper.Maverick));\\n        maverick.swapAmount = (maverick.swapAmount * newAmount) / oldAmount;\\n        return abi.encode(maverick);\\n    }\\n\\n    function newSyncSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.SyncSwap memory syncSwap = abi.decode(data, (IExecutorHelper.SyncSwap));\\n        syncSwap.collectAmount = (syncSwap.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(syncSwap);\\n    }\\n\\n    function newAlgebraV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.AlgebraV1 memory algebraV1Swap = abi.decode(data, (IExecutorHelper.AlgebraV1));\\n        algebraV1Swap.swapAmount = (algebraV1Swap.swapAmount * newAmount) / oldAmount;\\n        return abi.encode(algebraV1Swap);\\n    }\\n\\n    function newBalancerBatch(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.BalancerBatch memory balancerBatch = abi.decode(data, (IExecutorHelper.BalancerBatch));\\n        balancerBatch.amountIn = (balancerBatch.amountIn * newAmount) / oldAmount;\\n        return abi.encode(balancerBatch);\\n    }\\n\\n    function newMantis(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Mantis memory mantis = abi.decode(data, (IExecutorHelper.Mantis));\\n        mantis.amount = (mantis.amount * newAmount) / oldAmount;\\n        return abi.encode(mantis);\\n    }\\n\\n    function newIziSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.IziSwap memory iZi = abi.decode(data, (IExecutorHelper.IziSwap));\\n        iZi.swapAmount = (iZi.swapAmount * newAmount) / oldAmount;\\n        return abi.encode(iZi);\\n    }\\n\\n    function newTraderJoeV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.TraderJoeV2 memory traderJoe = abi.decode(data, (IExecutorHelper.TraderJoeV2));\\n\\n        // traderJoe.collectAmount; // most significant 1 bit is to determine whether pool is v2.1, else v2.0\\n        traderJoe.collectAmount =\\n            (traderJoe.collectAmount & (1 << 255)) |\\n            ((uint256((traderJoe.collectAmount << 1) >> 1) * newAmount) / oldAmount);\\n        return abi.encode(traderJoe);\\n    }\\n\\n    function newLevelFiV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.LevelFiV2 memory levelFiV2 = abi.decode(data, (IExecutorHelper.LevelFiV2));\\n        levelFiV2.amountIn = (levelFiV2.amountIn * newAmount) / oldAmount;\\n        return abi.encode(levelFiV2);\\n    }\\n\\n    function newGMXGLP(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.GMXGLP memory swapData = abi.decode(data, (IExecutorHelper.GMXGLP));\\n        swapData.swapAmount = (swapData.swapAmount * newAmount) / oldAmount;\\n        return abi.encode(swapData);\\n    }\\n\\n    function newVooi(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Vooi memory vooi = abi.decode(data, (IExecutorHelper.Vooi));\\n        vooi.fromAmount = (vooi.fromAmount * newAmount) / oldAmount;\\n        return abi.encode(vooi);\\n    }\\n\\n    function newVelocoreV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.VelocoreV2 memory velocorev2 = abi.decode(data, (IExecutorHelper.VelocoreV2));\\n        velocorev2.amount = (velocorev2.amount * newAmount) / oldAmount;\\n        return abi.encode(velocorev2);\\n    }\\n\\n    function newMaticMigrate(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.MaticMigrate memory maticMigrate = abi.decode(data, (IExecutorHelper.MaticMigrate));\\n        maticMigrate.amount = (maticMigrate.amount * newAmount) / oldAmount;\\n        return abi.encode(maticMigrate);\\n    }\\n\\n    function newKokonut(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Kokonut memory kokonut = abi.decode(data, (IExecutorHelper.Kokonut));\\n        kokonut.dx = (kokonut.dx * newAmount) / oldAmount;\\n        return abi.encode(kokonut);\\n    }\\n\\n    function newBalancerV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.BalancerV1 memory balancerV1 = abi.decode(data, (IExecutorHelper.BalancerV1));\\n        balancerV1.amount = (balancerV1.amount * newAmount) / oldAmount;\\n        return abi.encode(balancerV1);\\n    }\\n\\n    function newArbswapStable(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper.ArbswapStable memory arbswapStable = abi.decode(data, (IExecutorHelper.ArbswapStable));\\n        arbswapStable.dx = (arbswapStable.dx * newAmount) / oldAmount;\\n        return abi.encode(arbswapStable);\\n    }\\n\\n    function newBancorV2(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.BancorV2 memory bancorV2 = abi.decode(data, (IExecutorHelper.BancorV2));\\n        bancorV2.amount = (bancorV2.amount * newAmount) / oldAmount;\\n        return abi.encode(bancorV2);\\n    }\\n\\n    function newAmbient(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper.Ambient memory ambient = abi.decode(data, (IExecutorHelper.Ambient));\\n        ambient.qty = uint128((uint256(ambient.qty) * newAmount) / oldAmount);\\n        return abi.encode(ambient);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/BytesHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary BytesHelper {\\n    function write16Bytes(bytes memory original, uint256 index, bytes16 value) internal pure returns (bytes memory) {\\n        assembly {\\n            let offset := add(original, add(index, 32))\\n            let val := mload(offset) // read 32 bytes [index : index + 32]\\n            val := and(val, not(0xffffffffffffffffffffffffffffffff00000000000000000000000000000000)) // clear [index : index + 16]\\n            val := or(val, value) // set 16 bytes to val above\\n            mstore(offset, val) // store to [index : index + 32]\\n        }\\n        return original;\\n    }\\n\\n    function write16Bytes(bytes memory original, uint256 index, uint128 value) internal pure returns (bytes memory) {\\n        return write16Bytes(original, index, bytes16(value));\\n    }\\n\\n    function write16Bytes(\\n        bytes memory original,\\n        uint256 index,\\n        uint256 value,\\n        string memory errorMsg\\n    ) internal pure returns (bytes memory) {\\n        require(value <= type(uint128).max, string(abi.encodePacked(errorMsg, \\\"/Exceed compressed type range\\\")));\\n        return write16Bytes(original, index, uint128(value));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/CalldataReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary CalldataReader {\\n    /// @notice read the bytes value of data from a starting position and length\\n    /// @param data bytes array of data\\n    /// @param startByte starting position to read\\n    /// @param length length from starting position\\n    /// @return retVal value of the bytes\\n    /// @return (the next position to read from)\\n    function _calldataVal(\\n        bytes memory data,\\n        uint256 startByte,\\n        uint256 length\\n    ) internal pure returns (bytes memory retVal, uint256) {\\n        require(length + startByte <= data.length, \\\"calldataVal trying to read beyond data size\\\");\\n        uint256 loops = (length + 31) / 32;\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, length)\\n            for {\\n                let i := 0\\n            } lt(i, loops) {\\n                i := add(1, i)\\n            } {\\n                mstore(add(m, mul(32, add(1, i))), mload(add(data, add(mul(32, add(1, i)), startByte))))\\n            }\\n            mstore(0x40, add(m, add(32, length)))\\n            retVal := m\\n        }\\n        return (retVal, length + startByte);\\n    }\\n\\n    function _readBool(bytes memory data, uint256 startByte) internal pure returns (bool, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        return (bytes1(ret) > 0, startByte);\\n    }\\n\\n    function _readUint8(bytes memory data, uint256 startByte) internal pure returns (uint8, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        return (uint8(bytes1(ret)), startByte);\\n    }\\n\\n    function _readUint24(bytes memory data, uint256 startByte) internal pure returns (uint24, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 3);\\n        return (uint24(bytes3(ret)), startByte);\\n    }\\n\\n    function _readUint32(bytes memory data, uint256 startByte) internal pure returns (uint32, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 4);\\n        return (uint32(bytes4(ret)), startByte);\\n    }\\n\\n    function _readUint128(bytes memory data, uint256 startByte) internal pure returns (uint128, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 16);\\n        return (uint128(bytes16(ret)), startByte);\\n    }\\n\\n    function _readUint160(bytes memory data, uint256 startByte) internal pure returns (uint160, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 20);\\n        return (uint160(bytes20(ret)), startByte);\\n    }\\n\\n    /// @dev only when sure that the value of uint256 never exceed uint128\\n    function _readUint128AsUint256(bytes memory data, uint256 startByte) internal pure returns (uint256, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 16);\\n        return (uint256(uint128(bytes16(ret))), startByte);\\n    }\\n\\n    function _readAddress(bytes memory data, uint256 startByte) internal pure returns (address, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 20);\\n        return (address(bytes20(ret)), startByte);\\n    }\\n\\n    function _readBytes1(bytes memory data, uint256 startByte) internal pure returns (bytes1, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        return (bytes1(ret), startByte);\\n    }\\n\\n    function _readBytes4(bytes memory data, uint256 startByte) internal pure returns (bytes4, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 4);\\n        return (bytes4(ret), startByte);\\n    }\\n\\n    function _readBytes32(bytes memory data, uint256 startByte) internal pure returns (bytes32, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 32);\\n        return (bytes32(ret), startByte);\\n    }\\n\\n    /// @dev length of bytes is currently limited to uint32\\n    function _readBytes(bytes memory data, uint256 startByte) internal pure returns (bytes memory b, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 4);\\n        uint256 length = uint256(uint32(bytes4(ret)));\\n        (b, startByte) = _calldataVal(data, startByte, length);\\n        return (b, startByte);\\n    }\\n\\n    /// @dev length of bytes array is currently limited to uint8\\n    function _readBytesArray(\\n        bytes memory data,\\n        uint256 startByte\\n    ) internal pure returns (bytes[] memory bytesArray, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        uint256 length = uint256(uint8(bytes1(ret)));\\n        bytesArray = new bytes[](length);\\n        for (uint8 i = 0; i < length; ++i) {\\n            (bytesArray[i], startByte) = _readBytes(data, startByte);\\n        }\\n        return (bytesArray, startByte);\\n    }\\n\\n    /// @dev length of address array is currently limited to uint8 to save bytes\\n    function _readAddressArray(\\n        bytes memory data,\\n        uint256 startByte\\n    ) internal pure returns (address[] memory addrs, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        uint256 length = uint256(uint8(bytes1(ret)));\\n        addrs = new address[](length);\\n        for (uint8 i = 0; i < length; ++i) {\\n            (addrs[i], startByte) = _readAddress(data, startByte);\\n        }\\n        return (addrs, startByte);\\n    }\\n\\n    /// @dev length of uint array is currently limited to uint8 to save bytes\\n    /// @dev same as _readUint128AsUint256, only use when sure that value never exceed uint128\\n    function _readUint128ArrayAsUint256Array(\\n        bytes memory data,\\n        uint256 startByte\\n    ) internal pure returns (uint256[] memory, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = _calldataVal(data, startByte, 1);\\n        uint256 length = uint256(uint8(bytes1(ret)));\\n        uint256[] memory us = new uint256[](length);\\n        for (uint8 i = 0; i < length; ++i) {\\n            (us[i], startByte) = _readUint128AsUint256(data, startByte);\\n        }\\n        return (us, startByte);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/CalldataWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IMetaAggregationRouterV2} from \\\"../interfaces/IMetaAggregationRouterV2.sol\\\";\\nimport {IAggregationExecutorOptimistic as IExecutorHelperL2} from \\\"../interfaces/IAggregationExecutorOptimistic.sol\\\";\\nimport {IExecutorHelper as IExecutorHelperL1} from \\\"../interfaces/IExecutorHelper.sol\\\";\\n\\nlibrary CalldataWriter {\\n    function writeSimpleSwapData(\\n        IMetaAggregationRouterV2.SimpleSwapData memory simpleSwapData\\n    ) internal pure returns (bytes memory shortData) {\\n        shortData = bytes.concat(shortData, _writeAddressArray(simpleSwapData.firstPools));\\n        shortData = bytes.concat(shortData, _writeUint256ArrayAsUint128Array(simpleSwapData.firstSwapAmounts));\\n        shortData = bytes.concat(shortData, _writeBytesArray(simpleSwapData.swapDatas));\\n        shortData = bytes.concat(shortData, bytes16(uint128(simpleSwapData.deadline)));\\n        shortData = bytes.concat(shortData, _writeBytes(simpleSwapData.positiveSlippageData));\\n    }\\n\\n    /*\\n     ************************ AggregationExecutor ************************\\n     */\\n    function writeSwapExecutorDescription(\\n        IExecutorHelperL2.SwapExecutorDescription memory desc\\n    ) internal pure returns (bytes memory shortData) {\\n        // write Swap array\\n        uint8 lX = uint8(desc.swapSequences.length);\\n        shortData = bytes.concat(shortData, bytes1(lX));\\n        for (uint8 i = 0; i < lX; ++i) {\\n            uint8 lY = uint8(desc.swapSequences[i].length);\\n            shortData = bytes.concat(shortData, bytes1(lY));\\n            for (uint8 j = 0; j < lY; ++j) {\\n                shortData = bytes.concat(shortData, _writeSwap(desc.swapSequences[i][j]));\\n            }\\n        }\\n\\n        // basic members\\n        shortData = bytes.concat(shortData, bytes20(desc.tokenIn));\\n        shortData = bytes.concat(shortData, bytes20(desc.tokenOut));\\n        shortData = bytes.concat(shortData, bytes20(desc.to));\\n        shortData = bytes.concat(shortData, bytes16(uint128(desc.deadline)));\\n        shortData = bytes.concat(shortData, _writeBytes(desc.positiveSlippageData));\\n    }\\n\\n    function writeSimpleModeSwapDatas(\\n        bytes[] memory swapDatas,\\n        address tokenIn\\n    ) internal pure returns (bytes[] memory shortData) {\\n        uint8 len = uint8(swapDatas.length);\\n        for (uint8 i = 0; i < len; ++i) {\\n            swapDatas[i] = _writeSwapSingleSequence(swapDatas[i], tokenIn);\\n        }\\n        return (swapDatas);\\n    }\\n\\n    function _writeSwapSingleSequence(\\n        bytes memory data,\\n        address tokenIn\\n    ) internal pure returns (bytes memory shortData) {\\n        IExecutorHelperL2.Swap[] memory swaps = abi.decode(data, (IExecutorHelperL2.Swap[]));\\n\\n        uint8 len = uint8(swaps.length);\\n        shortData = bytes.concat(shortData, bytes1(len));\\n        for (uint8 i = 0; i < len; ++i) {\\n            shortData = bytes.concat(shortData, _writeSwap(swaps[i]));\\n        }\\n        shortData = bytes.concat(shortData, bytes20(tokenIn));\\n    }\\n\\n    function _writeAddressArray(address[] memory addrs) internal pure returns (bytes memory data) {\\n        uint8 length = uint8(addrs.length);\\n        data = bytes.concat(data, bytes1(length));\\n        for (uint8 i = 0; i < length; ++i) {\\n            data = bytes.concat(data, bytes20(addrs[i]));\\n        }\\n        return data;\\n    }\\n\\n    function _writeUint256ArrayAsUint128Array(uint256[] memory us) internal pure returns (bytes memory data) {\\n        uint8 length = uint8(us.length);\\n        data = bytes.concat(data, bytes1(length));\\n        for (uint8 i = 0; i < length; ++i) {\\n            data = bytes.concat(data, bytes16(uint128(us[i])));\\n        }\\n        return data;\\n    }\\n\\n    function _writeBytes(bytes memory b) internal pure returns (bytes memory data) {\\n        uint32 length = uint32(b.length);\\n        data = bytes.concat(data, bytes4(length));\\n        data = bytes.concat(data, b);\\n        return data;\\n    }\\n\\n    function _writeBytesArray(bytes[] memory bytesArray) internal pure returns (bytes memory data) {\\n        uint8 x = uint8(bytesArray.length);\\n        data = bytes.concat(data, bytes1(x));\\n        for (uint8 i; i < x; ++i) {\\n            uint32 length = uint32(bytesArray[i].length);\\n            data = bytes.concat(data, bytes4(length));\\n            data = bytes.concat(data, bytesArray[i]);\\n        }\\n        return data;\\n    }\\n\\n    function _writeBytes32Array(bytes32[] memory bytesArray) internal pure returns (bytes memory data) {\\n        uint8 x = uint8(bytesArray.length);\\n        data = bytes.concat(data, bytes1(x));\\n        for (uint8 i; i < x; ++i) {\\n            data = bytes.concat(data, bytesArray[i]);\\n        }\\n        return data;\\n    }\\n\\n    function _writeSwap(IExecutorHelperL2.Swap memory swap) internal pure returns (bytes memory shortData) {\\n        shortData = bytes.concat(shortData, _writeBytes(swap.data));\\n        shortData = bytes.concat(shortData, bytes1(uint8(uint32(swap.functionSelector))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CalldataReader.sol\\\";\\n\\nlibrary Common {\\n    using CalldataReader for bytes;\\n\\n    function _readPool(bytes memory data, uint256 startByte) internal pure returns (address, uint256) {\\n        uint24 poolId;\\n        address poolAddress;\\n        (poolId, startByte) = data._readUint24(startByte);\\n        if (poolId == 0) {\\n            (poolAddress, startByte) = data._readAddress(startByte);\\n        }\\n        return (poolAddress, startByte);\\n    }\\n\\n    function _readRecipient(bytes memory data, uint256 startByte) internal pure returns (address, uint256) {\\n        uint8 recipientFlag;\\n        address recipient;\\n        (recipientFlag, startByte) = data._readUint8(startByte);\\n        if (recipientFlag != 2 && recipientFlag != 1) {\\n            (recipient, startByte) = data._readAddress(startByte);\\n        }\\n        return (recipient, startByte);\\n    }\\n\\n    function _readBytes32Array(\\n        bytes memory data,\\n        uint256 startByte\\n    ) internal pure returns (bytes32[] memory bytesArray, uint256) {\\n        bytes memory ret;\\n        (ret, startByte) = data._calldataVal(startByte, 1);\\n        uint256 length = uint256(uint8(bytes1(ret)));\\n        bytesArray = new bytes32[](length);\\n        for (uint8 i = 0; i < length; ++i) {\\n            (bytesArray[i], startByte) = data._readBytes32(startByte);\\n        }\\n        return (bytesArray, startByte);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/DexScaler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CalldataReader.sol\\\";\\nimport \\\"../interfaces/IExecutorHelperL2.sol\\\";\\nimport {BytesHelper} from \\\"./BytesHelper.sol\\\";\\nimport {Common} from \\\"./Common.sol\\\";\\n\\n/// @title DexScaler\\n/// @notice Contain functions to scale DEX structs\\n/// @dev For this repo's scope, we only care about swap amounts, so we just need to decode until we get swap amounts\\nlibrary DexScaler {\\n    using BytesHelper for bytes;\\n    using CalldataReader for bytes;\\n    using Common for bytes;\\n\\n    function scaleUniSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n        (, startByte) = data._readRecipient(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleUniSwap\\\");\\n    }\\n\\n    function scaleStableSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        (, startByte) = data._readPool(startByte);\\n        (, startByte) = data._readUint8(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleStableSwap\\\");\\n    }\\n\\n    function scaleCurveSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        bool canGetIndex;\\n        (canGetIndex, startByte) = data._readBool(0);\\n        (, startByte) = data._readPool(startByte);\\n        if (!canGetIndex) {\\n            (, startByte) = data._readAddress(startByte);\\n            (, startByte) = data._readUint8(startByte);\\n        }\\n        (, startByte) = data._readUint8(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleCurveSwap\\\");\\n    }\\n\\n    function scaleUniswapV3KSElastic(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        (, startByte) = data._readRecipient(startByte);\\n        (, startByte) = data._readPool(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(\\n                startByte,\\n                oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount,\\n                \\\"scaleUniswapV3KSElastic\\\"\\n            );\\n    }\\n\\n    function scaleBalancerV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        (, startByte) = data._readPool(startByte);\\n        (, startByte) = data._readBytes32(startByte);\\n        (, startByte) = data._readUint8(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleBalancerV2\\\");\\n    }\\n\\n    function scaleDODO(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        (, startByte) = data._readRecipient(startByte);\\n        (, startByte) = data._readPool(startByte);\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleDODO\\\");\\n    }\\n\\n    function scaleGMX(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleGMX\\\");\\n    }\\n\\n    function scaleSynthetix(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n        (, startByte) = data._readBytes32(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleSynthetix\\\");\\n    }\\n\\n    function scaleWrappedstETH(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(\\n                startByte,\\n                oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount,\\n                \\\"scaleWrappedstETH\\\"\\n            );\\n    }\\n\\n    function scaleStETH(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(0);\\n        return data.write16Bytes(0, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleStETH\\\");\\n    }\\n\\n    function scalePlatypus(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (, startByte) = data._readRecipient(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scalePlatypus\\\");\\n    }\\n\\n    function scalePSM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scalePSM\\\");\\n    }\\n\\n    function scaleMaverick(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (, startByte) = data._readRecipient(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleMaverick\\\");\\n    }\\n\\n    function scaleSyncSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readBytes(startByte);\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleSyncSwap\\\");\\n    }\\n\\n    function scaleAlgebraV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readRecipient(startByte);\\n\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readAddress(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleAlgebraV1\\\");\\n    }\\n\\n    function scaleBalancerBatch(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // decode\\n        (, startByte) = data._readPool(startByte);\\n\\n        (, startByte) = data._readBytes32Array(startByte);\\n        (, startByte) = data._readAddressArray(startByte);\\n        (, startByte) = data._readBytesArray(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte);\\n        return\\n            data.write16Bytes(\\n                startByte,\\n                oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount,\\n                \\\"scaleBalancerBatch\\\"\\n            );\\n    }\\n\\n    function scaleMantis(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddress(startByte); // tokenOut\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte); // amount\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleMantis\\\");\\n    }\\n\\n    function scaleIziSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddress(startByte); // tokenOut\\n\\n        // recipient\\n        (, startByte) = data._readRecipient(startByte);\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte); // amount\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleIziSwap\\\");\\n    }\\n\\n    function scaleTraderJoeV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        // recipient\\n        (, startByte) = data._readRecipient(startByte);\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddress(startByte); // tokenOut\\n\\n        (, startByte) = data._readBool(startByte); // isV2\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte); // amount\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleTraderJoeV2\\\");\\n    }\\n\\n    function scaleLevelFiV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddress(startByte); // tokenOut\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte); // amount\\n        return\\n            data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleLevelFiV2\\\");\\n    }\\n\\n    function scaleGMXGLP(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddress(startByte); // yearnVault\\n\\n        uint8 directionFlag;\\n        (directionFlag, startByte) = data._readUint8(startByte);\\n        if (directionFlag == 1) (, startByte) = data._readAddress(startByte); // tokenOut\\n\\n        (uint256 swapAmount, ) = data._readUint128AsUint256(startByte); // amount\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (swapAmount * newAmount) / oldAmount, \\\"scaleGMXGLP\\\");\\n    }\\n\\n    function scaleVooi(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readUint8(startByte); // toId\\n\\n        (uint256 fromAmount, ) = data._readUint128AsUint256(startByte); // amount\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (fromAmount * newAmount) / oldAmount, \\\"scaleVooi\\\");\\n    }\\n\\n    function scaleVelocoreV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (uint256 amount, ) = data._readUint128AsUint256(startByte); // amount\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (amount * newAmount) / oldAmount, \\\"scaleVelocoreV2\\\");\\n    }\\n\\n    function scaleKokonut(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (uint256 amount, ) = data._readUint128AsUint256(startByte); // amount\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (amount * newAmount) / oldAmount, \\\"scaleKokonut\\\");\\n    }\\n\\n    function scaleBalancerV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (uint256 amount, ) = data._readUint128AsUint256(startByte); // amount\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (amount * newAmount) / oldAmount, \\\"scaleBalancerV1\\\");\\n    }\\n\\n    function scaleArbswapStable(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (uint256 dx, ) = data._readUint128AsUint256(startByte); // dx\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (dx * newAmount) / oldAmount, \\\"scaleArbswapStable\\\");\\n    }\\n\\n    function scaleBancorV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (, startByte) = data._readAddressArray(startByte); // swapPath\\n\\n        (uint256 amount, ) = data._readUint128AsUint256(startByte); // amount\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (amount * newAmount) / oldAmount, \\\"scaleBancorV2\\\");\\n    }\\n\\n    function scaleAmbient(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        uint256 startByte;\\n\\n        (, startByte) = data._readPool(startByte); // pool\\n\\n        (uint128 qty, ) = data._readUint128(startByte); // amount\\n\\n        return data.write16Bytes(startByte, oldAmount == 0 ? 0 : (qty * newAmount) / oldAmount, \\\"scaleAmbient\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/ExecutorReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CalldataReader.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IAggregationExecutorOptimistic.sol\\\";\\n\\nlibrary ExecutorReader {\\n    function readSwapExecutorDescription(bytes memory data) internal pure returns (bytes memory) {\\n        uint256 startByte = 0;\\n        IAggregationExecutorOptimistic.SwapExecutorDescription memory desc;\\n\\n        // Swap array\\n        bytes memory ret;\\n        (ret, startByte) = CalldataReader._calldataVal(data, startByte, 1);\\n        uint256 lX = uint256(uint8(bytes1(ret)));\\n        desc.swapSequences = new IAggregationExecutorOptimistic.Swap[][](lX);\\n        for (uint8 i = 0; i < lX; ++i) {\\n            (ret, startByte) = CalldataReader._calldataVal(data, startByte, 1);\\n            uint256 lY = uint256(uint8(bytes1(ret)));\\n            desc.swapSequences[i] = new IAggregationExecutorOptimistic.Swap[](lY);\\n            for (uint8 j = 0; j < lY; ++j) {\\n                (desc.swapSequences[i][j], startByte) = _readSwap(data, startByte);\\n            }\\n        }\\n\\n        // basic members\\n        (desc.tokenIn, startByte) = CalldataReader._readAddress(data, startByte);\\n        (desc.tokenOut, startByte) = CalldataReader._readAddress(data, startByte);\\n        (desc.to, startByte) = CalldataReader._readAddress(data, startByte);\\n        (desc.deadline, startByte) = CalldataReader._readUint128AsUint256(data, startByte);\\n        (desc.positiveSlippageData, startByte) = CalldataReader._readBytes(data, startByte);\\n\\n        return abi.encode(desc);\\n    }\\n\\n    function readSwapSingleSequence(\\n        bytes memory data\\n    ) internal pure returns (IAggregationExecutorOptimistic.Swap[] memory swaps, address tokenIn) {\\n        uint256 startByte = 0;\\n        bytes memory ret;\\n        (ret, startByte) = CalldataReader._calldataVal(data, startByte, 1);\\n        uint256 len = uint256(uint8(bytes1(ret)));\\n        swaps = new IAggregationExecutorOptimistic.Swap[](len);\\n        for (uint8 i = 0; i < len; ++i) {\\n            (swaps[i], startByte) = _readSwap(data, startByte);\\n        }\\n        (tokenIn, startByte) = CalldataReader._readAddress(data, startByte);\\n    }\\n\\n    function _readSwap(\\n        bytes memory data,\\n        uint256 startByte\\n    ) internal pure returns (IAggregationExecutorOptimistic.Swap memory swap, uint256) {\\n        (swap.data, startByte) = CalldataReader._readBytes(data, startByte);\\n        bytes1 t;\\n        (t, startByte) = CalldataReader._readBytes1(data, startByte);\\n        swap.functionSelector = bytes4(uint32(uint8(t)));\\n        return (swap, startByte);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/InputScalingHelperL2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IAggregationExecutorOptimistic as IExecutorHelperL2} from \\\"../interfaces/IAggregationExecutorOptimistic.sol\\\";\\nimport {IExecutorHelper as IExecutorHelperL1} from \\\"../interfaces/IExecutorHelper.sol\\\";\\nimport {IMetaAggregationRouterV2} from \\\"../interfaces/IMetaAggregationRouterV2.sol\\\";\\nimport {ScalingDataL2Lib} from \\\"./ScalingDataL2Lib.sol\\\";\\nimport {ExecutorReader} from \\\"./ExecutorReader.sol\\\";\\nimport {CalldataWriter} from \\\"./CalldataWriter.sol\\\";\\n\\nlibrary InputScalingHelperL2 {\\n    using ExecutorReader for bytes;\\n    using ScalingDataL2Lib for bytes;\\n\\n    uint256 private constant _PARTIAL_FILL = 0x01;\\n    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;\\n    uint256 private constant _SHOULD_CLAIM = 0x04;\\n    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;\\n    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;\\n    uint256 private constant _SIMPLE_SWAP = 0x20;\\n\\n    struct PositiveSlippageFeeData {\\n        uint256 partnerPSInfor;\\n        uint256 expectedReturnAmount;\\n    }\\n\\n    enum DexIndex {\\n        UNI,\\n        KyberDMM,\\n        Velodrome,\\n        Fraxswap,\\n        Camelot,\\n        KyberLO,\\n        RFQ,\\n        Hashflow,\\n        StableSwap,\\n        Curve,\\n        UniswapV3KSElastic,\\n        BalancerV2,\\n        DODO,\\n        GMX,\\n        Synthetix,\\n        wstETH,\\n        stETH,\\n        Platypus,\\n        PSM,\\n        Maverick,\\n        SyncSwap,\\n        AlgebraV1,\\n        BalancerBatch,\\n        Mantis,\\n        Wombat,\\n        iZiSwap,\\n        TraderJoeV2,\\n        WooFiV2,\\n        KyberDSLO,\\n        LevelFiV2,\\n        GMXGLP,\\n        PancakeStableSwap,\\n        Vooi,\\n        VelocoreV2,\\n        Smardex,\\n        SolidlyV2,\\n        Kokonut,\\n        BalancerV1,\\n        SwaapV2,\\n        NomiswapStable,\\n        ArbswapStable,\\n        BancorV2,\\n        BancorV3,\\n        Ambient\\n    }\\n\\n    function _getScaledInputData(bytes calldata inputData, uint256 newAmount) internal pure returns (bytes memory) {\\n        bytes4 selector = bytes4(inputData[:4]);\\n        bytes calldata dataToDecode = inputData[4:];\\n\\n        if (selector == IMetaAggregationRouterV2.swap.selector) {\\n            IMetaAggregationRouterV2.SwapExecutionParams memory params = abi.decode(\\n                dataToDecode,\\n                (IMetaAggregationRouterV2.SwapExecutionParams)\\n            );\\n\\n            (params.desc, params.targetData) = _getScaledInputDataV2(\\n                params.desc,\\n                params.targetData,\\n                newAmount,\\n                _flagsChecked(params.desc.flags, _SIMPLE_SWAP)\\n            );\\n            return abi.encodeWithSelector(selector, params);\\n        } else if (selector == IMetaAggregationRouterV2.swapSimpleMode.selector) {\\n            (\\n                address callTarget,\\n                IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n                bytes memory targetData,\\n                bytes memory clientData\\n            ) = abi.decode(dataToDecode, (address, IMetaAggregationRouterV2.SwapDescriptionV2, bytes, bytes));\\n\\n            (desc, targetData) = _getScaledInputDataV2(desc, targetData, newAmount, true);\\n            return abi.encodeWithSelector(selector, callTarget, desc, targetData, clientData);\\n        } else {\\n            revert(\\\"InputScalingHelper: Invalid selector\\\");\\n        }\\n    }\\n\\n    function _getScaledInputDataV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        bytes memory executorData,\\n        uint256 newAmount,\\n        bool isSimpleMode\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory, bytes memory) {\\n        uint256 oldAmount = desc.amount;\\n        if (oldAmount == newAmount) {\\n            return (desc, executorData);\\n        }\\n\\n        // simple mode swap\\n        if (isSimpleMode) {\\n            return (\\n                _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n                _scaledSimpleSwapData(executorData, oldAmount, newAmount)\\n            );\\n        }\\n\\n        //normal mode swap\\n        return (\\n            _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n            _scaledExecutorCallBytesData(executorData, oldAmount, newAmount)\\n        );\\n    }\\n\\n    /// @dev Scale the swap description\\n    function _scaledSwapDescriptionV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory) {\\n        desc.minReturnAmount = (desc.minReturnAmount * newAmount) / oldAmount;\\n        if (desc.minReturnAmount == 0) desc.minReturnAmount = 1;\\n        desc.amount = (desc.amount * newAmount) / oldAmount;\\n\\n        uint256 nReceivers = desc.srcReceivers.length;\\n        for (uint256 i = 0; i < nReceivers; ) {\\n            desc.srcAmounts[i] = (desc.srcAmounts[i] * newAmount) / oldAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return desc;\\n    }\\n\\n    /// @dev Scale the executorData in case swapSimpleMode\\n    function _scaledSimpleSwapData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IMetaAggregationRouterV2.SimpleSwapData memory simpleSwapData = abi.decode(\\n            data,\\n            (IMetaAggregationRouterV2.SimpleSwapData)\\n        );\\n        uint256 nPools = simpleSwapData.firstPools.length;\\n        address tokenIn;\\n\\n        for (uint256 i = 0; i < nPools; ) {\\n            simpleSwapData.firstSwapAmounts[i] = (simpleSwapData.firstSwapAmounts[i] * newAmount) / oldAmount;\\n\\n            IExecutorHelperL2.Swap[] memory dexData;\\n\\n            (dexData, tokenIn) = simpleSwapData.swapDatas[i].readSwapSingleSequence();\\n\\n            // only need to scale the first dex in each sequence\\n            if (dexData.length > 0) {\\n                dexData[0] = _scaleDexData(dexData[0], oldAmount, newAmount);\\n            }\\n\\n            simpleSwapData.swapDatas[i] = CalldataWriter._writeSwapSingleSequence(abi.encode(dexData), tokenIn);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        simpleSwapData.positiveSlippageData = _scaledPositiveSlippageFeeData(\\n            simpleSwapData.positiveSlippageData,\\n            oldAmount,\\n            newAmount\\n        );\\n\\n        return abi.encode(simpleSwapData);\\n    }\\n\\n    /// @dev Scale the executorData in case normal swap\\n    function _scaledExecutorCallBytesData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelperL2.SwapExecutorDescription memory executorDesc = abi.decode(\\n            data.readSwapExecutorDescription(),\\n            (IExecutorHelperL2.SwapExecutorDescription)\\n        );\\n\\n        executorDesc.positiveSlippageData = _scaledPositiveSlippageFeeData(\\n            executorDesc.positiveSlippageData,\\n            oldAmount,\\n            newAmount\\n        );\\n\\n        uint256 nSequences = executorDesc.swapSequences.length;\\n        for (uint256 i = 0; i < nSequences; ) {\\n            // only need to scale the first dex in each sequence\\n            IExecutorHelperL2.Swap memory swap = executorDesc.swapSequences[i][0];\\n            executorDesc.swapSequences[i][0] = _scaleDexData(swap, oldAmount, newAmount);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return CalldataWriter.writeSwapExecutorDescription(executorDesc);\\n    }\\n\\n    function _scaledPositiveSlippageFeeData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory newData) {\\n        if (data.length > 32) {\\n            PositiveSlippageFeeData memory psData = abi.decode(data, (PositiveSlippageFeeData));\\n            uint256 left = uint256(psData.expectedReturnAmount >> 128);\\n            uint256 right = (uint256(uint128(psData.expectedReturnAmount)) * newAmount) / oldAmount;\\n            require(right <= type(uint128).max, \\\"_scaledPositiveSlippageFeeData/Exceeded type range\\\");\\n            psData.expectedReturnAmount = right | (left << 128);\\n            data = abi.encode(psData);\\n        } else if (data.length == 32) {\\n            uint256 expectedReturnAmount = abi.decode(data, (uint256));\\n            uint256 left = uint256(expectedReturnAmount >> 128);\\n            uint256 right = (uint256(uint128(expectedReturnAmount)) * newAmount) / oldAmount;\\n            require(right <= type(uint128).max, \\\"_scaledPositiveSlippageFeeData/Exceeded type range\\\");\\n            expectedReturnAmount = right | (left << 128);\\n            data = abi.encode(expectedReturnAmount);\\n        }\\n        return data;\\n    }\\n\\n    function _scaleDexData(\\n        IExecutorHelperL2.Swap memory swap,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (IExecutorHelperL2.Swap memory) {\\n        uint8 functionSelectorIndex = uint8(uint32(swap.functionSelector));\\n\\n        if (DexIndex(functionSelectorIndex) == DexIndex.UNI) {\\n            swap.data = swap.data.newUniSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.StableSwap) {\\n            swap.data = swap.data.newStableSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Curve) {\\n            swap.data = swap.data.newCurveSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.KyberDMM) {\\n            swap.data = swap.data.newKyberDMM(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.UniswapV3KSElastic) {\\n            swap.data = swap.data.newUniswapV3KSElastic(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.RFQ) {\\n            revert(\\\"InputScalingHelper: Can not scale RFQ swap\\\");\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.BalancerV2) {\\n            swap.data = swap.data.newBalancerV2(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.wstETH) {\\n            swap.data = swap.data.newWrappedstETHSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.stETH) {\\n            swap.data = swap.data.newStETHSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.DODO) {\\n            swap.data = swap.data.newDODO(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Velodrome) {\\n            swap.data = swap.data.newVelodrome(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.GMX) {\\n            swap.data = swap.data.newGMX(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Synthetix) {\\n            swap.data = swap.data.newSynthetix(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Hashflow) {\\n            revert(\\\"InputScalingHelper: Can not scale Hashflow swap\\\");\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Camelot) {\\n            swap.data = swap.data.newCamelot(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.KyberLO) {\\n            revert(\\\"InputScalingHelper: Can not scale KyberLO swap\\\");\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.PSM) {\\n            swap.data = swap.data.newPSM(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Fraxswap) {\\n            swap.data = swap.data.newFrax(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Platypus) {\\n            swap.data = swap.data.newPlatypus(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Maverick) {\\n            swap.data = swap.data.newMaverick(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.SyncSwap) {\\n            swap.data = swap.data.newSyncSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.AlgebraV1) {\\n            swap.data = swap.data.newAlgebraV1(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.BalancerBatch) {\\n            swap.data = swap.data.newBalancerBatch(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Mantis) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Wombat) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.iZiSwap) {\\n            swap.data = swap.data.newIziSwap(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.TraderJoeV2) {\\n            swap.data = swap.data.newTraderJoeV2(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.WooFiV2) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.KyberDSLO) {\\n            revert(\\\"InputScalingHelper: Can not scale KyberDSLO swap\\\");\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.LevelFiV2) {\\n            swap.data = swap.data.newLevelFiV2(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.PancakeStableSwap) {\\n            swap.data = swap.data.newCurveSwap(oldAmount, newAmount); // @dev same encoded data as Curve\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.GMXGLP) {\\n            swap.data = swap.data.newGMXGLP(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Vooi) {\\n            swap.data = swap.data.newVooi(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.VelocoreV2) {\\n            swap.data = swap.data.newVelocoreV2(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Smardex) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.SolidlyV2) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Kokonut) {\\n            swap.data = swap.data.newKokonut(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.BalancerV1) {\\n            swap.data = swap.data.newBalancerV1(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.SwaapV2) {\\n            revert(\\\"InputScalingHelper: Can not scale SwaapV2 swap\\\");\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.NomiswapStable) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.ArbswapStable) {\\n            swap.data = swap.data.newArbswapStable(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.BancorV2) {\\n            swap.data = swap.data.newBancorV2(oldAmount, newAmount);\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.BancorV3) {\\n            swap.data = swap.data.newMantis(oldAmount, newAmount); // @dev use identical calldata structure as Mantis\\n        } else if (DexIndex(functionSelectorIndex) == DexIndex.Ambient) {\\n            swap.data = swap.data.newAmbient(oldAmount, newAmount);\\n        } else {\\n            revert(\\\"InputScaleHelper: Dex type not supported\\\");\\n        }\\n        return swap;\\n    }\\n\\n    function _flagsChecked(uint256 number, uint256 flag) internal pure returns (bool) {\\n        return number & flag != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/kyberswap/l2-contracts/ScalingDataL2Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IExecutorHelper} from \\\"../interfaces/IExecutorHelper.sol\\\";\\nimport {DexScaler} from \\\"./DexScaler.sol\\\";\\n\\nlibrary ScalingDataL2Lib {\\n    using DexScaler for bytes;\\n\\n    function newUniSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleUniSwap(oldAmount, newAmount);\\n    }\\n\\n    function newStableSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleStableSwap(oldAmount, newAmount);\\n    }\\n\\n    function newCurveSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleCurveSwap(oldAmount, newAmount);\\n    }\\n\\n    function newKyberDMM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleUniSwap(oldAmount, newAmount);\\n    }\\n\\n    function newUniswapV3KSElastic(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleUniswapV3KSElastic(oldAmount, newAmount);\\n    }\\n\\n    function newBalancerV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleBalancerV2(oldAmount, newAmount);\\n    }\\n\\n    function newDODO(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleDODO(oldAmount, newAmount);\\n    }\\n\\n    function newVelodrome(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleUniSwap(oldAmount, newAmount);\\n    }\\n\\n    function newGMX(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleGMX(oldAmount, newAmount);\\n    }\\n\\n    function newSynthetix(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleSynthetix(oldAmount, newAmount);\\n    }\\n\\n    function newCamelot(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleUniSwap(oldAmount, newAmount);\\n    }\\n\\n    function newPlatypus(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scalePlatypus(oldAmount, newAmount);\\n    }\\n\\n    function newWrappedstETHSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleWrappedstETH(oldAmount, newAmount);\\n    }\\n\\n    function newPSM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scalePSM(oldAmount, newAmount);\\n    }\\n\\n    function newFrax(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleUniSwap(oldAmount, newAmount);\\n    }\\n\\n    function newStETHSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleStETH(oldAmount, newAmount);\\n    }\\n\\n    function newMaverick(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleMaverick(oldAmount, newAmount);\\n    }\\n\\n    function newSyncSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleSyncSwap(oldAmount, newAmount);\\n    }\\n\\n    function newAlgebraV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleAlgebraV1(oldAmount, newAmount);\\n    }\\n\\n    function newBalancerBatch(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleBalancerBatch(oldAmount, newAmount);\\n    }\\n\\n    function newMantis(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleMantis(oldAmount, newAmount);\\n    }\\n\\n    function newIziSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleIziSwap(oldAmount, newAmount);\\n    }\\n\\n    function newTraderJoeV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleTraderJoeV2(oldAmount, newAmount);\\n    }\\n\\n    function newLevelFiV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleLevelFiV2(oldAmount, newAmount);\\n    }\\n\\n    function newGMXGLP(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleGMXGLP(oldAmount, newAmount);\\n    }\\n\\n    function newVooi(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleVooi(oldAmount, newAmount);\\n    }\\n\\n    function newVelocoreV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleVelocoreV2(oldAmount, newAmount);\\n    }\\n\\n    function newKokonut(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleKokonut(oldAmount, newAmount);\\n    }\\n\\n    function newBalancerV1(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleBalancerV1(oldAmount, newAmount);\\n    }\\n\\n    function newArbswapStable(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        return data.scaleArbswapStable(oldAmount, newAmount);\\n    }\\n\\n    function newBancorV2(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleBancorV2(oldAmount, newAmount);\\n    }\\n\\n    function newAmbient(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        return data.scaleAmbient(oldAmount, newAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/oneinch/I1inchAggregationRouterV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ninterface I1inchAggregationRouterV5 {\\n    struct SwapDescription {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address payable srcReceiver;\\n        address payable dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n    }\\n\\n    function uniswapV3SwapTo(\\n        address payable recipient,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] calldata pools\\n    ) external payable returns (uint256 returnAmount);\\n\\n    function swap(\\n        address executor,\\n        SwapDescription calldata desc,\\n        bytes calldata permit,\\n        bytes calldata data\\n    ) external payable returns (uint256 returnAmount, uint256 spentAmount);\\n\\n    function unoswapTo(\\n        address payable recipient,\\n        address srcToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] calldata pools\\n    ) external payable returns (uint256 returnAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/oneinch/OneInchAggregationRouterHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./I1inchAggregationRouterV5.sol\\\";\\nimport \\\"../../../core/libraries/Errors.sol\\\";\\n\\nabstract contract OneInchAggregationRouterHelper {\\n    function _rescaleMinAmount(\\n        uint256 minAmount,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (uint256) {\\n        return (minAmount * newAmount) / oldAmount;\\n    }\\n\\n    function _get1inchScaledInputData(\\n        bytes calldata rawCallData,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        bytes4 selector = bytes4(rawCallData[:4]);\\n        bytes memory args = rawCallData[4:];\\n\\n        if (selector == I1inchAggregationRouterV5.uniswapV3SwapTo.selector) {\\n            (address payable recipient, uint256 amount, uint256 minReturn, uint256[] memory pools) = abi.decode(\\n                args,\\n                (address, uint256, uint256, uint256[])\\n            );\\n\\n            amount = newAmount;\\n            return abi.encodeWithSelector(selector, recipient, amount, minReturn, pools);\\n        }\\n\\n        if (selector == I1inchAggregationRouterV5.swap.selector) {\\n            (\\n                address executor,\\n                I1inchAggregationRouterV5.SwapDescription memory desc,\\n                bytes memory permit,\\n                bytes memory data\\n            ) = abi.decode(args, (address, I1inchAggregationRouterV5.SwapDescription, bytes, bytes));\\n\\n            desc.amount = newAmount;\\n            return abi.encodeWithSelector(selector, executor, desc, permit, data);\\n        }\\n\\n        if (selector == I1inchAggregationRouterV5.unoswapTo.selector) {\\n            (\\n                address payable recipient,\\n                address srcToken,\\n                uint256 amount,\\n                uint256 minReturn,\\n                uint256[] memory pools\\n            ) = abi.decode(args, (address, address, uint256, uint256, uint256[]));\\n\\n            amount = newAmount;\\n            return abi.encodeWithSelector(selector, recipient, srcToken, amount, minReturn, pools);\\n        }\\n\\n        revert Errors.UnsupportedSelector(2, selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/PendleSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport \\\"../../core/libraries/TokenHelper.sol\\\";\\nimport \\\"./IPSwapAggregator.sol\\\";\\nimport \\\"./kyberswap/l1-contracts/InputScalingHelper.sol\\\";\\nimport \\\"./kyberswap/l2-contracts/InputScalingHelperL2.sol\\\";\\nimport \\\"./oneinch/OneInchAggregationRouterHelper.sol\\\";\\n\\nabstract contract PendleSwapBase is IPSwapAggregator, TokenHelper, OneInchAggregationRouterHelper {\\n    using Address for address;\\n\\n    function swap(address tokenIn, uint256 amountIn, SwapData calldata data) external payable {\\n        _safeApproveInf(tokenIn, data.extRouter);\\n        data.extRouter.functionCallWithValue(\\n            data.needScale ? _getScaledInputData(data.swapType, data.extCalldata, amountIn) : data.extCalldata,\\n            tokenIn == NATIVE ? amountIn : 0\\n        );\\n    }\\n\\n    function _getScaledInputData(\\n        SwapType swapType,\\n        bytes calldata rawCallData,\\n        uint256 amountIn\\n    ) internal pure returns (bytes memory scaledCallData) {\\n        if (swapType == SwapType.KYBERSWAP) {\\n            scaledCallData = _getKyberScaledInputData(rawCallData, amountIn);\\n        } else if (swapType == SwapType.ONE_INCH) {\\n            scaledCallData = _get1inchScaledInputData(rawCallData, amountIn);\\n        } else {\\n            assert(false);\\n        }\\n    }\\n\\n    function _getKyberScaledInputData(\\n        bytes calldata rawCallData,\\n        uint256 amountIn\\n    ) internal pure virtual returns (bytes memory scaledCallData);\\n\\n    receive() external payable {}\\n}\\n\\ncontract PendleSwapL1 is PendleSwapBase {\\n    function _getKyberScaledInputData(\\n        bytes calldata rawCallData,\\n        uint256 amountIn\\n    ) internal pure override returns (bytes memory) {\\n        return InputScalingHelper._getScaledInputData(rawCallData, amountIn);\\n    }\\n}\\n\\ncontract PendleSwapL2 is PendleSwapBase {\\n    function _getKyberScaledInputData(\\n        bytes calldata rawCallData,\\n        uint256 amountIn\\n    ) internal pure override returns (bytes memory) {\\n        return InputScalingHelperL2._getScaledInputData(rawCallData, amountIn);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aggregatorType\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedSelector\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"extRouter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extCalldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"needScale\",\"type\":\"bool\"}],\"internalType\":\"struct SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PendleSwapL1", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}