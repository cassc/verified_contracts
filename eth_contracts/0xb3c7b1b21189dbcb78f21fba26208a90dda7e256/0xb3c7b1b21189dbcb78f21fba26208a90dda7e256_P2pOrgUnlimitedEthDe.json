{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/p2pEth2Depositor/P2pOrgUnlimitedEthDepositor.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"../@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"./interfaces/IDepositContract.sol\\\";\\nimport \\\"../lib/P2pAddressLib.sol\\\";\\nimport \\\"./P2pOrgUnlimitedEthDepositorErrors.sol\\\";\\nimport \\\"../constants/P2pConstants.sol\\\";\\nimport \\\"./IP2pOrgUnlimitedEthDepositor.sol\\\";\\nimport \\\"../feeDistributorFactory/IFeeDistributorFactory.sol\\\";\\nimport \\\"../structs/P2pStructs.sol\\\";\\n\\n/// @title Single entrypoint contract for P2P Validator ETH staking deposits\\n/// @dev All client sent ETH is temporarily held in this contract until P2P picks it up\\n/// to further forward to the Beacon (aka ETH2) DepositContract.\\n/// There are no other ways for any ETH to go from this contract other than to:\\n/// 1) Beacon DepositContract with client defined withdrawal credentials\\n/// 2) Client defined withdrawal credentials address itself\\ncontract P2pOrgUnlimitedEthDepositor is ERC165, IP2pOrgUnlimitedEthDepositor {\\n\\n    /// @notice Beacon DepositContract address\\n    IDepositContract public immutable i_depositContract;\\n\\n    /// @notice FeeDistributorFactory address\\n    IFeeDistributorFactory public immutable i_feeDistributorFactory;\\n\\n    /// @notice client FeeDistributor instance -> (amount, expiration)\\n    mapping(address => ClientDeposit) private s_deposits;\\n\\n    /// @dev Set values known at the initial deploy time.\\n    /// @param _feeDistributorFactory address of FeeDistributorFactory\\n    constructor(address _feeDistributorFactory) {\\n        if (!ERC165Checker.supportsInterface(_feeDistributorFactory, type(IFeeDistributorFactory).interfaceId)) {\\n            revert P2pOrgUnlimitedEthDepositor__NotFactory(_feeDistributorFactory);\\n        }\\n\\n        i_feeDistributorFactory = IFeeDistributorFactory(_feeDistributorFactory);\\n\\n        i_depositContract = block.chainid == 1\\n            ? IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa) // real Mainnet DepositContract\\n            : IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b); // real Goerli DepositContract\\n    }\\n\\n    /// @notice ETH should only be sent to this contract along with the `addEth` function\\n    receive() external payable {\\n        revert P2pOrgUnlimitedEthDepositor__DoNotSendEthDirectlyHere();\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function addEth(\\n        address _referenceFeeDistributor,\\n        FeeRecipient calldata _clientConfig,\\n        FeeRecipient calldata _referrerConfig\\n    ) external payable returns(address feeDistributorInstance) {\\n        if (msg.value < MIN_DEPOSIT) {\\n            revert P2pOrgUnlimitedEthDepositor__NoSmallDeposits();\\n        }\\n\\n        if (!ERC165Checker.supportsInterface(_referenceFeeDistributor, type(IFeeDistributor).interfaceId)) {\\n            revert P2pOrgUnlimitedEthDepositor__NotFeeDistributor(_referenceFeeDistributor);\\n        }\\n\\n        feeDistributorInstance = i_feeDistributorFactory.predictFeeDistributorAddress(\\n            _referenceFeeDistributor,\\n            _clientConfig,\\n            _referrerConfig\\n        );\\n\\n        if (s_deposits[feeDistributorInstance].status == ClientDepositStatus.ServiceRejected) {\\n            revert P2pOrgUnlimitedEthDepositor__ShouldNotBeRejected(feeDistributorInstance);\\n        }\\n\\n        if (feeDistributorInstance.code.length == 0) {\\n            // if feeDistributorInstance doesn't exist, deploy it\\n\\n            i_feeDistributorFactory.createFeeDistributor(\\n                _referenceFeeDistributor,\\n                _clientConfig,\\n                _referrerConfig\\n            );\\n        }\\n\\n        // amount = previous amount of feeDistributorInstance + new deposit\\n        uint112 amount = uint112(s_deposits[feeDistributorInstance].amount + msg.value);\\n\\n        // reset expiration starting from the current block.timestamp\\n        uint40 expiration = uint40(block.timestamp + TIMEOUT);\\n\\n        s_deposits[feeDistributorInstance] = ClientDeposit({\\n            amount: amount,\\n            expiration: expiration,\\n            status: ClientDepositStatus.EthAdded,\\n            reservedForFutureUse: 0\\n        });\\n\\n        emit P2pOrgUnlimitedEthDepositor__ClientEthAdded(\\n            msg.sender,\\n            feeDistributorInstance,\\n            amount,\\n            expiration\\n        );\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function rejectService(\\n        address _feeDistributorInstance,\\n        string calldata _reason\\n    ) external {\\n        i_feeDistributorFactory.checkOperatorOrOwner(msg.sender);\\n\\n        if (s_deposits[_feeDistributorInstance].status == ClientDepositStatus.None) {\\n            revert P2pOrgUnlimitedEthDepositor__NoDepositToReject(_feeDistributorInstance);\\n        }\\n\\n        s_deposits[_feeDistributorInstance].status = ClientDepositStatus.ServiceRejected;\\n        s_deposits[_feeDistributorInstance].expiration = 0; // allow the client to get a refund immediately\\n\\n        emit P2pOrgUnlimitedEthDepositor__ServiceRejected(_feeDistributorInstance, _reason);\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function refund(\\n        address _feeDistributorInstance\\n    ) public {\\n        address client = IFeeDistributor(_feeDistributorInstance).client();\\n        if (msg.sender != client) {\\n            revert P2pOrgUnlimitedEthDepositor__CallerNotClient(msg.sender, client);\\n        }\\n\\n        uint40 expiration = s_deposits[_feeDistributorInstance].expiration;\\n        if (uint40(block.timestamp) < expiration) {\\n            revert P2pOrgUnlimitedEthDepositor__WaitForExpiration(expiration, uint40(block.timestamp));\\n        }\\n\\n        uint256 amount = s_deposits[_feeDistributorInstance].amount;\\n        if (amount == 0) {\\n            revert P2pOrgUnlimitedEthDepositor__InsufficientBalance(_feeDistributorInstance);\\n        }\\n\\n        delete s_deposits[_feeDistributorInstance];\\n\\n        bool success = P2pAddressLib._sendValue(payable(client), amount);\\n        if (!success) {\\n            revert P2pOrgUnlimitedEthDepositor__FailedToSendEth(client, amount);\\n        }\\n\\n        emit P2pOrgUnlimitedEthDepositor__Refund(_feeDistributorInstance, client, amount);\\n    }\\n\\n    /// @notice Cheaper, requires calling feeDistributorFactory's allClientFeeDistributors externally first\\n    /// Only callable by client\\n    /// @param _allClientFeeDistributors array of all client FeeDistributor instances whose associated ETH amounts should be refunded\\n    function refundAll(address[] calldata _allClientFeeDistributors) external {\\n        for (uint256 i = 0; i < _allClientFeeDistributors.length;) {\\n            refund(_allClientFeeDistributors[i]);\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function makeBeaconDeposit(\\n        address _feeDistributorInstance,\\n        bytes[] calldata _pubkeys,\\n        bytes[] calldata _signatures,\\n        bytes32[] calldata _depositDataRoots\\n    ) external {\\n        i_feeDistributorFactory.checkOperatorOrOwner(msg.sender);\\n\\n        if (s_deposits[_feeDistributorInstance].status == ClientDepositStatus.ServiceRejected) {\\n            revert P2pOrgUnlimitedEthDepositor__ShouldNotBeRejected(_feeDistributorInstance);\\n        }\\n\\n        uint256 validatorCount = _pubkeys.length;\\n        uint112 amountToStake = uint112(COLLATERAL * validatorCount);\\n\\n        if (validatorCount == 0 || validatorCount > VALIDATORS_MAX_AMOUNT) {\\n            revert P2pOrgUnlimitedEthDepositor__ValidatorCountError();\\n        }\\n\\n        if (s_deposits[_feeDistributorInstance].amount < amountToStake) {\\n            revert P2pOrgUnlimitedEthDepositor__EtherValueError();\\n        }\\n\\n        if (!(\\n            _signatures.length == validatorCount &&\\n            _depositDataRoots.length == validatorCount\\n        )) {\\n            revert P2pOrgUnlimitedEthDepositor__AmountOfParametersError();\\n        }\\n\\n        uint112 newAmount = s_deposits[_feeDistributorInstance].amount - amountToStake;\\n        s_deposits[_feeDistributorInstance].amount = newAmount;\\n        if (newAmount == 0) { // all ETH has been deposited to Beacon DepositContract\\n            delete s_deposits[_feeDistributorInstance];\\n            emit P2pOrgUnlimitedEthDepositor__Eth2DepositCompleted(_feeDistributorInstance);\\n        } else {\\n            s_deposits[_feeDistributorInstance].status = ClientDepositStatus.BeaconDepositInProgress;\\n            emit P2pOrgUnlimitedEthDepositor__Eth2DepositInProgress(_feeDistributorInstance);\\n        }\\n\\n        bytes memory withdrawalCredentials = abi.encodePacked(\\n            hex'010000000000000000000000',\\n            IFeeDistributor(_feeDistributorInstance).eth2WithdrawalCredentialsAddress()\\n        );\\n\\n        for (uint256 i = 0; i < validatorCount;) {\\n            // pubkey, withdrawal_credentials, signature lengths are already checked inside Beacon DepositContract\\n\\n            i_depositContract.deposit{value : COLLATERAL}(\\n                _pubkeys[i],\\n                withdrawalCredentials,\\n                _signatures[i],\\n                _depositDataRoots[i]\\n            );\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        IFeeDistributor(_feeDistributorInstance).increaseDepositedCount(uint32(validatorCount));\\n\\n        emit P2pOrgUnlimitedEthDepositor__Eth2Deposit(_feeDistributorInstance, validatorCount);\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function totalBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function depositAmount(address _feeDistributorInstance) external view returns (uint112) {\\n        return s_deposits[_feeDistributorInstance].amount;\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function depositExpiration(address _feeDistributorInstance) external view returns (uint40) {\\n        return s_deposits[_feeDistributorInstance].expiration;\\n    }\\n\\n    /// @inheritdoc IP2pOrgUnlimitedEthDepositor\\n    function depositStatus(address _feeDistributorInstance) external view returns (ClientDepositStatus) {\\n        return s_deposits[_feeDistributorInstance].status;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IP2pOrgUnlimitedEthDepositor).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pEth2Depositor/interfaces/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity 0.8.10;\\n\\n// This interface is designed to be compatible with the Vyper version.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/P2pAddressLib.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nlibrary P2pAddressLib {\\n    /// @notice Sends amount of ETH in wei to recipient\\n    /// @param _recipient address of recipient\\n    /// @param _amount amount of ETH in wei\\n    /// @return bool whether send succeeded\\n    function _sendValue(address payable _recipient, uint256 _amount) internal returns (bool) {\\n        (bool success, ) = _recipient.call{\\n            value: _amount,\\n            gas: gasleft() / 4 // to prevent DOS, should be enough in normal cases\\n        }(\\\"\\\");\\n\\n        return success;\\n    }\\n\\n    /// @notice Sends amount of ETH in wei to recipient\\n    /// @param _recipient address of recipient\\n    /// @param _amount amount of ETH in wei\\n    /// @return bool whether send succeeded\\n    function _sendValueWithoutGasRestrictions(address payable _recipient, uint256 _amount) internal returns (bool) {\\n        (bool success, ) = _recipient.call{\\n            value: _amount\\n        }(\\\"\\\");\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pEth2Depositor/P2pOrgUnlimitedEthDepositorErrors.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Could not send ETH. Most likely, the receiver is a contract rejecting ETH.\\n/// @param _receiver receiver address\\n/// @param _amount amount of ETH is wei\\nerror P2pOrgUnlimitedEthDepositor__FailedToSendEth(address _receiver, uint256 _amount);\\n\\n/// @notice Deposits must be at least 1 ETH.\\nerror P2pOrgUnlimitedEthDepositor__NoSmallDeposits();\\n\\n/// @notice Only client can call refund\\n/// @param _caller address calling refund\\n/// @param _client actual client address who should be calling\\nerror P2pOrgUnlimitedEthDepositor__CallerNotClient(address _caller, address _client);\\n\\n/// @notice There is no ETH associated with the provided FeeDistributor instance address\\n/// @param _feeDistributorInstance FeeDistributor instance address\\nerror P2pOrgUnlimitedEthDepositor__InsufficientBalance(address _feeDistributorInstance);\\n\\n/// @notice Should wait for block timestamp to become greater than expiration to ask for a refund\\n/// @param _expiration block timestamp after which the client will be able to get a refund\\n/// @param _now block timestamp at the time of the actual call\\nerror P2pOrgUnlimitedEthDepositor__WaitForExpiration(uint40 _expiration, uint40 _now);\\n\\n/// @notice you can deposit only 1 to 400 validators per transaction\\nerror P2pOrgUnlimitedEthDepositor__ValidatorCountError();\\n\\n/// @notice the amount of ETH does not match the amount of validators\\nerror P2pOrgUnlimitedEthDepositor__EtherValueError();\\n\\n/// @notice amount of parameters do no match\\nerror P2pOrgUnlimitedEthDepositor__AmountOfParametersError();\\n\\n/// @notice do not send ETH directly here\\nerror P2pOrgUnlimitedEthDepositor__DoNotSendEthDirectlyHere();\\n\\n/// @notice Most likely, the client is a contract rejecting ETH.\\n/// @param _client client address\\nerror P2pOrgUnlimitedEthDepositor__ClientNotAcceptingEth(address _client);\\n\\n/// @notice _referenceFeeDistributor should implement IFeeDistributor interface\\n/// @param _passedAddress passed address for _referenceFeeDistributor\\nerror P2pOrgUnlimitedEthDepositor__NotFeeDistributor(address _passedAddress);\\n\\n/// @notice Should be a FeeDistributorFactory contract\\n/// @param _passedAddress passed address that does not support IFeeDistributorFactory interface\\nerror P2pOrgUnlimitedEthDepositor__NotFactory(address _passedAddress);\\n\\n/// @notice There is no active deposit for the given FeeDistributor instance\\n/// @param _feeDistributorInstance FeeDistributor instance address\\nerror P2pOrgUnlimitedEthDepositor__NoDepositToReject(address _feeDistributorInstance);\\n\\n/// @notice Cannot proceed because a deposit for this FeeDistributor instance has already been rejected\\n/// @param _feeDistributorInstance FeeDistributor instance address\\nerror P2pOrgUnlimitedEthDepositor__ShouldNotBeRejected(address _feeDistributorInstance);\\n\"\r\n    },\r\n    \"contracts/constants/P2pConstants.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @dev Maximal number of ETH2 deposits within a single transaction\\n/// @dev 400 deposits (12800 ETH) is determined by calldata size limit of 128 kb\\n/// https://ethereum.stackexchange.com/questions/144120/maximum-calldata-size-per-block\\nuint256 constant VALIDATORS_MAX_AMOUNT = 400;\\n\\n/// @dev Collateral size of 1 validator\\nuint256 constant COLLATERAL = 32 ether;\\n\\n/// @dev Minimal 1 time deposit\\nuint256 constant MIN_DEPOSIT = 1 ether;\\n\\n/// @dev Lockup time to allow P2P to make ETH2 deposits\\n/// @dev If there is leftover ETH after this time, it can be refunded\\nuint40 constant TIMEOUT = 1 days;\\n\\n/// @dev Cooldown period for the client to restore their ETH receiving ability to receive their collaterals\\nuint256 constant COOLDOWN = 30 days;\\n\"\r\n    },\r\n    \"contracts/p2pEth2Depositor/IP2pOrgUnlimitedEthDepositor.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"../feeDistributor/IFeeDistributor.sol\\\";\\nimport \\\"../structs/P2pStructs.sol\\\";\\n\\n/// @dev External interface of P2pOrgUnlimitedEthDepositor declared to support ERC165 detection.\\ninterface IP2pOrgUnlimitedEthDepositor is IERC165 {\\n\\n    /// @notice Emits when a client adds ETH for staking\\n    /// @param _sender address who sent ETH\\n    /// @param _feeDistributorInstance address of FeeDistributor instance that determines the terms of staking service\\n    /// @param _amount sent amount of ETH in wei\\n    /// @param _expiration block timestamp after which the client will be able to get a refund\\n    event P2pOrgUnlimitedEthDepositor__ClientEthAdded(\\n        address indexed _sender,\\n        address indexed _feeDistributorInstance,\\n        uint256 _amount,\\n        uint40 _expiration\\n    );\\n\\n    /// @notice Emits when a refund has been sent to the client\\n    /// @param _feeDistributorInstance address of FeeDistributor instance that was associated with the client deposit\\n    /// @param _client address who received the refunded ETH\\n    /// @param _amount refunded amount of ETH in wei\\n    event P2pOrgUnlimitedEthDepositor__Refund(\\n        address indexed _feeDistributorInstance,\\n        address indexed _client,\\n        uint256 _amount\\n    );\\n\\n    /// @notice Emits when P2P has made ETH2 deposits with client funds and withdrawal credentials\\n    /// @param _feeDistributorAddress address of FeeDistributor instance that was associated with the client deposit\\n    /// @param _validatorCount number of validators that has been created\\n    event P2pOrgUnlimitedEthDepositor__Eth2Deposit(\\n        address indexed _feeDistributorAddress,\\n        uint256 _validatorCount\\n    );\\n\\n    /// @notice Emits when all the available ETH has been forwarded to Beacon DepositContract\\n    /// @param _feeDistributorAddress address of FeeDistributor instance that was associated with the client deposit\\n    event P2pOrgUnlimitedEthDepositor__Eth2DepositCompleted(\\n        address indexed _feeDistributorAddress\\n    );\\n\\n    /// @notice Emits when some (but not all) of the available ETH has been forwarded to Beacon DepositContract\\n    /// @param _feeDistributorAddress address of FeeDistributor instance that was associated with the client deposit\\n    event P2pOrgUnlimitedEthDepositor__Eth2DepositInProgress(\\n        address indexed _feeDistributorAddress\\n    );\\n\\n    /// @notice Emits when P2P rejects the service for a given FeeDistributor client instance.\\n    /// The client can get a full refund immediately in this case.\\n    /// @param _feeDistributorAddress address of FeeDistributor instance that was associated with the client deposit\\n    /// @param _reason optional reason why P2P decided not to provide service\\n    event P2pOrgUnlimitedEthDepositor__ServiceRejected(\\n        address indexed _feeDistributorAddress,\\n        string _reason\\n    );\\n\\n    /// @notice Send unlimited amount of ETH along with the fixed terms of staking service\\n    /// Callable by clients\\n    /// @param _referenceFeeDistributor address of FeeDistributor template that determines the terms of staking service\\n    /// @param _clientConfig address and basis points (percent * 100) of the client\\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer.\\n    /// @return feeDistributorInstance client FeeDistributor instance corresponding to the passed template\\n    function addEth(\\n        address _referenceFeeDistributor,\\n        FeeRecipient calldata _clientConfig,\\n        FeeRecipient calldata _referrerConfig\\n    ) external payable returns(address feeDistributorInstance);\\n\\n    /// @notice Reject the service for a given FeeDistributor client instance.\\n    /// @dev Allows the client to avoid waiting for expiration to get a refund.\\n    /// @dev Can be helpful if the client made a mistake while adding ETH.\\n    /// @dev Callable by P2P\\n    /// @param _feeDistributorInstance client FeeDistributor instance corresponding to the passed template\\n    /// @param _reason optional reason why P2P decided not to provide service\\n    function rejectService(\\n        address _feeDistributorInstance,\\n        string calldata _reason\\n    ) external;\\n\\n    /// @notice refund the unused for staking ETH after the expiration timestamp.\\n    /// If not called, all multiples of 32 ETH will be used for staking eventually.\\n    /// @param _feeDistributorInstance client FeeDistributor instance that has non-zero ETH amount (can be checked by `depositAmount`)\\n    function refund(address _feeDistributorInstance) external;\\n\\n    /// @notice Send ETH to ETH2 DepositContract on behalf of the client. Callable by P2P\\n    /// @param _feeDistributorInstance user FeeDistributor instance that determines the terms of staking service\\n    /// @param _pubkeys BLS12-381 public keys\\n    /// @param _signatures BLS12-381 signatures\\n    /// @param _depositDataRoots SHA-256 hashes of the SSZ-encoded DepositData objects\\n    function makeBeaconDeposit(\\n        address _feeDistributorInstance,\\n        bytes[] calldata _pubkeys,\\n        bytes[] calldata _signatures,\\n        bytes32[] calldata _depositDataRoots\\n    ) external;\\n\\n    /// @notice Returns the total contract ETH balance in wei\\n    /// @return uint256 total contract ETH balance in wei\\n    function totalBalance() external view returns (uint256);\\n\\n    /// @notice Returns the amount of ETH in wei that is associated with a client FeeDistributor instance\\n    /// @param _feeDistributorInstance address of client FeeDistributor instance\\n    /// @return uint112 amount of ETH in wei\\n    function depositAmount(address _feeDistributorInstance) external view returns (uint112);\\n\\n    /// @notice Returns the block timestamp after which the client will be able to get a refund\\n    /// @param _feeDistributorInstance address of client FeeDistributor instance\\n    /// @return uint40 block timestamp\\n    function depositExpiration(address _feeDistributorInstance) external view returns (uint40);\\n\\n    /// @notice Returns the status of the deposit\\n    /// @param _feeDistributorInstance address of client FeeDistributor instance\\n    /// @return ClientDepositStatus status\\n    function depositStatus(address _feeDistributorInstance) external view returns (ClientDepositStatus);\\n}\\n\"\r\n    },\r\n    \"contracts/feeDistributorFactory/IFeeDistributorFactory.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"../access/IOwnable.sol\\\";\\nimport \\\"../feeDistributor/IFeeDistributor.sol\\\";\\nimport \\\"../structs/P2pStructs.sol\\\";\\n\\n/// @dev External interface of FeeDistributorFactory declared to support ERC165 detection.\\ninterface IFeeDistributorFactory is IOwnable, IERC165 {\\n\\n    /// @notice Emits when a new FeeDistributor instance has been created for a client\\n    /// @param _newFeeDistributorAddress address of the newly created FeeDistributor contract instance\\n    /// @param _clientAddress address of the client for whom the new instance was created\\n    /// @param _referenceFeeDistributor The address of the reference implementation of FeeDistributor used as the basis for clones\\n    /// @param _clientBasisPoints client basis points (percent * 100)\\n    event FeeDistributorFactory__FeeDistributorCreated(\\n        address indexed _newFeeDistributorAddress,\\n        address indexed _clientAddress,\\n        address indexed _referenceFeeDistributor,\\n        uint96 _clientBasisPoints\\n    );\\n\\n    /// @notice Emits when a new P2pEth2Depositor contract address has been set.\\n    /// @param _p2pEth2Depositor the address of the new P2pEth2Depositor contract\\n    event FeeDistributorFactory__P2pEth2DepositorSet(\\n        address indexed _p2pEth2Depositor\\n    );\\n\\n    /// @notice Emits when a new value of defaultClientBasisPoints has been set.\\n    /// @param _defaultClientBasisPoints new value of defaultClientBasisPoints\\n    event FeeDistributorFactory__DefaultClientBasisPointsSet(\\n        uint96 _defaultClientBasisPoints\\n    );\\n\\n    /// @notice Creates a FeeDistributor instance for a client\\n    /// @dev _referrerConfig can be zero if there is no referrer.\\n    ///\\n    /// @param _referenceFeeDistributor The address of the reference implementation of FeeDistributor used as the basis for clones\\n    /// @param _clientConfig address and basis points (percent * 100) of the client\\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer.\\n    /// @return newFeeDistributorAddress user FeeDistributor instance that has just been deployed\\n    function createFeeDistributor(\\n        address _referenceFeeDistributor,\\n        FeeRecipient calldata _clientConfig,\\n        FeeRecipient calldata _referrerConfig\\n    ) external returns (address newFeeDistributorAddress);\\n\\n    /// @notice Computes the address of a FeeDistributor created by `createFeeDistributor` function\\n    /// @dev FeeDistributor instances are guaranteed to have the same address if all of\\n    /// 1) referenceFeeDistributor 2) clientConfig 3) referrerConfig\\n    /// are the same\\n    /// @param _referenceFeeDistributor The address of the reference implementation of FeeDistributor used as the basis for clones\\n    /// @param _clientConfig address and basis points (percent * 100) of the client\\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer.\\n    /// @return address user FeeDistributor instance that will be or has been deployed\\n    function predictFeeDistributorAddress(\\n        address _referenceFeeDistributor,\\n        FeeRecipient calldata _clientConfig,\\n        FeeRecipient calldata _referrerConfig\\n    ) external view returns (address);\\n\\n    /// @notice Returns an array of client FeeDistributors\\n    /// @param _client client address\\n    /// @return address[] array of client FeeDistributors\\n    function allClientFeeDistributors(\\n        address _client\\n    ) external view returns (address[] memory);\\n\\n    /// @notice Returns an array of all FeeDistributors for all clients\\n    /// @return address[] array of all FeeDistributors\\n    function allFeeDistributors() external view returns (address[] memory);\\n\\n    /// @notice The address of P2pEth2Depositor\\n    /// @return address of P2pEth2Depositor\\n    function p2pEth2Depositor() external view returns (address);\\n\\n    /// @notice Returns default client basis points\\n    /// @return default client basis points\\n    function defaultClientBasisPoints() external view returns (uint96);\\n\\n    /// @notice Returns the current operator\\n    /// @return address of the current operator\\n    function operator() external view returns (address);\\n\\n    /// @notice Reverts if the passed address is neither operator nor owner\\n    /// @param _address passed address\\n    function checkOperatorOrOwner(address _address) external view;\\n\\n    /// @notice Reverts if the passed address is not P2pEth2Depositor\\n    /// @param _address passed address\\n    function checkP2pEth2Depositor(address _address) external view;\\n\\n    /// @notice Reverts if the passed address is neither of: 1) operator 2) owner 3) P2pEth2Depositor\\n    /// @param _address passed address\\n    function check_Operator_Owner_P2pEth2Depositor(address _address) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/structs/P2pStructs.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../feeDistributor/IFeeDistributor.sol\\\";\\n\\n/// @dev 256 bit struct\\n/// @member basisPoints basis points (percent * 100) of EL rewards that should go to the recipient\\n/// @member recipient address of the recipient\\nstruct FeeRecipient {\\n    uint96 basisPoints;\\n    address payable recipient;\\n}\\n\\n/// @dev 256 bit struct\\n/// @member depositedCount the number of deposited validators\\n/// @member exitedCount the number of validators requested to exit\\n/// @member collateralReturnedValue amount of ETH returned to the client to cover the collaterals\\n/// @member cooldownUntil timestamp after which it will be possible to withdraw ignoring the client's revert on ETH receive\\nstruct ValidatorData {\\n    uint32 depositedCount;\\n    uint32 exitedCount;\\n    uint112 collateralReturnedValue;\\n    uint80 cooldownUntil;\\n}\\n\\n/// @dev status of the client deposit\\n/// @member None default status indicating that no ETH is waiting to be forwarded to Beacon DepositContract\\n/// @member EthAdded client added ETH\\n/// @member BeaconDepositInProgress P2P has forwarded some (but not all) ETH to Beacon DepositContract\\n/// If all ETH has been forwarded, the status will be None.\\n/// @member ServiceRejected P2P has rejected the service for a given FeeDistributor instance\\n// The client can get a refund immediately.\\nenum ClientDepositStatus {\\n    None,\\n    EthAdded,\\n    BeaconDepositInProgress,\\n    ServiceRejected\\n}\\n\\n/// @dev 256 bit struct\\n/// @member amount amount of ETH in wei to be used for an ETH2 deposit corresponding to a particular FeeDistributor instance\\n/// @member expiration block timestamp after which the client will be able to get a refund\\n/// @member status deposit status\\n/// @member reservedForFutureUse unused space making up to 256 bit\\nstruct ClientDeposit {\\n    uint112 amount;\\n    uint40 expiration;\\n    ClientDepositStatus status;\\n    uint96 reservedForFutureUse;\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/feeDistributor/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"../structs/P2pStructs.sol\\\";\\n\\n/// @dev External interface of FeeDistributor declared to support ERC165 detection.\\ninterface IFeeDistributor is IERC165 {\\n\\n    /// @notice Emits once the client and the optional referrer have been set.\\n    /// @param _client address of the client.\\n    /// @param _clientBasisPoints basis points (percent * 100) of EL rewards that should go to the client\\n    /// @param _referrer address of the referrer.\\n    /// @param _referrerBasisPoints basis points (percent * 100) of EL rewards that should go to the referrer\\n    event FeeDistributor__Initialized(\\n        address indexed _client,\\n        uint96 _clientBasisPoints,\\n        address indexed _referrer,\\n        uint96 _referrerBasisPoints\\n    );\\n\\n    /// @notice Emits on successful withdrawal\\n    /// @param _serviceAmount how much wei service received\\n    /// @param _clientAmount how much wei client received\\n    /// @param _referrerAmount how much wei referrer received\\n    event FeeDistributor__Withdrawn(\\n        uint256 _serviceAmount,\\n        uint256 _clientAmount,\\n        uint256 _referrerAmount\\n    );\\n\\n    /// @notice Emits on request for a voluntary exit of validators\\n    /// @param _pubkeys pubkeys of validators\\n    event FeeDistributor__VoluntaryExit(\\n        bytes[] _pubkeys\\n    );\\n\\n    /// @notice Emits if case there was some ether left after `withdraw` and it has been sent successfully.\\n    /// @param _to destination address for ether.\\n    /// @param _amount how much wei the destination address received.\\n    event FeeDistributor__EtherRecovered(\\n        address indexed _to,\\n        uint256 _amount\\n    );\\n\\n    /// @notice Set client address.\\n    /// @dev Could not be in the constructor since it is different for different clients.\\n    /// _referrerConfig can be zero if there is no referrer.\\n    /// @param _clientConfig address and basis points (percent * 100) of the client\\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer.\\n    function initialize(\\n        FeeRecipient calldata _clientConfig,\\n        FeeRecipient calldata _referrerConfig\\n    ) external;\\n\\n    /// @notice Increase the number of deposited validators.\\n    /// @dev Should be called when a new ETH2 deposit has been made\\n    /// @param _validatorCountToAdd number of newly deposited validators\\n    function increaseDepositedCount(\\n        uint32 _validatorCountToAdd\\n    ) external;\\n\\n    /// @notice Request a voluntary exit of validators\\n    /// @dev Should be called by the client when they want to signal P2P that certain validators need to be exited\\n    /// @param _pubkeys pubkeys of validators\\n    function voluntaryExit(\\n        bytes[] calldata _pubkeys\\n    ) external;\\n\\n    /// @notice Returns the factory address\\n    /// @return address factory address\\n    function factory() external view returns (address);\\n\\n    /// @notice Returns the service address\\n    /// @return address service address\\n    function service() external view returns (address);\\n\\n    /// @notice Returns the client address\\n    /// @return address client address\\n    function client() external view returns (address);\\n\\n    /// @notice Returns the client basis points\\n    /// @return uint256 client basis points\\n    function clientBasisPoints() external view returns (uint256);\\n\\n    /// @notice Returns the referrer address\\n    /// @return address referrer address\\n    function referrer() external view returns (address);\\n\\n    /// @notice Returns the referrer basis points\\n    /// @return uint256 referrer basis points\\n    function referrerBasisPoints() external view returns (uint256);\\n\\n    /// @notice Returns the address for ETH2 0x01 withdrawal credentials associated with this FeeDistributor\\n    /// @dev Return FeeDistributor's own address if FeeDistributor should be CL rewards recipient\\n    /// Otherwise, return the client address\\n    /// @return address address for ETH2 0x01 withdrawal credentials\\n    function eth2WithdrawalCredentialsAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/access/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev External interface of Ownable.\\n */\\ninterface IOwnable {\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"P2pOrgUnlimitedEthDepositor__AmountOfParametersError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__CallerNotClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"P2pOrgUnlimitedEthDepositor__DoNotSendEthDirectlyHere\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"P2pOrgUnlimitedEthDepositor__EtherValueError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__FailedToSendEth\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__NoDepositToReject\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"P2pOrgUnlimitedEthDepositor__NoSmallDeposits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_passedAddress\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__NotFactory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_passedAddress\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__NotFeeDistributor\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__ShouldNotBeRejected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"P2pOrgUnlimitedEthDepositor__ValidatorCountError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_expiration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_now\",\"type\":\"uint40\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__WaitForExpiration\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"_expiration\",\"type\":\"uint40\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__ClientEthAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_validatorCount\",\"type\":\"uint256\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__Eth2Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorAddress\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__Eth2DepositCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorAddress\",\"type\":\"address\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__Eth2DepositInProgress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeDistributorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"P2pOrgUnlimitedEthDepositor__ServiceRejected\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referenceFeeDistributor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"basisPoints\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct FeeRecipient\",\"name\":\"_clientConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"basisPoints\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct FeeRecipient\",\"name\":\"_referrerConfig\",\"type\":\"tuple\"}],\"name\":\"addEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeDistributorInstance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"depositAmount\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"depositExpiration\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"depositStatus\",\"outputs\":[{\"internalType\":\"enum ClientDepositStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"i_depositContract\",\"outputs\":[{\"internalType\":\"contract IDepositContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"i_feeDistributorFactory\",\"outputs\":[{\"internalType\":\"contract IFeeDistributorFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"_pubkeys\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_depositDataRoots\",\"type\":\"bytes32[]\"}],\"name\":\"makeBeaconDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_allClientFeeDistributors\",\"type\":\"address[]\"}],\"name\":\"refundAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorInstance\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"rejectService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "P2pOrgUnlimitedEthDepositor", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000086a9f3e908b4658a1327952eb1ec297a4212e1bb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}