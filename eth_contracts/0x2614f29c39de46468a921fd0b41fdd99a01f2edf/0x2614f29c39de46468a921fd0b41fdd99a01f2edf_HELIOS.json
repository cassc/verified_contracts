{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/BurnInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/constant.sol\\\";\\nimport \\\"../libs/enum.sol\\\";\\n\\n/**\\n * @title BurnInfo\\n * @dev this contract is meant to be inherited into main contract\\n * @notice It has the variables and functions specifically for tracking burn amount and reward\\n */\\n\\nabstract contract BurnInfo {\\n    //Variables\\n    //track the total helios burn amount\\n    uint256 private s_totalHlxBurned;\\n\\n    //mappings\\n    //track wallet address -> total helios burn amount\\n    mapping(address => uint256) private s_userBurnAmount;\\n    //track contract/project address -> total helios burn amount\\n    mapping(address => uint256) private s_project_BurnAmount;\\n    //track contract/project address, wallet address -> total helios burn amount\\n    mapping(address => mapping(address => uint256))\\n        private s_projectUser_BurnAmount;\\n\\n    //events\\n    /** @dev log user burn helios event\\n     * project can be address(0) if user burns helios directly from helios contract\\n     * burnPoolCycleIndex is the cycle 28 index, which reuse the same index as Day 28 cycle index\\n     * helioSource 0=Liquid, 1=Mint, 2=Stake\\n     */\\n    event HlxBurned(\\n        address indexed user,\\n        address indexed project,\\n        uint256 amount,\\n        BurnSource helioSource\\n    );\\n\\n    //functions\\n    /** @dev update the burn amount in each 28-cylce for user and project (if any)\\n     * @param user wallet address\\n     * @param project contract address\\n     * @param amount helios amount burned\\n     */\\n    function _updateBurnAmount(\\n        address user,\\n        address project,\\n        uint256 amount,\\n        BurnSource source\\n    ) internal {\\n        s_userBurnAmount[user] += amount;\\n        s_totalHlxBurned += amount;\\n\\n        if (project != address(0)) {\\n            s_project_BurnAmount[project] += amount;\\n            s_projectUser_BurnAmount[project][user] += amount;\\n        }\\n\\n        emit HlxBurned(user, project, amount, source);\\n    }\\n\\n    /** @dev returned value is in 18 decimals, need to divide it by 1e18 and 100 (percentage) when using this value for reward calculation\\n     * The burn amplifier percentage is applied to all future mints. Capped at MAX_BURN_AMP_PERCENT (8%)\\n     * @param user wallet address\\n     * @return percentage returns percentage value in 18 decimals\\n     */\\n    function getUserBurnAmplifierBonus(\\n        address user\\n    ) public view returns (uint256) {\\n        uint256 userBurnTotal = getUserBurnTotal(user);\\n        if (userBurnTotal == 0) return 0;\\n        if (userBurnTotal >= MAX_BURN_AMP_BASE) return MAX_BURN_AMP_PERCENT;\\n        return (MAX_BURN_AMP_PERCENT * userBurnTotal) / MAX_BURN_AMP_BASE;\\n    }\\n\\n    //views\\n    /** @notice return total burned helios amount from all users burn or projects burn\\n     * @return totalBurnAmount returns entire burned helios\\n     */\\n    function getTotalBurnTotal() public view returns (uint256) {\\n        return s_totalHlxBurned;\\n    }\\n\\n    /** @notice return user address total burned helios\\n     * @return userBurnAmount returns user address total burned helios\\n     */\\n    function getUserBurnTotal(address user) public view returns (uint256) {\\n        return s_userBurnAmount[user];\\n    }\\n\\n    /** @notice return project address total burned helios amount\\n     * @return projectTotalBurnAmount returns project total burned helios\\n     */\\n    function getProjectBurnTotal(\\n        address contractAddress\\n    ) public view returns (uint256) {\\n        return s_project_BurnAmount[contractAddress];\\n    }\\n\\n    /** @notice return user address total burned helios amount via a project address\\n     * @param contractAddress project address\\n     * @param user user address\\n     * @return projectUserTotalBurnAmount returns user address total burned helios via a project address\\n     */\\n    function getProjectUserBurnTotal(\\n        address contractAddress,\\n        address user\\n    ) public view returns (uint256) {\\n        return s_projectUser_BurnAmount[contractAddress][user];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GlobalInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/enum.sol\\\";\\nimport \\\"../libs/constant.sol\\\";\\n\\nabstract contract GlobalInfo {\\n    //Variables\\n    //deployed timestamp\\n    uint256 private immutable i_genesisTs;\\n\\n    /** @dev track current contract day */\\n    uint256 private s_currentContractDay;\\n    /** @dev shareRate starts 420 ether and increases capped at 1500 ether */\\n    uint256 private s_currentshareRate;\\n    /** @dev mintCost starts 420m ether increases and capped at 2B ether, uin256 has enough size */\\n    uint256 private s_currentMintCost;\\n    /** @dev mintableHlx starts 4.2m ether decreases and capped at 420 ether, uint96 has enough size */\\n    uint256 private s_currentMintableHlx;\\n    /** @dev mintPowerBonus starts 350_000_000 and decreases capped at 35_000 */\\n    uint256 private s_currentMintPowerBonus;\\n    /** @dev EAABonus starts 10_000_000 and decreases to 0 */\\n    uint256 private s_currentEAABonus;\\n\\n    /** @dev 7 day update for percentages */\\n    uint256 private s_nextSevenDayUpdate;\\n\\n    /** @dev Percentage Share to BuynBurn */\\n    uint256 private s_percentBuynBurn;\\n\\n    /** @dev Percentage to Treasury*/\\n    uint256 private s_percentTreasury;\\n\\n    /** @dev track if any of the cycle day 22, 69, 420 has payout triggered succesfully\\n     * this is used in end stake where either the shares change should be tracked in current/next payout cycle\\n     */\\n    PayoutTriggered private s_isGlobalPayoutTriggered;\\n\\n    /** @dev track payouts based on every cycle day 22, 69, 420 when distributeTitanX() is called */\\n    mapping(uint256 => uint256) private s_cyclePayouts;\\n\\n    /** @dev track payouts based on every cycle day 22, 69, 420 when distributeETH() is called */\\n    mapping(uint256 => uint256) private s_ethCyclePayouts;\\n\\n    /** @dev track payout index for each cycle day, increased by 1 when triggerPayouts() is called succesfully\\n     *  eg. curent index is 2, s_cyclePayoutIndex[DAY22] = 2 */\\n    mapping(uint256 => uint256) private s_cyclePayoutIndex;\\n\\n    /** @dev track payout info (day and payout per share) for each cycle day\\n     * eg. s_cyclePayoutIndex is 2,\\n     *  s_CyclePayoutPerShare[DAY22][2].day = 22\\n     * s_CyclePayoutPerShare[DAY22][2].payoutPerShare = 0.1\\n     */\\n    mapping(uint256 => mapping(uint256 => CycleRewardPerShare))\\n        private s_cyclePayoutPerShare;\\n\\n    /** @dev track payout info (day and payout per share) for each cycle day\\n     * eg. s_cyclePayoutIndex is 2,\\n     *  s_ETHCyclePayoutPerShare[DAY22][2].day = 7\\n     * s_ETHCyclePayoutPerShare[DAY22][2].payoutPerShare = 0.1\\n     */\\n    mapping(uint256 => mapping(uint256 => CycleRewardPerShare))\\n        private s_ethCyclePayoutPerShare;\\n\\n    /** @dev track user last payout reward claim index for cycleIndex and sharesIndex\\n     * so calculation would start from next index instead of the first index\\n     * [address][DAY22].cycleIndex = 1\\n     * [address][DAY22].sharesIndex = 2\\n     * cycleIndex is the last stop in s_cyclePayoutPerShare\\n     * sharesIndex is the last stop in s_addressIdToActiveShares\\n     */\\n    mapping(address => mapping(uint256 => UserCycleClaimIndex))\\n        private s_addressCycleToLastClaimIndex;\\n\\n    /** @dev track when is the next cycle payout day for each cycle day\\n     * eg. s_nextCyclePayoutDay[DAY22] = 22\\n     *     s_nextCyclePayoutDay[DAY69] = 69\\n     */\\n    mapping(uint256 => uint256) s_nextCyclePayoutDay;\\n\\n    //structs\\n    struct CycleRewardPerShare {\\n        uint256 day;\\n        uint256 payoutPerShare;\\n    }\\n\\n    struct UserCycleClaimIndex {\\n        uint256 cycleIndex;\\n        uint256 sharesIndex;\\n    }\\n\\n    //event\\n    event GlobalDailyUpdateStats(\\n        uint256 indexed day,\\n        uint256 indexed mintCost,\\n        uint256 mintableHlx,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus\\n    );\\n\\n    /** @dev Update variables in terms of day, modifier is used in all external/public functions (exclude view)\\n     * Every interaction to the contract would run this function to update variables\\n     */\\n    modifier dailyUpdate() {\\n        _dailyUpdate();\\n        _;\\n    }\\n\\n    constructor() {\\n        i_genesisTs = block.timestamp;\\n        s_currentContractDay = 1;\\n        s_currentMintCost = START_MAX_MINT_COST;\\n        s_currentMintableHlx = START_MAX_MINTABLE_PER_DAY;\\n        s_currentshareRate = START_SHARE_RATE;\\n        s_currentMintPowerBonus = START_MINTPOWER_INCREASE_BONUS;\\n        s_currentEAABonus = EAA_START;\\n        s_nextCyclePayoutDay[DAY22] = DAY22;\\n        s_nextCyclePayoutDay[DAY69] = DAY69;\\n        s_nextCyclePayoutDay[DAY420] = DAY420;\\n        s_nextSevenDayUpdate = 7;\\n        s_percentBuynBurn = 60_00;\\n        s_percentTreasury = 10_00;\\n    }\\n\\n    /** @dev calculate and update variables daily and reset triggers flag */\\n    function _dailyUpdate() private {\\n        uint256 currentContractDay = s_currentContractDay;\\n        uint256 currentBlockDay = ((block.timestamp - i_genesisTs) / 1 days) +\\n            1;\\n\\n        if (currentBlockDay > currentContractDay) {\\n            //get last day info ready for calculation\\n            uint256 newMintCost = s_currentMintCost;\\n            uint256 newMintableHlx = s_currentMintableHlx;\\n            uint256 newMintPowerBonus = s_currentMintPowerBonus;\\n            uint256 newEAABonus = s_currentEAABonus;\\n            uint256 dayDifference = currentBlockDay - currentContractDay;\\n\\n            /** Reason for a for loop to update Mint supply\\n             * Ideally, user interaction happens daily, so Mint supply is synced in every day\\n             *      (cylceDifference = 1)\\n             * However, if there's no interaction for more than 1 day, then\\n             *      Mint supply isn't updated correctly due to cylceDifference > 1 day\\n             * Eg. 2 days of no interaction, then interaction happens in 3rd day.\\n             *     It's incorrect to only decrease the Mint supply one time as now it's in 3rd day.\\n             *   And if this happens, there will be no tracked data for the skipped days as not needed\\n             */\\n\\n            for (uint256 i; i < dayDifference; i++) {\\n                newMintCost =\\n                    (newMintCost * DAILY_MINT_COST_INCREASE_STEP) /\\n                    PERCENT_BPS;\\n                newMintableHlx =\\n                    (newMintableHlx * DAILY_SUPPLY_MINTABLE_REDUCTION) /\\n                    PERCENT_BPS;\\n                newMintPowerBonus =\\n                    (newMintPowerBonus *\\n                        DAILY_MINTPOWER_INCREASE_BONUS_REDUCTION) /\\n                    PERCENT_BPS;\\n\\n                if (newMintCost > CAPPED_MAX_MINT_COST) {\\n                    newMintCost = CAPPED_MAX_MINT_COST;\\n                }\\n\\n                if (\\n                    currentContractDay >= s_nextSevenDayUpdate &&\\n                    s_percentBuynBurn != PERCENT_TO_BUY_AND_BURN_FINAL &&\\n                    s_percentTreasury != PERCENT_TO_TREASURY_FINAL\\n                ) {\\n                    s_percentBuynBurn -= PERCENT_CHANGE;\\n                    s_percentTreasury += PERCENT_CHANGE;\\n                    s_nextSevenDayUpdate += 7;\\n                }\\n\\n                if (newMintableHlx < CAPPED_MIN_DAILY_HLX_MINTABLE) {\\n                    newMintableHlx = CAPPED_MIN_DAILY_HLX_MINTABLE;\\n                }\\n\\n                if (newMintPowerBonus < CAPPED_MIN_MINTPOWER_BONUS) {\\n                    newMintPowerBonus = CAPPED_MIN_MINTPOWER_BONUS;\\n                }\\n\\n                if (currentBlockDay <= MAX_BONUS_DAY) {\\n                    newEAABonus -= EAA_BONUSE_FIXED_REDUCTION_PER_DAY;\\n                } else {\\n                    newEAABonus = EAA_END;\\n                }\\n\\n                emit GlobalDailyUpdateStats(\\n                    ++currentContractDay,\\n                    newMintCost,\\n                    newMintableHlx,\\n                    newMintPowerBonus,\\n                    newEAABonus\\n                );\\n            }\\n\\n            s_currentMintCost = newMintCost;\\n            s_currentMintableHlx = newMintableHlx;\\n            s_currentMintPowerBonus = newMintPowerBonus;\\n            s_currentEAABonus = newEAABonus;\\n            s_currentContractDay = currentBlockDay;\\n            s_isGlobalPayoutTriggered = PayoutTriggered.NO;\\n        }\\n    }\\n\\n    /** @dev first created shares will start from the last payout index + 1 (next cycle payout)\\n     * as first shares will always disqualified from past payouts\\n     * reduce gas cost needed to loop from first index\\n     * @param user user address\\n     * @param isFirstShares flag to only initialize when address is fresh wallet\\n     */\\n    function _initFirstSharesCycleIndex(\\n        address user,\\n        uint256 isFirstShares\\n    ) internal {\\n        if (isFirstShares == 1) {\\n            if (s_cyclePayoutIndex[DAY22] != 0) {\\n                s_addressCycleToLastClaimIndex[user][DAY22].cycleIndex =\\n                    s_cyclePayoutIndex[DAY22] +\\n                    1;\\n\\n                s_addressCycleToLastClaimIndex[user][DAY69].cycleIndex =\\n                    s_cyclePayoutIndex[DAY69] +\\n                    1;\\n                s_addressCycleToLastClaimIndex[user][DAY420]\\n                    .cycleIndex = uint96(s_cyclePayoutIndex[DAY420] + 1);\\n            }\\n        }\\n    }\\n\\n    /** @dev first created shares will start from the last payout index + 1 (next cycle payout)\\n     * as first shares will always disqualified from past payouts\\n     * reduce gas cost needed to loop from first index\\n     * @param cycleNo cylce day 22, 69, 420\\n     * @param reward total accumulated reward in cycle day 22, 69, 420\\n     * @param globalActiveShares global active shares\\n     * @return index return latest current cycleIndex\\n     */\\n    function _calculateCycleRewardPerShare(\\n        uint256 cycleNo,\\n        uint256 reward,\\n        uint256 ethReward,\\n        uint256 globalActiveShares\\n    ) internal returns (uint256 index) {\\n        s_cyclePayouts[cycleNo] = 0;\\n        s_ethCyclePayouts[cycleNo] = 0;\\n        index = ++s_cyclePayoutIndex[cycleNo];\\n        //add 18 decimals to reward for better precision in calculation\\n        s_cyclePayoutPerShare[cycleNo][index].payoutPerShare =\\n            (reward * SCALING_FACTOR_1e18) /\\n            globalActiveShares;\\n        s_cyclePayoutPerShare[cycleNo][index].day = getCurrentContractDay();\\n        s_ethCyclePayoutPerShare[cycleNo][index].payoutPerShare =\\n            (ethReward * SCALING_FACTOR_1e18) /\\n            globalActiveShares;\\n        s_ethCyclePayoutPerShare[cycleNo][index].day = getCurrentContractDay();\\n    }\\n\\n    /** @dev update with the last index where a user has claimed the payout reward\\n     * @param user user address\\n     * @param cycleNo cylce day 22, 69, 420\\n     * @param userClaimCycleIndex last claimed cycle index\\n     * @param userClaimSharesIndex last claimed shares index\\n     */\\n    function _updateUserClaimIndexes(\\n        address user,\\n        uint256 cycleNo,\\n        uint256 userClaimCycleIndex,\\n        uint256 userClaimSharesIndex\\n    ) internal {\\n        if (\\n            userClaimCycleIndex !=\\n            s_addressCycleToLastClaimIndex[user][cycleNo].cycleIndex\\n        )\\n            s_addressCycleToLastClaimIndex[user][cycleNo]\\n                .cycleIndex = userClaimCycleIndex;\\n\\n        if (\\n            userClaimSharesIndex !=\\n            s_addressCycleToLastClaimIndex[user][cycleNo].sharesIndex\\n        )\\n            s_addressCycleToLastClaimIndex[user][cycleNo]\\n                .sharesIndex = userClaimSharesIndex;\\n    }\\n\\n    /** @dev set to YES when any of the cycle days payout is triggered\\n     * reset to NO in new contract day\\n     */\\n    function _setGlobalPayoutTriggered() internal {\\n        s_isGlobalPayoutTriggered = PayoutTriggered.YES;\\n    }\\n\\n    /** @dev add reward into cycle day 22, 69, 420 pool\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @param reward reward from distributeETH()\\n     */\\n    function _setCyclePayoutPool(uint256 cycleNo, uint256 reward) internal {\\n        s_cyclePayouts[cycleNo] += reward;\\n    }\\n\\n    /** @dev add ETH reward into cycle day 22, 69, 420 pool\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @param ethReward reward\\n     */\\n    function _setETHCyclePayoutPool(\\n        uint256 cycleNo,\\n        uint256 ethReward\\n    ) internal {\\n        s_ethCyclePayouts[cycleNo] += ethReward;\\n    }\\n\\n    /** @dev calculate and update the next payout day for specified cycleNo\\n     * the formula will update the payout day based on current contract day\\n     * this is to make sure the value is correct when for some reason has skipped more than one cycle payout\\n     * @param cycleNo cycle day 22, 69, 420\\n     */\\n    function _setNextCyclePayoutDay(uint256 cycleNo) internal {\\n        uint256 maturityDay = s_nextCyclePayoutDay[cycleNo];\\n        uint256 currentContractDay = s_currentContractDay;\\n        if (currentContractDay >= maturityDay) {\\n            s_nextCyclePayoutDay[cycleNo] +=\\n                cycleNo *\\n                (((currentContractDay - maturityDay) / cycleNo) + 1);\\n        }\\n    }\\n\\n    //Public functions\\n    /** @notice allow anyone to sync dailyUpdate manually */\\n    function manualDailyUpdate() public dailyUpdate {}\\n\\n    /** Views */\\n    /** @notice Returns current block timestamp\\n     * @return currentBlockTs current block timestamp\\n     */\\n    function getCurrentBlockTimeStamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /** @notice Returns current contract day\\n     * @return currentContractDay current contract day\\n     */\\n    function getCurrentContractDay() public view returns (uint256) {\\n        return s_currentContractDay;\\n    }\\n\\n    /** @notice Returns current Treasury Percentage\\n     * @return percentTreasury current day\\n     */\\n    function getTreasuryPercentage() public view returns (uint256) {\\n        return s_percentTreasury;\\n    }\\n\\n    /** @notice Returns current BuynBurn Percentage\\n     * @return percentBuynBurn current  day\\n     */\\n    function getBuynBurnPercentage() public view returns (uint256) {\\n        return s_percentBuynBurn;\\n    }\\n\\n    /** @notice Returns current mint cost\\n     * @return currentMintCost current block timestamp\\n     */\\n    function getCurrentMintCost() public view returns (uint256) {\\n        return s_currentMintCost;\\n    }\\n\\n    /** @notice Returns current share rate\\n     * @return currentShareRate current share rate\\n     */\\n    function getCurrentShareRate() public view returns (uint256) {\\n        return s_currentshareRate;\\n    }\\n\\n    /** @notice Returns current mintable Helios\\n     * @return currentMintableHlx current mintable Helios\\n     */\\n    function getCurrentMintableHlx() public view returns (uint256) {\\n        return s_currentMintableHlx;\\n    }\\n\\n    /** @notice Returns current mint power bonus\\n     * @return currentMintPowerBonus current mint power bonus\\n     */\\n    function getCurrentMintPowerBonus() public view returns (uint256) {\\n        return s_currentMintPowerBonus;\\n    }\\n\\n    /** @notice Returns current contract EAA bonus\\n     * @return currentEAABonus current EAA bonus\\n     */\\n    function getCurrentEAABonus() public view returns (uint256) {\\n        return s_currentEAABonus;\\n    }\\n\\n    /** @notice Returns current cycle index for the specified cycle day\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @return currentCycleIndex current cycle index to track the payouts\\n     */\\n    function getCurrentCycleIndex(\\n        uint256 cycleNo\\n    ) public view returns (uint256) {\\n        return s_cyclePayoutIndex[cycleNo];\\n    }\\n\\n    /** @notice Returns whether payout is triggered successfully in any cylce day\\n     * @return isTriggered 0 or 1, 0= No, 1=Yes\\n     */\\n    function getGlobalPayoutTriggered() public view returns (PayoutTriggered) {\\n        return s_isGlobalPayoutTriggered;\\n    }\\n\\n    /** @notice Returns the distributed pool reward for the specified cycle day\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @return currentPayoutPool current accumulated payout pool\\n     */\\n    function getCyclePayoutPool(uint256 cycleNo) public view returns (uint256) {\\n        return s_cyclePayouts[cycleNo];\\n    }\\n\\n    /** @notice Returns the distributed ETH pool reward for the specified cycle day\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @return currentPayoutPool current accumulated payout pool\\n     */\\n    function getETHCyclePayoutPool(\\n        uint256 cycleNo\\n    ) public view returns (uint256) {\\n        return s_ethCyclePayouts[cycleNo];\\n    }\\n\\n    /** @notice Returns the calculated payout per share and contract day for the specified cycle day and index\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @param index cycle index\\n     * @return payoutPerShare calculated payout per share\\n     * @return triggeredDay the day when payout was triggered to perform calculation\\n     */\\n    function getPayoutPerShare(\\n        uint256 cycleNo,\\n        uint256 index\\n    ) public view returns (uint256, uint256) {\\n        return (\\n            s_cyclePayoutPerShare[cycleNo][index].payoutPerShare,\\n            s_cyclePayoutPerShare[cycleNo][index].day\\n        );\\n    }\\n\\n    /** @notice Returns the calculated ETH payout per share and contract day for the specified cycle day and index\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @param index cycle index\\n     * @return payoutPerShare calculated payout per share\\n     * @return triggeredDay the day when payout was triggered to perform calculation\\n     */\\n    function getETHPayoutPerShare(\\n        uint256 cycleNo,\\n        uint256 index\\n    ) public view returns (uint256, uint256) {\\n        return (\\n            s_ethCyclePayoutPerShare[cycleNo][index].payoutPerShare,\\n            s_ethCyclePayoutPerShare[cycleNo][index].day\\n        );\\n    }\\n\\n    /** @notice Returns user's last claimed shares payout indexes for the specified cycle day\\n     * @param user user address\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @return cycleIndex cycle index\\n     * @return sharesIndex shares index\\n     \\n     */\\n    function getUserLastClaimIndex(\\n        address user,\\n        uint256 cycleNo\\n    ) public view returns (uint256 cycleIndex, uint256 sharesIndex) {\\n        return (\\n            s_addressCycleToLastClaimIndex[user][cycleNo].cycleIndex,\\n            s_addressCycleToLastClaimIndex[user][cycleNo].sharesIndex\\n        );\\n    }\\n\\n    /** @notice Returns contract deployment block timestamp\\n     * @return genesisTs deployed timestamp\\n     */\\n    function genesisTs() public view returns (uint256) {\\n        return i_genesisTs;\\n    }\\n\\n    /** @notice Returns next payout day for the specified cycle day\\n     * @param cycleNo cycle day 22, 69, 420\\n     * @return nextPayoutDay next payout day\\n     */\\n    function getNextCyclePayoutDay(\\n        uint256 cycleNo\\n    ) public view returns (uint256) {\\n        return s_nextCyclePayoutDay[cycleNo];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Helios.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/IHlxOnBurn.sol\\\";\\nimport \\\"../interfaces/ITITANX.sol\\\";\\nimport \\\"../interfaces/ITitanOnBurn.sol\\\";\\nimport \\\"../interfaces/IBuynBurn.sol\\\";\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\nimport \\\"./GlobalInfo.sol\\\";\\nimport \\\"./MintInfo.sol\\\";\\nimport \\\"./StakeInfo.sol\\\";\\nimport \\\"./BurnInfo.sol\\\";\\nimport \\\"./OwnerInfo.sol\\\";\\n\\n//custom errors\\nerror Helios_InvalidAmount();\\nerror Helios_InsufficientBalance();\\nerror Helios_NotSupportedContract();\\nerror Helios_InsufficientProtocolFees();\\nerror Helios_FailedToSendAmount();\\nerror Helios_NotAllowed();\\nerror Helios_NoCycleRewardToClaim();\\nerror Helios_NoSharesExist();\\nerror Helios_EmptyUndistributeFees();\\nerror Helios_InvalidBurnRewardPercent();\\nerror Helios_MaxedWalletMints();\\nerror Helios_LPTokensHasMinted();\\nerror Helios_InvalidAddress();\\nerror Helios_InsufficientBurnAllowance();\\nerror Helios_OnlyBuyAndBurn();\\nerror Helios_OnlyWhiteListedProjects();\\n\\n/** @title Helios */\\ncontract HELIOS is\\n    ERC20,\\n    ReentrancyGuard,\\n    GlobalInfo,\\n    MintInfo,\\n    StakeInfo,\\n    BurnInfo,\\n    OwnerInfo,\\n    IERC165,\\n    ITitanOnBurn\\n{\\n    /** Storage Variables*/\\n    /** @dev stores genesis wallet address */\\n    address private s_genesisAddress;\\n\\n    /** @dev stores Investment address */\\n    address private s_investmentAddress;\\n\\n    /** @dev stores buy and burn contract address */\\n    address private s_buyAndBurnAddress;\\n\\n    /** @dev stores treasury contract address */\\n    address private s_treasuryAddress;\\n\\n    /** @dev stores TITANX contract address */\\n    address private s_titanxAddress;\\n\\n    /** @dev tracks collected protocol fees until it is distributed */\\n    uint256 private s_undistributedTitanX;\\n\\n    /** @dev tracks collected protocol fees until it is distributed */\\n    uint256 private s_undistributedETH;\\n\\n    /** @dev stores total Titanx burned by Users  */\\n    uint256 private s_totalTitanBurned;\\n\\n    // /** @dev tracks burn reward from distributeTitanX() until payout is triggered */\\n    // uint88 private s_cycleBurnReward;\\n\\n    /** @dev tracks if initial LP tokens has minted or not */\\n    InitialLPMinted private s_initialLPMinted;\\n\\n    // /** @dev trigger to turn on burn pool reward */\\n    // BurnPoolEnabled private s_burnPoolEnabled;\\n\\n    /** @dev tracks user + project burn mints allowance */\\n    mapping(address => mapping(address => uint256))\\n        private s_allowanceBurnMints;\\n\\n    /** @dev tracks projects whiteListed to stake on hlx */\\n    mapping(address => bool) private s_whiteList;\\n\\n    /** @dev tracks user + project burn stakes allowance */\\n    mapping(address => mapping(address => uint256))\\n        private s_allowanceBurnStakes;\\n\\n    struct MintParams {\\n        uint256 mintPower;\\n        uint256 numOfDays;\\n        uint256 titanToBurn;\\n        uint256 gMintPower;\\n        uint256 currentHRank;\\n        uint256 mintCost;\\n    }\\n\\n    event ProtocolFeeRecevied(\\n        address indexed user,\\n        uint256 indexed day,\\n        uint256 indexed amount\\n    );\\n    event TitanXDistributed(address indexed caller, uint256 indexed amount);\\n    event CyclePayoutTriggered(\\n        address indexed caller,\\n        uint256 indexed cycleNo,\\n        uint256 indexed reward\\n        // uint256 burnReward\\n    );\\n    event RewardClaimed(\\n        address indexed user,\\n        uint256 indexed reward,\\n        uint256 indexed ethReward\\n    );\\n    event ApproveBurnStakes(\\n        address indexed user,\\n        address indexed project,\\n        uint256 indexed amount\\n    );\\n    event ApproveBurnMints(\\n        address indexed user,\\n        address indexed project,\\n        uint256 indexed amount\\n    );\\n\\n    constructor(\\n        address genesisAddress,\\n        address buyAndBurnAddress,\\n        address titanxAddress,\\n        address treasuryAddress,\\n        address investmentAddress\\n    ) ERC20(\\\"HELIOS\\\", \\\"HLX\\\") {\\n        if (genesisAddress == address(0)) revert Helios_InvalidAddress();\\n        if (buyAndBurnAddress == address(0)) revert Helios_InvalidAddress();\\n        if (titanxAddress == address(0)) revert Helios_InvalidAddress();\\n        if (treasuryAddress == address(0)) revert Helios_InvalidAddress();\\n        s_genesisAddress = genesisAddress;\\n        s_investmentAddress = investmentAddress;\\n        s_buyAndBurnAddress = buyAndBurnAddress;\\n        s_titanxAddress = titanxAddress;\\n        s_treasuryAddress = treasuryAddress;\\n    }\\n\\n    modifier onlyBuyAndBurn() {\\n        if (_msgSender() != s_buyAndBurnAddress) revert Helios_OnlyBuyAndBurn();\\n        _;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external pure override returns (bool) {\\n        return\\n            interfaceId == INTERFACE_ID_ERC165 ||\\n            interfaceId == INTERFACE_ID_ITITANONBURN;\\n    }\\n\\n    function onBurn(address, uint256 amount) external override {\\n        require(msg.sender == s_titanxAddress, \\\"Only TitanX\\\");\\n        s_totalTitanBurned += amount;\\n    }\\n\\n    /**** Mint Functions *****/\\n    /** @notice create a new mint\\n     * @param mintPower 1 - 100,000\\n     * @param numOfDays mint length of 1 - 250\\n     */\\n    function startMint(\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 titanToBurn\\n    ) external payable nonReentrant dailyUpdate {\\n        if (getUserLatestMintId(_msgSender()) + 1 > MAX_MINT_PER_WALLET)\\n            revert Helios_MaxedWalletMints();\\n\\n        if (titanToBurn > 0) _burnTitanX(titanToBurn);\\n\\n        MintParams memory params = MintParams({\\n            mintPower: mintPower,\\n            numOfDays: numOfDays,\\n            titanToBurn: titanToBurn,\\n            gMintPower: getGlobalMintPower() + mintPower,\\n            currentHRank: getGlobalHRank() + 1,\\n            mintCost: getMintCost(mintPower, getCurrentMintCost())\\n        });\\n\\n        uint256 gMinting = getTotalMinting() +\\n            _startMint(\\n                _msgSender(),\\n                params.mintPower,\\n                params.numOfDays,\\n                getCurrentMintableHlx(),\\n                getCurrentMintPowerBonus(),\\n                getCurrentEAABonus(),\\n                getUserBurnAmplifierBonus(_msgSender()),\\n                params.gMintPower,\\n                params.currentHRank,\\n                params.mintCost,\\n                params.titanToBurn\\n            );\\n        _updateMintStats(params.currentHRank, params.gMintPower, gMinting);\\n        _protocolFees(mintPower);\\n    }\\n\\n    /** @notice claim a matured mint\\n     * @param id mint id\\n     */\\n    function claimMint(uint256 id) external dailyUpdate nonReentrant {\\n        _mintReward(_claimMint(_msgSender(), id, MintAction.CLAIM));\\n    }\\n\\n    /**** Stake Functions *****/\\n    /** @notice start a new stake\\n     * @param amount Helios amount\\n     * @param numOfDays stake length\\n     * @param titanToBurn amount of titanX tokens to burn to get reward\\n     */\\n    function startStake(\\n        uint256 amount,\\n        uint256 numOfDays,\\n        uint256 titanToBurn\\n    ) external dailyUpdate nonReentrant {\\n        if (balanceOf(_msgSender()) < amount)\\n            revert Helios_InsufficientBalance();\\n\\n        if (msg.sender != tx.origin) {\\n            // check if it's whitelisted\\n            require(s_whiteList[msg.sender], \\\"Contract not whitelisted.\\\");\\n        }\\n\\n        if (titanToBurn > 0) _burnTitanX(titanToBurn);\\n\\n        _burn(_msgSender(), amount);\\n        _initFirstSharesCycleIndex(\\n            _msgSender(),\\n            _startStake(\\n                _msgSender(),\\n                amount,\\n                numOfDays,\\n                getCurrentShareRate(),\\n                getCurrentContractDay(),\\n                getGlobalPayoutTriggered(),\\n                titanToBurn,\\n                titanToBurn > 0\\n                    ? IBuynBurn(s_buyAndBurnAddress).getCurrentTitanPrice()\\n                    : 0\\n            )\\n        );\\n    }\\n\\n    /** @notice end a stake\\n     * @param id stake id\\n     */\\n    function endStake(uint256 id) external dailyUpdate nonReentrant {\\n        _mint(\\n            _msgSender(),\\n            _endStake(\\n                _msgSender(),\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.END,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            )\\n        );\\n    }\\n\\n    /** @notice end a stake for others\\n     * @param user wallet address\\n     * @param id stake id\\n     */\\n    function endStakeForOthers(\\n        address user,\\n        uint256 id\\n    ) external dailyUpdate nonReentrant {\\n        _mint(\\n            user,\\n            _endStake(\\n                user,\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.END,\\n                StakeAction.END_OTHER,\\n                getGlobalPayoutTriggered()\\n            )\\n        );\\n    }\\n\\n    /** @notice distribute the collected protocol fees into different pools/payouts\\n     * automatically send the incentive fee to caller, buyAndBurnFunds to BuyAndBurn contract, and genesis wallet\\n     */\\n    function distributeTitanX() external dailyUpdate nonReentrant {\\n        (\\n            uint256 incentiveFee,\\n            uint256 buyAndBurnFunds,\\n            uint256 treasuryReward,\\n            uint256 genesisWallet\\n        ) = _distributeTitanX();\\n        _sendFunds(\\n            incentiveFee,\\n            buyAndBurnFunds,\\n            treasuryReward,\\n            genesisWallet\\n        );\\n    }\\n\\n    /** @notice trigger cylce payouts for day 22, 69, 420\\n     * As long as the cycle has met its maturiy day (eg. Cycle22 is day 22), payout can be triggered in any day onwards\\n     */\\n    function triggerPayouts() external dailyUpdate nonReentrant {\\n        uint256 globalActiveShares = getGlobalShares() -\\n            getGlobalExpiredShares();\\n        if (globalActiveShares < 1) revert Helios_NoSharesExist();\\n\\n        uint256 incentiveFee;\\n        uint256 buyAndBurnFunds;\\n        uint256 genesisWallet;\\n        uint256 treasuryReward;\\n\\n        if (s_undistributedTitanX != 0)\\n            (\\n                incentiveFee,\\n                buyAndBurnFunds,\\n                treasuryReward,\\n                genesisWallet\\n            ) = _distributeTitanX();\\n\\n        uint256 currentContractDay = getCurrentContractDay();\\n        PayoutTriggered isTriggered = PayoutTriggered.NO;\\n\\n        _triggerCyclePayout(DAY22, globalActiveShares, currentContractDay) ==\\n            PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY69, globalActiveShares, currentContractDay) ==\\n            PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY420, globalActiveShares, currentContractDay) ==\\n            PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n\\n        if (isTriggered == PayoutTriggered.YES) {\\n            if (getGlobalPayoutTriggered() == PayoutTriggered.NO)\\n                _setGlobalPayoutTriggered();\\n        }\\n\\n        if (incentiveFee != 0)\\n            _sendFunds(\\n                incentiveFee,\\n                buyAndBurnFunds,\\n                treasuryReward,\\n                genesisWallet\\n            );\\n    }\\n\\n    /** @notice claim all user available TitanX/ETH payouts in one call */\\n    function claimUserAvailablePayouts() external dailyUpdate nonReentrant {\\n        uint256 totalTitanXReward = 0;\\n        uint256 totalEthReward = 0;\\n\\n        (uint256 reward, uint256 ethReward) = _claimCyclePayout(DAY22);\\n        totalTitanXReward += reward;\\n        totalEthReward += ethReward;\\n\\n        (reward, ethReward) = _claimCyclePayout(DAY69);\\n        totalTitanXReward += reward;\\n        totalEthReward += ethReward;\\n\\n        (reward, ethReward) = _claimCyclePayout(DAY420);\\n        totalTitanXReward += reward;\\n        totalEthReward += ethReward;\\n\\n        if (totalTitanXReward == 0 && totalEthReward == 0)\\n            revert Helios_NoCycleRewardToClaim();\\n\\n        if (totalTitanXReward > 0) {\\n            _sendTitanX(_msgSender(), totalTitanXReward);\\n        }\\n\\n        if (totalEthReward > 0) {\\n            _sendViaCall(payable(_msgSender()), totalEthReward);\\n        }\\n        emit RewardClaimed(_msgSender(), totalTitanXReward, totalEthReward);\\n    }\\n\\n    /** @notice Set BuyAndBurn Contract Address - able to change to new contract that supports UniswapV4+\\n     * Only owner can call this function\\n     * @param contractAddress BuyAndBurn contract address\\n     */\\n    function setBuyAndBurnContractAddress(\\n        address contractAddress\\n    ) external onlyOwner {\\n        if (contractAddress == address(0)) revert Helios_InvalidAddress();\\n        s_buyAndBurnAddress = contractAddress;\\n    }\\n\\n    /** @notice adds address to whitelist\\n     * Only owner can call this function\\n     * @param contractAddress project contract address\\n     * @param permit bool  True to allow\\n     */\\n    function whiteList(\\n        address contractAddress,\\n        bool permit\\n    ) external onlyOwner {\\n        if (contractAddress == address(0)) revert Helios_InvalidAddress();\\n        s_whiteList[contractAddress] = permit;\\n    }\\n\\n    /** @notice Set Treasury Contract Address - able to change to new contract that supports UniswapV4+\\n     * Only owner can call this function\\n     * @param contractAddress Treasury contract address\\n     */\\n    function setTreasuryContractAddress(\\n        address contractAddress\\n    ) external onlyOwner {\\n        if (contractAddress == address(0)) revert Helios_InvalidAddress();\\n        s_treasuryAddress = contractAddress;\\n    }\\n\\n    /** @notice Set TitanX Contract Address - able to change to new contract that supports UniswapV4+\\n     * Only owner can call this function\\n     * @param contractAddress TitanX contract address\\n     */\\n    function setTitanXContractAddress(\\n        address contractAddress\\n    ) external onlyOwner {\\n        if (contractAddress == address(0)) revert Helios_InvalidAddress();\\n        s_titanxAddress = contractAddress;\\n    }\\n\\n    /** @notice Set to new genesis wallet. Only genesis wallet can call this function\\n     * @param newAddress new genesis wallet address\\n     */\\n    function setNewGenesisAddress(address newAddress) external {\\n        if (_msgSender() != s_genesisAddress) revert Helios_NotAllowed();\\n        if (newAddress == address(0)) revert Helios_InvalidAddress();\\n        s_genesisAddress = newAddress;\\n    }\\n\\n    /** @notice Set to new Investment Address.\\n     * @param newAddress new Investment address\\n     */\\n    function setNewInvestmentAddress(address newAddress) external {\\n        if (_msgSender() != s_investmentAddress) revert Helios_NotAllowed();\\n        if (newAddress == address(0)) revert Helios_InvalidAddress();\\n        s_investmentAddress = newAddress;\\n    }\\n\\n    /** @notice mint initial LP tokens. Only BuyAndBurn contract set by genesis wallet can call this function\\n     */\\n    function mintLPTokens() external {\\n        if (_msgSender() != s_buyAndBurnAddress) revert Helios_NotAllowed();\\n        if (s_initialLPMinted == InitialLPMinted.YES)\\n            revert Helios_LPTokensHasMinted();\\n        s_initialLPMinted = InitialLPMinted.YES;\\n        _mint(s_buyAndBurnAddress, INITAL_LP_TOKENS);\\n    }\\n\\n    /** @notice burn all BuyAndBurn contract Helios */\\n    function burnLPTokens() external dailyUpdate onlyBuyAndBurn {\\n        _burn(s_buyAndBurnAddress, balanceOf(s_buyAndBurnAddress));\\n    }\\n\\n    //private functions\\n    /** @dev mint reward to user and 1% to genesis wallet\\n     * @param reward helios amount\\n     */\\n    function _mintReward(uint256 reward) private {\\n        _mint(_msgSender(), reward);\\n        _mint(s_investmentAddress, (reward * 100) / PERCENT_BPS);\\n    }\\n\\n    /** @dev burns given amount of titanX with giving reward to caller and genesis Wallet\\n     * @param titanAmount amount titanX to burn\\n     */\\n    function _burnTitanX(uint256 titanAmount) private {\\n        ITITANX(TITANX).burnTokensToPayAddress(\\n            _msgSender(),\\n            titanAmount,\\n            BURN_REWARD_PERCENT_EACH,\\n            BURN_REWARD_PERCENT_EACH,\\n            s_genesisAddress\\n        );\\n    }\\n\\n    /** @dev send TitanX to respective parties\\n     * @param incentiveFee fees for caller to run distributeTitanX()\\n     * @param buyAndBurnFunds funds for buy and burn\\n     * @param genesisWalletFunds funds for genesis wallet\\n     */\\n    function _sendFunds(\\n        uint256 incentiveFee,\\n        uint256 buyAndBurnFunds,\\n        uint256 treasuryReward,\\n        uint256 genesisWalletFunds\\n    ) private {\\n        _sendTitanX(_msgSender(), incentiveFee);\\n        _sendTitanX(s_genesisAddress, genesisWalletFunds);\\n        _sendTitanX(s_buyAndBurnAddress, buyAndBurnFunds);\\n        _sendTitanX(s_treasuryAddress, treasuryReward);\\n    }\\n\\n    /** @dev calculation to distribute collected protocol fees into different pools/parties */\\n    function _distributeTitanX()\\n        private\\n        returns (\\n            uint256 incentiveFee,\\n            uint256 buyAndBurnFunds,\\n            uint256 treasuryReward,\\n            uint256 genesisWallet\\n        )\\n    {\\n        uint256 accumulatedFees = s_undistributedTitanX;\\n        if (accumulatedFees == 0) revert Helios_EmptyUndistributeFees();\\n        s_undistributedTitanX = 0;\\n        emit TitanXDistributed(_msgSender(), accumulatedFees);\\n\\n        incentiveFee =\\n            (accumulatedFees * INCENTIVE_FEE_PERCENT) /\\n            INCENTIVE_FEE_PERCENT_BASE;\\n        accumulatedFees -= incentiveFee;\\n\\n        buyAndBurnFunds =\\n            (accumulatedFees * getBuynBurnPercentage()) /\\n            PERCENT_BPS;\\n        treasuryReward =\\n            (accumulatedFees * getTreasuryPercentage()) /\\n            PERCENT_BPS;\\n        genesisWallet = (accumulatedFees * PERCENT_TO_GENESIS) / PERCENT_BPS;\\n        uint256 cycleRewardPool = accumulatedFees -\\n            buyAndBurnFunds -\\n            treasuryReward -\\n            genesisWallet;\\n\\n        //cycle payout\\n        if (cycleRewardPool != 0) {\\n            uint256 cycle22Reward = (cycleRewardPool * CYCLE_22_PERCENT) /\\n                PERCENT_BPS;\\n            uint256 cycle69Reward = (cycleRewardPool * CYCLE_69_PERCENT) /\\n                PERCENT_BPS;\\n            _setCyclePayoutPool(DAY22, cycle22Reward);\\n            _setCyclePayoutPool(DAY69, cycle69Reward);\\n            _setCyclePayoutPool(\\n                DAY420,\\n                cycleRewardPool - cycle22Reward - cycle69Reward\\n            );\\n        }\\n\\n        uint256 ethForDistribution = s_undistributedETH;\\n\\n        //cycle ETH payout\\n        if (ethForDistribution != 0) {\\n            s_undistributedETH = 0;\\n            uint256 ethCycle22Reward = (ethForDistribution * CYCLE_22_PERCENT) /\\n                PERCENT_BPS;\\n            uint256 ethCycle69Reward = (ethForDistribution * CYCLE_69_PERCENT) /\\n                PERCENT_BPS;\\n\\n            _setETHCyclePayoutPool(DAY22, ethCycle22Reward);\\n            _setETHCyclePayoutPool(DAY69, ethCycle69Reward);\\n            _setETHCyclePayoutPool(\\n                DAY420,\\n                ethForDistribution - ethCycle22Reward - ethCycle69Reward\\n            );\\n        }\\n    }\\n\\n    /** @dev calcualte required protocol fees, and return the balance (if any)\\n     * @param mintPower mint power 1-100,000\\n     */\\n    function _protocolFees(uint256 mintPower) private {\\n        uint256 protocolFee;\\n\\n        protocolFee = getMintCost(mintPower, getCurrentMintCost());\\n\\n        // Transfer Titanx From user to contract\\n        IERC20(s_titanxAddress).transferFrom(\\n            _msgSender(),\\n            address(this),\\n            protocolFee\\n        );\\n\\n        s_undistributedTitanX += protocolFee;\\n\\n        emit ProtocolFeeRecevied(\\n            _msgSender(),\\n            getCurrentContractDay(),\\n            protocolFee\\n        );\\n    }\\n\\n    /** @dev calculate payouts for each cycle day tracked by cycle index\\n     * @param cycleNo cylce day 22, 69, 420\\n     * @param currentContractDay current contract day\\n     * @return triggered is payout triggered succesfully\\n     */\\n    function _triggerCyclePayout(\\n        uint256 cycleNo,\\n        uint256 globalActiveShares,\\n        uint256 currentContractDay\\n    ) private returns (PayoutTriggered triggered) {\\n        //check against cylce payout maturity day\\n        if (currentContractDay < getNextCyclePayoutDay(cycleNo))\\n            return PayoutTriggered.NO;\\n\\n        //update the next cycle payout day regardless of payout triggered succesfully or not\\n        _setNextCyclePayoutDay(cycleNo);\\n\\n        uint256 reward = getCyclePayoutPool(cycleNo);\\n        uint256 ethReward = getETHCyclePayoutPool(cycleNo);\\n\\n        if (reward == 0 && ethReward == 0) return PayoutTriggered.NO;\\n\\n        //calculate cycle reward per share and get new cycle Index\\n        _calculateCycleRewardPerShare(\\n            cycleNo,\\n            reward,\\n            ethReward,\\n            globalActiveShares\\n        );\\n\\n        emit CyclePayoutTriggered(_msgSender(), cycleNo, reward);\\n\\n        return PayoutTriggered.YES;\\n    }\\n\\n    /** @dev calculate user reward with specified cycle day and claim type (shares) and update user's last claim cycle index\\n     * @param cycleNo cycle day 22, 69, 420\\n     */\\n    function _claimCyclePayout(\\n        uint256 cycleNo\\n    ) private returns (uint256, uint256) {\\n        (\\n            uint256 reward,\\n            uint256 ethRewards,\\n            uint256 userClaimCycleIndex,\\n            uint256 userClaimSharesIndex\\n        ) = calculateUserCycleReward(_msgSender(), cycleNo);\\n        _updateUserClaimIndexes(\\n            _msgSender(),\\n            cycleNo,\\n            userClaimCycleIndex,\\n            userClaimSharesIndex\\n        );\\n        return (reward, ethRewards);\\n    }\\n\\n    /** @dev burn liquid Helios through other project.\\n     * called by other contracts for proof of burn 2.0 with up to 8% for both builder fee and user rebate\\n     * @param user user address\\n     * @param amount liquid helios amount\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function _burnLiquidHlx(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) private {\\n        if (amount == 0) revert Helios_InvalidAmount();\\n        if (balanceOf(user) < amount) revert Helios_InsufficientBalance();\\n        _spendAllowance(user, _msgSender(), amount);\\n        _burnbefore(userRebatePercentage, rewardPaybackPercentage);\\n        _burn(user, amount);\\n        _burnAfter(\\n            user,\\n            amount,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress,\\n            BurnSource.LIQUID\\n        );\\n    }\\n\\n    /** @dev burn stake through other project.\\n     * called by other contracts for proof of burn 2.0 with up to 8% for both builder fee and user rebate\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function _burnStake(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) private {\\n        _spendBurnStakeAllowance(user);\\n        _burnbefore(userRebatePercentage, rewardPaybackPercentage);\\n        _burnAfter(\\n            user,\\n            _endStake(\\n                user,\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.BURN,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            ),\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress,\\n            BurnSource.STAKE\\n        );\\n    }\\n\\n    /** @dev burn mint through other project.\\n     * called by other contracts for proof of burn 2.0\\n     * burn mint has no builder reward and no user rebate\\n     * @param user user address\\n     * @param id mint id\\n     */\\n    function _burnMint(address user, uint256 id) private {\\n        _spendBurnMintAllowance(user);\\n        _burnbefore(0, 0);\\n        uint256 amount = _claimMint(user, id, MintAction.BURN);\\n        _mint(s_genesisAddress, (amount * 800) / PERCENT_BPS);\\n        _burnAfter(user, amount, 0, 0, _msgSender(), BurnSource.MINT);\\n    }\\n\\n    /** @dev perform checks before burning starts.\\n     * check reward percentage and check if called by supported contract\\n     * @param userRebatePercentage percentage for user rebate\\n     * @param rewardPaybackPercentage percentage for builder fee\\n     */\\n    function _burnbefore(\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) private view {\\n        if (\\n            rewardPaybackPercentage + userRebatePercentage >\\n            MAX_BURN_REWARD_PERCENT\\n        ) revert Helios_InvalidBurnRewardPercent();\\n\\n        //Only supported contracts is allowed to call this function\\n        if (\\n            !IERC165(_msgSender()).supportsInterface(\\n                IERC165.supportsInterface.selector\\n            ) ||\\n            !IERC165(_msgSender()).supportsInterface(\\n                type(IHlxOnBurn).interfaceId\\n            )\\n        ) revert Helios_NotSupportedContract();\\n    }\\n\\n    /** @dev update burn stats and mint reward to builder or user if applicable\\n     * @param user user address\\n     * @param amount helios amount burned\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     * @param source liquid/mint/stake\\n     */\\n    function _burnAfter(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress,\\n        BurnSource source\\n    ) private {\\n        _updateBurnAmount(user, _msgSender(), amount, source);\\n\\n        uint256 devFee;\\n        uint256 userRebate;\\n        if (rewardPaybackPercentage != 0)\\n            devFee =\\n                (amount * rewardPaybackPercentage * PERCENT_BPS) /\\n                (100 * PERCENT_BPS);\\n        if (userRebatePercentage != 0)\\n            userRebate =\\n                (amount * userRebatePercentage * PERCENT_BPS) /\\n                (100 * PERCENT_BPS);\\n\\n        if (devFee != 0) _mint(rewardPaybackAddress, devFee);\\n        if (userRebate != 0) _mint(user, userRebate);\\n\\n        IHlxOnBurn(_msgSender()).onBurn(user, amount);\\n    }\\n\\n    /** @dev Recommended method to transfer Tokens\\n     * @param to receiving address.\\n     * @param amount in wei.\\n     */\\n    function _sendTitanX(address to, uint256 amount) private {\\n        if (to == address(0)) revert Helios_InvalidAddress();\\n        IERC20(s_titanxAddress).transfer(to, amount);\\n    }\\n\\n    /** @dev Recommended method to use to send native coins.\\n     * @param to receiving address.\\n     * @param amount in wei.\\n     */\\n    function _sendViaCall(address payable to, uint256 amount) private {\\n        if (to == address(0)) revert Helios_InvalidAddress();\\n        (bool sent, ) = to.call{value: amount}(\\\"\\\");\\n        if (!sent) revert Helios_FailedToSendAmount();\\n    }\\n\\n    /** @dev reduce user's allowance for caller (spender/project) by 1 (burn 1 stake at a time)\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     * @param user user address\\n     */\\n    function _spendBurnStakeAllowance(address user) private {\\n        uint256 currentAllowance = allowanceBurnStakes(user, _msgSender());\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance == 0)\\n                revert Helios_InsufficientBurnAllowance();\\n            --s_allowanceBurnStakes[user][_msgSender()];\\n        }\\n    }\\n\\n    /** @dev reduce user's allowance for caller (spender/project) by 1 (burn 1 mint at a time)\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     * @param user user address\\n     */\\n    function _spendBurnMintAllowance(address user) private {\\n        uint256 currentAllowance = allowanceBurnMints(user, _msgSender());\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance == 0)\\n                revert Helios_InsufficientBurnAllowance();\\n            --s_allowanceBurnMints[user][_msgSender()];\\n        }\\n    }\\n\\n    //Views\\n    /** @dev calculate user payout reward with specified cycle day and claim type (shares/burn).\\n     * it loops through all the unclaimed cylce index until the latest cycle index\\n     * @param user user address\\n     * @param cycleNo cycle day 7, 25, 69, 183, 420\\n     * @return rewards calculated reward\\n     * @return ethRewards calculated reward\\n     * @return userClaimCycleIndex last claim cycle index\\n     * @return userClaimSharesIndex last claim shares index\\n     */\\n    function calculateUserCycleReward(\\n        address user,\\n        uint256 cycleNo\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 rewards,\\n            uint256 ethRewards,\\n            uint256 userClaimCycleIndex,\\n            uint256 userClaimSharesIndex\\n        )\\n    {\\n        uint256 cycleMaxIndex = getCurrentCycleIndex(cycleNo);\\n\\n        (userClaimCycleIndex, userClaimSharesIndex) = getUserLastClaimIndex(\\n            user,\\n            cycleNo\\n        );\\n        uint256 sharesMaxIndex = getUserLatestShareIndex(user);\\n\\n        for (uint256 i = userClaimCycleIndex; i <= cycleMaxIndex; i++) {\\n            (uint256 payoutPerShare, uint256 payoutDay) = getPayoutPerShare(\\n                cycleNo,\\n                i\\n            );\\n            (uint256 ethPayoutPerShare, ) = getETHPayoutPerShare(cycleNo, i);\\n            uint256 shares;\\n            (shares, userClaimSharesIndex) = _getSharesAndUpdateIndex(\\n                user,\\n                userClaimSharesIndex,\\n                sharesMaxIndex,\\n                payoutDay\\n            );\\n            if (payoutPerShare != 0 && shares != 0) {\\n                //reward has 18 decimals scaling, so here divide by 1e18\\n                rewards += (shares * payoutPerShare) / SCALING_FACTOR_1e18;\\n            }\\n\\n            if (ethPayoutPerShare != 0 && shares != 0) {\\n                ethRewards +=\\n                    (shares * ethPayoutPerShare) /\\n                    SCALING_FACTOR_1e18;\\n            }\\n\\n            userClaimCycleIndex = i + 1;\\n        }\\n    }\\n\\n    function _getSharesAndUpdateIndex(\\n        address user,\\n        uint256 userClaimSharesIndex,\\n        uint256 sharesMaxIndex,\\n        uint256 payoutDay\\n    ) private view returns (uint256 shares, uint256) {\\n        //loop shares indexes to find the last updated shares before/same triggered payout day\\n        for (uint256 j = userClaimSharesIndex; j <= sharesMaxIndex; j++) {\\n            if (getUserActiveSharesDay(user, j) <= payoutDay)\\n                shares = getUserActiveShares(user, j);\\n            else break;\\n\\n            userClaimSharesIndex = j;\\n        }\\n        return (shares, userClaimSharesIndex);\\n    }\\n\\n    /** @notice get contract ETH balance\\n     * @return balance eth balance\\n     */\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /** @notice get genesis Wallet Address\\n     * @return address\\n     */\\n    function getGenesisAddress() public view returns (address) {\\n        return s_genesisAddress;\\n    }\\n\\n    /** @notice get Investment Address\\n     * @return address\\n     */\\n    function getInvestmentAddress() public view returns (address) {\\n        return s_investmentAddress;\\n    }\\n\\n    /** @notice check if address is whitelisted\\n     * @return bool\\n     */\\n    function isWhiteListed(address contractAddress) public view returns (bool) {\\n        return s_whiteList[contractAddress];\\n    }\\n\\n    /** @notice get total TitanX burned by user using this contract\\n     * @return total titan burned\\n     */\\n    function getTotalTitanXBurned() public view returns (uint256) {\\n        return s_totalTitanBurned;\\n    }\\n\\n    /** @notice get contract TitanX balance\\n     * @return balance TitanX balance\\n     */\\n    function getTitanXBalance() public view returns (uint256) {\\n        return IERC20(s_titanxAddress).balanceOf(address(this));\\n    }\\n\\n    /** @notice get contract Hlx balance\\n     * @return balance Hlx balance\\n     */\\n    function getHlxBalance() public view returns (uint256) {\\n        return balanceOf(address(this));\\n    }\\n\\n    /** @notice get undistributed TitanX balance\\n     * @return amount titanX amount\\n     */\\n    function getUndistributedTitanX() public view returns (uint256) {\\n        return s_undistributedTitanX;\\n    }\\n\\n    /** @notice get undistributed ETH balance\\n     * @return amount ETH\\n     */\\n    function getUndistributedETH() public view returns (uint256) {\\n        return s_undistributedETH;\\n    }\\n\\n    /** @notice get estimated Hlx at end of miner\\n     * @return amount of hlx\\n     */\\n    function getMintableHlx(\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 titanToBurn,\\n        address user\\n    ) public view returns (uint256) {\\n        uint256 mintCost = getMintCost(mintPower, getCurrentMintCost());\\n\\n        uint256 percentage = _calculateBonusPercentage(titanToBurn, mintCost);\\n\\n        return\\n            calculateMintReward(\\n                mintPower,\\n                numOfDays,\\n                getCurrentMintableHlx(),\\n                getCurrentEAABonus(),\\n                getUserBurnAmplifierBonus(user),\\n                percentage\\n            );\\n    }\\n\\n    /** @notice get estimated shares\\n     */\\n    function estimateShares(\\n        uint256 amount,\\n        uint256 numOfDays\\n    )\\n        public\\n        view\\n        returns (uint256 sharesWithBonus, uint256 sharesWithoutBonus)\\n    {\\n        uint256 shareRate = getCurrentShareRate();\\n\\n        sharesWithBonus = calculateShares(amount, numOfDays, shareRate);\\n\\n        sharesWithoutBonus = amount / (shareRate / SCALING_FACTOR_1e18);\\n    }\\n\\n    /** @notice calculate share bonus\\n     * @return shareBonus calculated shares bonus in 11 decimals\\n     */\\n    function getShareBonus(uint256 noOfDays) public pure returns (uint256) {\\n        return calculateShareBonus(noOfDays);\\n    }\\n\\n    /** @notice get user TitanX payout for all cycles\\n     * @param user user address\\n     * @return reward total reward\\n     */\\n    function getUserTitanXClaimableTotal(\\n        address user\\n    ) public view returns (uint256 reward) {\\n        uint256 _reward;\\n\\n        (_reward, , , ) = calculateUserCycleReward(user, DAY22);\\n        reward += _reward;\\n        (_reward, , , ) = calculateUserCycleReward(user, DAY69);\\n        reward += _reward;\\n        (_reward, , , ) = calculateUserCycleReward(user, DAY420);\\n        reward += _reward;\\n    }\\n\\n    /** @notice get user ETH payout for all cycles\\n     * @param user user address\\n     * @return reward total reward\\n     */\\n    function getUserETHClaimableTotal(\\n        address user\\n    ) public view returns (uint256 reward) {\\n        uint256 _reward;\\n        (, _reward, , ) = calculateUserCycleReward(user, DAY22);\\n        reward += _reward;\\n        (, _reward, , ) = calculateUserCycleReward(user, DAY69);\\n        reward += _reward;\\n        (, _reward, , ) = calculateUserCycleReward(user, DAY420);\\n        reward += _reward;\\n    }\\n\\n    /** @notice get total penalties from mint and stake\\n     * @return amount total penalties\\n     */\\n    function getTotalPenalties() public view returns (uint256) {\\n        return getTotalMintPenalty() + getTotalStakePenalty();\\n    }\\n\\n    /** @notice returns user's burn stakes allowance of a project\\n     * @param user user address\\n     * @param spender project address\\n     */\\n    function allowanceBurnStakes(\\n        address user,\\n        address spender\\n    ) public view returns (uint256) {\\n        return s_allowanceBurnStakes[user][spender];\\n    }\\n\\n    /** @notice returns user's burn mints allowance of a project\\n     * @param user user address\\n     * @param spender project address\\n     */\\n    function allowanceBurnMints(\\n        address user,\\n        address spender\\n    ) public view returns (uint256) {\\n        return s_allowanceBurnMints[user][spender];\\n    }\\n\\n    /** @notice Burn Helios tokens and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param amount helios amount\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function burnTokensToPayAddress(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) public dailyUpdate nonReentrant {\\n        _burnLiquidHlx(\\n            user,\\n            amount,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress\\n        );\\n    }\\n\\n    /** @notice Burn Hlx tokens and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param amount helios amount\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     */\\n    function burnTokens(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) public dailyUpdate nonReentrant {\\n        _burnLiquidHlx(\\n            user,\\n            amount,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            _msgSender()\\n        );\\n    }\\n\\n    /** @notice receive eth */\\n    receive() external payable {\\n        if (msg.value > 0) {\\n            s_undistributedETH += msg.value;\\n        }\\n    }\\n\\n    /** @notice allows user to burn liquid helios directly from contract\\n     * @param amount helios amount\\n     */\\n    function userBurnTokens(uint256 amount) public dailyUpdate nonReentrant {\\n        if (amount == 0) revert Helios_InvalidAmount();\\n        if (balanceOf(_msgSender()) < amount)\\n            revert Helios_InsufficientBalance();\\n        _burn(_msgSender(), amount);\\n        _updateBurnAmount(_msgSender(), address(0), amount, BurnSource.LIQUID);\\n    }\\n\\n    /** @notice Burn stake and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function burnStakeToPayAddress(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) public dailyUpdate nonReentrant {\\n        _burnStake(\\n            user,\\n            id,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress\\n        );\\n    }\\n\\n    /** @notice Burn stake and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to project contract address\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid helios (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid helios (0 - 8)\\n     */\\n    function burnStake(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) public dailyUpdate nonReentrant {\\n        _burnStake(\\n            user,\\n            id,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            _msgSender()\\n        );\\n    }\\n\\n    /** @notice allows user to burn stake directly from contract\\n     * @param id stake id\\n     */\\n    function userBurnStake(uint256 id) public dailyUpdate nonReentrant {\\n        _updateBurnAmount(\\n            _msgSender(),\\n            address(0),\\n            _endStake(\\n                _msgSender(),\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.BURN,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            ),\\n            BurnSource.STAKE\\n        );\\n    }\\n\\n    /** @notice Burn mint and creates Proof-Of-Burn record to be used by connected DeFi.\\n     * Burn mint has no project reward or user rebate\\n     * @param user user address\\n     * @param id mint id\\n     */\\n    function burnMint(\\n        address user,\\n        uint256 id\\n    ) public dailyUpdate nonReentrant {\\n        _burnMint(user, id);\\n    }\\n\\n    /** @notice allows user to burn mint directly from contract\\n     * @param id mint id\\n     */\\n    function userBurnMint(uint256 id) public dailyUpdate nonReentrant {\\n        _updateBurnAmount(\\n            _msgSender(),\\n            address(0),\\n            _claimMint(_msgSender(), id, MintAction.BURN),\\n            BurnSource.MINT\\n        );\\n    }\\n\\n    /** @notice Sets `amount` as the allowance of `spender` over the caller's (user) mints.\\n     * @param spender contract address\\n     * @param amount allowance amount\\n     */\\n    function approveBurnMints(\\n        address spender,\\n        uint256 amount\\n    ) public returns (bool) {\\n        if (spender == address(0)) revert Helios_InvalidAddress();\\n        s_allowanceBurnMints[_msgSender()][spender] = amount;\\n        emit ApproveBurnMints(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /** @notice Sets `amount` as the allowance of `spender` over the caller's (user) stakes.\\n     * @param spender contract address\\n     * @param amount allowance amount\\n     */\\n    function approveBurnStakes(\\n        address spender,\\n        uint256 amount\\n    ) public returns (bool) {\\n        if (spender == address(0)) revert Helios_InvalidAddress();\\n        s_allowanceBurnStakes[_msgSender()][spender] = amount;\\n        emit ApproveBurnStakes(_msgSender(), spender, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MintInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\n//custom errors\\nerror Helios_InvalidMintLength();\\nerror Helios_InvalidMintPower();\\nerror Helios_NoMintExists();\\nerror Helios_MintHasClaimed();\\nerror Helios_MintNotMature();\\nerror Helios_MintHasBurned();\\n\\nabstract contract MintInfo {\\n    //variables\\n    /** @dev track global hRank */\\n    uint256 private s_globalHRank;\\n    /** @dev track total mint claimed */\\n    uint256 private s_globalMintClaim;\\n    /** @dev track total mint burned */\\n    uint256 private s_globalMintBurn;\\n    /** @dev track total helios minting */\\n    uint256 private s_globalHlxMinting;\\n    /** @dev track total helios penalty */\\n    uint256 private s_globalHlxMintPenalty;\\n    /** @dev track global mint power */\\n    uint256 private s_globalMintPower;\\n\\n    //mappings\\n    /** @dev track address => mintId */\\n    mapping(address => uint256) private s_addressMId;\\n    /** @dev track address, mintId => hRank info (gHrank, gMintPower) */\\n    mapping(address => mapping(uint256 => HRankInfo))\\n        private s_addressMIdToHRankInfo;\\n    /** @dev track global hRank => mintInfo*/\\n    mapping(uint256 => UserMintInfo) private s_hRankToMintInfo;\\n\\n    //structs\\n    struct UserMintInfo {\\n        uint256 mintPower;\\n        uint16 numOfDays;\\n        uint256 mintableHlx;\\n        uint48 mintStartTs;\\n        uint48 maturityTs;\\n        uint256 mintPowerBonus;\\n        uint256 EAABonus;\\n        uint256 mintedHlx;\\n        uint256 mintCost;\\n        uint256 penalty;\\n        uint256 titanBurned;\\n        MintStatus status;\\n    }\\n\\n    struct HRankInfo {\\n        uint256 hRank;\\n        uint256 gMintPower;\\n    }\\n\\n    struct UserMint {\\n        uint256 mId;\\n        uint256 hRank;\\n        uint256 gMintPower;\\n        UserMintInfo mintInfo;\\n    }\\n\\n    //events\\n    event MintStarted(\\n        address indexed user,\\n        uint256 indexed hRank,\\n        uint256 indexed gMintpower,\\n        UserMintInfo userMintInfo\\n    );\\n\\n    event MintClaimed(\\n        address indexed user,\\n        uint256 indexed hRank,\\n        uint256 rewardMinted,\\n        uint256 indexed penalty,\\n        uint256 mintPenalty\\n    );\\n\\n    //functions\\n    /** @dev create a new mint\\n     * @param user user address\\n     * @param mintPower mint power\\n     * @param numOfDays mint lenght\\n     * @param mintableHlx mintable helios\\n     * @param mintPowerBonus mint power bonus\\n     * @param EAABonus EAA bonus\\n     * @param burnAmpBonus burn amplifier bonus\\n     * @param gMintPower global mint power\\n     * @param currentHRank current global hRank\\n     * @param mintCost actual mint cost paid for a mint\\n     * @param titanAmount titan Burned amount\\n     */\\n    function _startMint(\\n        address user,\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 mintableHlx,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus,\\n        uint256 burnAmpBonus,\\n        uint256 gMintPower,\\n        uint256 currentHRank,\\n        uint256 mintCost,\\n        uint256 titanAmount\\n    ) internal returns (uint256 mintable) {\\n        if (numOfDays == 0 || numOfDays > MAX_MINT_LENGTH)\\n            revert Helios_InvalidMintLength();\\n        if (mintPower == 0 || mintPower > MAX_MINT_POWER_CAP)\\n            revert Helios_InvalidMintPower();\\n\\n        uint256 percentage = 0;\\n\\n        if (titanAmount > 0) {\\n            percentage = _calculateBonusPercentage(titanAmount, mintCost);\\n        }\\n\\n        //calculate mint reward up front with the provided params\\n        mintable = calculateMintReward(\\n            mintPower,\\n            numOfDays,\\n            mintableHlx,\\n            EAABonus,\\n            burnAmpBonus,\\n            percentage\\n        );\\n\\n        _storeMintInfo(\\n            user,\\n            mintPower,\\n            numOfDays,\\n            mintable,\\n            mintPowerBonus,\\n            EAABonus,\\n            currentHRank,\\n            gMintPower,\\n            mintCost,\\n            titanAmount\\n        );\\n    }\\n\\n    function _calculateBonusPercentage(\\n        uint256 titanAmount,\\n        uint256 mintCost\\n    ) internal pure returns (uint256) {\\n        uint256 percentage = (titanAmount * 10000) / mintCost;\\n\\n        return percentage;\\n    }\\n\\n    function _storeMintInfo(\\n        address user,\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 mintable,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus,\\n        uint256 currentHRank,\\n        uint256 gMintPower,\\n        uint256 mintCost,\\n        uint256 titanAmount\\n    ) private {\\n        //store variables into mint info\\n        UserMintInfo memory userMintInfo = UserMintInfo({\\n            mintPower: mintPower,\\n            numOfDays: uint16(numOfDays),\\n            mintableHlx: mintable,\\n            mintPowerBonus: mintPowerBonus,\\n            EAABonus: EAABonus,\\n            mintStartTs: uint48(block.timestamp),\\n            maturityTs: uint48(block.timestamp + (numOfDays * SECONDS_IN_DAY)),\\n            mintedHlx: 0,\\n            mintCost: mintCost,\\n            penalty: 0,\\n            titanBurned: titanAmount,\\n            status: MintStatus.ACTIVE\\n        });\\n\\n        /** s_addressMId[user] tracks mintId for each addrress\\n         * s_addressMIdToHRankInfo[user][id] tracks current mint hRank and gPowerMint\\n         *  s_hRankToMintInfo[currentHRank] stores mint info\\n         */\\n        uint256 id = ++s_addressMId[user];\\n        s_addressMIdToHRankInfo[user][id].hRank = currentHRank;\\n        s_addressMIdToHRankInfo[user][id].gMintPower = gMintPower;\\n        s_hRankToMintInfo[currentHRank] = userMintInfo;\\n\\n        emit MintStarted(user, currentHRank, gMintPower, userMintInfo);\\n    }\\n\\n    /** @dev update variables\\n     * @param currentHRank current hRank\\n     * @param gMintPower current global mint power\\n     * @param gMinting current global minting\\n     */\\n    function _updateMintStats(\\n        uint256 currentHRank,\\n        uint256 gMintPower,\\n        uint256 gMinting\\n    ) internal {\\n        s_globalHRank = currentHRank;\\n        s_globalMintPower = gMintPower;\\n        s_globalHlxMinting = gMinting;\\n    }\\n\\n    /** @dev calculate reward for claim mint or burn mint.\\n     * Claim mint has maturity check while burn mint would bypass maturity check.\\n     * @param user user address\\n     * @param id mint id\\n     * @param action claim mint or burn mint\\n     * @return reward calculated final reward after all bonuses and penalty (if any)\\n     */\\n    function _claimMint(\\n        address user,\\n        uint256 id,\\n        MintAction action\\n    ) internal returns (uint256 reward) {\\n        uint256 hRank = s_addressMIdToHRankInfo[user][id].hRank;\\n        uint256 gMintPower = s_addressMIdToHRankInfo[user][id].gMintPower;\\n        if (hRank == 0) revert Helios_NoMintExists();\\n\\n        UserMintInfo memory mint = s_hRankToMintInfo[hRank];\\n        if (mint.status == MintStatus.CLAIMED) revert Helios_MintHasClaimed();\\n        if (mint.status == MintStatus.BURNED) revert Helios_MintHasBurned();\\n\\n        //Only check maturity for claim mint action, burn mint bypass this check\\n        if (mint.maturityTs > block.timestamp && action == MintAction.CLAIM)\\n            revert Helios_MintNotMature();\\n\\n        s_globalHlxMinting -= mint.mintableHlx;\\n        reward = _calculateClaimReward(user, hRank, gMintPower, mint, action);\\n    }\\n\\n    /** @dev calculate final reward with bonuses and penalty (if any)\\n     * @param user user address\\n     * @param hRank mint's hRank\\n     * @param gMintPower mint's gMintPower\\n     * @param userMintInfo mint's info\\n     * @param action claim mint or burn mint\\n     * @return reward calculated final reward after all bonuses and penalty (if any)\\n     */\\n    function _calculateClaimReward(\\n        address user,\\n        uint256 hRank,\\n        uint256 gMintPower,\\n        UserMintInfo memory userMintInfo,\\n        MintAction action\\n    ) private returns (uint256 reward) {\\n        if (action == MintAction.CLAIM)\\n            s_hRankToMintInfo[hRank].status = MintStatus.CLAIMED;\\n        if (action == MintAction.BURN)\\n            s_hRankToMintInfo[hRank].status = MintStatus.BURNED;\\n\\n        uint256 penaltyAmount;\\n        uint256 penalty;\\n        uint256 bonus;\\n\\n        //only calculate penalty when current block timestamp > maturity timestamp\\n        if (block.timestamp > userMintInfo.maturityTs) {\\n            penalty = calculateClaimMintPenalty(\\n                block.timestamp - userMintInfo.maturityTs\\n            );\\n        }\\n\\n        //Only Claim action has mintPower bonus\\n        if (action == MintAction.CLAIM) {\\n            bonus = calculateMintPowerBonus(\\n                userMintInfo.mintPowerBonus,\\n                userMintInfo.mintPower,\\n                gMintPower,\\n                s_globalMintPower\\n            );\\n        }\\n\\n        //mintPowerBonus has scaling factor of 1e7, so divide by 1e7\\n        reward =\\n            uint256(userMintInfo.mintableHlx) +\\n            (bonus / SCALING_FACTOR_1e7);\\n        penaltyAmount = (reward * penalty) / 100;\\n        reward -= penaltyAmount;\\n\\n        if (action == MintAction.CLAIM) ++s_globalMintClaim;\\n        if (action == MintAction.BURN) ++s_globalMintBurn;\\n        if (penaltyAmount != 0) s_globalHlxMintPenalty += penaltyAmount;\\n\\n        //only stored minted amount for claim mint\\n        if (action == MintAction.CLAIM) {\\n            s_hRankToMintInfo[hRank].mintedHlx = reward;\\n            s_hRankToMintInfo[hRank].penalty = penaltyAmount;\\n        }\\n\\n        emit MintClaimed(user, hRank, reward, penalty, penaltyAmount);\\n    }\\n\\n    //views\\n    /** @notice Returns the latest Mint Id of an address\\n     * @param user address\\n     * @return mId latest mint id\\n     */\\n    function getUserLatestMintId(address user) public view returns (uint256) {\\n        return s_addressMId[user];\\n    }\\n\\n    /**\\n     * @dev Estimates the reward for a specific mint operation for a user, including any applicable bonuses and subtracting penalties for late claims.\\n     * This function calculates an estimate of the total reward a user can expect from a mint at the time of its maturity, based on the current state.\\n     *\\n     * @param user The address of the user who initiated the mint operation.\\n     * @param mintId The unique identifier of the mint operation for which the reward is being estimated.\\n     */\\n    function estimateMintReward(\\n        address user,\\n        uint256 mintId\\n    ) public view returns (uint256 baseReward) {\\n        uint256 hRank = s_addressMIdToHRankInfo[user][mintId].hRank;\\n        uint256 gMintPower = s_addressMIdToHRankInfo[user][mintId].gMintPower;\\n        if (hRank == 0) revert Helios_NoMintExists();\\n\\n        UserMintInfo memory mint = s_hRankToMintInfo[hRank];\\n        // Base mintable HLX\\n        baseReward = mint.mintableHlx;\\n\\n        // Calculate additional rewards here.\\n        uint256 bonus = calculateMintPowerBonus(\\n            mint.mintPowerBonus,\\n            mint.mintPower,\\n            gMintPower,\\n            s_globalMintPower\\n        );\\n        baseReward += baseReward + (bonus / SCALING_FACTOR_1e7); //hypothetical bonus\\n    }\\n\\n    /** @notice Returns mint info of an address + mint id\\n     * @param user address\\n     * @param id mint id\\n     * @return mintInfo user mint info\\n     */\\n    function getUserMintInfo(\\n        address user,\\n        uint256 id\\n    ) public view returns (UserMintInfo memory mintInfo) {\\n        return s_hRankToMintInfo[s_addressMIdToHRankInfo[user][id].hRank];\\n    }\\n\\n    /** @notice Return all mints info of an address\\n     * @param user address\\n     * @return mintInfos all mints info of an address including mint id, hRank and gMintPower\\n     */\\n    function getUserMints(\\n        address user\\n    ) public view returns (UserMint[] memory mintInfos) {\\n        uint256 count = s_addressMId[user];\\n        mintInfos = new UserMint[](count);\\n\\n        for (uint256 i = 1; i <= count; i++) {\\n            mintInfos[i - 1] = UserMint({\\n                mId: i,\\n                hRank: s_addressMIdToHRankInfo[user][i].hRank,\\n                gMintPower: s_addressMIdToHRankInfo[user][i].gMintPower,\\n                mintInfo: getUserMintInfo(user, i)\\n            });\\n        }\\n    }\\n\\n    /** @notice Return total mints burned\\n     * @return totalMintBurned total mints burned\\n     */\\n    function getTotalMintBurn() public view returns (uint256) {\\n        return s_globalMintBurn;\\n    }\\n\\n    /** @notice Return current gobal hRank\\n     * @return globalHRank global hRank\\n     */\\n    function getGlobalHRank() public view returns (uint256) {\\n        return s_globalHRank;\\n    }\\n\\n    /** @notice Return current gobal mint power\\n     * @return globalMintPower global mint power\\n     */\\n    function getGlobalMintPower() public view returns (uint256) {\\n        return s_globalMintPower;\\n    }\\n\\n    /** @notice Return total mints claimed\\n     * @return totalMintClaimed total mints claimed\\n     */\\n    function getTotalMintClaim() public view returns (uint256) {\\n        return s_globalMintClaim;\\n    }\\n\\n    /** @notice Return total active mints (exluded claimed and burned mints)\\n     * @return totalActiveMints total active mints\\n     */\\n    function getTotalActiveMints() public view returns (uint256) {\\n        return s_globalHRank - s_globalMintClaim - s_globalMintBurn;\\n    }\\n\\n    /** @notice Return total minting helios\\n     * @return totalMinting total minting helios\\n     */\\n    function getTotalMinting() public view returns (uint256) {\\n        return s_globalHlxMinting;\\n    }\\n\\n    /** @notice Return total helios penalty\\n     * @return totalHlxPenalty total helios penalty\\n     */\\n    function getTotalMintPenalty() public view returns (uint256) {\\n        return s_globalHlxMintPenalty;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OwnerInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nerror Helios_NotOnwer();\\n\\nabstract contract OwnerInfo is Context {\\n    address private s_owner;\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        s_owner = _msgSender();\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (s_owner != _msgSender()) revert Helios_NotOnwer();\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        s_owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakeInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\n//custom errors\\nerror Helios_InvalidStakeLength();\\nerror Helios_RequireOneMinimumShare();\\nerror Helios_ExceedMaxAmountPerStake();\\nerror Helios_NoStakeExists();\\nerror Helios_StakeHasEnded();\\nerror Helios_StakeNotMatured();\\nerror Helios_StakeHasBurned();\\nerror Helios_MaxedWalletStakes();\\n\\nabstract contract StakeInfo {\\n    //Variables\\n    /** @dev track global stake Id */\\n    uint256 private s_globalStakeId;\\n    /** @dev track global shares */\\n    uint256 private s_globalShares;\\n    /** @dev track global expired shares */\\n    uint256 private s_globalExpiredShares;\\n    /** @dev track global staked Helios */\\n    uint256 private s_globalHlxStaked;\\n    /** @dev track global end stake penalty */\\n    uint256 private s_globalStakePenalty;\\n    /** @dev track global ended stake */\\n    uint256 private s_globalStakeEnd;\\n    /** @dev track global burned stake */\\n    uint256 private s_globalStakeBurn;\\n\\n    //mappings\\n    /** @dev track address => stakeId */\\n    mapping(address => uint256) private s_addressSId;\\n    /** @dev track address, stakeId => global stake Id */\\n    mapping(address => mapping(uint256 => uint256))\\n        private s_addressSIdToGlobalStakeId;\\n    /** @dev track global stake Id => stake info */\\n    mapping(uint256 => UserStakeInfo) private s_globalStakeIdToStakeInfo;\\n\\n    /** @dev track address => shares Index */\\n    mapping(address => uint256) private s_userSharesIndex;\\n    /** @dev track user total active shares by user shares index\\n     * s_addressIdToActiveShares[user][index] = UserActiveShares (contract day, total user active shares)\\n     * works like a snapshot or log when user shares has changed (increase/decrease)\\n     */\\n    mapping(address => mapping(uint256 => UserActiveShares))\\n        private s_addressIdToActiveShares;\\n\\n    //structs\\n    struct UserStakeInfo {\\n        uint256 hlxAmount;\\n        uint256 shares;\\n        uint16 numOfDays;\\n        uint48 stakeStartTs;\\n        uint48 maturityTs;\\n        uint256 titanBurned;\\n        StakeStatus status;\\n    }\\n\\n    struct UserStake {\\n        uint256 sId;\\n        uint256 globalStakeId;\\n        UserStakeInfo stakeInfo;\\n    }\\n\\n    struct UserActiveShares {\\n        uint256 day;\\n        uint256 activeShares;\\n    }\\n\\n    //events\\n    event StakeStarted(\\n        address indexed user,\\n        uint256 indexed globalStakeId,\\n        uint256 numOfDays,\\n        UserStakeInfo userStakeInfo\\n    );\\n\\n    event StakeEnded(\\n        address indexed user,\\n        uint256 indexed globalStakeId,\\n        uint256 hlxAmount,\\n        uint256 indexed penalty,\\n        uint256 penaltyAmount\\n    );\\n\\n    //functions\\n    /** @dev create a new stake\\n     * @param user user address\\n     * @param amount helios amount\\n     * @param numOfDays stake lenght\\n     * @param shareRate current share rate\\n     * @param day current contract day\\n     * @param isPayoutTriggered has global payout triggered\\n     * @param titanAmount titan amount burned\\n     * @param titanPrice titan price against hlx\\n     * @return isFirstShares first created shares or not\\n     */\\n    function _startStake(\\n        address user,\\n        uint256 amount,\\n        uint256 numOfDays,\\n        uint256 shareRate,\\n        uint256 day,\\n        PayoutTriggered isPayoutTriggered,\\n        uint256 titanAmount,\\n        uint256 titanPrice\\n    ) internal returns (uint256 isFirstShares) {\\n        uint256 sId = ++s_addressSId[user];\\n        if (sId > MAX_STAKE_PER_WALLET) revert Helios_MaxedWalletStakes();\\n        if (numOfDays < MIN_STAKE_LENGTH || numOfDays > MAX_STAKE_LENGTH)\\n            revert Helios_InvalidStakeLength();\\n\\n        //calculate shares\\n        uint256 shares = calculateShares(amount, numOfDays, shareRate);\\n\\n        if (shares / SCALING_FACTOR_1e18 < 1)\\n            revert Helios_RequireOneMinimumShare();\\n\\n        if (titanAmount > 0) {\\n            uint256 percentage = calculateBonusPercentage(\\n                titanAmount,\\n                titanPrice,\\n                amount\\n            );\\n            if (percentage > BURN_STAKE_AMP) percentage = BURN_STAKE_AMP;\\n\\n            shares = shares + ((shares * percentage) / PERCENT_BASE);\\n        }\\n\\n        _storeUserStakesInfo(sId, user, amount, numOfDays, shares, titanAmount);\\n        //update shares changes\\n        isFirstShares = _updateSharesStats(\\n            user,\\n            shares,\\n            amount,\\n            day,\\n            isPayoutTriggered,\\n            StakeAction.START\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculates the bonus percentage based on the amount of Titan tokens burned.\\n     * @param titanAmount The amount of Titan tokens burned by the user.\\n     * @param titanPrice The price of Titan tokens relative to Helios.\\n     * @param amountStaked The amount of Helios staked by the user.\\n     * @return The bonus percentage, scaled to maintain precision.\\n     *\\n     * This function calculates the value of the burned Titan tokens in terms of the staked Helios tokens.\\n     * It then computes the bonus percentage based on this value. The result is scaled to account for\\n     * Solidity's lack of support for floating-point arithmetic.\\n     */\\n    function calculateBonusPercentage(\\n        uint256 titanAmount,\\n        uint256 titanPrice,\\n        uint256 amountStaked\\n    ) internal pure returns (uint256) {\\n        uint256 titanValueInHlx = (amountStaked * titanPrice) /\\n            SCALING_FACTOR_1e18;\\n\\n        uint256 percentage = (titanAmount * PERCENT_BASE) / titanValueInHlx;\\n\\n        return percentage;\\n    }\\n\\n    /**\\n     * @dev Records stake information for a user.\\n     * @param sId Unique identifier for the stake.\\n     * @param user Address of the user staking the tokens.\\n     * @param amount Amount of tokens staked.\\n     * @param numOfDays Duration of the stake in days.\\n     * @param shares Number of shares allocated for the stake.\\n     */\\n    function _storeUserStakesInfo(\\n        uint256 sId,\\n        address user,\\n        uint256 amount,\\n        uint256 numOfDays,\\n        uint256 shares,\\n        uint256 titanAmount\\n    ) private {\\n        uint256 currentGStakeId = ++s_globalStakeId;\\n        uint256 maturityTs;\\n\\n        maturityTs = block.timestamp + (numOfDays * SECONDS_IN_DAY);\\n\\n        UserStakeInfo memory userStakeInfo = UserStakeInfo({\\n            hlxAmount: amount,\\n            shares: shares,\\n            numOfDays: uint16(numOfDays),\\n            stakeStartTs: uint48(block.timestamp),\\n            maturityTs: uint48(maturityTs),\\n            status: StakeStatus.ACTIVE,\\n            titanBurned: titanAmount\\n        });\\n\\n        /** s_addressSId[user] tracks stake Id for each address\\n         * s_addressSIdToGlobalStakeId[user][id] tracks stack id to global stake Id\\n         * s_globalStakeIdToStakeInfo[currentGStakeId] stores stake info\\n         */\\n        s_addressSIdToGlobalStakeId[user][sId] = currentGStakeId;\\n        s_globalStakeIdToStakeInfo[currentGStakeId] = userStakeInfo;\\n\\n        emit StakeStarted(user, currentGStakeId, numOfDays, userStakeInfo);\\n    }\\n\\n    /** @dev end stake and calculate pinciple with penalties (if any) or burn stake\\n     * @param user user address\\n     * @param id stake Id\\n     * @param day current contract day\\n     * @param action end stake or burn stake\\n     * @param payOther is end stake for others\\n     * @param isPayoutTriggered has global payout triggered\\n     * @return helios helios principle\\n     */\\n    function _endStake(\\n        address user,\\n        uint256 id,\\n        uint256 day,\\n        StakeAction action,\\n        StakeAction payOther,\\n        PayoutTriggered isPayoutTriggered\\n    ) internal returns (uint256 helios) {\\n        uint256 globalStakeId = s_addressSIdToGlobalStakeId[user][id];\\n        if (globalStakeId == 0) revert Helios_NoStakeExists();\\n\\n        UserStakeInfo memory userStakeInfo = s_globalStakeIdToStakeInfo[\\n            globalStakeId\\n        ];\\n        if (userStakeInfo.status == StakeStatus.ENDED)\\n            revert Helios_StakeHasEnded();\\n        if (userStakeInfo.status == StakeStatus.BURNED)\\n            revert Helios_StakeHasBurned();\\n        //end stake for others requires matured stake to prevent EES for others\\n        if (\\n            payOther == StakeAction.END_OTHER &&\\n            block.timestamp < userStakeInfo.maturityTs\\n        ) revert Helios_StakeNotMatured();\\n\\n        //update shares changes\\n        uint256 shares = userStakeInfo.shares;\\n        _updateSharesStats(\\n            user,\\n            shares,\\n            userStakeInfo.hlxAmount,\\n            day,\\n            isPayoutTriggered,\\n            action\\n        );\\n\\n        if (action == StakeAction.END) {\\n            ++s_globalStakeEnd;\\n            s_globalStakeIdToStakeInfo[globalStakeId].status = StakeStatus\\n                .ENDED;\\n        } else if (action == StakeAction.BURN) {\\n            ++s_globalStakeBurn;\\n            s_globalStakeIdToStakeInfo[globalStakeId].status = StakeStatus\\n                .BURNED;\\n        }\\n\\n        helios = _calculatePrinciple(\\n            user,\\n            globalStakeId,\\n            userStakeInfo,\\n            action\\n        );\\n    }\\n\\n    /** @dev update shares changes to track when user shares has changed, this affect the payout calculation\\n     * @param user user address\\n     * @param shares shares\\n     * @param amount helios amount\\n     * @param day current contract day\\n     * @param isPayoutTriggered has global payout triggered\\n     * @param action start stake or end stake\\n     * @return isFirstShares first created shares or not\\n     */\\n    function _updateSharesStats(\\n        address user,\\n        uint256 shares,\\n        uint256 amount,\\n        uint256 day,\\n        PayoutTriggered isPayoutTriggered,\\n        StakeAction action\\n    ) private returns (uint256 isFirstShares) {\\n        //Get previous active shares to calculate new shares change\\n        uint256 index = s_userSharesIndex[user];\\n        uint256 previousShares = s_addressIdToActiveShares[user][index]\\n            .activeShares;\\n\\n        if (action == StakeAction.START) {\\n            //return 1 if this is a new wallet address\\n            //this is used to initialize last claim index to the latest cycle index\\n            if (index == 0) isFirstShares = 1;\\n\\n            s_addressIdToActiveShares[user][++index].activeShares =\\n                previousShares +\\n                shares;\\n            s_globalShares += shares;\\n            s_globalHlxStaked += amount;\\n        } else {\\n            s_addressIdToActiveShares[user][++index].activeShares =\\n                previousShares -\\n                shares;\\n            s_globalExpiredShares += shares;\\n            s_globalHlxStaked -= amount;\\n        }\\n\\n        //If global payout hasn't triggered, use current contract day to eligible for payout\\n        //If global payout has triggered, then start with next contract day as it's no longer eligible to claim latest payout\\n        s_addressIdToActiveShares[user][index].day = isPayoutTriggered ==\\n            PayoutTriggered.NO\\n            ? day\\n            : day + 1;\\n\\n        s_userSharesIndex[user] = index;\\n    }\\n\\n    /** @dev calculate stake principle and apply penalty (if any)\\n     * @param user user address\\n     * @param globalStakeId global stake Id\\n     * @param userStakeInfo stake info\\n     * @param action end stake or burn stake\\n     * @return principle calculated principle after penalty (if any)\\n     */\\n    function _calculatePrinciple(\\n        address user,\\n        uint256 globalStakeId,\\n        UserStakeInfo memory userStakeInfo,\\n        StakeAction action\\n    ) internal returns (uint256 principle) {\\n        uint256 hlxAmount = userStakeInfo.hlxAmount;\\n        //penalty is in percentage\\n        uint256 penalty = calculateEndStakePenalty(\\n            userStakeInfo.stakeStartTs,\\n            userStakeInfo.maturityTs,\\n            block.timestamp,\\n            action\\n        );\\n\\n        uint256 penaltyAmount;\\n        penaltyAmount = (hlxAmount * penalty) / 100;\\n        principle = hlxAmount - penaltyAmount;\\n        s_globalStakePenalty += penaltyAmount;\\n\\n        emit StakeEnded(user, globalStakeId, principle, penalty, penaltyAmount);\\n    }\\n\\n    //Views\\n    /** @notice get global shares\\n     * @return globalShares global shares\\n     */\\n    function getGlobalShares() public view returns (uint256) {\\n        return s_globalShares;\\n    }\\n\\n    /** @notice get global expired shares\\n     * @return globalExpiredShares global expired shares\\n     */\\n    function getGlobalExpiredShares() public view returns (uint256) {\\n        return s_globalExpiredShares;\\n    }\\n\\n    /** @notice get global active shares\\n     * @return globalActiveShares global active shares\\n     */\\n    function getGlobalActiveShares() public view returns (uint256) {\\n        return s_globalShares - s_globalExpiredShares;\\n    }\\n\\n    /** @notice get total helios staked\\n     * @return totalHlxStaked total helios staked\\n     */\\n    function getTotalHlxStaked() public view returns (uint256) {\\n        return s_globalHlxStaked;\\n    }\\n\\n    /** @notice get global stake id\\n     * @return globalStakeId global stake id\\n     */\\n    function getGlobalStakeId() public view returns (uint256) {\\n        return s_globalStakeId;\\n    }\\n\\n    /** @notice get global active stakes\\n     * @return globalActiveStakes global active stakes\\n     */\\n    function getGlobalActiveStakes() public view returns (uint256) {\\n        return s_globalStakeId - getTotalStakeEnd();\\n    }\\n\\n    /** @notice get total stake ended\\n     * @return totalStakeEnded total stake ended\\n     */\\n    function getTotalStakeEnd() public view returns (uint256) {\\n        return s_globalStakeEnd;\\n    }\\n\\n    /** @notice get total stake burned\\n     * @return totalStakeBurned total stake burned\\n     */\\n    function getTotalStakeBurn() public view returns (uint256) {\\n        return s_globalStakeBurn;\\n    }\\n\\n    /** @notice get total end stake penalty\\n     * @return totalEndStakePenalty total end stake penalty\\n     */\\n    function getTotalStakePenalty() public view returns (uint256) {\\n        return s_globalStakePenalty;\\n    }\\n\\n    /** @notice get user latest shares index\\n     * @return latestSharesIndex latest shares index\\n     */\\n    function getUserLatestShareIndex(\\n        address user\\n    ) public view returns (uint256) {\\n        return s_userSharesIndex[user];\\n    }\\n\\n    /** @notice get user current active shares\\n     * @return currentActiveShares current active shares\\n     */\\n    function getUserCurrentActiveShares(\\n        address user\\n    ) public view returns (uint256) {\\n        return\\n            s_addressIdToActiveShares[user][getUserLatestShareIndex(user)]\\n                .activeShares;\\n    }\\n\\n    /** @notice get user active shares at sharesIndex\\n     * @return activeShares active shares at sharesIndex\\n     */\\n    function getUserActiveShares(\\n        address user,\\n        uint256 sharesIndex\\n    ) internal view returns (uint256) {\\n        return s_addressIdToActiveShares[user][sharesIndex].activeShares;\\n    }\\n\\n    /** @notice get user active shares contract day at sharesIndex\\n     * @return activeSharesDay active shares contract day at sharesIndex\\n     */\\n    function getUserActiveSharesDay(\\n        address user,\\n        uint256 sharesIndex\\n    ) internal view returns (uint256) {\\n        return s_addressIdToActiveShares[user][sharesIndex].day;\\n    }\\n\\n    /** @notice get stake info with stake id\\n     * @return stakeInfo stake info\\n     */\\n    function getUserStakeInfo(\\n        address user,\\n        uint256 id\\n    ) public view returns (UserStakeInfo memory) {\\n        return\\n            s_globalStakeIdToStakeInfo[s_addressSIdToGlobalStakeId[user][id]];\\n    }\\n\\n    /** @notice get all stake info of an address\\n     * @return stakeInfos all stake info of an address\\n     */\\n    function getUserStakes(\\n        address user\\n    ) public view returns (UserStake[] memory) {\\n        uint256 count = s_addressSId[user];\\n        UserStake[] memory stakes = new UserStake[](count);\\n\\n        for (uint256 i = 1; i <= count; i++) {\\n            stakes[i - 1] = UserStake({\\n                sId: i,\\n                globalStakeId: s_addressSIdToGlobalStakeId[user][i],\\n                stakeInfo: getUserStakeInfo(user, i)\\n            });\\n        }\\n\\n        return stakes;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IBuynBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface IBuynBurn {\\n    function getCurrentTitanPrice() external view returns (uint256);\\n}\"\r\n    },\r\n    \"interfaces/IHlxOnBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface IHlxOnBurn {\\n    function onBurn(address user, uint256 amount) external;\\n}\"\r\n    },\r\n    \"interfaces/ITitanOnBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface ITitanOnBurn {\\n    function onBurn(address user, uint256 amount) external;\\n}\"\r\n    },\r\n    \"interfaces/ITITANX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface ITITANX {\\n\\n    // Enum for stake status\\n    enum StakeStatus {\\n        ACTIVE,\\n        ENDED,\\n        BURNED\\n    }\\n\\n    // Struct for user stake information\\n    struct UserStakeInfo {\\n        uint152 titanAmount;\\n        uint128 shares;\\n        uint16 numOfDays;\\n        uint48 stakeStartTs;\\n        uint48 maturityTs;\\n        StakeStatus status;\\n    }\\n\\n    struct UserStake {\\n        uint256 sId;\\n        uint256 globalStakeId;\\n        UserStakeInfo stakeInfo;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function getBalance() external;\\n\\n    function mintLPTokens() external;\\n\\n    function burnLPTokens() external;\\n\\n    function startStake(uint256 amount, uint256 numOfDays) external;\\n\\n    function endStake(uint256 id) external;\\n\\n    function claimUserAvailableETHPayouts() external;\\n     \\n    function burnTokensToPayAddress(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) external;\\n\\n    /** @notice get stake info with stake id\\n     * @return stakeInfo stake info\\n     */\\n    function getUserStakeInfo(\\n        address user,\\n        uint256 id\\n    ) external view returns (UserStakeInfo memory);\\n\\n    /**\\n     * @notice Calculates the total ETH claimable by a user for all cycles.\\n     * @dev This function sums up the rewards from various cycles based on user shares.\\n     * @param user The address of the user for whom to calculate the claimable ETH.\\n     * @return reward The total ETH reward claimable by the user.\\n     */\\n    function getUserETHClaimableTotal(\\n        address user\\n    ) external view returns (uint256 reward);\\n\\n    /**\\n     * @notice Get all stake info of a given user address.\\n     * @param user The address of the user to query stake information for.\\n     * @return An array of UserStake structs containing all stake info for the given address.\\n     */\\n    function getUserStakes(\\n        address user\\n    ) external view returns (UserStake[] memory);\\n\\n    /**\\n     * @notice Trigger cycle payouts for days 8, 28, 90, 369, 888, including the burn reward cycle 28.\\n     * Payouts can be triggered on or after the maturity day of each cycle (e.g., Cycle8 on day 8).\\n     */\\n    function triggerPayouts() external;\\n}\\n\"\r\n    },\r\n    \"libs/calcFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./constant.sol\\\";\\nimport \\\"./enum.sol\\\";\\n\\n/** @notice get mint cost\\n * @param mintPower mint power (1 - 100)\\n * @param mintCost cost of mint\\n * @return mintCost total mint cost\\n */\\nfunction getMintCost(\\n    uint256 mintPower,\\n    uint256 mintCost\\n) pure returns (uint256) {\\n    return (mintCost * mintPower) / MAX_MINT_POWER_CAP;\\n}\\n\\n//MintInfo\\n\\n/** @notice the formula to calculate mint reward at create new mint\\n * @param mintPower mint power 1 - 100,000\\n * @param numOfDays mint length 1 - 250\\n * @param mintableHlx current contract day mintable helios\\n * @param EAABonus current contract day EAA Bonus\\n * @param burnAmpBonus user burn amplifier bonus from getUserBurnAmplifierBonus(user)\\n * @return reward base helios amount\\n */\\nfunction calculateMintReward(\\n    uint256 mintPower,\\n    uint256 numOfDays,\\n    uint256 mintableHlx,\\n    uint256 EAABonus,\\n    uint256 burnAmpBonus,\\n    uint256 percentageBonus\\n) pure returns (uint256 reward) {\\n    uint256 baseReward = (mintableHlx * mintPower * numOfDays);\\n    if (numOfDays != 1)\\n        baseReward -= (baseReward * MINT_DAILY_REDUCTION * (numOfDays - 1)) / PERCENT_BPS;\\n\\n    reward = baseReward;\\n    if (EAABonus != 0) {\\n        //EAA Bonus has 1e6 scaling, so here divide by 1e6\\n        reward += ((baseReward * EAABonus) / 100 / SCALING_FACTOR_1e6);\\n    }\\n\\n    if (burnAmpBonus != 0) {\\n        //burnAmpBonus has 1e18 scaling\\n        reward += (baseReward * burnAmpBonus) / 100 / SCALING_FACTOR_1e18;\\n    }\\n\\n    // Apply the percentage bonus\\n    if (percentageBonus != 0) {\\n        \\n        percentageBonus = percentageBonus > BURN_MINT_AMP ? BURN_MINT_AMP : percentageBonus;\\n        // Convert the bonus to a percentage (1000 represents 10%, so divide by 10000)\\n        uint256 additionalReward = (reward * percentageBonus) / 10000;\\n        reward += additionalReward;\\n    }\\n\\n    reward /= MAX_MINT_POWER_CAP;\\n}\\n\\n/** @notice the formula to calculate bonus reward\\n * heavily influenced by the difference between current global mint power and user mint's global mint power\\n * @param mintPowerBonus mint power bonus from mintinfo\\n * @param mintPower mint power 1 - 100,000 from mintinfo\\n * @param gMintPower global mint power from mintinfo\\n * @param globalMintPower current global mint power\\n * @return bonus bonus amount in helios\\n */\\nfunction calculateMintPowerBonus(\\n    uint256 mintPowerBonus,\\n    uint256 mintPower,\\n    uint256 gMintPower,\\n    uint256 globalMintPower\\n) pure returns (uint256 bonus) {\\n    if (globalMintPower <= gMintPower) return 0;\\n    bonus = (((mintPowerBonus * mintPower * (globalMintPower - gMintPower)) * SCALING_FACTOR_1e18) /\\n        MAX_MINT_POWER_CAP);\\n}\\n\\n/** @notice Return max mint length\\n * @return maxMintLength max mint length\\n */\\nfunction getMaxMintDays() pure returns (uint256) {\\n    return MAX_MINT_LENGTH;\\n}\\n\\n/** @notice Return max mints per wallet\\n * @return maxMintPerWallet max mints per wallet\\n */\\nfunction getMaxMintsPerWallet() pure returns (uint256) {\\n    return MAX_MINT_PER_WALLET;\\n}\\n\\n/**\\n * @dev Return penalty percentage based on number of days late after the grace period of 7 days\\n * @param secsLate seconds late (block timestamp - maturity timestamp)\\n * @return penalty penalty in percentage\\n */\\nfunction calculateClaimMintPenalty(uint256 secsLate) pure returns (uint256 penalty) {\\n    if (secsLate <= CLAIM_MINT_GRACE_PERIOD * SECONDS_IN_DAY) return 0;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 1) * SECONDS_IN_DAY) return 1;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 2) * SECONDS_IN_DAY) return 3;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 3) * SECONDS_IN_DAY) return 8;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 4) * SECONDS_IN_DAY) return 17;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 5) * SECONDS_IN_DAY) return 35;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 6) * SECONDS_IN_DAY) return 72;\\n    return 99;\\n}\\n\\n//StakeInfo\\n\\nerror Helios_AtLeastHalfMaturity();\\n\\n/** @notice get max stake length\\n * @return maxStakeLength max stake length\\n */\\nfunction getMaxStakeLength() pure returns (uint256) {\\n    return MAX_STAKE_LENGTH;\\n}\\n\\n/** @notice calculate shares and shares bonus\\n * @param amount helios amount\\n * @param noOfDays stake length\\n * @param shareRate current contract share rate\\n * @return shares calculated shares in 18 decimals\\n */\\nfunction calculateShares(\\n    uint256 amount,\\n    uint256 noOfDays,\\n    uint256 shareRate\\n) pure returns (uint256) {\\n    uint256 shares = amount;\\n    shares += (shares * calculateShareBonus(noOfDays)) / SCALING_FACTOR_1e11;\\n    shares /= (shareRate / SCALING_FACTOR_1e18);\\n    return shares;\\n}\\n\\n/** @notice calculate share bonus\\n * @param noOfDays stake length\\n * @return shareBonus calculated shares bonus in 11 decimals\\n */\\nfunction calculateShareBonus(uint256 noOfDays) pure returns (uint256 shareBonus) {\\n    if (noOfDays <= MIN_STAKE_LENGTH) {\\n        \\n        return SCALING_FACTOR_1e6; // no bonus\\n    }\\n\\n    uint256 effectiveDays = noOfDays - MIN_STAKE_LENGTH;\\n    uint256 cappedEffectiveDays = effectiveDays <= (LPB_MAX_DAYS - MIN_STAKE_LENGTH) ? effectiveDays : (LPB_MAX_DAYS - MIN_STAKE_LENGTH);\\n    shareBonus = ((cappedEffectiveDays * SCALING_FACTOR_1e11) / LPB_PER_PERCENT);\\n    return shareBonus;\\n}\\n\\n\\n/** @notice calculate end stake penalty\\n * @param stakeStartTs start stake timestamp\\n * @param maturityTs  maturity timestamp\\n * @param currentBlockTs current block timestamp\\n * @param action end stake or burn stake\\n * @return penalty penalty in percentage\\n */\\nfunction calculateEndStakePenalty(\\n    uint256 stakeStartTs,\\n    uint256 maturityTs,\\n    uint256 currentBlockTs,\\n    StakeAction action\\n) view returns (uint256) {\\n    //Matured, then calculate and return penalty\\n    if (currentBlockTs >= maturityTs) {\\n        uint256 lateSec = currentBlockTs - maturityTs;\\n        uint256 gracePeriodSec = END_STAKE_GRACE_PERIOD * SECONDS_IN_DAY;\\n        if (lateSec <= gracePeriodSec) return 0;\\n        return max((min((lateSec - gracePeriodSec), 1) / SECONDS_IN_DAY) + 1, 99);\\n    }\\n\\n    //burn stake is excluded from penalty\\n    //if not matured and action is burn stake then return 0\\n    if (action == StakeAction.BURN) return 0;\\n\\n    //Emergency End Stake\\n    //Not allow to EES below 50% maturity\\n    if (block.timestamp < stakeStartTs + (maturityTs - stakeStartTs) / 2)\\n        revert Helios_AtLeastHalfMaturity();\\n\\n    //50% penalty for EES before maturity timestamp\\n    return 50;\\n}\\n\\n//a - input to check against b\\n//b - minimum number\\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\\n    if (a > b) return a;\\n    return b;\\n}\\n\\n//a - input to check against b\\n//b - maximum number\\nfunction max(uint256 a, uint256 b) pure returns (uint256) {\\n    if (a > b) return b;\\n    return a;\\n}\"\r\n    },\r\n    \"libs/constant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/ITitanOnBurn.sol\\\";\\n\\n\\n// ===================== common ==========================================\\nuint256 constant SECONDS_IN_DAY = 86400;\\nuint256 constant SCALING_FACTOR_1e3 = 1e3;\\nuint256 constant SCALING_FACTOR_1e6 = 1e6;\\nuint256 constant SCALING_FACTOR_1e7 = 1e7;\\nuint256 constant SCALING_FACTOR_1e11 = 1e11;\\nuint256 constant SCALING_FACTOR_1e18 = 1e18;\\n\\n// ===================== Helios ==========================================\\nuint256 constant PERCENT_TO_BUY_AND_BURN_FINAL = 0;\\nuint256 constant PERCENT_TO_CYCLE_PAYOUTS = 28_00;\\nuint256 constant PERCENT_TO_TREASURY_FINAL = 70_00;\\nuint256 constant PERCENT_CHANGE = 50;\\nuint256 constant PERCENT_TO_GENESIS = 2_00;\\n\\nuint256 constant INCENTIVE_FEE_PERCENT = 3_000; //0.3%  \\nuint256 constant INCENTIVE_FEE_PERCENT_BASE = 1_000_000;\\n\\nuint256 constant INITAL_LP_TOKENS = 1_600_000_000 ether; \\n\\n// ===================== globalInfo ==========================================\\n//Helios Supply Variables\\nuint256 constant START_MAX_MINTABLE_PER_DAY = 4_200_000_000 ether;\\nuint256 constant CAPPED_MIN_DAILY_HLX_MINTABLE = 420_000 ether;\\nuint256 constant DAILY_SUPPLY_MINTABLE_REDUCTION = 99_65;\\n\\n\\n//10% - 0% linear for 69 days\\n//EAA Variables\\nuint256 constant EAA_START = 10 * SCALING_FACTOR_1e6;\\nuint256 constant EAA_BONUSE_FIXED_REDUCTION_PER_DAY = 144_927;\\nuint256 constant EAA_END = 0;\\nuint256 constant MAX_BONUS_DAY = 69;\\n\\n//Mint Cost Variables\\nuint256 constant START_MAX_MINT_COST = 420_000_000_000 ether;\\nuint256 constant CAPPED_MAX_MINT_COST = 2_000_000_000_000 ether;\\nuint256 constant DAILY_MINT_COST_INCREASE_STEP = 100_10;//0.1%\\n\\n// 1000 to 0.1 HLX -0.35% Daily\\n//mintPower Bonus Variables\\nuint256 constant START_MINTPOWER_INCREASE_BONUS = 10_000 * SCALING_FACTOR_1e7; //starts at 10_000 with 1e7 scaling factor\\nuint256 constant CAPPED_MIN_MINTPOWER_BONUS = 10_000 * SCALING_FACTOR_1e3; //capped min of 0.1 * 1e7 = 10_000 * 1e3\\nuint256 constant DAILY_MINTPOWER_INCREASE_BONUS_REDUCTION = 99_65;\\n\\n//Share Rate Variables\\nuint256 constant START_SHARE_RATE = 420 ether;\\n\\n//Cycle Variables\\nuint256 constant DAY22 = 22;\\nuint256 constant DAY69 = 69;\\nuint256 constant DAY420 = 420;\\nuint256 constant CYCLE_22_PERCENT = 35_00;\\nuint256 constant CYCLE_69_PERCENT = 30_00;\\nuint256 constant CYCLE_420_PERCENT = 35_00;\\nuint256 constant PERCENT_BPS = 100_00;\\n\\n// ===================== mintInfo ==========================================\\nuint256 constant MAX_MINT_POWER_CAP = 100_000;\\nuint256 constant MAX_MINT_LENGTH = 250;\\nuint256 constant CLAIM_MINT_GRACE_PERIOD = 7;\\nuint256 constant MAX_MINT_PER_WALLET = 1000;\\nuint256 constant MAX_BURN_AMP_BASE = 80 * 1e9 * 1 ether;\\nuint256 constant MAX_BURN_AMP_PERCENT = 8 ether;\\nuint256 constant MINT_DAILY_REDUCTION = 11; \\n\\n// ===================== stakeInfo ==========================================\\nuint256 constant MAX_STAKE_PER_WALLET = 1000;\\nuint256 constant MIN_STAKE_LENGTH = 30;\\nuint256 constant MAX_STAKE_LENGTH = 830;\\nuint256 constant END_STAKE_GRACE_PERIOD = 7;\\n\\n\\n\\n// 0%-200% linear 1-830 days\\n/* Stake Longer Pays Better bonus */\\nuint256 constant LPB_MAX_DAYS = 830;\\nuint256 constant LPB_PER_PERCENT = 400;\\n\\n//20%\\n/* Burn Stake Amplifier */\\nuint256 constant BURN_STAKE_AMP = 2000;\\n\\n//10% \\n/* Burn Mint Amplifier */\\nuint256 constant BURN_MINT_AMP = 1000;\\n\\n\\n// ===================== burnInfo ==========================================\\nuint256 constant MAX_BURN_REWARD_PERCENT = 8;\\n\\n// ===================== Treasury ==========================================\\nuint256 constant PERCENT_TO_STAKERS = 10_00;\\nuint256 constant PERCENT_TO_BUYANDBURNHELIOS = 70_00;\\nuint16 constant STAKE_DURATION = 3500;\\n\\nuint24 constant POOLFEE1PERCENT = 10000; //1% Fee\\nuint160 constant MIN_SQRT_RATIO = 4295128739;\\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\naddress constant TITANX = 0xF19308F923582A6f7c465e5CE7a9Dc1BEC6665B1;\\naddress constant UNISWAPV3FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\naddress constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\naddress constant TITANX_WETH_POOL = 0xc45A81BC23A64eA556ab4CdF08A86B61cdcEEA8b;\\naddress constant NONFUNGIBLEPOSITIONMANAGER = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\\n\\nuint8 constant BURN_REWARD_PERCENT_EACH = 4;\\n\\nuint256 constant TREASURY_INCENTIVE_FEE_PERCENT = 1000;\\n\\nuint256 constant INCENTIVE_FEE_CAP_ETH = 0.1 ether;\\n\\nuint256 constant PERCENT_BASE = 10_000;\\n\\n/*\\n    bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n*/\\nbytes4 constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n// ERC-165 Interface ID for ITitanOnBurn\\nbytes4 constant INTERFACE_ID_ITITANONBURN =\\n    type(ITitanOnBurn).interfaceId;\\n\"\r\n    },\r\n    \"libs/enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nenum MintAction {\\n    CLAIM,\\n    BURN\\n}\\nenum MintStatus {\\n    ACTIVE,\\n    CLAIMED,\\n    BURNED\\n}\\nenum StakeAction {\\n    START,\\n    END,\\n    BURN,\\n    END_OWN,\\n    END_OTHER\\n}\\nenum StakeStatus {\\n    ACTIVE,\\n    ENDED,\\n    BURNED\\n}\\nenum PayoutTriggered {\\n    NO,\\n    YES\\n}\\nenum InitialLPMinted {\\n    NO,\\n    YES\\n}\\nenum PayoutClaim {\\n    SHARES,\\n    BURN\\n}\\nenum BurnSource {\\n    LIQUID,\\n    MINT,\\n    STAKE\\n}\\nenum BurnPoolEnabled {\\n    FALSE,\\n    TRUE\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"genesisAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyAndBurnAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"titanxAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investmentAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Helios_AtLeastHalfMaturity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_EmptyUndistributeFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_FailedToSendAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InsufficientBurnAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidBurnRewardPercent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidMintLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidMintPower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_InvalidStakeLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_LPTokensHasMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_MaxedWalletMints\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_MaxedWalletStakes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_MintHasBurned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_MintHasClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_MintNotMature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NoCycleRewardToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NoMintExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NoSharesExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NoStakeExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NotOnwer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_NotSupportedContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_OnlyBuyAndBurn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_RequireOneMinimumShare\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_StakeHasBurned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_StakeHasEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helios_StakeNotMatured\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveBurnMints\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveBurnStakes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CyclePayoutTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mintCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintableHlx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPowerBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"EAABonus\",\"type\":\"uint256\"}],\"name\":\"GlobalDailyUpdateStats\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum BurnSource\",\"name\":\"helioSource\",\"type\":\"uint8\"}],\"name\":\"HlxBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hRank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPenalty\",\"type\":\"uint256\"}],\"name\":\"MintClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hRank\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gMintpower\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"mintableHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"mintPowerBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EAABonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"userMintInfo\",\"type\":\"tuple\"}],\"name\":\"MintStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeRecevied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethReward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hlxAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"hlxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"userStakeInfo\",\"type\":\"tuple\"}],\"name\":\"StakeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TitanXDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceBurnMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceBurnStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveBurnMints\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveBurnStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnLPTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burnMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"}],\"name\":\"burnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardPaybackAddress\",\"type\":\"address\"}],\"name\":\"burnStakeToPayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardPaybackAddress\",\"type\":\"address\"}],\"name\":\"burnTokensToPayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"calculateUserCycleReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userClaimCycleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userClaimSharesIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claimMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUserAvailablePayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeTitanX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"endStakeForOthers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintId\",\"type\":\"uint256\"}],\"name\":\"estimateMintReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"}],\"name\":\"estimateShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesWithBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesWithoutBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuynBurnPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBlockTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentContractDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getCurrentCycleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEAABonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintPowerBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintableHlx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentShareRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getCyclePayoutPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getETHCyclePayoutPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getETHPayoutPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenesisAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalActiveShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalActiveStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalExpiredShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalHRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalMintPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalPayoutTriggered\",\"outputs\":[{\"internalType\":\"enum PayoutTriggered\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalStakeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHlxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInvestmentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanToBurn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMintableHlx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getNextCyclePayoutDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPayoutPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getProjectBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProjectUserBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"noOfDays\",\"type\":\"uint256\"}],\"name\":\"getShareBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTitanXBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalActiveMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalHlxStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMinting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakeBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakeEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTitanXBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasuryPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUndistributedETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUndistributedTitanX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBurnAmplifierBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserCurrentActiveShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserETHClaimableTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getUserLastClaimIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLatestMintId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLatestShareIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserMintInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"mintableHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"mintPowerBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EAABonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"mintInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMints\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gMintPower\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"mintableHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"mintPowerBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EAABonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedHlx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"mintInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct MintInfo.UserMint[]\",\"name\":\"mintInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"hlxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"hlxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"titanBurned\",\"type\":\"uint256\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"stakeInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct StakeInfo.UserStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTitanXClaimableTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailyUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintLPTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setBuyAndBurnContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setNewGenesisAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setNewInvestmentAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setTitanXContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setTreasuryContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanToBurn\",\"type\":\"uint256\"}],\"name\":\"startMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"titanToBurn\",\"type\":\"uint256\"}],\"name\":\"startStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"userBurnMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"userBurnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userBurnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"permit\",\"type\":\"bool\"}],\"name\":\"whiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HELIOS", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "0000000000000000000000006c3c3a22ab3725c017d41d31b23efaf51a8ece480000000000000000000000009bff9f810d19cdb4bf7701c9d5ad101e91cda08d000000000000000000000000f19308f923582a6f7c465e5ce7a9dc1bec6665b1000000000000000000000000a2d21205aa7273baddfc8e9551e05e23bb49ce4600000000000000000000000015e5b9b9adf208cc7ca3ae1e6a49506eb5f397dd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}