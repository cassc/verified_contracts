{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/QDistributor.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IV3Oracle.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./interfaces/IV2Oracle.sol\\\";\\nimport \\\"./interfaces/ILPGateway.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\n\\ncontract QDistributor {\\n    error GotNothing();\\n    error NotGovernance();\\n    error FailedToSend();\\n    error SumNot10000();\\n\\n    event Received(\\n        address from, uint256 ethAmount, uint256 amountToVault, uint256 amountToProtocol, uint256 amountToLP\\n    );\\n    event SentToProtocol(uint256 amount);\\n    event SentToVault(uint256 amount);\\n    event AddedLP(uint256 amount);\\n    event UpdatedPercentages(uint256 vaultPercentage, uint256 protocolPercentage, uint256 lpPercentage);\\n    event UpdatedMaxSlippage(uint256 maxSlippageForETHDXNSwap, uint256 maxSlippageForDXNNXDSwap);\\n    event UpdatedLPGateway(address lpGateway);\\n    event UpdatedGovernance(address governance);\\n\\n    uint256 public constant PERCENTAGE_DIVISOR = 10000;\\n    address public constant nxdStakingVault = 0xa1B56E42137D06280E34B3E1352d80Ac3BECAF79;\\n    address public constant nxdProtocol = 0xE05430D42842C7B757E5633D19ca65350E01aE11;\\n\\n    uint256 public vaultPercentage = 3334;\\n    uint256 public protocolPercentage = 3333;\\n    uint256 public lpPercentage = 3333;\\n\\n    uint256 public pendingAmountVault;\\n    uint256 public pendingAmountProtocol;\\n    uint256 public pendingAmountLP;\\n\\n    address public governance;\\n\\n    ISwapRouter public constant UNISWAP_V3_ROUTER = ISwapRouter(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564));\\n\\n    address public constant DXN_WETH_POOL = 0x7F808fD904FFA3eb6A6F259e6965Fb1466A05372;\\n    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    IERC20 public constant dxn = IERC20(0x80f0C1c49891dcFDD40b6e0F960F84E6042bcB6F);\\n    IERC20 public constant nxd = IERC20(0x70536D44820fE3ddd4A2e3eEdbC937b8B9D566C7);\\n\\n    IUniswapV2Router02 public constant UNISWAP_V2_ROUTER =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n    IV3Oracle public constant v3Oracle = IV3Oracle(0x21c6e0427fb2bA0E827253f48241aAbDd8051eAa);\\n    IUniswapV2Pair constant nxdDXNPair = IUniswapV2Pair(0x98134CDE70ff7280bb4b9f4eBa2154009f2C13aC);\\n    IV2Oracle public constant v2Oracle = IV2Oracle(0x14D558267A97c7a61554d7F7b23a594781E04495);\\n\\n    uint256 public maxSlippageForETHDXNSwap = 300; // 3%\\n    uint256 public maxSlippageForDXNNXDSwap = 300; // 3%\\n\\n    ILPGateway public lpGateway;\\n\\n    constructor(address _lpGateway) {\\n        governance = msg.sender;\\n        lpGateway = ILPGateway(_lpGateway);\\n    }\\n\\n    function setLPGateway(address _lpGateway) public {\\n        if (msg.sender != governance) {\\n            revert NotGovernance();\\n        }\\n        lpGateway = ILPGateway(_lpGateway);\\n        emit UpdatedLPGateway(_lpGateway);\\n    }\\n\\n    function setMaxSlippageForSwap(uint256 _maxSlippageForETHDXNSwap, uint256 _maxSlippageForDXNNXDSwap) public {\\n        if (msg.sender != governance) {\\n            revert NotGovernance();\\n        }\\n        maxSlippageForETHDXNSwap = _maxSlippageForETHDXNSwap;\\n        maxSlippageForDXNNXDSwap = _maxSlippageForDXNNXDSwap;\\n        emit UpdatedMaxSlippage(_maxSlippageForETHDXNSwap, _maxSlippageForDXNNXDSwap);\\n    }\\n\\n    function setGovernance(address _governance) public {\\n        if (msg.sender != governance) {\\n            revert NotGovernance();\\n        }\\n        governance = _governance;\\n        emit UpdatedGovernance(_governance);\\n    }\\n\\n    function sendToVault() public {\\n        uint256 amount = pendingAmountVault;\\n        pendingAmountVault = 0;\\n        (bool sent,) = nxdStakingVault.call{value: amount}(\\\"\\\");\\n        if (!sent) {\\n            revert FailedToSend();\\n        }\\n        emit SentToVault(amount);\\n    }\\n\\n    function sendToProtocol(uint256 amount) public {\\n        if (amount > pendingAmountProtocol) {\\n            amount = pendingAmountProtocol;\\n        }\\n        pendingAmountProtocol -= amount;\\n        (bool sent,) = nxdProtocol.call{value: amount}(\\\"\\\");\\n        if (!sent) {\\n            revert FailedToSend();\\n        }\\n        emit SentToProtocol(amount);\\n    }\\n\\n    function addLP(uint256 amount) public {\\n        if (amount > pendingAmountLP) {\\n            amount = pendingAmountLP;\\n        }\\n        pendingAmountLP -= amount;\\n\\n        // Sell 50% of the ETH for DXN\\n        uint256 quote = v3Oracle.getHumanQuote(DXN_WETH_POOL, 5 minutes, 1 ether, WETH9, address(dxn));\\n        uint256 minOut = (amount * quote) / 1e18;\\n        // slippage tolerance\\n        minOut = (minOut * (10000 - maxSlippageForETHDXNSwap)) / 10000;\\n        UNISWAP_V3_ROUTER.exactInputSingle{value: amount}(\\n            ISwapRouter.ExactInputSingleParams(\\n                WETH9, address(dxn), 10000, address(this), block.timestamp, amount, minOut, 0\\n            )\\n        );\\n\\n        uint256 dxnPriceInEth = (1e18 * 1 ether) / quote;\\n        uint256 dxnAmountToAdd = (amount / 2) * 1e18 / dxnPriceInEth;\\n        uint256 dxnToSwapForNXD = dxn.balanceOf(address(this)) - dxnAmountToAdd;\\n\\n        if (v2Oracle.canUpdate()) {\\n            v2Oracle.update();\\n        }\\n        // Buy NXD with remaining DXN\\n        uint256 amountOutMin = v2Oracle.consult(address(dxn), dxnToSwapForNXD);\\n        // slippage tolerance\\n        amountOutMin = (amountOutMin * (10000 - maxSlippageForDXNNXDSwap)) / 10000;\\n        address[] memory path = new address[](2);\\n        path[0] = address(dxn);\\n        path[1] = address(nxd);\\n\\n        dxn.approve(address(UNISWAP_V2_ROUTER), dxnToSwapForNXD);\\n\\n        uint256[] memory amounts = UNISWAP_V2_ROUTER.swapExactTokensForTokens(\\n            dxnToSwapForNXD, amountOutMin, path, address(this), block.timestamp\\n        );\\n        if (amounts[1] == 0) {\\n            revert GotNothing();\\n        }\\n\\n        dxn.approve(address(lpGateway), dxn.balanceOf(address(this)));\\n        nxd.approve(address(lpGateway), nxd.balanceOf(address(this)));\\n\\n        lpGateway.addLiquidity(\\n            address(dxn),\\n            nxd.balanceOf(address(this)),\\n            dxn.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        emit AddedLP(amount);\\n    }\\n\\n    function setPercentages(uint256 _vaultPercentage, uint256 _protocolPercentage, uint256 _lpPercentage) public {\\n        if (msg.sender != governance) {\\n            revert NotGovernance();\\n        }\\n        if (_vaultPercentage + _protocolPercentage + _lpPercentage != PERCENTAGE_DIVISOR) {\\n            revert SumNot10000();\\n        }\\n        vaultPercentage = _vaultPercentage;\\n        protocolPercentage = _protocolPercentage;\\n        lpPercentage = _lpPercentage;\\n        emit UpdatedPercentages(_vaultPercentage, _protocolPercentage, _lpPercentage);\\n    }\\n\\n    receive() external payable {\\n        uint256 amount = address(this).balance;\\n\\n        uint256 amountToVault = (amount * vaultPercentage) / PERCENTAGE_DIVISOR;\\n        uint256 amountToProtocol = (amount * protocolPercentage) / PERCENTAGE_DIVISOR;\\n        uint256 amountToLP = (amount * lpPercentage) / PERCENTAGE_DIVISOR;\\n\\n        pendingAmountVault += amountToVault;\\n        pendingAmountProtocol += amountToProtocol;\\n        pendingAmountLP += amountToLP;\\n        emit Received(msg.sender, amount, amountToVault, amountToProtocol, amountToLP);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IV3Oracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IV3Oracle {\\n    function getHumanQuote(\\n        address uniswapV3Pool,\\n        uint32 secondsAgo,\\n        uint128 baseAmount,\\n        address baseToken,\\n        address quoteToken\\n    ) external view returns (uint256 quoteAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IV2Oracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IV2Oracle {\\n    function update() external;\\n\\n    // note this will always return 0 before update has been called successfully for the first time.\\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n    function canUpdate() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILPGateway.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface ILPGateway {\\n    function addLiquidity(\\n        address tokenB,\\n        uint256 amountNXDDesired,\\n        uint256 amountBDesired,\\n        uint256 amountNXDMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n}\\n\"\r\n    },\r\n    \"lib/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external returns (address);\\n\\n    function WETH() external returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountOut);\\n\\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"@uniswap/lib/=lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"abdk-libraries-solidity/=lib/abdk-libraries-solidity/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"base64-sol/=lib/base64/\",\r\n      \"base64/=lib/base64/\",\r\n      \"solidity-lib/=lib/solidity-lib/contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpGateway\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedToSend\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GotNothing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SumNot10000\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddedLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToVault\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToProtocol\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToLP\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SentToProtocol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SentToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"UpdatedGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpGateway\",\"type\":\"address\"}],\"name\":\"UpdatedLPGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSlippageForETHDXNSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSlippageForDXNNXDSwap\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxSlippage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpPercentage\",\"type\":\"uint256\"}],\"name\":\"UpdatedPercentages\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DXN_WETH_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V2_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_ROUTER\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH9\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dxn\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpGateway\",\"outputs\":[{\"internalType\":\"contract ILPGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippageForDXNNXDSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippageForETHDXNSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nxd\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nxdProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nxdStakingVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAmountLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAmountProtocol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAmountVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpGateway\",\"type\":\"address\"}],\"name\":\"setLPGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippageForETHDXNSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSlippageForDXNNXDSwap\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippageForSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpPercentage\",\"type\":\"uint256\"}],\"name\":\"setPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2Oracle\",\"outputs\":[{\"internalType\":\"contract IV2Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v3Oracle\",\"outputs\":[{\"internalType\":\"contract IV3Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QDistributor", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f4ef460478240ee5b398cf2994a42cb3d061922", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}