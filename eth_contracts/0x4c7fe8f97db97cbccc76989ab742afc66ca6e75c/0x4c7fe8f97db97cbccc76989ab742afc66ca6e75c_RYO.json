{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/governance/TimelockController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/TimelockController.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {AccessControl} from \\\"../access/AccessControl.sol\\\";\\nimport {ERC721Holder} from \\\"../token/ERC721/utils/ERC721Holder.sol\\\";\\nimport {ERC1155Holder} from \\\"../token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport {Address} from \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n */\\ncontract TimelockController is AccessControl, ERC721Holder, ERC1155Holder {\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    bytes32 public constant CANCELLER_ROLE = keccak256(\\\"CANCELLER_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    mapping(bytes32 id => uint256) private _timestamps;\\n    uint256 private _minDelay;\\n\\n    enum OperationState {\\n        Unset,\\n        Waiting,\\n        Ready,\\n        Done\\n    }\\n\\n    /**\\n     * @dev Mismatch between the parameters length for an operation call.\\n     */\\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\\n\\n    /**\\n     * @dev The schedule operation doesn't meet the minimum delay.\\n     */\\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\\n\\n    /**\\n     * @dev The current state of an operation is not as required.\\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\\n     * counting from right to left.\\n     *\\n     * See {_encodeStateBitmap}.\\n     */\\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\\n\\n    /**\\n     * @dev The predecessor to an operation not yet done.\\n     */\\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\\n\\n    /**\\n     * @dev The caller account is not authorized.\\n     */\\n    error TimelockUnauthorizedCaller(address caller);\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(\\n        bytes32 indexed id,\\n        uint256 indexed index,\\n        address target,\\n        uint256 value,\\n        bytes data,\\n        bytes32 predecessor,\\n        uint256 delay\\n    );\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\\n     */\\n    event CallSalt(bytes32 indexed id, bytes32 salt);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    /**\\n     * @dev Initializes the contract with the following parameters:\\n     *\\n     * - `minDelay`: initial minimum delay in seconds for operations\\n     * - `proposers`: accounts to be granted proposer and canceller roles\\n     * - `executors`: accounts to be granted executor role\\n     * - `admin`: optional account to be granted admin role; disable with zero address\\n     *\\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\\n     * without being subject to delay, but this role should be subsequently renounced in favor of\\n     * administration through timelocked proposals. Previous versions of this contract would assign\\n     * this admin to the deployer automatically and should be renounced as well.\\n     */\\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) {\\n        // self administration\\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\\n\\n        // optional admin\\n        if (admin != address(0)) {\\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        }\\n\\n        // register proposers and cancellers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _grantRole(PROPOSER_ROLE, proposers[i]);\\n            _grantRole(CANCELLER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _grantRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        _minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRoleOrOpenRole(bytes32 role) {\\n        if (!hasRole(role, address(0))) {\\n            _checkRole(role, _msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns whether an id corresponds to a registered operation. This\\n     * includes both Waiting, Ready, and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) != OperationState.Unset;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not. Note that a \\\"pending\\\" operation may also be \\\"ready\\\".\\n     */\\n    function isOperationPending(bytes32 id) public view returns (bool) {\\n        OperationState state = getOperationState(id);\\n        return state == OperationState.Waiting || state == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready for execution. Note that a \\\"ready\\\" operation is also \\\"pending\\\".\\n     */\\n    function isOperationReady(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Done;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\\n        return _timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns operation state.\\n     */\\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\\n        uint256 timestamp = getTimestamp(id);\\n        if (timestamp == 0) {\\n            return OperationState.Unset;\\n        } else if (timestamp == _DONE_TIMESTAMP) {\\n            return OperationState.Done;\\n        } else if (timestamp > block.timestamp) {\\n            return OperationState.Waiting;\\n        } else {\\n            return OperationState.Ready;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256) {\\n        return _minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\\n        }\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to become valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        if (isOperation(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\\n        }\\n        uint256 minDelay = getMinDelay();\\n        if (delay < minDelay) {\\n            revert TimelockInsufficientDelay(delay, minDelay);\\n        }\\n        _timestamps[id] = block.timestamp + delay;\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'canceller' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\\n        if (!isOperationPending(id)) {\\n            revert TimelockUnexpectedOperationState(\\n                id,\\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\\n            );\\n        }\\n        delete _timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata payload,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        _execute(target, value, payload);\\n        emit CallExecuted(id, 0, target, value, payload);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function executeBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            address target = targets[i];\\n            uint256 value = values[i];\\n            bytes calldata payload = payloads[i];\\n            _execute(target, value, payload);\\n            emit CallExecuted(id, i, target, value, payload);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     */\\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        Address.verifyCallResult(success, returndata);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\\n            revert TimelockUnexecutedPredecessor(predecessor);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        _timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        address sender = _msgSender();\\n        if (sender != address(this)) {\\n            revert TimelockUnauthorizedCaller(sender);\\n        }\\n        emit MinDelayChange(_minDelay, newDelay);\\n        _minDelay = newDelay;\\n    }\\n\\n    /**\\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\\n     * the underlying position in the `OperationState` enum. For example:\\n     *\\n     * 0x000...1000\\n     *   ^^^^^^----- ...\\n     *         ^---- Done\\n     *          ^--- Ready\\n     *           ^-- Waiting\\n     *            ^- Unset\\n     */\\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\\n        return bytes32(1 << uint8(operationState));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165, ERC165} from \\\"../../../utils/introspection/ERC165.sol\\\";\\nimport {IERC1155Receiver} from \\\"../IERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n */\\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys a `value` amount of tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 value) public virtual {\\n        _burn(_msgSender(), value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n     * the caller's allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `value`.\\n     */\\n    function burnFrom(address account, uint256 value) public virtual {\\n        _spendAllowance(account, _msgSender(), value);\\n        _burn(account, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\\n * {IERC721-setApprovalForAll}.\\n */\\nabstract contract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AdvisorsSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"./MerkleTokenUnlockSchedule.sol\\\";\\n\\ncontract AdvisorsSchedule is MerkleTokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address _timelockController\\n    ) MerkleTokenUnlockSchedule(_timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 333));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 667));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1000));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1333));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 1667));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2000));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 2333));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 2667));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 3000));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 3667));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 4000));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 4333));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 4667));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 5333));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 5667));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 6000));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 6333));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 7000));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 7333));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 7667));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 8000));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 8333));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 8667));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 9000));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 9333));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 9667));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nuint256 constant TOTAL_RYO_SUPPLY = 2_000_000_000;\\n\"\r\n    },\r\n    \"contracts/EarlyContributorsSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"./MerkleTokenUnlockSchedule.sol\\\";\\n\\ncontract EarlyContributorsSchedule is MerkleTokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n        address _timelockController\\n    ) MerkleTokenUnlockSchedule(_timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(0 days, 200));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 608));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1017));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1425));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1832));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 2242));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2650));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 3058));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 3467));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 3875));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 4283));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 4692));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 5100));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 5508));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 5917));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 6325));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 6733));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 7142));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 7550));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 7958));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 8367));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 8775));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 9183));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 9592));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EcosystemSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract EcosystemSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(0 days, 300));\\n        unlockSchedule.push(UnlockScheduleItem(30 days, 462));\\n        unlockSchedule.push(UnlockScheduleItem(60 days, 623));\\n        unlockSchedule.push(UnlockScheduleItem(90 days, 785));\\n        unlockSchedule.push(UnlockScheduleItem(120 days, 947));\\n        unlockSchedule.push(UnlockScheduleItem(150 days, 1108));\\n        unlockSchedule.push(UnlockScheduleItem(180 days, 1270));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 1432));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1593));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1755));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1917));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 2078));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2240));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 2402));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 2563));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 2725));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 2887));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 3048));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 3210));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 3372));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 3533));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 3695));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 3857));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 4018));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 4180));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 4342));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 4503));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 4665));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 4827));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 4988));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 5150));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 5312));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 5473));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 5635));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 5797));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 5958));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 6120));\\n        unlockSchedule.push(UnlockScheduleItem(1110 days, 6282));\\n        unlockSchedule.push(UnlockScheduleItem(1140 days, 6443));\\n        unlockSchedule.push(UnlockScheduleItem(1170 days, 6605));\\n        unlockSchedule.push(UnlockScheduleItem(1200 days, 6767));\\n        unlockSchedule.push(UnlockScheduleItem(1230 days, 6928));\\n        unlockSchedule.push(UnlockScheduleItem(1260 days, 7090));\\n        unlockSchedule.push(UnlockScheduleItem(1290 days, 7252));\\n        unlockSchedule.push(UnlockScheduleItem(1320 days, 7413));\\n        unlockSchedule.push(UnlockScheduleItem(1350 days, 7575));\\n        unlockSchedule.push(UnlockScheduleItem(1380 days, 7737));\\n        unlockSchedule.push(UnlockScheduleItem(1410 days, 7898));\\n        unlockSchedule.push(UnlockScheduleItem(1440 days, 8059));\\n        unlockSchedule.push(UnlockScheduleItem(1470 days, 8222));\\n        unlockSchedule.push(UnlockScheduleItem(1500 days, 8383));\\n        unlockSchedule.push(UnlockScheduleItem(1530 days, 8545));\\n        unlockSchedule.push(UnlockScheduleItem(1560 days, 8707));\\n        unlockSchedule.push(UnlockScheduleItem(1590 days, 8868));\\n        unlockSchedule.push(UnlockScheduleItem(1620 days, 9030));\\n        unlockSchedule.push(UnlockScheduleItem(1650 days, 9192));\\n        unlockSchedule.push(UnlockScheduleItem(1680 days, 9353));\\n        unlockSchedule.push(UnlockScheduleItem(1710 days, 9515));\\n        unlockSchedule.push(UnlockScheduleItem(1740 days, 9677));\\n        unlockSchedule.push(UnlockScheduleItem(1770 days, 9838));\\n        unlockSchedule.push(UnlockScheduleItem(1800 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GovernanceTimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/governance/TimelockController.sol\\\";\\n\\ncontract GovernanceTimeLock is TimelockController {\\n    constructor(\\n        uint256 minDelay,\\n        address[] memory proposers,\\n        address[] memory executors\\n    ) TimelockController(minDelay, proposers, executors, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"contracts/InvestorsSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract InvestorsSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 417));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 833));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 1250));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 1667));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 2083));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 2500));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 2917));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 3750));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 4167));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 4583));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 5417));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 5833));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 6250));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 7083));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 7500));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 7917));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 8333));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 8750));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 9167));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 9583));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LiquiditySchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract LiquiditySchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(0 days, 2000));\\n        unlockSchedule.push(UnlockScheduleItem(30 days, 2222));\\n        unlockSchedule.push(UnlockScheduleItem(60 days, 2444));\\n        unlockSchedule.push(UnlockScheduleItem(90 days, 2667));\\n        unlockSchedule.push(UnlockScheduleItem(120 days, 2889));\\n        unlockSchedule.push(UnlockScheduleItem(150 days, 3111));\\n        unlockSchedule.push(UnlockScheduleItem(180 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 3556));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 3778));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 4000));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 4222));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 4444));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 4667));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 4889));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 5111));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 5333));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 5556));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 5778));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 6000));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 6222));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 6444));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 6889));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 7111));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 7333));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 7556));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 7778));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 8000));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 8222));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 8444));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 8667));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 8889));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 9111));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 9333));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 9556));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 9778));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MarketingSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract MarketingSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(0 days, 200));\\n        unlockSchedule.push(UnlockScheduleItem(30 days, 363));\\n        unlockSchedule.push(UnlockScheduleItem(60 days, 527));\\n        unlockSchedule.push(UnlockScheduleItem(90 days, 690));\\n        unlockSchedule.push(UnlockScheduleItem(120 days, 852));\\n        unlockSchedule.push(UnlockScheduleItem(150 days, 1017));\\n        unlockSchedule.push(UnlockScheduleItem(180 days, 1180));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 1343));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1507));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1670));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1832));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 1997));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2160));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 2323));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 2487));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 2650));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 2813));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 2977));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 3140));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 3303));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 3467));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 3629));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 3793));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 3957));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 4120));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 4283));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 4447));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 4610));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 4773));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 4937));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 5100));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 5263));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 5427));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 5590));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 5753));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 5917));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 6080));\\n        unlockSchedule.push(UnlockScheduleItem(1110 days, 6243));\\n        unlockSchedule.push(UnlockScheduleItem(1140 days, 6406));\\n        unlockSchedule.push(UnlockScheduleItem(1170 days, 6570));\\n        unlockSchedule.push(UnlockScheduleItem(1200 days, 6733));\\n        unlockSchedule.push(UnlockScheduleItem(1230 days, 6897));\\n        unlockSchedule.push(UnlockScheduleItem(1260 days, 7059));\\n        unlockSchedule.push(UnlockScheduleItem(1290 days, 7223));\\n        unlockSchedule.push(UnlockScheduleItem(1320 days, 7387));\\n        unlockSchedule.push(UnlockScheduleItem(1350 days, 7550));\\n        unlockSchedule.push(UnlockScheduleItem(1380 days, 7713));\\n        unlockSchedule.push(UnlockScheduleItem(1410 days, 7877));\\n        unlockSchedule.push(UnlockScheduleItem(1440 days, 8040));\\n        unlockSchedule.push(UnlockScheduleItem(1470 days, 8203));\\n        unlockSchedule.push(UnlockScheduleItem(1500 days, 8367));\\n        unlockSchedule.push(UnlockScheduleItem(1530 days, 8530));\\n        unlockSchedule.push(UnlockScheduleItem(1560 days, 8693));\\n        unlockSchedule.push(UnlockScheduleItem(1590 days, 8857));\\n        unlockSchedule.push(UnlockScheduleItem(1620 days, 9020));\\n        unlockSchedule.push(UnlockScheduleItem(1650 days, 9183));\\n        unlockSchedule.push(UnlockScheduleItem(1680 days, 9347));\\n        unlockSchedule.push(UnlockScheduleItem(1710 days, 9510));\\n        unlockSchedule.push(UnlockScheduleItem(1740 days, 9673));\\n        unlockSchedule.push(UnlockScheduleItem(1770 days, 9837));\\n        unlockSchedule.push(UnlockScheduleItem(1800 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MerkleTokenUnlockSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Abstract TokenUnlockSchedule\\r\\n * @dev TokenUnlockSchedule implements unlocking schedule for early investors.\\r\\n */\\r\\nabstract contract MerkleTokenUnlockSchedule is AccessControl {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    event ClaimRootSet(bytes32 _newClaimRoot);\\r\\n    event SaleLaunch(address sender);\\r\\n    event TokenInitialized(address token);\\r\\n\\r\\n    struct UnlockScheduleItem {\\r\\n        uint256 unlockTimePass;\\r\\n        uint16 totalPercentageUnlocked;\\r\\n    }\\r\\n\\r\\n    mapping(address => uint256) private _withdrawnBalances;\\r\\n    UnlockScheduleItem[] internal unlockSchedule;\\r\\n\\r\\n    uint256 public scheduleStartTimestamp = 0;\\r\\n    bytes32 private claimRoot;\\r\\n\\r\\n    IERC20 public token;\\r\\n\\r\\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\\\"CONTROLLER_ROLE\\\");\\r\\n    uint16 private constant PERCENT_DENOMINATOR = 10_000;\\r\\n\\r\\n    function _initUnlockSchedule() internal virtual;\\r\\n\\r\\n    constructor(address _timelockController) {\\r\\n        require(\\r\\n            _timelockController != address(0), \\r\\n            \\\"MerkleTokenUnlockSchedule: Timelock controller address cannot be null\\\"\\r\\n        );\\r\\n\\r\\n        _grantRole(CONTROLLER_ROLE, _timelockController);\\r\\n\\r\\n        _initUnlockSchedule();\\r\\n        _validateUnlockSchedule();\\r\\n    }\\r\\n\\r\\n    function setToken(IERC20 token_) external onlyRole(CONTROLLER_ROLE) {\\r\\n        require(\\r\\n            address(token_) != address(0),\\r\\n            \\\"MerkleTokenUnlockSchedule: New token address cannot be null\\\"\\r\\n        );\\r\\n        require(\\r\\n            address(token) == address(0),\\r\\n            \\\"MerkleTokenUnlockSchedule: Token already set\\\"\\r\\n        );\\r\\n\\r\\n        token = token_;\\r\\n        emit TokenInitialized(address(token_));\\r\\n    }\\r\\n\\r\\n    function setClaimRoot(bytes32 _root) external onlyRole(CONTROLLER_ROLE) {\\r\\n        require(_root != bytes32(0), \\\"MerkleTokenUnlockSchedule: Claim root cannot be null\\\");\\r\\n        claimRoot = _root;\\r\\n        emit ClaimRootSet(_root);\\r\\n    }\\r\\n\\r\\n    function launchSale() external onlyRole(CONTROLLER_ROLE) {\\r\\n        require(scheduleStartTimestamp == 0, \\\"MerkleTokenUnlockSchedule: Sale already launched\\\");\\r\\n        require(address(token) != address(0), \\\"TokenUnlockSchedule: Token not set\\\");\\r\\n        require(\\r\\n            claimRoot != bytes32(0), \\r\\n            \\\"MerkleTokenUnlockSchedule: Cannot launch - Claim root is not set\\\"\\r\\n        );\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        scheduleStartTimestamp = block.timestamp;\\r\\n\\r\\n        emit SaleLaunch(msg.sender);\\r\\n    }\\r\\n\\r\\n    function withdraw(\\r\\n        address to,\\r\\n        uint256 amountToWithdraw,\\r\\n        uint256 lockedAmount,\\r\\n        bytes32[] calldata proof\\r\\n    ) external returns (bool) {\\r\\n        require(\\r\\n            to != address(0),\\r\\n            \\\"MerkleTokenUnlockSchedule: Recipient address cannot be null\\\"\\r\\n        );\\r\\n        require(\\r\\n            amountToWithdraw > 0,\\r\\n            \\\"MerkleTokenUnlockSchedule: Withdraw amount must be greater than zero\\\"\\r\\n        );\\r\\n        require(\\r\\n            scheduleStartTimestamp > 0 && scheduleStartTimestamp < block.timestamp, // solhint-disable-line not-rely-on-time\\r\\n            \\\"MerkleTokenUnlockSchedule: Unlock schedule not started yet\\\"\\r\\n        );\\r\\n        require(\\r\\n            unlockedOf(msg.sender, lockedAmount) >= amountToWithdraw,\\r\\n            \\\"MerkleTokenUnlockSchedule: Amount to withdraw is greater than unlocked amount\\\"\\r\\n        );\\r\\n\\r\\n        /* Verify proof */\\r\\n\\r\\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(msg.sender, lockedAmount))));\\r\\n        require(\\r\\n            MerkleProof.verifyCalldata(proof, claimRoot, leaf),\\r\\n            \\\"MerkleTokenUnlockSchedule: Invalid claim proof\\\"\\r\\n        );\\r\\n\\r\\n        _withdrawnBalances[msg.sender] += amountToWithdraw;\\r\\n        token.safeTransfer(to, amountToWithdraw);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function unlockedOf(\\r\\n        address account,\\r\\n        uint256 lockedAmount\\r\\n    ) public view returns (uint256) {\\r\\n        if (scheduleStartTimestamp > 0) {\\r\\n            uint256 totalUnlocked = Math.mulDiv(\\r\\n                lockedAmount,\\r\\n                getUnlockedPercent(block.timestamp - scheduleStartTimestamp), // solhint-disable-line not-rely-on-time\\r\\n                PERCENT_DENOMINATOR\\r\\n            );\\r\\n\\r\\n            if (totalUnlocked <= _withdrawnBalances[account]) {\\r\\n                return 0;\\r\\n            }\\r\\n\\r\\n            return totalUnlocked - _withdrawnBalances[account];\\r\\n        }\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getUnlockedPercent(\\r\\n        uint256 secondsPassed\\r\\n    ) internal view returns (uint16) {\\r\\n        uint256 index = 0;\\r\\n        while(index < unlockSchedule.length && unlockSchedule[index].unlockTimePass < secondsPassed) { index++; }\\r\\n\\r\\n        return index > 0 ? unlockSchedule[index - 1].totalPercentageUnlocked : 0;\\r\\n    }\\r\\n\\r\\n    function _validateUnlockSchedule() private view {\\r\\n        uint256 steps = unlockSchedule.length;\\r\\n        assert(steps > 1);\\r\\n        assert(unlockSchedule[steps - 1].totalPercentageUnlocked == PERCENT_DENOMINATOR);\\r\\n\\r\\n        for (uint256 i = 1; i < steps; ++i) {\\r\\n            assert(\\r\\n                unlockSchedule[i - 1].unlockTimePass <\\r\\n                    unlockSchedule[i].unlockTimePass\\r\\n            );\\r\\n            assert(\\r\\n                unlockSchedule[i - 1].totalPercentageUnlocked <\\r\\n                    unlockSchedule[i].totalPercentageUnlocked\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/PrivateSaleSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract PrivateSaleSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 830));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1670));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 2500));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 3329));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 4170));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 5830));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 6670));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 7500));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 8330));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 9170));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RYO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"./constants.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title RYO Token\\n * @notice Smart contract implements token for RYO\\n */\\ncontract RYO is ERC20, ERC20Burnable {\\n    constructor(\\n        address privateSaleSchedule,\\n        address investorsSchedule,\\n        address teamSchedule,\\n        address earlyContributorsSchedule,\\n        address advisorsSchedule,\\n        address ecosystemSchedule,\\n        address validatorSchedule,\\n        address marketingSchedule,\\n        address liquiditySchedule,\\n        address treasurySchedule\\n    ) ERC20(\\\"RYO Token\\\", \\\"RYO\\\") {\\n        uint256 scale =  10 ** decimals();\\n        _mint(privateSaleSchedule, 30_000_000 * scale);\\n        _mint(investorsSchedule, 200_000_000 * scale);\\n        _mint(teamSchedule, 300_000_000 * scale);\\n        _mint(earlyContributorsSchedule, 120_000_000 * scale);\\n        _mint(advisorsSchedule, 120_000_000 * scale);\\n        _mint(ecosystemSchedule, 250_000_000 * scale);\\n        _mint(validatorSchedule, 300_000_000 * scale);\\n        _mint(marketingSchedule, 200_000_000 * scale);\\n        _mint(liquiditySchedule, 240_000_000 * scale);\\n        _mint(treasurySchedule, 240_000_000 * scale);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TeamSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract TeamSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 208));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 417));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 625));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 833));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 1042));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 1250));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 1458));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 1667));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 1875));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 2083));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 2292));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 2500));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 2708));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 2917));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 3125));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 3542));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 3750));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 3958));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 4167));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 4375));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 4583));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 4792));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(1110 days, 5208));\\n        unlockSchedule.push(UnlockScheduleItem(1140 days, 5417));\\n        unlockSchedule.push(UnlockScheduleItem(1170 days, 5625));\\n        unlockSchedule.push(UnlockScheduleItem(1200 days, 5833));\\n        unlockSchedule.push(UnlockScheduleItem(1230 days, 6042));\\n        unlockSchedule.push(UnlockScheduleItem(1260 days, 6250));\\n        unlockSchedule.push(UnlockScheduleItem(1290 days, 6458));\\n        unlockSchedule.push(UnlockScheduleItem(1320 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(1350 days, 6875));\\n        unlockSchedule.push(UnlockScheduleItem(1380 days, 7083));\\n        unlockSchedule.push(UnlockScheduleItem(1410 days, 7292));\\n        unlockSchedule.push(UnlockScheduleItem(1440 days, 7500));\\n        unlockSchedule.push(UnlockScheduleItem(1470 days, 7708));\\n        unlockSchedule.push(UnlockScheduleItem(1500 days, 7917));\\n        unlockSchedule.push(UnlockScheduleItem(1530 days, 8125));\\n        unlockSchedule.push(UnlockScheduleItem(1560 days, 8333));\\n        unlockSchedule.push(UnlockScheduleItem(1590 days, 8542));\\n        unlockSchedule.push(UnlockScheduleItem(1620 days, 8750));\\n        unlockSchedule.push(UnlockScheduleItem(1650 days, 8958));\\n        unlockSchedule.push(UnlockScheduleItem(1680 days, 9167));\\n        unlockSchedule.push(UnlockScheduleItem(1710 days, 9375));\\n        unlockSchedule.push(UnlockScheduleItem(1740 days, 9583));\\n        unlockSchedule.push(UnlockScheduleItem(1770 days, 9792));\\n        unlockSchedule.push(UnlockScheduleItem(1800 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenUnlockSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title Abstract TokenUnlockSchedule\\n * @dev TokenUnlockSchedule implements unlocking schedule for early investors.\\n */\\nabstract contract TokenUnlockSchedule is AccessControl {\\n    using SafeERC20 for IERC20;\\n\\n    event Deposit(\\n        address sender,\\n        address indexed to,\\n        uint256 amount\\n    );\\n    event TokenInitialized(address token);\\n    event SaleLaunch(address sender);\\n\\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\\\"CONTROLLER_ROLE\\\");\\n    uint16 private constant PERCENT_DENOMINATOR = 10_000;\\n\\n    uint256 public scheduleStartTimestamp = 0;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => uint256) private _withdrawnBalances;\\n\\n    uint256 public totalBalance;\\n\\n    struct UnlockScheduleItem {\\n        uint256 unlockTimePass;\\n        uint16 totalPercentageUnlocked;\\n    }\\n\\n    UnlockScheduleItem[] internal unlockSchedule;\\n\\n    IERC20 public token;\\n\\n    function _initUnlockSchedule() internal virtual;\\n\\n    constructor(address timelockController_) {\\n        require(\\n          timelockController_ != address(0),\\n          \\\"TokenUnlockSchedule: Timelock controller address cannot be null\\\"\\n        );\\n\\n        _grantRole(CONTROLLER_ROLE, timelockController_);\\n\\n        _initUnlockSchedule();\\n        _validateUnlockSchedule();\\n    }\\n\\n    function setToken(IERC20 token_) external onlyRole(CONTROLLER_ROLE) {\\n        require(\\n            address(token_) != address(0),\\n            \\\"TokenUnlockSchedule: New token address cannot be null\\\"\\n        );\\n        require(\\n            address(token) == address(0),\\n            \\\"TokenUnlockSchedule: Token already set\\\"\\n        );\\n\\n        token = token_;\\n        emit TokenInitialized(address(token_));\\n    }\\n\\n    function launchSale() external onlyRole(CONTROLLER_ROLE) {\\n        require(scheduleStartTimestamp == 0, \\\"TokenUnlockSchedule: Sale already launched\\\");\\n        require(address(token) != address(0), \\\"TokenUnlockSchedule: Token not set\\\");\\n\\n        // solhint-disable-next-line not-rely-on-time\\n        scheduleStartTimestamp = block.timestamp;\\n\\n        emit SaleLaunch(msg.sender);\\n    }\\n\\n    function addBalance(\\n        address to,\\n        uint256 amount\\n    ) external virtual onlyRole(CONTROLLER_ROLE) {\\n        _addBalance(to, amount);\\n    }\\n\\n    function withdraw(address to, uint256 amount) external returns (bool) {\\n        require(\\n            to != address(0),\\n            \\\"TokenUnlockSchedule: Recipient address cannot be null\\\"\\n        );\\n        require(\\n            amount > 0,\\n            \\\"TokenUnlockSchedule: Withdraw amount must be greater than zero\\\"\\n        );\\n        require(\\n            scheduleStartTimestamp > 0 && scheduleStartTimestamp < block.timestamp, // solhint-disable-line not-rely-on-time\\n            \\\"TokenUnlockSchedule: Unlock schedule not started yet\\\"\\n        );\\n        require(\\n            unlockedOf(msg.sender) >= amount,\\n            \\\"TokenUnlockSchedule: Amount to withdraw is greater than unlocked amount\\\"\\n        );\\n\\n        _withdrawnBalances[msg.sender] += amount;\\n        totalBalance -= amount;\\n        token.safeTransfer(to, amount);\\n        return true;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account] - _withdrawnBalances[account];\\n    }\\n\\n    function unlockedOf(address account) public view returns (uint256) {\\n        if (scheduleStartTimestamp > 0) {\\n            uint256 totalUnlocked = Math.mulDiv(\\n                _balances[account],\\n                getUnlockedPercent(block.timestamp - scheduleStartTimestamp), // solhint-disable-line not-rely-on-time\\n                PERCENT_DENOMINATOR\\n            );\\n\\n            if (totalUnlocked <= _withdrawnBalances[account]) {\\n                return 0;\\n            }\\n\\n            return totalUnlocked - _withdrawnBalances[account];\\n        }\\n\\n        return 0;\\n    }\\n\\n    function getUnlockedPercent(\\n        uint256 secondsPassed\\n    ) internal view returns (uint16) {\\n        uint256 index = 0;\\n        while(index < unlockSchedule.length && unlockSchedule[index].unlockTimePass < secondsPassed) { index++; }\\n\\n        return index > 0 ? unlockSchedule[index - 1].totalPercentageUnlocked : 0;\\n    }\\n\\n    function _addBalance(address to, uint256 amount) internal {\\n        require(\\n            to != address(0),\\n            \\\"TokenUnlockSchedule: Recipient address cannot be null\\\"\\n        );\\n        require(\\n            amount > 0,\\n            \\\"TokenUnlockSchedule: Balance amount must be greater than zero\\\"\\n        );\\n        require(\\n            totalBalance + amount <= token.balanceOf(address(this)),\\n            \\\"TokenUnlockSchedule: Total balance exceeds available balance\\\"\\n        );\\n\\n        _balances[to] += amount;\\n        totalBalance += amount;\\n\\n        emit Deposit(msg.sender, to, amount);\\n    }\\n\\n    function _validateUnlockSchedule() private view {\\n        uint256 steps = unlockSchedule.length;\\n        assert(steps > 1);\\n        assert(unlockSchedule[steps - 1].totalPercentageUnlocked == PERCENT_DENOMINATOR);\\n\\n        for (uint256 i = 1; i < steps; ++i) {\\n          assert(\\n              unlockSchedule[i - 1].unlockTimePass <\\n              unlockSchedule[i].unlockTimePass\\n          );\\n          assert(\\n              unlockSchedule[i - 1].totalPercentageUnlocked <\\n              unlockSchedule[i].totalPercentageUnlocked\\n          );\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/TreasurySchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract TreasurySchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(30 days, 167));\\n        unlockSchedule.push(UnlockScheduleItem(60 days, 333));\\n        unlockSchedule.push(UnlockScheduleItem(90 days, 500));\\n        unlockSchedule.push(UnlockScheduleItem(120 days, 667));\\n        unlockSchedule.push(UnlockScheduleItem(150 days, 833));\\n        unlockSchedule.push(UnlockScheduleItem(180 days, 1000));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 1167));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1333));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1500));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1667));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 1832));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2000));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 2167));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 2333));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 2500));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 2667));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 2833));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 3000));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 3167));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 3500));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 3667));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 3833));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 4000));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 4167));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 4333));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 4500));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 4667));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 4833));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 5167));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 5333));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 5500));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 5667));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 5833));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 6000));\\n        unlockSchedule.push(UnlockScheduleItem(1110 days, 6167));\\n        unlockSchedule.push(UnlockScheduleItem(1140 days, 6333));\\n        unlockSchedule.push(UnlockScheduleItem(1170 days, 6500));\\n        unlockSchedule.push(UnlockScheduleItem(1200 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(1230 days, 6833));\\n        unlockSchedule.push(UnlockScheduleItem(1260 days, 7000));\\n        unlockSchedule.push(UnlockScheduleItem(1290 days, 7167));\\n        unlockSchedule.push(UnlockScheduleItem(1320 days, 7333));\\n        unlockSchedule.push(UnlockScheduleItem(1350 days, 7500));\\n        unlockSchedule.push(UnlockScheduleItem(1380 days, 7667));\\n        unlockSchedule.push(UnlockScheduleItem(1410 days, 7833));\\n        unlockSchedule.push(UnlockScheduleItem(1440 days, 8000));\\n        unlockSchedule.push(UnlockScheduleItem(1470 days, 8167));\\n        unlockSchedule.push(UnlockScheduleItem(1500 days, 8333));\\n        unlockSchedule.push(UnlockScheduleItem(1530 days, 8500));\\n        unlockSchedule.push(UnlockScheduleItem(1560 days, 8667));\\n        unlockSchedule.push(UnlockScheduleItem(1590 days, 8833));\\n        unlockSchedule.push(UnlockScheduleItem(1620 days, 9000));\\n        unlockSchedule.push(UnlockScheduleItem(1650 days, 9167));\\n        unlockSchedule.push(UnlockScheduleItem(1680 days, 9333));\\n        unlockSchedule.push(UnlockScheduleItem(1710 days, 9500));\\n        unlockSchedule.push(UnlockScheduleItem(1740 days, 9667));\\n        unlockSchedule.push(UnlockScheduleItem(1770 days, 9833));\\n        unlockSchedule.push(UnlockScheduleItem(1800 days, 10000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ValidatorSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./TokenUnlockSchedule.sol\\\";\\n\\ncontract ValidatorSchedule is TokenUnlockSchedule {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n      address timelockController\\n    ) TokenUnlockSchedule(timelockController) {}\\n\\n    function _initUnlockSchedule() internal override {\\n        unlockSchedule.push(UnlockScheduleItem(30 days, 167));\\n        unlockSchedule.push(UnlockScheduleItem(60 days, 333));\\n        unlockSchedule.push(UnlockScheduleItem(90 days, 500));\\n        unlockSchedule.push(UnlockScheduleItem(120 days, 667));\\n        unlockSchedule.push(UnlockScheduleItem(150 days, 833));\\n        unlockSchedule.push(UnlockScheduleItem(180 days, 1000));\\n        unlockSchedule.push(UnlockScheduleItem(210 days, 1167));\\n        unlockSchedule.push(UnlockScheduleItem(240 days, 1333));\\n        unlockSchedule.push(UnlockScheduleItem(270 days, 1500));\\n        unlockSchedule.push(UnlockScheduleItem(300 days, 1667));\\n        unlockSchedule.push(UnlockScheduleItem(330 days, 1832));\\n        unlockSchedule.push(UnlockScheduleItem(360 days, 2000));\\n        unlockSchedule.push(UnlockScheduleItem(390 days, 2167));\\n        unlockSchedule.push(UnlockScheduleItem(420 days, 2333));\\n        unlockSchedule.push(UnlockScheduleItem(450 days, 2500));\\n        unlockSchedule.push(UnlockScheduleItem(480 days, 2667));\\n        unlockSchedule.push(UnlockScheduleItem(510 days, 2833));\\n        unlockSchedule.push(UnlockScheduleItem(540 days, 3000));\\n        unlockSchedule.push(UnlockScheduleItem(570 days, 3167));\\n        unlockSchedule.push(UnlockScheduleItem(600 days, 3333));\\n        unlockSchedule.push(UnlockScheduleItem(630 days, 3500));\\n        unlockSchedule.push(UnlockScheduleItem(660 days, 3667));\\n        unlockSchedule.push(UnlockScheduleItem(690 days, 3833));\\n        unlockSchedule.push(UnlockScheduleItem(720 days, 4000));\\n        unlockSchedule.push(UnlockScheduleItem(750 days, 4167));\\n        unlockSchedule.push(UnlockScheduleItem(780 days, 4333));\\n        unlockSchedule.push(UnlockScheduleItem(810 days, 4500));\\n        unlockSchedule.push(UnlockScheduleItem(840 days, 4667));\\n        unlockSchedule.push(UnlockScheduleItem(870 days, 4833));\\n        unlockSchedule.push(UnlockScheduleItem(900 days, 5000));\\n        unlockSchedule.push(UnlockScheduleItem(930 days, 5167));\\n        unlockSchedule.push(UnlockScheduleItem(960 days, 5333));\\n        unlockSchedule.push(UnlockScheduleItem(990 days, 5500));\\n        unlockSchedule.push(UnlockScheduleItem(1020 days, 5667));\\n        unlockSchedule.push(UnlockScheduleItem(1050 days, 5833));\\n        unlockSchedule.push(UnlockScheduleItem(1080 days, 6000));\\n        unlockSchedule.push(UnlockScheduleItem(1110 days, 6167));\\n        unlockSchedule.push(UnlockScheduleItem(1140 days, 6333));\\n        unlockSchedule.push(UnlockScheduleItem(1170 days, 6500));\\n        unlockSchedule.push(UnlockScheduleItem(1200 days, 6667));\\n        unlockSchedule.push(UnlockScheduleItem(1230 days, 6833));\\n        unlockSchedule.push(UnlockScheduleItem(1260 days, 7000));\\n        unlockSchedule.push(UnlockScheduleItem(1290 days, 7167));\\n        unlockSchedule.push(UnlockScheduleItem(1320 days, 7333));\\n        unlockSchedule.push(UnlockScheduleItem(1350 days, 7500));\\n        unlockSchedule.push(UnlockScheduleItem(1380 days, 7667));\\n        unlockSchedule.push(UnlockScheduleItem(1410 days, 7833));\\n        unlockSchedule.push(UnlockScheduleItem(1440 days, 8000));\\n        unlockSchedule.push(UnlockScheduleItem(1470 days, 8167));\\n        unlockSchedule.push(UnlockScheduleItem(1500 days, 8333));\\n        unlockSchedule.push(UnlockScheduleItem(1530 days, 8500));\\n        unlockSchedule.push(UnlockScheduleItem(1560 days, 8667));\\n        unlockSchedule.push(UnlockScheduleItem(1590 days, 8833));\\n        unlockSchedule.push(UnlockScheduleItem(1620 days, 9000));\\n        unlockSchedule.push(UnlockScheduleItem(1650 days, 9167));\\n        unlockSchedule.push(UnlockScheduleItem(1680 days, 9333));\\n        unlockSchedule.push(UnlockScheduleItem(1710 days, 9500));\\n        unlockSchedule.push(UnlockScheduleItem(1740 days, 9667));\\n        unlockSchedule.push(UnlockScheduleItem(1770 days, 9833));\\n        unlockSchedule.push(UnlockScheduleItem(1800 days, 10000));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"privateSaleSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investorsSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"teamSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"earlyContributorsSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"advisorsSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ecosystemSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketingSchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquiditySchedule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasurySchedule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RYO", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ab65769a0abc1f7956403e913082d1b0e652bf630000000000000000000000006344ab9dfe8296b71ef896a5e77fdca34a3868ca00000000000000000000000085d9cf98068440870a56bcd948b67a8c5a411ab80000000000000000000000005d01fb4425996e16d452c2014f2f19141cd6ceb5000000000000000000000000cf7489d3bf40d5a026d91244e088f96cb1f1a8440000000000000000000000007ac7ec3be848d8f1c6f253586ca0c368f12e8a47000000000000000000000000ffee572f3e0d9f610efab2a10a160948e052f049000000000000000000000000587f90cba7510286175051ed5bb9f42b370db2a70000000000000000000000008bf248e73aa4ac48d7ab6478ffe112db18c6cd780000000000000000000000006150eb989a3d10595de05801a00bbc2a71930df1", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}