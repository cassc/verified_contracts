{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/ajna-actions/AjnaProxyActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.18;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport { IAjnaPoolUtilsInfo } from \\\"../../interfaces/ajna/IAjnaPoolUtilsInfo.sol\\\";\\nimport { IERC20Pool } from \\\"../interfaces/pool/erc20/IERC20Pool.sol\\\";\\nimport { IPositionManager } from \\\"../interfaces/position/IPositionManager.sol\\\";\\nimport { IRewardsManager } from \\\"../interfaces/rewards/IRewardsManager.sol\\\";\\n\\nimport { IAccountGuard } from \\\"../../interfaces/dpm/IAccountGuard.sol\\\";\\n\\nimport { IWETH } from \\\"../../interfaces/tokens/IWETH.sol\\\";\\n\\ninterface IAjnaProxyActions {\\n    function positionManager() external view returns (IPositionManager);\\n\\n    function rewardsManager() external view returns (IRewardsManager);\\n\\n    function ARC() external view returns (address);\\n}\\n\\ncontract AjnaProxyActions is IAjnaProxyActions {\\n    IAjnaPoolUtilsInfo public immutable poolInfoUtils;\\n    IERC20 public immutable ajnaToken;\\n    address public immutable WETH;\\n    address public immutable GUARD;\\n    address public immutable deployer;\\n    IAjnaProxyActions public immutable self;\\n    IPositionManager public positionManager;\\n    IRewardsManager public rewardsManager;\\n    address public ARC;\\n\\n    using SafeERC20 for IERC20;\\n\\n    constructor(IAjnaPoolUtilsInfo _poolInfoUtils, IERC20 _ajnaToken, address _WETH, address _GUARD) {\\n        poolInfoUtils = _poolInfoUtils;\\n        ajnaToken = _ajnaToken;\\n        WETH = _WETH;\\n        GUARD = _GUARD;\\n        self = this;\\n        deployer = msg.sender;\\n    }\\n\\n    function initialize(address _positionManager, address _rewardsManager, address _ARC) external {\\n        require(msg.sender == deployer, \\\"apa/not-deployer\\\");\\n        require(\\n            address(positionManager) == address(0) && address(rewardsManager) == address(0) && ARC == address(0),\\n            \\\"apa/already-initialized\\\"\\n        );\\n        positionManager = IPositionManager(_positionManager);\\n        rewardsManager = IRewardsManager(_rewardsManager);\\n        ARC = _ARC;\\n    }\\n\\n    /**\\n     * @dev Emitted once an Operation has completed execution\\n     * @param name Name of the operation\\n     **/\\n    event ProxyActionsOperation(bytes32 indexed name);\\n\\n    /**\\n     * @dev Emitted when a new position is created\\n     * @param proxyAddress The address of the newly created position proxy contract\\n     * @param protocol The name of the protocol associated with the position\\n     * @param positionType The type of position being created (e.g. borrow or earn)\\n     * @param collateralToken The address of the collateral token being used for the position\\n     * @param debtToken The address of the debt token being used for the position\\n     **/\\n    event CreatePosition(\\n        address indexed proxyAddress,\\n        string protocol,\\n        string positionType,\\n        address collateralToken,\\n        address debtToken\\n    );\\n\\n    function _send(address token, uint256 amount) internal {\\n        if (token == WETH) {\\n            IWETH(WETH).withdraw(amount);\\n            payable(msg.sender).transfer(amount);\\n        } else {\\n            IERC20(token).safeTransfer(msg.sender, amount);\\n        }\\n    }\\n\\n    function _pull(address token, uint256 amount) internal {\\n        if (token == WETH) {\\n            IWETH(WETH).deposit{ value: amount }();\\n        } else {\\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Mints and empty NFT for the user, NFT is bound to a specific pool.\\n     *  @param  pool            Address of the Ajana Pool.\\n     *  @return  tokenId  - id of the minted NFT\\n     */\\n    function _mintNft(IERC20Pool pool) internal returns (uint256 tokenId) {\\n        address _ARC = self.ARC();\\n        tokenId = self.positionManager().mint(address(pool), address(this), keccak256(\\\"ERC20_NON_SUBSET_HASH\\\"));\\n        if (!IAccountGuard(GUARD).canCall(address(this), _ARC)) {\\n            IAccountGuard(GUARD).permit(_ARC, address(this), true);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Redeem bucket from NFT\\n     *  @param  price         Price of the momorialized bucket\\n     *  @param  tokenId       Nft ID\\n     *  @param  pool          Pool address\\n     */\\n\\n    function _redeemPosition(uint256 price, uint256 tokenId, address pool) internal {\\n        uint256 index = convertPriceToIndex(price);\\n        uint256[] memory indexes = new uint256[](1);\\n        indexes[0] = index;\\n        address[] memory addresses = new address[](1);\\n        addresses[0] = address(self.positionManager());\\n        IERC20Pool(pool).approveLPTransferors(addresses);\\n        self.positionManager().redeemPositions(address(pool), tokenId, indexes);\\n    }\\n\\n    /**\\n     *  @notice Memorialize bucket in NFT\\n     *  @param  price         Price of the momorialized bucket\\n     *  @param  tokenId       Nft ID\\n     */\\n    function _memorializeLiquidity(uint256 price, uint256 tokenId, IERC20Pool pool) internal {\\n        uint256 index = convertPriceToIndex(price);\\n\\n        (uint256 lpCount, ) = IERC20Pool(pool).lenderInfo(index, address(this));\\n        uint256[] memory indexes = new uint256[](1);\\n        indexes[0] = index;\\n        uint256[] memory lpCounts = new uint256[](1);\\n        lpCounts[0] = lpCount;\\n        IERC20Pool(pool).increaseLPAllowance(address(self.positionManager()), indexes, lpCounts);\\n        self.positionManager().memorializePositions(address(pool), tokenId, indexes);\\n        IERC721(address(self.positionManager())).approve(address(self.rewardsManager()), tokenId);\\n    }\\n\\n    /**\\n     *  @notice Move LP from one bucket to another while momorialzied in NFT, requires unstaked NFT\\n     *  @param  oldPrice      Old price of the momorialized bucket\\n     *  @param  newPrice      New price of the momorialized bucket\\n     *  @param  tokenId       Nft ID\\n     *  @param  pool           Pool address\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function _moveLiquidity(\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        uint256 tokenId,\\n        address pool,\\n        bool revertIfBelowLup\\n    ) internal {\\n        uint256 oldIndex = convertPriceToIndex(oldPrice);\\n        uint256 newIndex = convertPriceToIndex(newPrice);\\n\\n        self.positionManager().moveLiquidity(pool, tokenId, oldIndex, newIndex, block.timestamp + 1, revertIfBelowLup);\\n        IERC721(address(self.positionManager())).approve(address(self.rewardsManager()), tokenId);\\n    }\\n\\n    /**\\n     *  @notice Called internally to add an amount of credit at a specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  amount       The maximum amount of quote token to be moved by a lender.\\n     *  @param  price        The price the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     *  @dev price of uint (10**decimals) collateral token in debt token (10**decimals) with 3 decimal points for instance\\n     *  @dev 1WBTC = 16,990.23 USDC   translates to: 16990230\\n     */\\n    function _supplyQuote(IERC20Pool pool, uint256 amount, uint256 price, bool revertIfBelowLup) internal {\\n        address debtToken = pool.quoteTokenAddress();\\n        _pull(debtToken, amount);\\n        uint256 index = convertPriceToIndex(price);\\n        IERC20(debtToken).safeApprove(address(pool), amount);\\n        pool.addQuoteToken(amount * pool.quoteTokenScale(), index, block.timestamp + 1, revertIfBelowLup);\\n    }\\n\\n    /**\\n     *  @notice Called internally to move max amount of credit from a specified price bucket to another specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  oldPrice        The price of the bucket  from which the quote tokens will be removed.\\n     *  @param  newPrice     The price of the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function _moveQuote(IERC20Pool pool, uint256 oldPrice, uint256 newPrice, bool revertIfBelowLup) internal {\\n        uint256 oldIndex = convertPriceToIndex(oldPrice);\\n        pool.moveQuoteToken(\\n            type(uint256).max,\\n            oldIndex,\\n            convertPriceToIndex(newPrice),\\n            block.timestamp + 1,\\n            revertIfBelowLup\\n        );\\n    }\\n\\n    /**\\n     *  @notice Called internally to remove an amount of credit at a specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  amount       The maximum amount of quote token to be moved by a lender.\\n     *  @param  price        The price the bucket to which the quote tokens will be added.\\n     *  @dev price of uint (10**decimals) collateral token in debt token (10**decimals) with 3 decimal points for instance\\n     *  @dev 1WBTC = 16,990.23 USDC   translates to: 16990230\\n     */\\n    function _withdrawQuote(IERC20Pool pool, uint256 amount, uint256 price) internal {\\n        address debtToken = pool.quoteTokenAddress();\\n        uint256 index = convertPriceToIndex(price);\\n        uint256 balanceBefore = IERC20(debtToken).balanceOf(address(this));\\n        if (amount == type(uint256).max) {\\n            pool.removeQuoteToken(type(uint256).max, index);\\n        } else {\\n            pool.removeQuoteToken((amount * pool.quoteTokenScale()), index);\\n        }\\n        uint256 withdrawnBalance = IERC20(debtToken).balanceOf(address(this)) - balanceBefore;\\n        _send(debtToken, withdrawnBalance);\\n    }\\n\\n    /**\\n     * @notice Reclaims collateral from liquidated bucket\\n     * @param  pool         Address of the Ajana Pool.\\n     * @param  price        Price of the bucket to redeem.\\n     */\\n    function _removeCollateral(IERC20Pool pool, uint256 price) internal {\\n        address collateralToken = pool.collateralAddress();\\n        uint256 index = convertPriceToIndex(price);\\n        uint256 balanceBefore = IERC20(collateralToken).balanceOf(address(this));\\n        pool.removeCollateral(type(uint256).max, index);\\n        uint256 withdrawnBalance = IERC20(collateralToken).balanceOf(address(this)) - balanceBefore;\\n        _send(collateralToken, withdrawnBalance);\\n    }\\n\\n    // BORROWER ACTIONS\\n\\n    /**\\n     *  @notice Deposit collateral\\n     *  @param  pool           Pool address\\n     *  @param  collateralAmount Amount of collateral to deposit\\n     *  @param  price          Price of the bucket\\n     */\\n    function depositCollateral(IERC20Pool pool, uint256 collateralAmount, uint256 price) public payable {\\n        address collateralToken = pool.collateralAddress();\\n        _pull(collateralToken, collateralAmount);\\n\\n        uint256 index = convertPriceToIndex(price);\\n        IERC20(collateralToken).safeApprove(address(pool), collateralAmount);\\n        pool.drawDebt(address(this), 0, index, collateralAmount * pool.collateralScale());\\n        emit ProxyActionsOperation(\\\"AjnaDeposit\\\");\\n    }\\n\\n    /**\\n     *  @notice Draw debt\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount     Amount of debt to draw\\n     *  @param  price          Price of the bucket\\n     */\\n    function drawDebt(IERC20Pool pool, uint256 debtAmount, uint256 price) public {\\n        address debtToken = pool.quoteTokenAddress();\\n        uint256 index = convertPriceToIndex(price);\\n\\n        pool.drawDebt(address(this), debtAmount * pool.quoteTokenScale(), index, 0);\\n        _send(debtToken, debtAmount);\\n        emit ProxyActionsOperation(\\\"AjnaBorrow\\\");\\n    }\\n\\n    /**\\n     *  @notice Deposit collateral and draw debt\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount     Amount of debt to draw\\n     *  @param  collateralAmount Amount of collateral to deposit\\n     *  @param  price          Price of the bucket\\n     */\\n    function depositCollateralAndDrawDebt(\\n        IERC20Pool pool,\\n        uint256 debtAmount,\\n        uint256 collateralAmount,\\n        uint256 price\\n    ) public {\\n        address debtToken = pool.quoteTokenAddress();\\n        address collateralToken = pool.collateralAddress();\\n        uint256 index = convertPriceToIndex(price);\\n        _pull(collateralToken, collateralAmount);\\n        IERC20(collateralToken).safeApprove(address(pool), collateralAmount);\\n        pool.drawDebt(\\n            address(this),\\n            debtAmount * pool.quoteTokenScale(),\\n            index,\\n            collateralAmount * pool.collateralScale()\\n        );\\n        _send(debtToken, debtAmount);\\n        emit ProxyActionsOperation(\\\"AjnaDepositBorrow\\\");\\n    }\\n\\n    /**\\n     *  @notice Deposit collateral and draw debt\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount     Amount of debt to borrow\\n     *  @param  collateralAmount Amount of collateral to deposit\\n     *  @param  price          Price of the bucket\\n     */\\n    function depositAndDraw(\\n        IERC20Pool pool,\\n        uint256 debtAmount,\\n        uint256 collateralAmount,\\n        uint256 price\\n    ) public payable {\\n        if (debtAmount > 0 && collateralAmount > 0) {\\n            depositCollateralAndDrawDebt(pool, debtAmount, collateralAmount, price);\\n        } else if (debtAmount > 0) {\\n            drawDebt(pool, debtAmount, price);\\n        } else if (collateralAmount > 0) {\\n            depositCollateral(pool, collateralAmount, price);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Repay debt\\n     *  @param  pool           Pool address\\n     *  @param  amount         Amount of debt to repay\\n     *  @param  stamploan      Whether to stamp the loan or not\\n     */\\n    function repayDebt(IERC20Pool pool, uint256 amount, bool stamploan) public payable {\\n        address debtToken = pool.quoteTokenAddress();\\n        _pull(debtToken, amount);\\n        IERC20(debtToken).safeApprove(address(pool), amount);\\n        (, , , , , uint256 lupIndex_) = poolInfoUtils.poolPricesInfo(address(pool));\\n        uint256 balanceBefore = IERC20(debtToken).balanceOf(address(this));\\n        pool.repayDebt(address(this), amount * pool.quoteTokenScale(), 0, address(this), lupIndex_);\\n        if (stamploan) {\\n            pool.stampLoan();\\n        }\\n        uint256 repaidAmount = balanceBefore - IERC20(debtToken).balanceOf(address(this));\\n        uint256 leftoverBalance = amount - repaidAmount;\\n        if (leftoverBalance > 0) {\\n            _send(debtToken, leftoverBalance);\\n        }\\n        emit ProxyActionsOperation(\\\"AjnaRepay\\\");\\n    }\\n\\n    /**\\n     *  @notice Withdraw collateral\\n     *  @param  pool           Pool address\\n     *  @param  amount         Amount of collateral to withdraw\\n     */\\n    function withdrawCollateral(IERC20Pool pool, uint256 amount) public {\\n        address collateralToken = pool.collateralAddress();\\n        (, , , , , uint256 lupIndex_) = poolInfoUtils.poolPricesInfo(address(pool));\\n        pool.repayDebt(address(this), 0, amount * pool.collateralScale(), address(this), lupIndex_);\\n        _send(collateralToken, amount);\\n        emit ProxyActionsOperation(\\\"AjnaWithdraw\\\");\\n    }\\n\\n    /**\\n     *  @notice Repay debt and withdraw collateral\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount         Amount of debt to repay\\n     *  @param  collateralAmount         Amount of collateral to withdraw\\n     */\\n    function repayDebtAndWithdrawCollateral(IERC20Pool pool, uint256 debtAmount, uint256 collateralAmount) public {\\n        address debtToken = pool.quoteTokenAddress();\\n        address collateralToken = pool.collateralAddress();\\n        _pull(debtToken, debtAmount);\\n        IERC20(debtToken).safeApprove(address(pool), debtAmount);\\n        (, , , , , uint256 lupIndex_) = poolInfoUtils.poolPricesInfo(address(pool));\\n        uint256 quoteBalanceBefore = IERC20(debtToken).balanceOf(address(this));\\n        pool.repayDebt(\\n            address(this),\\n            debtAmount * pool.quoteTokenScale(),\\n            collateralAmount * pool.collateralScale(),\\n            address(this),\\n            lupIndex_\\n        );\\n        _send(collateralToken, collateralAmount);\\n        uint256 repaidAmount = quoteBalanceBefore - IERC20(debtToken).balanceOf(address(this));\\n        uint256 quoteLeftoverBalance = debtAmount - repaidAmount;\\n        if (quoteLeftoverBalance > 0) {\\n            _send(debtToken, quoteLeftoverBalance);\\n        }\\n        emit ProxyActionsOperation(\\\"AjnaRepayWithdraw\\\");\\n    }\\n\\n    /**\\n     *  @notice Repay debt and withdraw collateral for msg.sender\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount     Amount of debt to repay\\n     *  @param  collateralAmount Amount of collateral to withdraw\\n     *  @param  stamploan      Whether to stamp the loan or not\\n     */\\n    function repayWithdraw(\\n        IERC20Pool pool,\\n        uint256 debtAmount,\\n        uint256 collateralAmount,\\n        bool stamploan\\n    ) external payable {\\n        if (debtAmount > 0 && collateralAmount > 0) {\\n            repayDebtAndWithdrawCollateral(pool, debtAmount, collateralAmount);\\n        } else if (debtAmount > 0) {\\n            repayDebt(pool, debtAmount, stamploan);\\n        } else if (collateralAmount > 0) {\\n            withdrawCollateral(pool, collateralAmount);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Repay debt and close position for msg.sender\\n     *  @param  pool           Pool address\\n     */\\n    function repayAndClose(IERC20Pool pool) public payable {\\n        address collateralToken = pool.collateralAddress();\\n        address debtToken = pool.quoteTokenAddress();\\n\\n        (uint256 debt, uint256 collateral, ) = poolInfoUtils.borrowerInfo(address(pool), address(this));\\n        uint256 debtPlusBuffer = ((debt / pool.quoteTokenScale()) + 1) * pool.quoteTokenScale();\\n        uint256 amountDebt = debtPlusBuffer / pool.quoteTokenScale();\\n        _pull(debtToken, amountDebt);\\n\\n        IERC20(debtToken).safeApprove(address(pool), amountDebt);\\n        (, , , , , uint256 lupIndex_) = poolInfoUtils.poolPricesInfo(address(pool));\\n        pool.repayDebt(address(this), debtPlusBuffer, collateral, address(this), lupIndex_);\\n\\n        uint256 amountCollateral = collateral / pool.collateralScale();\\n        _send(collateralToken, amountCollateral);\\n        emit ProxyActionsOperation(\\\"AjnaRepayAndClose\\\");\\n    }\\n\\n    /**\\n     *  @notice Open position for msg.sender\\n     *  @param  pool           Pool address\\n     *  @param  debtAmount     Amount of debt to borrow\\n     *  @param  collateralAmount Amount of collateral to deposit\\n     *  @param  price          Price of the bucket\\n     */\\n    function openPosition(IERC20Pool pool, uint256 debtAmount, uint256 collateralAmount, uint256 price) public payable {\\n        emit CreatePosition(address(this), \\\"Ajna\\\", \\\"Borrow\\\", pool.collateralAddress(), pool.quoteTokenAddress());\\n        depositAndDraw(pool, debtAmount, collateralAmount, price);\\n    }\\n\\n    /**\\n     *  @notice Open Earn position for msg.sender\\n     *  @param  pool           Pool address\\n     *  @param  depositAmount     Amount of debt to borrow\\n     *  @param  price          Price of the bucket\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function openEarnPosition(\\n        IERC20Pool pool,\\n        uint256 depositAmount,\\n        uint256 price,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        emit CreatePosition(address(this), \\\"Ajna\\\", \\\"Earn\\\", pool.collateralAddress(), pool.quoteTokenAddress());\\n        _supplyQuote(pool, depositAmount, price, revertIfBelowLup);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyQuote\\\");\\n    }\\n\\n    /**\\n     *  @notice Open Earn (with NFT) position for msg.sender\\n     *  @param  pool           Pool address\\n     *  @param  depositAmount     Amount of debt to borrow\\n     *  @param  price          Price of the bucket\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function openEarnPositionNft(\\n        IERC20Pool pool,\\n        uint256 depositAmount,\\n        uint256 price,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        emit CreatePosition(address(this), \\\"Ajna\\\", \\\"Earn\\\", pool.collateralAddress(), pool.quoteTokenAddress());\\n        supplyQuoteMintNftAndStake(pool, depositAmount, price, revertIfBelowLup);\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to add an amount of credit at a specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  amount       The maximum amount of quote token to be moved by a lender.\\n     *  @param  price        The price the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     *  @dev price of uint (10**decimals) collateral token in debt token (10**decimals) with 3 decimal points for instance\\n     *  @dev 1WBTC = 16,990.23 USDC   translates to: 16990230\\n     */\\n    function supplyQuote(IERC20Pool pool, uint256 amount, uint256 price, bool revertIfBelowLup) public payable {\\n        _supplyQuote(pool, amount, price, revertIfBelowLup);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyQuote\\\");\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to remove an amount of credit at a specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  amount       The maximum amount of quote token to be moved by a lender.\\n     *  @param  price        The price the bucket to which the quote tokens will be added.\\n     *  @dev price of uint (10**decimals) collateral token in debt token (10**decimals) with 3 decimal points for instance\\n     *  @dev 1WBTC = 16,990.23 USDC   translates to: 16990230\\n     */\\n    function withdrawQuote(IERC20Pool pool, uint256 amount, uint256 price) public {\\n        _withdrawQuote(pool, amount, price);\\n        emit ProxyActionsOperation(\\\"AjnaWithdrawQuote\\\");\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to move max amount of credit from a specified price bucket to another specified price bucket.\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  oldPrice        The price of the bucket  from which the quote tokens will be removed.\\n     *  @param  newPrice     The price of the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function moveQuote(IERC20Pool pool, uint256 oldPrice, uint256 newPrice, bool revertIfBelowLup) public {\\n        _moveQuote(pool, oldPrice, newPrice, revertIfBelowLup);\\n        emit ProxyActionsOperation(\\\"AjnaMoveQuote\\\");\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to move an amount of credit from a specified price bucket to another specified price bucket,\\n     *  @notice whilst adding additional amount.\\n     *  @param  pool            Address of the Ajana Pool.\\n     *  @param  amountToAdd     The maximum amount of quote token to be moved by a lender.\\n     *  @param  oldPrice        The price of the bucket  from which the quote tokens will be removed.\\n     *  @param  newPrice        The price of the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function supplyAndMoveQuote(\\n        IERC20Pool pool,\\n        uint256 amountToAdd,\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        _supplyQuote(pool, amountToAdd, newPrice, revertIfBelowLup);\\n        _moveQuote(pool, oldPrice, newPrice, revertIfBelowLup);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyAndMoveQuote\\\");\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to move an amount of credit from a specified price bucket to another specified price bucket,\\n     *  @notice whilst withdrawing additional amount.\\n     *  @param  pool            Address of the Ajana Pool.\\n     *  @param  amountToWithdraw     Amount of quote token to be withdrawn by a lender.\\n     *  @param  oldPrice        The price of the bucket  from which the quote tokens will be removed.\\n     *  @param  newPrice        The price of the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function withdrawAndMoveQuote(\\n        IERC20Pool pool,\\n        uint256 amountToWithdraw,\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        bool revertIfBelowLup\\n    ) public {\\n        _withdrawQuote(pool, amountToWithdraw, oldPrice);\\n        _moveQuote(pool, oldPrice, newPrice, revertIfBelowLup);\\n        emit ProxyActionsOperation(\\\"AjnaWithdrawAndMoveQuote\\\");\\n    }\\n\\n    // REWARDS\\n\\n    /**\\n     *  @notice Mints and NFT, memorizes the LPs of the user and stakes the NFT.\\n     *  @param  pool     Address of the Ajana Pool.\\n     *  @param  price    Price of the LPs to be memoriazed.\\n     *  @return tokenId  Id of the minted NFT\\n     */\\n    function _mintAndStakeNft(IERC20Pool pool, uint256 price) internal returns (uint256 tokenId) {\\n        tokenId = _mintNft(pool);\\n\\n        _memorializeLiquidity(price, tokenId, pool);\\n\\n        self.rewardsManager().stake(tokenId);\\n    }\\n\\n    /**\\n     *  @notice Unstakes NFT and redeems position\\n     *  @param  tokenId      ID of the NFT to modify\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  price        Price of the bucket to redeem.\\n     *  @param  burn         Whether to burn the NFT or not\\n     */\\n    function _unstakeNftAndRedeem(uint256 tokenId, IERC20Pool pool, uint256 price, bool burn) internal {\\n        address _ARC = self.ARC();\\n        self.rewardsManager().unstake(tokenId);\\n\\n        _redeemPosition(price, tokenId, address(pool));\\n\\n        if (burn) {\\n            self.positionManager().burn(address(pool), tokenId);\\n            if (IAccountGuard(GUARD).canCall(address(this), _ARC)) {\\n                IAccountGuard(GUARD).permit(_ARC, address(this), false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @notice Supplies quote token, mints and NFT, memorizes the LPs of the user and stakes the NFT.\\n     *  @param  pool     Address of the Ajana Pool.\\n     *  @param  amount   The maximum amount of quote token to be deposited by a lender.\\n     *  @param  price    Price of the bucket to which the quote tokens will be added.\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     *  @return tokenId  Id of the minted NFT\\n     */\\n    function supplyQuoteMintNftAndStake(\\n        IERC20Pool pool,\\n        uint256 amount,\\n        uint256 price,\\n        bool revertIfBelowLup\\n    ) public payable returns (uint256 tokenId) {\\n        _supplyQuote(pool, amount, price, revertIfBelowLup);\\n        tokenId = _mintAndStakeNft(pool, price);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyQuoteMintNftAndStake\\\");\\n    }\\n\\n    /**\\n     *  @notice Adds quote token to existing position and moves to different bucket\\n     *  @param  pool          Address of the Ajana Pool.\\n     *  @param  amountToAdd   The maximum amount of quote token to be deposited by a lender.\\n     *  @param  oldPrice      Index of the bucket to move from.\\n     *  @param  newPrice      Index of the bucket to move to.\\n     *  @param  tokenId       ID of the NFT to modify\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function supplyAndMoveQuoteNft(\\n        IERC20Pool pool,\\n        uint256 amountToAdd,\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        uint256 tokenId,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        self.rewardsManager().unstake(tokenId);\\n\\n        _moveLiquidity(oldPrice, newPrice, tokenId, address(pool), revertIfBelowLup);\\n        _supplyQuote(pool, amountToAdd, newPrice, revertIfBelowLup);\\n        _memorializeLiquidity(newPrice, tokenId, pool);\\n\\n        self.rewardsManager().stake(tokenId);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyAndMoveQuoteNft\\\");\\n    }\\n\\n    /**\\n     *  @notice Adds quote token to existing NFT position\\n     *  @param  pool          Address of the Ajana Pool.\\n     *  @param  amountToAdd   The maximum amount of quote token to be deposited by a lender.\\n     *  @param  price      Price of the bucket to move from.\\n     *  @param  tokenId       ID of the NFT to modify\\n     */\\n    function supplyQuoteNft(\\n        IERC20Pool pool,\\n        uint256 amountToAdd,\\n        uint256 price,\\n        uint256 tokenId,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        self.rewardsManager().unstake(tokenId);\\n\\n        _supplyQuote(pool, amountToAdd, price, revertIfBelowLup);\\n        _memorializeLiquidity(price, tokenId, pool);\\n\\n        self.rewardsManager().stake(tokenId);\\n        emit ProxyActionsOperation(\\\"AjnaSupplyQuoteNft\\\");\\n    }\\n\\n    /**\\n     *  @notice Withdraws quote token to existing position and moves to different bucket\\n     *  @param  pool          Address of the Ajana Pool.\\n     *  @param  amountToWithdraw   The maximum amount of quote token to be withdrawn by a lender.\\n     *  @param  oldPrice      Index of the bucket to move from.\\n     *  @param  newPrice      Index of the bucket to move to.\\n     *  @param  tokenId       ID of the NFT to modify\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function withdrawAndMoveQuoteNft(\\n        IERC20Pool pool,\\n        uint256 amountToWithdraw,\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        uint256 tokenId,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        self.rewardsManager().unstake(tokenId);\\n\\n        _moveLiquidity(oldPrice, newPrice, tokenId, address(pool), revertIfBelowLup);\\n        _redeemPosition(newPrice, tokenId, address(pool));\\n        _withdrawQuote(pool, amountToWithdraw, newPrice);\\n        _memorializeLiquidity(newPrice, tokenId, pool);\\n\\n        self.rewardsManager().stake(tokenId);\\n        emit ProxyActionsOperation(\\\"AjnaWithdrawAndMoveQuoteNft\\\");\\n    }\\n\\n    /**\\n     *  @notice Withdraws quote token from existing NFT position\\n     *  @param  pool          Address of the Ajana Pool.\\n     *  @param  amountToWithdraw   The maximum amount of quote token to be withdrawn by a lender.\\n     *  @param  price      Price of the bucket to withdraw from\\n     *  @param  tokenId       ID of the NFT to modify\\n     */\\n    function withdrawQuoteNft(\\n        IERC20Pool pool,\\n        uint256 amountToWithdraw,\\n        uint256 price,\\n        uint256 tokenId\\n    ) public payable {\\n        self.rewardsManager().unstake(tokenId);\\n\\n        _redeemPosition(price, tokenId, address(pool));\\n        _withdrawQuote(pool, amountToWithdraw, price);\\n        _memorializeLiquidity(price, tokenId, pool);\\n\\n        self.rewardsManager().stake(tokenId);\\n        emit ProxyActionsOperation(\\\"AjnaWithdrawQuoteNft\\\");\\n    }\\n\\n    /**\\n     *  @notice Called by lenders to move an amount of credit from a specified price bucket to another\\n     *  @notice specified price bucket using staked NFT.\\n     *  @param  oldPrice     Index of the bucket to move from.\\n     *  @param  newPrice     Index of the bucket to move to.\\n     *  @param  tokenId      ID of the NFT to modify\\n     *  @param  revertIfBelowLup  Revert if the new price is below the LUP\\n     */\\n    function moveQuoteNft(\\n        IERC20Pool pool,\\n        uint256 oldPrice,\\n        uint256 newPrice,\\n        uint256 tokenId,\\n        bool revertIfBelowLup\\n    ) public payable {\\n        self.rewardsManager().unstake(tokenId);\\n        _moveLiquidity(oldPrice, newPrice, tokenId, address(pool), revertIfBelowLup);\\n        self.rewardsManager().stake(tokenId);\\n        emit ProxyActionsOperation(\\\"AjnaMoveQuoteNft\\\");\\n    }\\n\\n    /**\\n     *  @notice Claim staking rewards\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  tokenId    TokenId to claim rewards for\\n     */\\n    function claimRewardsAndSendToOwner(IERC20Pool pool, uint256 tokenId) public {\\n        uint256 currentEpoch = IERC20Pool(pool).currentBurnEpoch();\\n        uint256 minAmount = self.rewardsManager().calculateRewards(tokenId, currentEpoch);\\n        self.rewardsManager().claimRewards(tokenId, currentEpoch, minAmount);\\n        ajnaToken.transfer(msg.sender, ajnaToken.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @notice Unstakes NFT and withdraws quote token\\n     * @param  pool         Address of the Ajana Pool.\\n     * @param  price        Price of the bucket to redeem.\\n     * @param  tokenId      ID of the NFT to unstake\\n     */\\n    function unstakeNftAndWithdrawQuote(IERC20Pool pool, uint256 price, uint256 tokenId) public {\\n        _unstakeNftAndRedeem(tokenId, pool, price, true);\\n        _withdrawQuote(pool, type(uint256).max, price);\\n        emit ProxyActionsOperation(\\\"AjnaUnstakeNftAndWithdrawQuote\\\");\\n    }\\n\\n    /**\\n     * @notice Unstakes NFT and withdraws quote token and reclaims collateral from liquidated bucket\\n     * @param  pool         Address of the Ajana Pool.\\n     * @param  price        Price of the bucket to redeem.\\n     * @param  tokenId      ID of the NFT to unstake\\n     */\\n    function unstakeNftAndClaimCollateral(IERC20Pool pool, uint256 price, uint256 tokenId) public {\\n        _unstakeNftAndRedeem(tokenId, pool, price, true);\\n        _removeCollateral(pool, price);\\n        emit ProxyActionsOperation(\\\"AjnaUnstakeNftAndClaimCollateral\\\");\\n    }\\n\\n    /**\\n     * @notice Reclaims collateral from liquidated bucket\\n     * @param  pool         Address of the Ajana Pool.\\n     * @param  price        Price of the bucket to redeem.\\n     */\\n    function removeCollateral(IERC20Pool pool, uint256 price) public {\\n        _removeCollateral(pool, price);\\n        emit ProxyActionsOperation(\\\"AjnaRemoveCollateral\\\");\\n    }\\n\\n    // OPT IN AND OUT\\n\\n    /**\\n     *  @notice Mints and NFT, memorizes the LPs of the user and stakes the NFT.\\n     *  @param  pool     Address of the Ajana Pool.\\n     *  @param  price    Price of the LPs to be memoriazed.\\n     *  @return tokenId  Id of the minted NFT\\n     */\\n    function optInStaking(IERC20Pool pool, uint256 price) public returns (uint256 tokenId) {\\n        tokenId = _mintAndStakeNft(pool, price);\\n        emit ProxyActionsOperation(\\\"AjnaOptInStaking\\\");\\n    }\\n\\n    /**\\n     * @notice Unstakes the NFT, burns it and redeems invested LP tokens, memorized by the user.\\n     * @param pool Address of the Ajana Pool.\\n     * @param tokenId Id of the NFT to unstake and burn.\\n     * @param price Price of the LPs to be redeemed.\\n     * @dev This function unstakes the NFT which was previously staked and also calls \\\"_unstakeNftAndRedeem\\\" to redeem invested LP tokens.\\n     */\\n    function optOutStaking(IERC20Pool pool, uint256 tokenId, uint256 price) public {\\n        _unstakeNftAndRedeem(tokenId, pool, price, true);\\n        emit ProxyActionsOperation(\\\"AjnaOptOutStaking\\\");\\n    }\\n\\n    // VIEW FUNCTIONS\\n    /**\\n     * @notice  Converts price to index\\n     * @param   price   price of uint (10**decimals) collateral token in debt token (10**decimals) with 18 decimal points for instance\\n     * @return index   index of the bucket\\n     * @dev     price of uint (10**decimals) collateral token in debt token (10**decimals) with 18 decimal points for instance\\n     * @dev     1WBTC = 16,990.23 USDC   translates to: 16990230000000000000000\\n     */\\n    function convertPriceToIndex(uint256 price) public view returns (uint256) {\\n        return poolInfoUtils.priceToIndex(price);\\n    }\\n\\n    /**\\n     *  @notice Get the amount of quote token deposited to a specific bucket\\n     *  @param  pool         Address of the Ajana Pool.\\n     *  @param  price        Price of the bucket to query\\n     *  @return  quoteAmount Amount of quote token deposited to dpecific bucket\\n     *  @dev price of uint (10**decimals) collateral token in debt token (10**decimals) with 18 decimal points for instance\\n     *  @dev     1WBTC = 16,990.23 USDC   translates to: 16990230000000000000000\\n     */\\n    function getQuoteAmount(IERC20Pool pool, uint256 price) public view returns (uint256 quoteAmount) {\\n        uint256 index = convertPriceToIndex(price);\\n\\n        (uint256 lpCount, ) = pool.lenderInfo(index, address(this));\\n        quoteAmount = poolInfoUtils.lpToQuoteTokens(address(pool), lpCount, index);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolBorrowerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Borrower Actions\\n */\\ninterface IPoolBorrowerActions {\\n\\n    /**\\n     *  @notice Called by fully colalteralized borrowers to restamp the `Neutral Price` of the loan (only if loan is fully collateralized and not in auction).\\n     *          The reason for stamping the neutral price on the loan is to provide some certainty to the borrower as to at what price they can expect to be liquidated.\\n     *          This action can restamp only the loan of `msg.sender`.\\n     */\\n    function stampLoan() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Derived State\\n */\\ninterface IPoolDerivedState {\\n\\n    /**\\n     *  @notice Returns the exchange rate for a given bucket index.\\n     *  @param  index_        The bucket index.\\n     *  @return exchangeRate_ Exchange rate of the bucket (`WAD` precision).\\n     */\\n    function bucketExchangeRate(\\n        uint256 index_\\n    ) external view returns (uint256 exchangeRate_);\\n\\n    /**\\n     *  @notice Returns the prefix sum of a given bucket.\\n     *  @param  index_   The bucket index.\\n     *  @return The deposit up to given index (`WAD` precision).\\n     */\\n    function depositUpToIndex(\\n        uint256 index_\\n    ) external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the bucket index for a given debt amount.\\n     *  @param  debt_  The debt amount to calculate bucket index for (`WAD` precision).\\n     *  @return Bucket index.\\n     */\\n    function depositIndex(\\n        uint256 debt_\\n    ) external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the total amount of quote tokens deposited in pool.\\n     *  @return Total amount of deposited quote tokens (`WAD` precision).\\n     */\\n    function depositSize() external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the meaningful actual utilization of the pool.\\n     *  @return Deposit utilization (`WAD` precision).\\n     */\\n    function depositUtilization() external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the scaling value of deposit at given index.\\n     *  @param  index_  Deposit index.\\n     *  @return Deposit scaling (`WAD` precision).\\n     */\\n    function depositScale(\\n        uint256 index_\\n    ) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Errors.\\n */\\ninterface IPoolErrors {\\n    /**************************/\\n    /*** Common Pool Errors ***/\\n    /**************************/\\n\\n    /**\\n     *  @notice `LP` allowance is already set by the owner.\\n     */\\n    error AllowanceAlreadySet();\\n\\n    /**\\n     *  @notice The action cannot be executed on an active auction.\\n     */\\n    error AuctionActive();\\n\\n    /**\\n     *  @notice Attempted auction to clear doesn't meet conditions.\\n     */\\n    error AuctionNotClearable();\\n\\n    /**\\n     *  @notice Head auction should be cleared prior of executing this action.\\n     */\\n    error AuctionNotCleared();\\n\\n    /**\\n     *  @notice The auction price is greater than the arbed bucket price.\\n     */\\n    error AuctionPriceGtBucketPrice();\\n\\n    /**\\n     *  @notice Pool already initialized.\\n     */\\n    error AlreadyInitialized();\\n\\n    /**\\n     *  @notice Borrower is attempting to create or modify a loan such that their loan's quote token would be less than the pool's minimum debt amount.\\n     */\\n    error AmountLTMinDebt();\\n\\n    /**\\n     *  @notice Recipient of borrowed quote tokens doesn't match the caller of the `drawDebt` function.\\n     */\\n    error BorrowerNotSender();\\n\\n    /**\\n     *  @notice Borrower has a healthy over-collateralized position.\\n     */\\n    error BorrowerOk();\\n\\n    /**\\n     *  @notice Borrower is attempting to borrow more quote token than they have collateral for.\\n     */\\n    error BorrowerUnderCollateralized();\\n\\n    /**\\n     *  @notice Operation cannot be executed in the same block when bucket becomes insolvent.\\n     */\\n    error BucketBankruptcyBlock();\\n\\n    /**\\n     *  @notice User attempted to merge collateral from a lower price bucket into a higher price bucket.\\n     */\\n    error CannotMergeToHigherPrice();\\n\\n    /**\\n     *  @notice User attempted an operation which does not exceed the dust amount, or leaves behind less than the dust amount.\\n     */\\n    error DustAmountNotExceeded();\\n\\n    /**\\n     *  @notice Callback invoked by `flashLoan` function did not return the expected hash (see `ERC-3156` spec).\\n     */\\n    error FlashloanCallbackFailed();\\n\\n    /**\\n     *  @notice Balance of pool contract before flashloan is different than the balance after flashloan.\\n     */\\n    error FlashloanIncorrectBalance();\\n\\n    /**\\n     *  @notice Pool cannot facilitate a flashloan for the specified token address.\\n     */\\n    error FlashloanUnavailableForToken();\\n\\n    /**\\n     *  @notice User is attempting to move or pull more collateral than is available.\\n     */\\n    error InsufficientCollateral();\\n\\n    /**\\n     *  @notice Lender is attempting to move or remove more collateral they have claim to in the bucket.\\n     *  @notice Lender is attempting to remove more collateral they have claim to in the bucket.\\n     *  @notice Lender must have enough `LP` to claim the desired amount of quote from the bucket.\\n     */\\n    error InsufficientLP();\\n\\n    /**\\n     *  @notice Bucket must have more quote available in the bucket than the lender is attempting to claim.\\n     */\\n    error InsufficientLiquidity();\\n\\n    /**\\n     *  @notice When increasing / decreasing `LP` allowances indexes and amounts arrays parameters should have same length.\\n     */\\n    error InvalidAllowancesInput();\\n\\n    /**\\n     *  @notice When transferring `LP` between indices, the new index must be a valid index.\\n     */\\n    error InvalidIndex();\\n\\n    /**\\n     *  @notice The amount used for performed action should be greater than `0`.\\n     */\\n    error InvalidAmount();\\n\\n    /**\\n     *  @notice Borrower is attempting to borrow more quote token than is available before the supplied `limitIndex`.\\n     */\\n    error LimitIndexExceeded();\\n\\n    /**\\n     *  @notice When moving quote token `HTP` must stay below `LUP`.\\n     *  @notice When removing quote token `HTP` must stay below `LUP`.\\n     */\\n    error LUPBelowHTP();\\n\\n    /**\\n     *  @notice Liquidation must result in `LUP` below the borrowers threshold price.\\n     */\\n    error LUPGreaterThanTP();\\n\\n    /**\\n     *  @notice From index and to index arguments to move are the same.\\n     */\\n    error MoveToSameIndex();\\n\\n    /**\\n     *  @notice Owner of the `LP` must have approved the new owner prior to transfer.\\n     */\\n    error NoAllowance();\\n\\n    /**\\n     *  @notice Actor is attempting to take or clear an inactive auction.\\n     */\\n    error NoAuction();\\n\\n    /**\\n     *  @notice No pool reserves are claimable.\\n     */\\n    error NoReserves();\\n\\n    /**\\n     *  @notice Actor is attempting to take or clear an inactive reserves auction.\\n     */\\n    error NoReservesAuction();\\n\\n    /**\\n     *  @notice Lender must have non-zero `LP` when attemptign to remove quote token from the pool.\\n     */\\n    error NoClaim();\\n\\n    /**\\n     *  @notice Borrower has no debt to liquidate.\\n     *  @notice Borrower is attempting to repay when they have no outstanding debt.\\n     */\\n    error NoDebt();\\n\\n    /**\\n     *  @notice Borrower is attempting to borrow an amount of quote tokens that will push the pool into under-collateralization.\\n     */\\n    error PoolUnderCollateralized();\\n\\n    /**\\n     *  @notice Actor is attempting to add or move quote tokens at a price below the `LUP`.\\n     *  @notice Actor is attempting to kick with bucket price below the `LUP`.\\n     */\\n    error PriceBelowLUP();\\n\\n    /**\\n     *  @notice Lender is attempting to remove quote tokens from a bucket that exists above active auction debt from top-of-book downward.\\n     */\\n    error RemoveDepositLockedByAuctionDebt();\\n\\n    /**\\n     * @notice User attempted to kick off a new auction less than `2` weeks since the last auction completed.\\n     */\\n    error ReserveAuctionTooSoon();\\n\\n    /**\\n     *  @notice Take was called before `1` hour had passed from kick time.\\n     */\\n    error TakeNotPastCooldown();\\n\\n    /**\\n     *  @notice Current block timestamp has reached or exceeded a user-provided expiration.\\n     */\\n    error TransactionExpired();\\n\\n    /**\\n     *  @notice The address that transfer `LP` is not approved by the `LP` receiving address.\\n     */\\n    error TransferorNotApproved();\\n\\n    /**\\n     *  @notice Owner of the `LP` attemps to transfer `LP` to same address.\\n     */\\n    error TransferToSameOwner();\\n\\n    /**\\n     *  @notice The threshold price of the loan to be inserted in loans heap is zero.\\n     */\\n    error ZeroThresholdPrice();\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Events\\n */\\ninterface IPoolEvents {\\n\\n    /*********************/\\n    /*** Lender events ***/\\n    /*********************/\\n\\n    /**\\n     *  @notice Emitted when lender adds quote token to the pool.\\n     *  @param  lender    Recipient that added quote tokens.\\n     *  @param  index     Index at which quote tokens were added.\\n     *  @param  amount    Amount of quote tokens added to the pool (`WAD` precision).\\n     *  @param  lpAwarded Amount of `LP` awarded for the deposit (`WAD` precision).\\n     *  @param  lup       `LUP` calculated after deposit.\\n     */\\n    event AddQuoteToken(\\n        address indexed lender,\\n        uint256 indexed index,\\n        uint256 amount,\\n        uint256 lpAwarded,\\n        uint256 lup\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender moves quote token from a bucket price to another.\\n     *  @param  lender         Recipient that moved quote tokens.\\n     *  @param  from           Price bucket from which quote tokens were moved.\\n     *  @param  to             Price bucket where quote tokens were moved.\\n     *  @param  amount         Amount of quote tokens moved (`WAD` precision).\\n     *  @param  lpRedeemedFrom Amount of `LP` removed from the `from` bucket (`WAD` precision).\\n     *  @param  lpAwardedTo    Amount of `LP` credited to the `to` bucket (`WAD` precision).\\n     *  @param  lup            `LUP` calculated after removal.\\n     */\\n    event MoveQuoteToken(\\n        address indexed lender,\\n        uint256 indexed from,\\n        uint256 indexed to,\\n        uint256 amount,\\n        uint256 lpRedeemedFrom,\\n        uint256 lpAwardedTo,\\n        uint256 lup\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender removes quote token from the pool.\\n     *  @param  lender     Recipient that removed quote tokens.\\n     *  @param  index      Index at which quote tokens were removed.\\n     *  @param  amount     Amount of quote tokens removed from the pool (`WAD` precision).\\n     *  @param  lpRedeemed Amount of `LP` exchanged for quote token (`WAD` precision).\\n     *  @param  lup        `LUP` calculated after removal.\\n     */\\n    event RemoveQuoteToken(\\n        address indexed lender,\\n        uint256 indexed index,\\n        uint256 amount,\\n        uint256 lpRedeemed,\\n        uint256 lup\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender claims collateral from a bucket.\\n     *  @param  claimer    Recipient that claimed collateral.\\n     *  @param  index      Index at which collateral was claimed.\\n     *  @param  amount     The amount of collateral (`WAD` precision for `ERC20` pools, number of `NFT` tokens for `ERC721` pools) transferred to the claimer.\\n     *  @param  lpRedeemed Amount of `LP` exchanged for quote token (`WAD` precision).\\n     */\\n    event RemoveCollateral(\\n        address indexed claimer,\\n        uint256 indexed index,\\n        uint256 amount,\\n        uint256 lpRedeemed\\n    );\\n\\n    /***********************/\\n    /*** Borrower events ***/\\n    /***********************/\\n\\n    /**\\n     *  @notice Emitted when borrower repays quote tokens to the pool and/or pulls collateral from the pool.\\n     *  @param  borrower         `msg.sender` or on behalf of sender.\\n     *  @param  quoteRepaid      Amount of quote tokens repaid to the pool (`WAD` precision).\\n     *  @param  collateralPulled The amount of collateral (`WAD` precision for `ERC20` pools, number of `NFT` tokens for `ERC721` pools) transferred to the claimer.\\n     *  @param  lup              `LUP` after repay.\\n     */\\n    event RepayDebt(\\n        address indexed borrower,\\n        uint256 quoteRepaid,\\n        uint256 collateralPulled,\\n        uint256 lup\\n    );\\n\\n    /**********************/\\n    /*** Auction events ***/\\n    /**********************/\\n\\n    /**\\n     *  @notice Emitted when a liquidation is initiated.\\n     *  @param  borrower   Identifies the loan being liquidated.\\n     *  @param  debt       Debt the liquidation will attempt to cover (`WAD` precision).\\n     *  @param  collateral Amount of collateral up for liquidation (`WAD` precision for `ERC20` pools, number of `NFT` tokens for `ERC721` pools).\\n     *  @param  bond       Bond amount locked by kicker (`WAD` precision).\\n     */\\n    event Kick(\\n        address indexed borrower,\\n        uint256 debt,\\n        uint256 collateral,\\n        uint256 bond\\n    );\\n\\n    /**\\n     *  @notice Emitted when kickers are withdrawing funds posted as auction bonds.\\n     *  @param  kicker   The kicker withdrawing bonds.\\n     *  @param  reciever The address receiving withdrawn bond amount.\\n     *  @param  amount   The bond amount that was withdrawn (`WAD` precision).\\n     */\\n    event BondWithdrawn(\\n        address indexed kicker,\\n        address indexed reciever,\\n        uint256 amount\\n    );\\n\\n    /**\\n     *  @notice Emitted when an actor uses quote token to arb higher-priced deposit off the book.\\n     *  @param  borrower    Identifies the loan being liquidated.\\n     *  @param  index       The index of the `Highest Price Bucket` used for this take.\\n     *  @param  amount      Amount of quote token used to purchase collateral (`WAD` precision).\\n     *  @param  collateral  Amount of collateral purchased with quote token (`WAD` precision).\\n     *  @param  bondChange  Impact of this take to the liquidation bond (`WAD` precision).\\n     *  @param  isReward    `True` if kicker was rewarded with `bondChange` amount, `false` if kicker was penalized.\\n     *  @dev    amount / collateral implies the auction price.\\n     */\\n    event BucketTake(\\n        address indexed borrower,\\n        uint256 index,\\n        uint256 amount,\\n        uint256 collateral,\\n        uint256 bondChange,\\n        bool    isReward\\n    );\\n\\n    /**\\n     *  @notice Emitted when `LP` are awarded to a taker or kicker in a bucket take.\\n     *  @param  taker           Actor who invoked the bucket take.\\n     *  @param  kicker          Actor who started the auction.\\n     *  @param  lpAwardedTaker  Amount of `LP` awarded to the taker (`WAD` precision).\\n     *  @param  lpAwardedKicker Amount of `LP` awarded to the actor who started the auction (`WAD` precision).\\n     */\\n    event BucketTakeLPAwarded(\\n        address indexed taker,\\n        address indexed kicker,\\n        uint256 lpAwardedTaker,\\n        uint256 lpAwardedKicker\\n    );\\n\\n    /**\\n     *  @notice Emitted when an actor uses quote token outside of the book to purchase collateral under liquidation.\\n     *  @param  borrower   Identifies the loan being liquidated.\\n     *  @param  amount     Amount of quote token used to purchase collateral (`WAD` precision).\\n     *  @param  collateral Amount of collateral purchased with quote token (for `ERC20` pool, `WAD` precision) or number of `NFT`s purchased (for `ERC721` pool).\\n     *  @param  bondChange Impact of this take to the liquidation bond (`WAD` precision).\\n     *  @param  isReward   `True` if kicker was rewarded with `bondChange` amount, `false` if kicker was penalized.\\n     *  @dev    amount / collateral implies the auction price.\\n     */\\n    event Take(\\n        address indexed borrower,\\n        uint256 amount,\\n        uint256 collateral,\\n        uint256 bondChange,\\n        bool    isReward\\n    );\\n\\n    /**\\n     *  @notice Emitted when an actor settles debt in a completed liquidation\\n     *  @param  borrower    Identifies the loan under liquidation.\\n     *  @param  settledDebt Amount of pool debt settled in this transaction (`WAD` precision).\\n     *  @dev    When `amountRemaining_ == 0`, the auction has been completed cleared and removed from the queue.\\n     */\\n    event Settle(\\n        address indexed borrower,\\n        uint256 settledDebt\\n    );\\n\\n    /**\\n     *  @notice Emitted when auction is completed.\\n     *  @param  borrower   Address of borrower that exits auction.\\n     *  @param  collateral Borrower's remaining collateral when auction completed (`WAD` precision).\\n     */\\n    event AuctionSettle(\\n        address indexed borrower,\\n        uint256 collateral\\n    );\\n\\n    /**\\n     *  @notice Emitted when `NFT` auction is completed.\\n     *  @param  borrower   Address of borrower that exits auction.\\n     *  @param  collateral Borrower's remaining collateral when auction completed.\\n     *  @param  lp         Amount of `LP` given to the borrower to compensate fractional collateral (if any, `WAD` precision).\\n     *  @param  index      Index of the bucket with `LP` to compensate fractional collateral.\\n     */\\n    event AuctionNFTSettle(\\n        address indexed borrower,\\n        uint256 collateral,\\n        uint256 lp,\\n        uint256 index\\n    );\\n\\n    /**\\n     *  @notice Emitted when a `Claimaible Reserve Auction` is started.\\n     *  @param  claimableReservesRemaining Amount of claimable reserves which has not yet been taken (`WAD` precision).\\n     *  @param  auctionPrice               Current price at which `1` quote token may be purchased, denominated in `Ajna`.\\n     *  @param  currentBurnEpoch           Current burn epoch.\\n     */\\n    event KickReserveAuction(\\n        uint256 claimableReservesRemaining,\\n        uint256 auctionPrice,\\n        uint256 currentBurnEpoch\\n    );\\n\\n    /**\\n     *  @notice Emitted when a `Claimaible Reserve Auction` is taken.\\n     *  @param  claimableReservesRemaining Amount of claimable reserves which has not yet been taken (`WAD` precision).\\n     *  @param  auctionPrice               Current price at which `1` quote token may be purchased, denominated in `Ajna`.\\n     *  @param  currentBurnEpoch           Current burn epoch.\\n     */\\n    event ReserveAuction(\\n        uint256 claimableReservesRemaining,\\n        uint256 auctionPrice,\\n        uint256 currentBurnEpoch\\n    );\\n\\n    /**************************/\\n    /*** LP transfer events ***/\\n    /**************************/\\n\\n    /**\\n     *  @notice Emitted when owner increase the `LP` allowance of a spender at specified indexes with specified amounts.\\n     *  @param  owner     `LP` owner.\\n     *  @param  spender   Address approved to transfer `LP`.\\n     *  @param  indexes   Bucket indexes of `LP` approved.\\n     *  @param  amounts   `LP` amounts added (ordered by indexes, `WAD` precision).\\n     */\\n    event IncreaseLPAllowance(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256[] indexes,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     *  @notice Emitted when owner decrease the `LP` allowance of a spender at specified indexes with specified amounts.\\n     *  @param  owner     `LP` owner.\\n     *  @param  spender   Address approved to transfer `LP`.\\n     *  @param  indexes   Bucket indexes of `LP` approved.\\n     *  @param  amounts   `LP` amounts removed (ordered by indexes, `WAD` precision).\\n     */\\n    event DecreaseLPAllowance(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256[] indexes,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender removes the allowance of a spender for their `LP`.\\n     *  @param  owner   `LP` owner.\\n     *  @param  spender Address that is having it's allowance revoked.\\n     *  @param  indexes List of bucket index to remove the allowance from.\\n     */\\n    event RevokeLPAllowance(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256[] indexes\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender whitelists addresses to accept `LP` from.\\n     *  @param  lender      Recipient that approves new owner for `LP`.\\n     *  @param  transferors List of addresses that can transfer `LP` to lender.\\n     */\\n    event ApproveLPTransferors(\\n        address indexed lender,\\n        address[] transferors\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender removes addresses from the `LP` transferors whitelist.\\n     *  @param  lender      Recipient that approves new owner for `LP`.\\n     *  @param  transferors List of addresses that won't be able to transfer `LP` to lender anymore.\\n     */\\n    event RevokeLPTransferors(\\n        address indexed lender,\\n        address[] transferors\\n    );\\n\\n    /**\\n     *  @notice Emitted when a lender transfers their `LP` to a different address.\\n     *  @dev    Used by `PositionManager.memorializePositions()`.\\n     *  @param  owner    The original owner address of the position.\\n     *  @param  newOwner The new owner address of the position.\\n     *  @param  indexes  Array of price bucket indexes at which `LP` were transferred.\\n     *  @param  lp       Amount of `LP` transferred (`WAD` precision).\\n     */\\n    event TransferLP(\\n        address owner,\\n        address newOwner,\\n        uint256[] indexes,\\n        uint256 lp\\n    );\\n\\n    /**************************/\\n    /*** Pool common events ***/\\n    /**************************/\\n\\n    /**\\n     *  @notice Emitted when `LP` are forfeited as a result of the bucket losing all assets.\\n     *  @param  index       The index of the bucket.\\n     *  @param  lpForfeited Amount of `LP` forfeited by lenders (`WAD` precision).\\n     */\\n    event BucketBankruptcy(\\n        uint256 indexed index,\\n        uint256 lpForfeited\\n    );\\n\\n    /**\\n     *  @notice Emitted when a flashloan is taken from pool.\\n     *  @param  receiver The address receiving the flashloan.\\n     *  @param  token    The address of token flashloaned from pool.\\n     *  @param  amount   The amount of tokens flashloaned from pool (token precision).\\n     */\\n    event Flashloan(\\n        address indexed receiver,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    /**\\n     *  @notice Emitted when a loan `Neutral Price` is restamped.\\n     *  @param  borrower Identifies the loan to update the `Neutral Price`.\\n     */\\n    event LoanStamped(\\n        address indexed borrower\\n    );\\n\\n    /**\\n     *  @notice Emitted when pool interest rate is reset. This happens when `interest rate > 10%` and `debtEma < 5%` of `depositEma`\\n     *  @param  oldRate Old pool interest rate.\\n     *  @param  newRate New pool interest rate.\\n     */\\n    event ResetInterestRate(\\n        uint256 oldRate,\\n        uint256 newRate\\n    );\\n\\n    /**\\n     *  @notice Emitted when pool interest rate is updated.\\n     *  @param  oldRate Old pool interest rate.\\n     *  @param  newRate New pool interest rate.\\n     */\\n    event UpdateInterestRate(\\n        uint256 oldRate,\\n        uint256 newRate\\n    );\\n\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Immutables\\n */\\ninterface IPoolImmutables {\\n\\n    /**\\n     *  @notice Returns the type of the pool (`0` for `ERC20`, `1` for `ERC721`).\\n     */\\n    function poolType() external pure returns (uint8);\\n\\n    /**\\n     *  @notice Returns the address of the pool's collateral token.\\n     */\\n    function collateralAddress() external pure returns (address);\\n\\n    /**\\n     *  @notice Returns the address of the pool's quote token.\\n     */\\n    function quoteTokenAddress() external pure returns (address);\\n\\n    /**\\n     *  @notice Returns the `quoteTokenScale` state variable.\\n     *  @notice Token scale is also the minimum amount a lender may have in a bucket (dust amount).\\n     *  @return The precision of the quote `ERC20` token based on decimals.\\n     */\\n    function quoteTokenScale() external pure returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolKickerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Kicker Actions\\n */\\ninterface IPoolKickerActions {\\n\\n    /********************/\\n    /*** Liquidations ***/\\n    /********************/\\n\\n    /**\\n     *  @notice Called by actors to initiate a liquidation.\\n     *  @param  borrower_     Identifies the loan to liquidate.\\n     *  @param  npLimitIndex_ Index of the lower bound of `NP` tolerated when kicking the auction.\\n     */\\n    function kick(\\n        address borrower_,\\n        uint256 npLimitIndex_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by lenders to liquidate the top loan.\\n     *  @param  index_        The deposit index to use for kicking the top loan.\\n     *  @param  npLimitIndex_ Index of the lower bound of `NP` tolerated when kicking the auction.\\n     */\\n    function lenderKick(\\n        uint256 index_,\\n        uint256 npLimitIndex_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by kickers to withdraw their auction bonds (the amount of quote tokens that are not locked in active auctions).\\n     *  @param  recipient_ Address to receive claimed bonds amount.\\n     *  @param  maxAmount_ The max amount to withdraw from auction bonds (`WAD` precision). Constrained by claimable amounts and liquidity.\\n     */\\n    function withdrawBonds(\\n        address recipient_,\\n        uint256 maxAmount_\\n    ) external;\\n\\n    /***********************/\\n    /*** Reserve Auction ***/\\n    /***********************/\\n\\n    /**\\n     *  @notice Called by actor to start a `Claimable Reserve Auction` (`CRA`).\\n     */\\n    function kickReserveAuction() external;\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolLenderActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Lender Actions\\n */\\ninterface IPoolLenderActions {\\n\\n    /*********************************************/\\n    /*** Quote/collateral management functions ***/\\n    /*********************************************/\\n\\n    /**\\n     *  @notice Called by lenders to add an amount of credit at a specified price bucket.\\n     *  @param  amount_           The amount of quote token to be added by a lender (`WAD` precision).\\n     *  @param  index_            The index of the bucket to which the quote tokens will be added.\\n     *  @param  expiry_           Timestamp after which this transaction will revert, preventing inclusion in a block with unfavorable price.\\n     *  @param  revertIfBelowLup_ The tx will revert if price of the bucket to which the quote tokens will be added is below `LUP` price (and avoid paying fee for deposit below `LUP`).\\n     *  @return bucketLP_         The amount of `LP` changed for the added quote tokens (`WAD` precision).\\n     */\\n    function addQuoteToken(\\n        uint256 amount_,\\n        uint256 index_,\\n        uint256 expiry_,\\n        bool    revertIfBelowLup_\\n    ) external returns (uint256 bucketLP_);\\n\\n    /**\\n     *  @notice Called by lenders to move an amount of credit from a specified price bucket to another specified price bucket.\\n     *  @param  maxAmount_        The maximum amount of quote token to be moved by a lender (`WAD` precision).\\n     *  @param  fromIndex_        The bucket index from which the quote tokens will be removed.\\n     *  @param  toIndex_          The bucket index to which the quote tokens will be added.\\n     *  @param  expiry_           Timestamp after which this transaction will revert, preventing inclusion in a block with unfavorable price.\\n     *  @param  revertIfBelowLup_ The tx will revert if quote token is moved from above the `LUP` to below the `LUP` (and avoid paying fee for move below `LUP`).\\n     *  @return fromBucketLP_     The amount of `LP` moved out from bucket (`WAD` precision).\\n     *  @return toBucketLP_       The amount of `LP` moved to destination bucket (`WAD` precision).\\n     *  @return movedAmount_      The amount of quote token moved (`WAD` precision).\\n     */\\n    function moveQuoteToken(\\n        uint256 maxAmount_,\\n        uint256 fromIndex_,\\n        uint256 toIndex_,\\n        uint256 expiry_,\\n        bool    revertIfBelowLup_\\n    ) external returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_);\\n\\n    /**\\n     *  @notice Called by lenders to claim collateral from a price bucket.\\n     *  @param  maxAmount_     The amount of collateral (`WAD` precision for `ERC20` pools, number of `NFT` tokens for `ERC721` pools) to claim.\\n     *  @param  index_         The bucket index from which collateral will be removed.\\n     *  @return removedAmount_ The amount of collateral removed (`WAD` precision).\\n     *  @return redeemedLP_    The amount of `LP` used for removing collateral amount (`WAD` precision).\\n     */\\n    function removeCollateral(\\n        uint256 maxAmount_,\\n        uint256 index_\\n    ) external returns (uint256 removedAmount_, uint256 redeemedLP_);\\n\\n    /**\\n     *  @notice Called by lenders to remove an amount of credit at a specified price bucket.\\n     *  @param  maxAmount_     The max amount of quote token to be removed by a lender (`WAD` precision).\\n     *  @param  index_         The bucket index from which quote tokens will be removed.\\n     *  @return removedAmount_ The amount of quote token removed (`WAD` precision).\\n     *  @return redeemedLP_    The amount of `LP` used for removing quote tokens amount (`WAD` precision).\\n     */\\n    function removeQuoteToken(\\n        uint256 maxAmount_,\\n        uint256 index_\\n    ) external returns (uint256 removedAmount_, uint256 redeemedLP_);\\n\\n    /********************************/\\n    /*** Interest update function ***/\\n    /********************************/\\n\\n    /**\\n     *  @notice Called by actors to update pool interest rate (can be updated only once in a `12` hours period of time).\\n     */\\n    function updateInterest() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolLPActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool `LP` Actions\\n */\\ninterface IPoolLPActions {\\n\\n    /**\\n     *  @notice Called by `LP` owners to approve transfer of an amount of `LP` to a new owner.\\n     *  @dev    Intended for use by the `PositionManager` contract.\\n     *  @param  spender_ The new owner of the `LP`.\\n     *  @param  indexes_ Bucket indexes from where `LP` are transferred.\\n     *  @param  amounts_ The amounts of `LP` approved to transfer (`WAD` precision).\\n     */\\n    function increaseLPAllowance(\\n        address spender_,\\n        uint256[] calldata indexes_,\\n        uint256[] calldata amounts_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by `LP` owners to decrease the amount of `LP` that can be spend by a new owner.\\n     *  @dev    Intended for use by the `PositionManager` contract.\\n     *  @param  spender_ The new owner of the `LP`.\\n     *  @param  indexes_ Bucket indexes from where `LP` are transferred.\\n     *  @param  amounts_ The amounts of `LP` disapproved to transfer (`WAD` precision).\\n     */\\n    function decreaseLPAllowance(\\n        address spender_,\\n        uint256[] calldata indexes_,\\n        uint256[] calldata amounts_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by `LP` owners to decrease the amount of `LP` that can be spend by a new owner.\\n     *  @param  spender_ Address that is having it's allowance revoked.\\n     *  @param  indexes_ List of bucket index to remove the allowance from.\\n     */\\n    function revokeLPAllowance(\\n        address spender_,\\n        uint256[] calldata indexes_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by `LP` owners to allow addresses that can transfer LP.\\n     *  @dev    Intended for use by the `PositionManager` contract.\\n     *  @param  transferors_ Addresses that are allowed to transfer `LP` to new owner.\\n     */\\n    function approveLPTransferors(\\n        address[] calldata transferors_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by `LP` owners to revoke addresses that can transfer `LP`.\\n     *  @dev    Intended for use by the `PositionManager` contract.\\n     *  @param  transferors_ Addresses that are revoked to transfer `LP` to new owner.\\n     */\\n    function revokeLPTransferors(\\n        address[] calldata transferors_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by `LP` owners to transfers their `LP` to a different address. `approveLpOwnership` needs to be run first.\\n     *  @dev    Used by `PositionManager.memorializePositions()`.\\n     *  @param  owner_    The original owner address of the position.\\n     *  @param  newOwner_ The new owner address of the position.\\n     *  @param  indexes_  Array of price buckets index at which `LP` were moved.\\n     */\\n    function transferLP(\\n        address owner_,\\n        address newOwner_,\\n        uint256[] calldata indexes_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolSettlerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Settler Actions\\n */\\ninterface IPoolSettlerActions {\\n\\n    /**\\n     *  @notice Called by actors to settle an amount of debt in a completed liquidation.\\n     *  @param  borrowerAddress_ Address of the auctioned borrower.\\n     *  @param  maxDepth_        Measured from `HPB`, maximum number of buckets deep to settle debt.\\n     *  @dev    `maxDepth_` is used to prevent unbounded iteration clearing large liquidations.\\n     */\\n    function settle(\\n        address borrowerAddress_,\\n        uint256 maxDepth_\\n    ) external;\\n\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool State\\n */\\ninterface IPoolState {\\n\\n    /**\\n     *  @notice Returns details of an auction for a given borrower address.\\n     *  @param  borrower_     Address of the borrower that is liquidated.\\n     *  @return kicker_       Address of the kicker that is kicking the auction.\\n     *  @return bondFactor_   The factor used for calculating bond size.\\n     *  @return bondSize_     The bond amount in quote token terms.\\n     *  @return kickTime_     Time the liquidation was initiated.\\n     *  @return kickMomp_     Price where the average loan utilizes deposit, at the time when the loan is liquidated (kicked).\\n     *  @return neutralPrice_ `Neutral Price` of auction.\\n     *  @return head_         Address of the head auction.\\n     *  @return next_         Address of the next auction in queue.\\n     *  @return prev_         Address of the prev auction in queue.\\n     *  @return alreadyTaken_ True if take has been called on auction\\n     */\\n    function auctionInfo(address borrower_)\\n        external\\n        view\\n        returns (\\n            address kicker_,\\n            uint256 bondFactor_,\\n            uint256 bondSize_,\\n            uint256 kickTime_,\\n            uint256 kickMomp_,\\n            uint256 neutralPrice_,\\n            address head_,\\n            address next_,\\n            address prev_,\\n            bool alreadyTaken_\\n        );\\n\\n    /**\\n     *  @notice Returns pool related debt values.\\n     *  @return debt_                Current amount of debt owed by borrowers in pool.\\n     *  @return accruedDebt_         Debt owed by borrowers based on last inflator snapshot.\\n     *  @return debtInAuction_       Total amount of debt in auction.\\n     *  @return t0Debt2ToCollateral_ t0debt accross all borrowers divided by their collateral, used in determining a collateralization weighted debt.\\n     */\\n    function debtInfo()\\n        external\\n        view\\n        returns (\\n            uint256 debt_,\\n            uint256 accruedDebt_,\\n            uint256 debtInAuction_,\\n            uint256 t0Debt2ToCollateral_\\n        );\\n\\n    /**\\n     *  @notice Mapping of borrower addresses to `Borrower` structs.\\n     *  @dev    NOTE: Cannot use appended underscore syntax for return params since struct is used.\\n     *  @param  borrower_   Address of the borrower.\\n     *  @return t0Debt_     Amount of debt borrower would have had if their loan was the first debt drawn from the pool.\\n     *  @return collateral_ Amount of collateral that the borrower has deposited, in collateral token.\\n     *  @return t0Np_       t0 `Neutral Price`\\n     */\\n    function borrowerInfo(address borrower_)\\n        external\\n        view\\n        returns (\\n            uint256 t0Debt_,\\n            uint256 collateral_,\\n            uint256 t0Np_\\n        );\\n\\n    /**\\n     *  @notice Mapping of buckets indexes to `Bucket` structs.\\n     *  @dev    NOTE: Cannot use appended underscore syntax for return params since struct is used.\\n     *  @param  index_               Bucket index.\\n     *  @return lpAccumulator_       Amount of `LP` accumulated in current bucket.\\n     *  @return availableCollateral_ Amount of collateral available in current bucket.\\n     *  @return bankruptcyTime_      Timestamp when bucket become insolvent, `0` if healthy.\\n     *  @return bucketDeposit_       Amount of quote tokens in bucket.\\n     *  @return bucketScale_         Bucket multiplier.\\n     */\\n    function bucketInfo(uint256 index_)\\n        external\\n        view\\n        returns (\\n            uint256 lpAccumulator_,\\n            uint256 availableCollateral_,\\n            uint256 bankruptcyTime_,\\n            uint256 bucketDeposit_,\\n            uint256 bucketScale_\\n        );\\n\\n    /**\\n     *  @notice Mapping of burnEventEpoch to `BurnEvent` structs.\\n     *  @dev    Reserve auctions correspond to burn events.\\n     *  @param  burnEventEpoch_  Id of the current reserve auction.\\n     *  @return burnBlock_       Block in which a reserve auction started.\\n     *  @return totalInterest_   Total interest as of the reserve auction.\\n     *  @return totalBurned_     Total ajna tokens burned as of the reserve auction.\\n     */\\n    function burnInfo(uint256 burnEventEpoch_) external view returns (uint256, uint256, uint256);\\n\\n    /**\\n     *  @notice Returns the latest `burnEventEpoch` of reserve auctions.\\n     *  @dev    If a reserve auction is active, it refers to the current reserve auction. If no reserve auction is active, it refers to the last reserve auction.\\n     *  @return Current `burnEventEpoch`.\\n     */\\n    function currentBurnEpoch() external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns information about the pool `EMA (Exponential Moving Average)` variables.\\n     *  @return debtColEma_   Debt squared to collateral Exponential, numerator to `TU` calculation.\\n     *  @return lupt0DebtEma_ Exponential of `LUP * t0 debt`, denominator to `TU` calculation\\n     *  @return debtEma_      Exponential debt moving average.\\n     *  @return depositEma_   sample of meaningful deposit Exponential, denominator to `MAU` calculation.\\n     */\\n    function emasInfo()\\n        external\\n        view\\n        returns (\\n            uint256 debtColEma_,\\n            uint256 lupt0DebtEma_,\\n            uint256 debtEma_,\\n            uint256 depositEma_\\n    );\\n\\n    /**\\n     *  @notice Returns information about pool inflator.\\n     *  @return inflator_   Pool inflator value.\\n     *  @return lastUpdate_ The timestamp of the last `inflator` update.\\n     */\\n    function inflatorInfo()\\n        external\\n        view\\n        returns (\\n            uint256 inflator_,\\n            uint256 lastUpdate_\\n    );\\n\\n    /**\\n     *  @notice Returns information about pool interest rate.\\n     *  @return interestRate_       Current interest rate in pool.\\n     *  @return interestRateUpdate_ The timestamp of the last interest rate update.\\n     */\\n    function interestRateInfo()\\n        external\\n        view\\n        returns (\\n            uint256 interestRate_,\\n            uint256 interestRateUpdate_\\n        );\\n\\n\\n    /**\\n     *  @notice Returns details about kicker balances.\\n     *  @param  kicker_    The address of the kicker to retrieved info for.\\n     *  @return claimable_ Amount of quote token kicker can claim / withdraw from pool at any time.\\n     *  @return locked_    Amount of quote token kicker locked in auctions (as bonds).\\n     */\\n    function kickerInfo(address kicker_)\\n        external\\n        view\\n        returns (\\n            uint256 claimable_,\\n            uint256 locked_\\n        );\\n\\n    /**\\n     *  @notice Mapping of buckets indexes and owner addresses to `Lender` structs.\\n     *  @param  index_       Bucket index.\\n     *  @param  lender_      Address of the liquidity provider.\\n     *  @return lpBalance_   Amount of `LP` owner has in current bucket.\\n     *  @return depositTime_ Time the user last deposited quote token.\\n     */\\n    function lenderInfo(\\n        uint256 index_,\\n        address lender_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 lpBalance_,\\n            uint256 depositTime_\\n    );\\n\\n    /**\\n     *  @notice Return the `LP` allowance a `LP` owner provided to a spender.\\n     *  @param  index_     Bucket index.\\n     *  @param  spender_   Address of the `LP` spender.\\n     *  @param  owner_     The initial owner of the `LP`.\\n     *  @return allowance_ Amount of `LP` spender can utilize.\\n     */\\n    function lpAllowance(\\n        uint256 index_,\\n        address spender_,\\n        address owner_\\n    ) external view returns (uint256 allowance_);\\n\\n    /**\\n     *  @notice Returns information about a loan in the pool.\\n     *  @param  loanId_         Loan's id within loan heap. Max loan is position `1`.\\n     *  @return borrower_       Borrower address at the given position.\\n     *  @return thresholdPrice_ Borrower threshold price in pool.\\n     */\\n    function loanInfo(\\n        uint256 loanId_\\n    )\\n        external\\n        view\\n        returns (\\n            address borrower_,\\n            uint256 thresholdPrice_\\n    );\\n\\n    /**\\n     *  @notice Returns information about pool loans.\\n     *  @return maxBorrower_       Borrower address with highest threshold price.\\n     *  @return maxThresholdPrice_ Highest threshold price in pool.\\n     *  @return noOfLoans_         Total number of loans.\\n     */\\n    function loansInfo()\\n        external\\n        view\\n        returns (\\n            address maxBorrower_,\\n            uint256 maxThresholdPrice_,\\n            uint256 noOfLoans_\\n    );\\n\\n    /**\\n     *  @notice Returns information about pool reserves.\\n     *  @return liquidationBondEscrowed_ Amount of liquidation bond across all liquidators.\\n     *  @return reserveAuctionUnclaimed_ Amount of claimable reserves which has not been taken in the `Claimable Reserve Auction`.\\n     *  @return reserveAuctionKicked_    Time a `Claimable Reserve Auction` was last kicked.\\n     *  @return totalInterestEarned_     Total interest earned by all lenders in the pool\\n     */\\n    function reservesInfo()\\n        external\\n        view\\n        returns (\\n            uint256 liquidationBondEscrowed_,\\n            uint256 reserveAuctionUnclaimed_,\\n            uint256 reserveAuctionKicked_,\\n            uint256 totalInterestEarned_\\n    );\\n\\n    /**\\n     *  @notice Returns the `pledgedCollateral` state variable.\\n     *  @return The total pledged collateral in the system, in WAD units.\\n     */\\n    function pledgedCollateral() external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the total number of active auctions in pool.\\n     *  @return totalAuctions_ Number of active auctions.\\n     */\\n    function totalAuctionsInPool() external view returns (uint256);\\n\\n     /**\\n     *  @notice Returns the `t0Debt` state variable.\\n     *  @dev    This value should be multiplied by inflator in order to calculate current debt of the pool.\\n     *  @return The total `t0Debt` in the system, in `WAD` units.\\n     */\\n    function totalT0Debt() external view returns (uint256);\\n\\n    /**\\n     *  @notice Returns the `t0DebtInAuction` state variable.\\n     *  @dev    This value should be multiplied by inflator in order to calculate current debt in auction of the pool.\\n     *  @return The total `t0DebtInAuction` in the system, in `WAD` units.\\n     */\\n    function totalT0DebtInAuction() external view returns (uint256);\\n\\n    /**\\n     *  @notice Mapping of addresses that can transfer `LP` to a given lender.\\n     *  @param  lender_     Lender that receives `LP`.\\n     *  @param  transferor_ Transferor that transfers `LP`.\\n     *  @return True if the transferor is approved by lender.\\n     */\\n    function approvedTransferors(\\n        address lender_,\\n        address transferor_\\n    ) external view returns (bool);\\n\\n}\\n\\n/*********************/\\n/*** State Structs ***/\\n/*********************/\\n\\n/******************/\\n/*** Pool State ***/\\n/******************/\\n\\n/// @dev Struct holding inflator state.\\nstruct InflatorState {\\n    uint208 inflator;       // [WAD] pool's inflator\\n    uint48  inflatorUpdate; // [SEC] last time pool's inflator was updated\\n}\\n\\n/// @dev Struct holding pool interest state.\\nstruct InterestState {\\n    uint208 interestRate;        // [WAD] pool's interest rate\\n    uint48  interestRateUpdate;  // [SEC] last time pool's interest rate was updated (not before 12 hours passed)\\n    uint256 debt;                // [WAD] previous update's debt\\n    uint256 meaningfulDeposit;   // [WAD] previous update's meaningfulDeposit\\n    uint256 t0Debt2ToCollateral; // [WAD] utilization weight accumulator, tracks debt and collateral relationship accross borrowers \\n    uint256 debtCol;             // [WAD] previous debt squared to collateral\\n    uint256 lupt0Debt;           // [WAD] previous LUP * t0 debt\\n}\\n\\n/// @dev Struct holding pool EMAs state.\\nstruct EmaState {\\n    uint256 debtEma;             // [WAD] sample of debt EMA, numerator to MAU calculation\\n    uint256 depositEma;          // [WAD] sample of meaningful deposit EMA, denominator to MAU calculation\\n    uint256 debtColEma;          // [WAD] debt squared to collateral EMA, numerator to TU calculation\\n    uint256 lupt0DebtEma;        // [WAD] EMA of LUP * t0 debt, denominator to TU calculation\\n    uint256 emaUpdate;           // [SEC] last time pool's EMAs were updated\\n}\\n\\n/// @dev Struct holding pool balances state.\\nstruct PoolBalancesState {\\n    uint256 pledgedCollateral; // [WAD] total collateral pledged in pool\\n    uint256 t0DebtInAuction;   // [WAD] Total debt in auction used to restrict LPB holder from withdrawing\\n    uint256 t0Debt;            // [WAD] Pool debt as if the whole amount was incurred upon the first loan\\n}\\n\\n/// @dev Struct holding pool params (in memory only).\\nstruct PoolState {\\n    uint8   poolType;             // pool type, can be ERC20 or ERC721\\n    uint256 t0Debt;               // [WAD] t0 debt in pool\\n    uint256 t0DebtInAuction;      // [WAD] t0 debt in auction within pool\\n    uint256 debt;                 // [WAD] total debt in pool, accrued in current block\\n    uint256 collateral;           // [WAD] total collateral pledged in pool\\n    uint256 inflator;             // [WAD] current pool inflator\\n    bool    isNewInterestAccrued; // true if new interest already accrued in current block\\n    uint256 rate;                 // [WAD] pool's current interest rate\\n    uint256 quoteTokenScale;      // [WAD] quote token scale of the pool. Same as quote token dust.\\n}\\n\\n/*********************/\\n/*** Buckets State ***/\\n/*********************/\\n\\n/// @dev Struct holding lender state.\\nstruct Lender {\\n    uint256 lps;         // [WAD] Lender LP accumulator\\n    uint256 depositTime; // timestamp of last deposit\\n}\\n\\n/// @dev Struct holding bucket state.\\nstruct Bucket {\\n    uint256 lps;                        // [WAD] Bucket LP accumulator\\n    uint256 collateral;                 // [WAD] Available collateral tokens deposited in the bucket\\n    uint256 bankruptcyTime;             // Timestamp when bucket become insolvent, 0 if healthy\\n    mapping(address => Lender) lenders; // lender address to Lender struct mapping\\n}\\n\\n/**********************/\\n/*** Deposits State ***/\\n/**********************/\\n\\n/// @dev Struct holding deposits (Fenwick) values and scaling.\\nstruct DepositsState {\\n    uint256[8193] values;  // Array of values in the FenwickTree.\\n    uint256[8193] scaling; // Array of values which scale (multiply) the FenwickTree accross indexes.\\n}\\n\\n/*******************/\\n/*** Loans State ***/\\n/*******************/\\n\\n/// @dev Struct holding loans state.\\nstruct LoansState {\\n    Loan[] loans;\\n    mapping (address => uint)     indices;   // borrower address => loan index mapping\\n    mapping (address => Borrower) borrowers; // borrower address => Borrower struct mapping\\n}\\n\\n/// @dev Struct holding loan state.\\nstruct Loan {\\n    address borrower;       // borrower address\\n    uint96  thresholdPrice; // [WAD] Loan's threshold price.\\n}\\n\\n/// @dev Struct holding borrower state.\\nstruct Borrower {\\n    uint256 t0Debt;     // [WAD] Borrower debt time-adjusted as if it was incurred upon first loan of pool.\\n    uint256 collateral; // [WAD] Collateral deposited by borrower.\\n    uint256 t0Np;       // [WAD] Neutral Price time-adjusted as if it was incurred upon first loan of pool.\\n}\\n\\n/**********************/\\n/*** Auctions State ***/\\n/**********************/\\n\\n/// @dev Struct holding pool auctions state.\\nstruct AuctionsState {\\n    uint96  noOfAuctions;                         // total number of auctions in pool\\n    address head;                                 // first address in auction queue\\n    address tail;                                 // last address in auction queue\\n    uint256 totalBondEscrowed;                    // [WAD] total amount of quote token posted as auction kick bonds\\n    mapping(address => Liquidation) liquidations; // mapping of borrower address and auction details\\n    mapping(address => Kicker)      kickers;      // mapping of kicker address and kicker balances\\n}\\n\\n/// @dev Struct holding liquidation state.\\nstruct Liquidation {\\n    address kicker;       // address that initiated liquidation\\n    uint96  bondFactor;   // [WAD] bond factor used to start liquidation\\n    uint96  kickTime;     // timestamp when liquidation was started\\n    address prev;         // previous liquidated borrower in auctions queue\\n    uint96  kickMomp;     // [WAD] Momp when liquidation was started\\n    address next;         // next liquidated borrower in auctions queue\\n    uint160 bondSize;     // [WAD] liquidation bond size\\n    uint96  neutralPrice; // [WAD] Neutral Price when liquidation was started\\n    bool    alreadyTaken; // true if take has been called on auction\\n}\\n\\n/// @dev Struct holding kicker state.\\nstruct Kicker {\\n    uint256 claimable; // [WAD] kicker's claimable balance\\n    uint256 locked;    // [WAD] kicker's balance of tokens locked in auction bonds\\n}\\n\\n/******************************/\\n/*** Reserve Auctions State ***/\\n/******************************/\\n\\n/// @dev Struct holding reserve auction state.\\nstruct ReserveAuctionState {\\n    uint256 kicked;                            // Time a Claimable Reserve Auction was last kicked.\\n    uint256 unclaimed;                         // [WAD] Amount of claimable reserves which has not been taken in the Claimable Reserve Auction.\\n    uint256 latestBurnEventEpoch;              // Latest burn event epoch.\\n    uint256 totalAjnaBurned;                   // [WAD] Total ajna burned in the pool.\\n    uint256 totalInterestEarned;               // [WAD] Total interest earned by all lenders in the pool.\\n    mapping (uint256 => BurnEvent) burnEvents; // Mapping burnEventEpoch => BurnEvent.\\n}\\n\\n/// @dev Struct holding burn event state.\\nstruct BurnEvent {\\n    uint256 timestamp;     // time at which the burn event occured\\n    uint256 totalInterest; // [WAD] current pool interest accumulator `PoolCommons.accrueInterest().newInterest`\\n    uint256 totalBurned;   // [WAD] burn amount accumulator\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/commons/IPoolTakerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Pool Taker Actions\\n */\\ninterface IPoolTakerActions {\\n\\n    /**\\n     *  @notice Called by actors to use quote token to arb higher-priced deposit off the book.\\n     *  @param  borrowerAddress_  Address of the borower take is being called upon.\\n     *  @param  depositTake_      If `true` then the take will happen at an auction price equal with bucket price. Auction price is used otherwise.\\n     *  @param  index_            Index of a bucket, likely the `HPB`, in which collateral will be deposited.\\n     */\\n    function bucketTake(\\n        address borrowerAddress_,\\n        bool    depositTake_,\\n        uint256 index_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by actors to purchase collateral from the auction in exchange for quote token.\\n     *  @param  borrowerAddress_  Address of the borower take is being called upon.\\n     *  @param  maxAmount_        Max amount of collateral that will be taken from the auction (`WAD` precision for `ERC20` pools, max number of `NFT`s for `ERC721` pools).\\n     *  @param  callee_           Identifies where collateral should be sent and where quote token should be obtained.\\n     *  @param  data_             If provided, take will assume the callee implements `IERC*Taker`.  Take will send collateral to \\n     *                            callee before passing this data to `IERC*Taker.atomicSwapCallback`.  If not provided, \\n     *                            the callback function will not be invoked.\\n     */\\n    function take(\\n        address        borrowerAddress_,\\n        uint256        maxAmount_,\\n        address        callee_,\\n        bytes calldata data_\\n    ) external;\\n\\n    /***********************/\\n    /*** Reserve Auction ***/\\n    /***********************/\\n\\n    /**\\n     *  @notice Purchases claimable reserves during a `CRA` using `Ajna` token.\\n     *  @param  maxAmount_ Maximum amount of quote token to purchase at the current auction price (`WAD` precision).\\n     *  @return amount_    Actual amount of reserves taken (`WAD` precision).\\n     */\\n    function takeReserves(\\n        uint256 maxAmount_\\n    ) external returns (uint256 amount_);\\n\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/erc20/IERC20Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport { IPool }                     from '../IPool.sol';\\nimport { IERC20PoolBorrowerActions } from './IERC20PoolBorrowerActions.sol';\\nimport { IERC20PoolLenderActions }   from './IERC20PoolLenderActions.sol';\\nimport { IERC20PoolImmutables }      from './IERC20PoolImmutables.sol';\\nimport { IERC20PoolEvents }          from './IERC20PoolEvents.sol';\\n\\n/**\\n * @title ERC20 Pool\\n */\\ninterface IERC20Pool is\\n    IPool,\\n    IERC20PoolLenderActions,\\n    IERC20PoolBorrowerActions,\\n    IERC20PoolImmutables,\\n    IERC20PoolEvents\\n{\\n\\n    /**\\n     *  @notice Initializes a new pool, setting initial state variables.\\n     *  @param  rate_ Initial interest rate of the pool (min accepted value 1%, max accepted value 10%).\\n     */\\n    function initialize(uint256 rate_) external;\\n\\n    /**\\n     *  @notice Returns the minimum amount of collateral an actor may have in a bucket.\\n     *  @param  bucketIndex_ The bucket index for which the dust limit is desired, or `0` for pledged collateral.\\n     *  @return The dust limit for `bucketIndex_`.\\n     */\\n    function bucketCollateralDust(\\n        uint256 bucketIndex_\\n    ) external pure returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/erc20/IERC20PoolBorrowerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title ERC20 Pool Borrower Actions\\n */\\ninterface IERC20PoolBorrowerActions {\\n\\n    /**\\n     *  @notice Called by borrowers to add collateral to the pool and/or borrow quote from the pool.\\n     *  @dev    Can be called by borrowers with either `0` `amountToBorrow_` or `0` `collateralToPledge_`, if borrower only wants to take a single action. \\n     *  @param  borrowerAddress_    The borrower to whom collateral was pledged, and/or debt was drawn for.\\n     *  @param  amountToBorrow_     The amount of quote tokens to borrow (`WAD` precision).\\n     *  @param  limitIndex_         Lower bound of `LUP` change (if any) that the borrower will tolerate from a creating or modifying position.\\n     *  @param  collateralToPledge_ The amount of collateral to be added to the pool (`WAD` precision).\\n     */\\n    function drawDebt(\\n        address borrowerAddress_,\\n        uint256 amountToBorrow_,\\n        uint256 limitIndex_,\\n        uint256 collateralToPledge_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by borrowers to repay borrowed quote to the pool, and/or pull collateral form the pool.\\n     *  @dev    Can be called by borrowers with either `0` `maxQuoteTokenAmountToRepay_` or `0` `collateralAmountToPull_`, if borrower only wants to take a single action. \\n     *  @param  borrowerAddress_            The borrower whose loan is being interacted with.\\n     *  @param  maxQuoteTokenAmountToRepay_ The max amount of quote tokens to repay (`WAD` precision).\\n     *  @param  collateralAmountToPull_     The max amount of collateral to be puled from the pool (`WAD` precision).\\n     *  @param  recipient_                  The address to receive amount of pulled collateral.\\n     *  @param  limitIndex_                 Ensures `LUP` has not moved far from state when borrower pulls collateral.\\n     */\\n    function repayDebt(\\n        address borrowerAddress_,\\n        uint256 maxQuoteTokenAmountToRepay_,\\n        uint256 collateralAmountToPull_,\\n        address recipient_,\\n        uint256 limitIndex_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/erc20/IERC20PoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title ERC20 Pool Events\\n */\\ninterface IERC20PoolEvents {\\n\\n    /**\\n     *  @notice Emitted when actor adds claimable collateral to a bucket.\\n     *  @param  actor     Recipient that added collateral.\\n     *  @param  index     Index at which collateral were added.\\n     *  @param  amount    Amount of collateral added to the pool (`WAD` precision).\\n     *  @param  lpAwarded Amount of `LP` awarded for the deposit (`WAD` precision).\\n     */\\n    event AddCollateral(\\n        address indexed actor,\\n        uint256 indexed index,\\n        uint256 amount,\\n        uint256 lpAwarded\\n    );\\n\\n    /**\\n     *  @notice Emitted when borrower draws debt from the pool, or adds collateral to the pool.\\n     *  @param  borrower          The borrower to whom collateral was pledged, and/or debt was drawn for.\\n     *  @param  amountBorrowed    Amount of quote tokens borrowed from the pool (`WAD` precision).\\n     *  @param  collateralPledged Amount of collateral locked in the pool (`WAD` precision).\\n     *  @param  lup               `LUP` after borrow.\\n     */\\n    event DrawDebt(\\n        address indexed borrower,\\n        uint256 amountBorrowed,\\n        uint256 collateralPledged,\\n        uint256 lup\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/erc20/IERC20PoolImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title ERC20 Pool Immutables\\n */\\ninterface IERC20PoolImmutables {\\n\\n    /**\\n     *  @notice Returns the `collateralScale` immutable.\\n     *  @return The precision of the collateral `ERC20` token based on decimals.\\n     */\\n    function collateralScale() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/erc20/IERC20PoolLenderActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title ERC20 Pool Lender Actions\\n */\\ninterface IERC20PoolLenderActions {\\n\\n    /**\\n     *  @notice Deposit claimable collateral into a specified bucket.\\n     *  @param  amountToAdd_ Amount of collateral to deposit (`WAD` precision).\\n     *  @param  index_       The bucket index to which collateral will be deposited.\\n     *  @param  expiry_      Timestamp after which this transaction will revert, preventing inclusion in a block with unfavorable price.\\n     *  @return bucketLP_    The amount of `LP` awarded for the added collateral (`WAD` precision).\\n     */\\n    function addCollateral(\\n        uint256 amountToAdd_,\\n        uint256 index_,\\n        uint256 expiry_\\n    ) external returns (uint256 bucketLP_);\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\ninterface IERC3156FlashBorrower {\\n\\n    /**\\n     * @dev    Receive a flash loan.\\n     * @param  initiator The initiator of the loan.\\n     * @param  token     The loan currency.\\n     * @param  amount    The amount of tokens lent (token precision).\\n     * @param  fee       The additional amount of tokens to repay.\\n     * @param  data      Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The `keccak256` hash of `ERC3156FlashBorrower.onFlashLoan`\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes   calldata data\\n    ) external returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\nimport { IERC3156FlashBorrower } from \\\"./IERC3156FlashBorrower.sol\\\";\\n\\n\\ninterface IERC3156FlashLender {\\n\\n    /**\\n     * @dev    The amount of currency available to be lent.\\n     * @param  token_ The loan currency.\\n     * @return The amount of `token` that can be borrowed (token precision).\\n     */\\n    function maxFlashLoan(\\n        address token_\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev    The fee to be charged for a given loan.\\n     * @param  token_    The loan currency.\\n     * @param  amount_   The amount of tokens lent (token precision).\\n     * @return The amount of `token` to be charged for the loan (token precision), on top of the returned principal .\\n     */\\n    function flashFee(\\n        address token_,\\n        uint256 amount_\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev    Initiate a flash loan.\\n     * @param  receiver_ The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param  token_    The loan currency.\\n     * @param  amount_   The amount of tokens lent (token precision).\\n     * @param  data_     Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return `True` when successful flashloan, `false` otherwise.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver_,\\n        address token_,\\n        uint256 amount_,\\n        bytes   calldata data_\\n    ) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/pool/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport { IPoolBorrowerActions } from './commons/IPoolBorrowerActions.sol';\\nimport { IPoolLPActions }       from './commons/IPoolLPActions.sol';\\nimport { IPoolLenderActions }   from './commons/IPoolLenderActions.sol';\\nimport { IPoolKickerActions }   from './commons/IPoolKickerActions.sol';\\nimport { IPoolTakerActions }    from './commons/IPoolTakerActions.sol';\\nimport { IPoolSettlerActions }  from './commons/IPoolSettlerActions.sol';\\n\\nimport { IPoolImmutables }      from './commons/IPoolImmutables.sol';\\nimport { IPoolState }           from './commons/IPoolState.sol';\\nimport { IPoolDerivedState }    from './commons/IPoolDerivedState.sol';\\nimport { IPoolEvents }          from './commons/IPoolEvents.sol';\\nimport { IPoolErrors }          from './commons/IPoolErrors.sol';\\nimport { IERC3156FlashLender }  from './IERC3156FlashLender.sol';\\n\\n/**\\n * @title Base Pool Interface\\n */\\ninterface IPool is\\n    IPoolBorrowerActions,\\n    IPoolLPActions,\\n    IPoolLenderActions,\\n    IPoolKickerActions,\\n    IPoolTakerActions,\\n    IPoolSettlerActions,\\n    IPoolImmutables,\\n    IPoolState,\\n    IPoolDerivedState,\\n    IPoolEvents,\\n    IPoolErrors,\\n    IERC3156FlashLender\\n{\\n\\n}\\n\\n/// @dev Pool type enum - `ERC20` and `ERC721`\\nenum PoolType { ERC20, ERC721 }\\n\\n/// @dev `ERC20` token interface.\\ninterface IERC20Token {\\n    function balanceOf(address account) external view returns (uint256);\\n    function burn(uint256 amount) external;\\n    function decimals() external view returns (uint8);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\n/// @dev `ERC721` token interface.\\ninterface IERC721Token {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport { IPositionManagerOwnerActions } from './IPositionManagerOwnerActions.sol';\\nimport { IPositionManagerState }        from './IPositionManagerState.sol';\\nimport { IPositionManagerDerivedState } from './IPositionManagerDerivedState.sol';\\nimport { IPositionManagerErrors }       from './IPositionManagerErrors.sol';\\nimport { IPositionManagerEvents }       from './IPositionManagerEvents.sol';\\n\\n/**\\n *  @title Position Manager Interface\\n */\\ninterface IPositionManager is\\n    IPositionManagerOwnerActions,\\n    IPositionManagerState,\\n    IPositionManagerDerivedState,\\n    IPositionManagerErrors,\\n    IPositionManagerEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManagerDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Positions Manager Derived State\\n */\\ninterface IPositionManagerDerivedState {\\n\\n    /**\\n     *  @notice Returns the `LP` accrued to a given `tokenId`, bucket pairing.\\n     *  @dev    Nested mappings aren't returned normally as part of the default getter for a mapping.\\n     *  @param  tokenId_ Unique `ID` of token.\\n     *  @param  index_   Index of bucket to check `LP` balance of.\\n     *  @return lp_      Balance of `LP` in the bucket for this position.\\n    */\\n    function getLP(\\n        uint256 tokenId_,\\n        uint256 index_\\n    ) external view returns (uint256 lp_);\\n\\n    /**\\n     *  @notice Returns an array of bucket indexes in which an `NFT` has liquidity.\\n     *  @dev    Potentially includes buckets that have been bankrupted.\\n     *  @param  tokenId_  Unique `ID` of token.\\n     *  @return Array of bucket indexes.\\n    */\\n    function getPositionIndexes(\\n        uint256 tokenId_\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     *  @notice Returns an array of bucket indexes in which an `NFT` has liquidity, with bankrupt buckets removed.\\n     *  @param  tokenId_ Unique `ID` of token.\\n     *  @return Array of bucket indexes filtered for active liquidity.\\n    */\\n    function getPositionIndexesFiltered(\\n        uint256 tokenId_\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     *  @notice Returns information about a given `NFT`.\\n     *  @param  tokenId_ Unique `ID` of token.\\n     *  @param  index_   Bucket index to check for position information.\\n     *  @return `LP` in bucket.\\n     *  @return Position's deposit time.\\n    */\\n    function getPositionInfo(\\n        uint256 tokenId_,\\n        uint256 index_\\n    ) external view returns (uint256, uint256);\\n\\n    /**\\n     *  @notice Returns the pool address associated with a positions `NFT`.\\n     *  @param  tokenId_ The token id of the positions `NFT`.\\n     *  @return Pool address associated with the `NFT`.\\n     */\\n    function poolKey(\\n        uint256 tokenId_\\n    ) external view returns (address);\\n\\n    /**\\n     *  @notice Checks if a given `pool_` address is an Ajna pool.\\n     *  @param  pool_       Address of the `Ajna` pool.\\n     *  @param  subsetHash_ Factory's subset hash pool.\\n     *  @return isAjnaPool_ `True` if the address to check is an Ajna pool.\\n    */\\n    function isAjnaPool(\\n        address pool_,\\n        bytes32 subsetHash_\\n    ) external view returns (bool isAjnaPool_);\\n\\n    /**\\n     *  @notice Checks if a given `tokenId` has a given position bucket.\\n     *  @param  tokenId_           Unique `ID` of token.\\n     *  @param  index_             Index of bucket to check if in position buckets.\\n     *  @return bucketInPosition_  `True` if tokenId has the position bucket.\\n    */\\n    function isIndexInPosition(\\n        uint256 tokenId_,\\n        uint256 index_\\n    ) external view returns (bool bucketInPosition_);\\n\\n    /**\\n     *  @notice Checks if a tokenId has a position in a bucket that was bankrupted.\\n     *  @param  tokenId_           Unique ID of token.\\n     *  @param  index_             Index of bucket to check for bankruptcy.\\n     *  @return isBankrupt_        True if the position in the bucket was bankrupted.\\n    */\\n    function isPositionBucketBankrupt(\\n        uint256 tokenId_,\\n        uint256 index_\\n    ) external view returns (bool isBankrupt_);\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManagerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Positions Manager Errors\\n */\\ninterface IPositionManagerErrors {\\n\\n    /**\\n     * @notice User attempting to memorialize position with an allowance set too low.\\n     */\\n    error AllowanceTooLow();\\n\\n    /**\\n     * @notice User attempting to utilize `LP` from a bankrupt bucket.\\n     */\\n    error BucketBankrupt();\\n\\n    /**\\n     *  @notice Can't deploy with `ERC20` or `ERC721` factory address `0x`.\\n     */\\n    error DeployWithZeroAddress();\\n\\n    /**\\n     * @notice User attempting to burn a `LP` `NFT` before removing liquidity.\\n     */\\n    error LiquidityNotRemoved();\\n\\n    /**\\n     * @notice User not authorized to interact with the specified `NFT`.\\n     */\\n    error NoAuth();\\n\\n    /**\\n     * @notice `NFT` with provided ID does not exist.\\n     */\\n    error NoToken();\\n\\n    /**\\n     * @notice User attempted to mint an `NFT` pointing to a pool that wasn't deployed by an `Ajna` factory.\\n     */\\n    error NotAjnaPool();\\n\\n    /**\\n     * @notice User failed to remove position from their `NFT`.\\n     */\\n    error RemovePositionFailed();\\n\\n    /**\\n     * @notice User attempting to interact with a pool that doesn't match the pool associated with the `tokenId`.\\n     */\\n    error WrongPool();\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManagerEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Positions Manager Events\\n */\\ninterface IPositionManagerEvents {\\n\\n    /**\\n     *  @notice Emitted when an existing `NFT` was burned.\\n     *  @param  lender  Lender address.\\n     *  @param  tokenId The token id of the `NFT` that was burned.\\n     */\\n    event Burn(\\n        address indexed lender,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     *  @notice Emitted when existing positions were memorialized for a given `NFT`.\\n     *  @param  tokenId The `tokenId` of the `NFT`.\\n     *  @param  indexes Bucket indexes of memorialized positions.\\n     */\\n    event MemorializePosition(\\n        address indexed lender,\\n        uint256 tokenId,\\n        uint256[] indexes\\n    );\\n\\n    /**\\n     *  @notice Emitted when representative `NFT` minted.\\n     *  @param  lender  Lender address.\\n     *  @param  pool    Pool address.\\n     *  @param  tokenId The `tokenId` of the newly minted `NFT`.\\n     */\\n    event Mint(\\n        address indexed lender,\\n        address indexed pool,\\n        uint256 tokenId\\n    );\\n\\n    /**\\n     *  @notice Emitted when a position's liquidity is moved between buckets.\\n     *  @param  lender         Lender address.\\n     *  @param  tokenId        The `tokenId` of the newly minted `NFT`.\\n     *  @param  fromIndex      Index of bucket from where liquidity is moved.\\n     *  @param  toIndex        Index of bucket where liquidity is moved.\\n     *  @param  lpRedeemedFrom Amount of `LP` removed from the `from` bucket.\\n     *  @param  lpAwardedTo    Amount of `LP` credited to the `to` bucket.\\n     */\\n    event MoveLiquidity(\\n        address indexed lender,\\n        uint256 tokenId,\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 lpRedeemedFrom,\\n        uint256 lpAwardedTo\\n    );\\n\\n    /**\\n     *  @notice Emitted when existing positions were redeemed for a given `NFT`.\\n     *  @param  tokenId The `tokenId` of the `NFT`.\\n     *  @param  indexes Bucket indexes of redeemed positions.\\n     */\\n    event RedeemPosition(\\n        address indexed lender,\\n        uint256 tokenId,\\n        uint256[] indexes\\n    );\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManagerOwnerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Positions Manager Owner Actions\\n */\\ninterface IPositionManagerOwnerActions {\\n\\n    /**\\n     *  @notice Called by owners to burn an existing `NFT`.\\n     *  @dev    Requires that all `LP` have been removed from the `NFT `prior to calling.\\n     *  @param  pool_    The pool address associated with burned positions NFT\\n     *  @param  tokenId_ The tokenId of the positions NFT to burn.\\n     */\\n    function burn(\\n        address pool_,\\n        uint256 tokenId_\\n    ) external;\\n\\n    /**\\n     *  @notice Called to memorialize existing positions with a given NFT.\\n     *  @dev    The array of buckets is expected to be constructed off chain by scanning events for that lender.\\n     *  @dev    The NFT must have already been created, and the number of buckets to be memorialized at a time determined by function caller.\\n     *  @dev    An additional call is made to the pool to transfer the LP from their previous owner, to the Position Manager.\\n     *  @dev    `Pool.increaseLPAllowance` must be called prior to calling this method in order to allow Position manager contract to transfer LP to be memorialized.\\n     *  @param  pool_    The pool address associated with positions NFT.\\n     *  @param  tokenId_ The tokenId of the positions NFT.\\n     *  @param  indexes_ The array of bucket indexes to memorialize positions.\\n     */\\n    function memorializePositions(\\n        address pool_,\\n        uint256 tokenId_,\\n        uint256[] calldata indexes_\\n    ) external;\\n\\n    /**\\n     *  @notice Called by owners to mint and receive an `Ajna` Position `NFT`.\\n     *  @dev    Position `NFT`s can only be minited with an association to pools that have been deployed by the `Ajna` `ERC20PoolFactory` or `ERC721PoolFactory`.\\n     *  @param  pool_           The pool address associated with minted positions NFT.\\n     *  @param  recipient_      Lender address.\\n     *  @param  poolSubsetHash_ Hash of pool information used to track pool in the factory after deployment.\\n     *  @return tokenId_ The `tokenId` of the newly minted `NFT`.\\n     */\\n    function mint(\\n        address pool_,\\n        address recipient_,\\n        bytes32 poolSubsetHash_\\n    ) external returns (uint256 tokenId_);\\n\\n    /**\\n     *  @notice Called by owners to move liquidity between two buckets.\\n     *  @param  pool_             The pool address associated with positions NFT.\\n     *  @param  tokenId_          The tokenId of the positions NFT.\\n     *  @param  fromIndex_        The bucket index from which liquidity should be moved.\\n     *  @param  toIndex_          The bucket index to which liquidity should be moved.\\n     *  @param  expiry_           Timestamp after which this TX will revert, preventing inclusion in a block with unfavorable price.\\n     *  @param  revertIfBelowLup_ The tx will revert if quote token is moved from above the `LUP` to below the `LUP` (and avoid paying fee for move below `LUP`).\\n     */\\n    function moveLiquidity(\\n        address pool_,\\n        uint256 tokenId_,\\n        uint256 fromIndex_,\\n        uint256 toIndex_,\\n        uint256 expiry_,\\n        bool    revertIfBelowLup_\\n    ) external;\\n\\n    /**\\n     *  @notice Called to redeem existing positions with a given `NFT`.\\n     *  @dev    The array of buckets is expected to be constructed off chain by scanning events for that lender.\\n     *  @dev    The `NFT` must have already been created, and the number of buckets to be memorialized at a time determined by function caller.\\n     *  @dev    An additional call is made to the pool to transfer the `LP` Position Manager to owner.\\n     *  @dev    `Pool.approveLPTransferors` must be called prior to calling this method in order to allow `Position manager` contract to transfer redeemed `LP`.\\n     *  @param  pool_    The pool address associated with positions NFT.\\n     *  @param  tokenId_ The tokenId of the positions NFT.\\n     *  @param  indexes_ The array of bucket indexes to memorialize positions.\\n     */\\n    function redeemPositions(\\n        address pool_,\\n        uint256 tokenId_,\\n        uint256[] calldata indexes_\\n    ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/position/IPositionManagerState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport { EnumerableSet } from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\n/**\\n * @title Positions Manager State\\n */\\ninterface IPositionManagerState {\\n\\n    /**\\n    * @dev Struct holding Position `LP` state.\\n    * @param lps         [WAD] position LP.\\n    * @param depositTime Deposit time for position\\n    */\\n    struct Position {\\n        uint256 lps;\\n        uint256 depositTime;\\n    }\\n\\n    /**\\n    * @dev Struct tracking a position token info.\\n    * @param pool            The pool address associated with the position.\\n    * @param positionIndexes Mapping tracking indexes to which a position is associated.\\n    * @param positions       Mapping tracking a positions state in a bucket index.\\n    */\\n    struct TokenInfo {\\n        address pool;\\n        EnumerableSet.UintSet positionIndexes;\\n        mapping(uint256 index => Position) positions;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport { IRewardsManagerOwnerActions } from './IRewardsManagerOwnerActions.sol';\\nimport { IRewardsManagerState }        from './IRewardsManagerState.sol';\\nimport { IRewardsManagerDerivedState } from './IRewardsManagerDerivedState.sol';\\nimport { IRewardsManagerEvents }       from './IRewardsManagerEvents.sol';\\nimport { IRewardsManagerErrors }       from './IRewardsManagerErrors.sol';\\n\\ninterface IRewardsManager is\\n    IRewardsManagerOwnerActions,\\n    IRewardsManagerState,\\n    IRewardsManagerDerivedState,\\n    IRewardsManagerErrors,\\n    IRewardsManagerEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManagerDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Rewards Manager Derived State\\n */\\ninterface IRewardsManagerDerivedState {\\n\\n    /**\\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\\n     *  @param  epochToClaim_ The end burn epoch to calculate rewards for (rewards calculation starts from the last claimed epoch).\\n     *  @return The amount of rewards earned by the staked `NFT`.\\n     */\\n    function calculateRewards(\\n        uint256 tokenId_,\\n        uint256 epochToClaim_\\n    ) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManagerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Rewards Manager Errors\\n */\\ninterface IRewardsManagerErrors {\\n    /**\\n     *  @notice User attempted to claim rewards multiple times.\\n     */\\n    error AlreadyClaimed();\\n\\n    /**\\n     *  @notice User attempted to claim rewards for an epoch that is not yet available.\\n     */\\n    error EpochNotAvailable();\\n\\n    /**\\n     *  @notice Insufficient Token Balance in contract to transfer rewards\\n     */\\n    error InsufficientLiquidity();\\n\\n    /**\\n     *  @notice User provided move index params that didn't match in size.\\n     */\\n    error MoveStakedLiquidityInvalid();\\n\\n    /**\\n     * @notice User attempted to update exchange rates for a pool that wasn't deployed by an `Ajna` factory.\\n     */\\n    error NotAjnaPool();\\n\\n    /**\\n     *  @notice User attempted to interact with an `NFT` they aren't the owner of.\\n     */\\n    error NotOwnerOfDeposit();\\n\\n    /**\\n     *  @notice Can't deploy with `Ajna` token or position manager address `0x`.\\n     */\\n    error DeployWithZeroAddress();\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManagerEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Rewards Manager Events\\n */\\ninterface IRewardsManagerEvents {\\n\\n     /**\\n     *  @notice Emitted when lender claims rewards that have accrued to their staked `NFT`.\\n     *  @param  owner         Owner of the staked `NFT`.\\n     *  @param  ajnaPool      Address of the `Ajna` pool the `NFT` corresponds to.\\n     *  @param  tokenId       `ID` of the staked `NFT`.\\n     *  @param  epochsClaimed Array of burn epochs claimed.\\n     *  @param  amount        The amount of `Ajna` tokens claimed by the staker.\\n     */\\n    event ClaimRewards(\\n        address indexed owner,\\n        address indexed ajnaPool,\\n        uint256 indexed tokenId,\\n        uint256[] epochsClaimed,\\n        uint256 amount\\n    );\\n\\n     /**\\n     *  @notice Emitted when moves liquidity in a staked `NFT` between buckets.\\n     *  @param  tokenId     `ID` of the staked `NFT`.\\n     *  @param  fromIndexes Array of indexes from which liquidity was moved.\\n     *  @param  toIndexes   Array of indexes to which liquidity was moved.\\n     */\\n    event MoveStakedLiquidity(\\n        uint256 tokenId,\\n        uint256[] fromIndexes,\\n        uint256[] toIndexes\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender stakes their `LP` `NFT` in the rewards contract.\\n     *  @param  owner    Owner of the staked `NFT`.\\n     *  @param  ajnaPool Address of the `Ajna` pool the `NFT` corresponds to.\\n     *  @param  tokenId  `ID` of the staked `NFT`.\\n     */\\n    event Stake(\\n        address indexed owner,\\n        address indexed ajnaPool,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     *  @notice Emitted when someone records the latest exchange rate for a bucket in a pool, and claims the associated reward.\\n     *  @param  caller          Address of the recorder. The address which will receive an update reward, if applicable.\\n     *  @param  ajnaPool        Address of the `Ajna` pool whose exchange rates are being updated.\\n     *  @param  indexesUpdated  Array of bucket indexes whose exchange rates are being updated.\\n     *  @param  rewardsClaimed  Amount of `Ajna` tokens claimed by the recorder as a reward for updating each bucket index.\\n     */\\n    event UpdateExchangeRates(\\n        address indexed caller,\\n        address indexed ajnaPool,\\n        uint256[] indexesUpdated,\\n        uint256 rewardsClaimed\\n    );\\n\\n    /**\\n     *  @notice Emitted when lender withdraws their `LP` `NFT` from the rewards contract.\\n     *  @param  owner    Owner of the staked `NFT`.\\n     *  @param  ajnaPool Address of the `Ajna` pool the `NFT` corresponds to.\\n     *  @param  tokenId  `ID` of the staked `NFT`.\\n     */\\n    event Unstake(\\n        address indexed owner,\\n        address indexed ajnaPool,\\n        uint256 indexed tokenId\\n    );\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManagerOwnerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Rewards Manager Owner Actions\\n */\\ninterface IRewardsManagerOwnerActions {\\n\\n    /**\\n     *  @notice Claim `Ajna` token rewards that have accrued to a staked `LP` `NFT`.\\n     *  @dev    Updates exchange rates for each bucket the `NFT` is associated with.\\n     *  @dev    Reverts with `InsufficientLiquidity` if calculated rewards or contract balance is below specified min amount to receive limit.\\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\\n     *  @param  epochToClaim_ The burn epoch to claim rewards for.\\n     *  @param  minAmount_    Minimum amount to be received by rewards claimer.\\n     */\\n    function claimRewards(\\n        uint256 tokenId_,\\n        uint256 epochToClaim_,\\n        uint256 minAmount_\\n    ) external;\\n\\n    /**\\n     *  @notice Stake a `LP` `NFT` into the rewards contract.\\n     *  @dev    Updates exchange rates for each bucket the `NFT` is associated with.\\n     *  @param  tokenId_ `ID` of the `LP` `NFT` to stake in the `Rewards contract.\\n     */\\n    function stake(\\n        uint256 tokenId_\\n    ) external;\\n\\n    /**\\n     *  @notice Withdraw a staked `LP` `NFT` from the rewards contract.\\n     *  @notice If rewards are available, claim all available rewards before withdrawal.\\n     *  @param  tokenId_ `ID` of the staked `LP` `NFT`.\\n     */\\n    function unstake(\\n        uint256 tokenId_\\n    ) external;\\n\\n    /**\\n     *  @notice Withdraw a staked `LP` `NFT` from the rewards contract without claiming any rewards before withdrawal.\\n     *  @param  tokenId_ `ID` of the staked `LP` `NFT`.\\n     */\\n    function emergencyUnstake(\\n        uint256 tokenId_\\n    ) external;\\n\\n    /**\\n     *  @notice Update the exchange rate of a list of buckets.\\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\\n     *  @param  pool_       Address of the pool whose exchange rates are being updated.\\n     *  @param  subsetHash_ Factory's subset hash pool that dpeloyed the Ajna pool. Used to validate that the `pool_` address is a legit Ajna pool.\\n     *  @param  indexes_    List of bucket indexes to be updated.\\n     *  @return Returns reward amount for updating bucket exchange rates.\\n     */\\n    function updateBucketExchangeRatesAndClaim(\\n        address pool_,\\n        bytes32 subsetHash_,\\n        uint256[] calldata indexes_\\n    ) external returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/ajna/interfaces/rewards/IRewardsManagerState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Rewards Manager State\\n */\\ninterface IRewardsManagerState {\\n\\n    /**\\n     *  @notice Track whether a bucket's exchange rate has been updated in a given burn event epoch.\\n     *  @param  pool_        The pool to check the update status of.\\n     *  @param  bucketIndex_ The bucket index to check the update status of.\\n     *  @param  epoch_   The burn epoch to check the bucket index in.\\n     *  @return `True` if the buckets exchange rate was updated in the given epoch, else false.\\n     */\\n    function isBucketUpdated(\\n        address pool_,\\n        uint256 bucketIndex_,\\n        uint256 epoch_\\n    ) external view returns (bool);\\n\\n    /**\\n     *  @notice Track whether a depositor has claimed rewards for a given burn event epoch.\\n     *  @param  tokenId_ ID of the staked `LP` `NFT`.\\n     *  @param  epoch_   The burn epoch to track if rewards were claimed.\\n     *  @return `True` if rewards were claimed for the given epoch, else false.\\n     */\\n    function isEpochClaimed(\\n        uint256 tokenId_,\\n        uint256 epoch_\\n    ) external view returns (bool);\\n\\n    /**\\n     *  @notice Track the total amount of rewards that have been claimed for a given epoch.\\n     *  @param  epoch_   The burn epoch to track if rewards were claimed.\\n     *  @return The amount of rewards claimed in given epoch.\\n     */\\n    function rewardsClaimed(\\n        uint256 epoch_\\n    ) external view returns (uint256);\\n\\n    /**\\n     *  @notice Track the total amount of rewards that have been claimed for a given burn event's bucket updates.\\n     *  @param  epoch_   The burn epoch to track if rewards were claimed.\\n     *  @return The amount of update rewards claimed in given epoch.\\n     */\\n    function updateRewardsClaimed(\\n        uint256 epoch_\\n    ) external view returns (uint256);\\n\\n    /**\\n     *  @notice Retrieve information about a given stake.\\n     *  @param  tokenId_          `ID` of the `NFT` staked in the rewards contract to retrieve information about.\\n     *  @return owner_            The owner of a given `NFT` stake.\\n     *  @return pool_             The `Pool` the `NFT` represents positions in.\\n     *  @return lastClaimedEpoch_ The last burn epoch in which the owner of the `NFT` claimed rewards.\\n     */\\n    function getStakeInfo(\\n        uint256 tokenId_\\n    ) external view returns (address owner_, address pool_, uint256 lastClaimedEpoch_);\\n\\n    /**\\n     *  @notice Retrieve information about recorded `LP` and rate values for a given bucket and a given stake, at stake time.\\n     *  @param  tokenId_  `ID` of the `NFT` staked in the rewards contract to retrieve information about.\\n     *  @param  bucketId_ `ID` of the bucket to retrieve recorded information at stake time.\\n     *  @return `LP` amount (in `WAD`) the `NFT` owner is entitled in current bucket at the time of staking.\\n     *  @return Current bucket exchange rate (`WAD`) at the time of staking.\\n     */\\n    function getBucketStateStakeInfo(\\n        uint256 tokenId_,\\n        uint256 bucketId_\\n    ) external view returns (uint256, uint256);\\n\\n}\\n\\n/*********************/\\n/*** State Structs ***/\\n/*********************/\\n\\n/// @dev Struct holding stake info state.\\nstruct StakeInfo {\\n    address ajnaPool;                         // address of the Ajna pool the NFT corresponds to\\n    uint96  lastClaimedEpoch;                 // last epoch the stake claimed rewards\\n    address owner;                            // owner of the LP NFT\\n    uint96  stakingEpoch;                     // epoch at staking time\\n    mapping(uint256 => BucketState) snapshot; // the LP NFT's balances and exchange rates in each bucket at the time of staking\\n}\\n\\n/// @dev Struct holding bucket state at stake time.\\nstruct BucketState {\\n    uint256 lpsAtStakeTime;  // [WAD] LP amount the NFT owner is entitled in current bucket at the time of staking\\n    uint256 rateAtStakeTime; // [WAD] current bucket exchange rate at the time of staking\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ajna/IAjnaPoolUtilsInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\ninterface IAjnaPoolUtilsInfo {\\n    function priceToIndex(uint256 price_) external pure returns (uint256);\\n\\n    function borrowerInfo(\\n        address pool_,\\n        address borrower_\\n    ) external view returns (uint256 debt_, uint256 collateral_, uint256 index_);\\n\\n    function poolPricesInfo(\\n        address ajnaPool_\\n    )\\n        external\\n        view\\n        returns (uint256 hpb_, uint256 hpbIndex_, uint256 htp_, uint256 htpIndex_, uint256 lup_, uint256 lupIndex_);\\n\\n    function lpToQuoteTokens(\\n        address ajnaPool_,\\n        uint256 lp_,\\n        uint256 index_\\n    ) external view returns (uint256 quoteAmount_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dpm/IAccountGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IAccountGuard {\\n    function owners(address) external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function setWhitelist(address target, bool status) external;\\n\\n    function canCall(\\n        address proxy,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function permit(address caller, address target, bool allowance) external;\\n    function isWhitelisted(address target) external view returns (bool);\\n    function isWhitelistedSend(address target) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/tokens/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAjnaPoolUtilsInfo\",\"name\":\"_poolInfoUtils\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_ajnaToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_GUARD\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"positionType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"}],\"name\":\"CreatePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"ProxyActionsOperation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ARC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ajnaToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimRewardsAndSendToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"convertPriceToIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"depositAndDraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"depositCollateralAndDrawDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"drawDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getQuoteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ARC\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"moveQuote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"moveQuoteNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"openEarnPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"openEarnPositionNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"optInStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"optOutStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfoUtils\",\"outputs\":[{\"internalType\":\"contract IAjnaPoolUtilsInfo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionManager\",\"outputs\":[{\"internalType\":\"contract IPositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"removeCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"repayAndClose\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stamploan\",\"type\":\"bool\"}],\"name\":\"repayDebt\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"repayDebtAndWithdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stamploan\",\"type\":\"bool\"}],\"name\":\"repayWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsManager\",\"outputs\":[{\"internalType\":\"contract IRewardsManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"self\",\"outputs\":[{\"internalType\":\"contract IAjnaProxyActions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"supplyAndMoveQuote\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"supplyAndMoveQuoteNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"supplyQuote\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"supplyQuoteMintNftAndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"supplyQuoteNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstakeNftAndClaimCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstakeNftAndWithdrawQuote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"withdrawAndMoveQuote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revertIfBelowLup\",\"type\":\"bool\"}],\"name\":\"withdrawAndMoveQuoteNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"withdrawQuote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawQuoteNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "AjnaProxyActions", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "000000000000000000000000154fff344f426f99e328bacf70f4eb632210ecdc0000000000000000000000009a96ec9b57fb64fbc60b423d1f4da7691bd35079000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ce91349d2a4577bbd0fc91fe6019600e047f2847", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}