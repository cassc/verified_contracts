{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/deployer/CornDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./Create3.sol\\\";\\nimport {Auth, Authority} from \\\"solmate/auth/Auth.sol\\\";\\n\\ncontract CornDeployer is Auth {\\n    string public constant name = \\\"Corn Deployer\\\";\\n\\n    event ContractDeployed(address indexed contractAddress, string contractName, bytes32 salt);\\n\\n    constructor() Auth(msg.sender, Authority(address(0))) {}\\n\\n    /**\\n     * @notice Deploy a contract using salt in string format and arbitrary runtime code.\\n     *     @dev Intended use is: get the future Corn addresses, then deploy the appropriate contract to each address via this method, building the constructor using the mapped addresses\\n     *     @dev no enforcment of bytecode at address as we can't know the runtime code in this contract due to space constraints\\n     */\\n    function _deploy(string memory _saltString, bytes memory _creationCode)\\n        internal\\n        returns (address deployedAddress)\\n    {\\n        bytes32 _salt = keccak256(abi.encodePacked(_saltString));\\n        deployedAddress = Create3.create3(_salt, _creationCode);\\n        emit ContractDeployed(deployedAddress, _saltString, _salt);\\n    }\\n\\n    /**\\n     * @notice Deploy a contract using salt in string format and arbitrary runtime code.\\n     *     @dev Intended use is: get the future Corn addresses, then deploy the appropriate contract to each address via this method, building the constructor using the mapped addresses\\n     *     @dev no enforcment of bytecode at address as we can't know the runtime code in this contract due to space constraints\\n     */\\n    function deploy(string memory _saltString, bytes memory _creationCode)\\n        public\\n        requiresAuth\\n        returns (address deployedAddress)\\n    {\\n        return _deploy(_saltString, _creationCode);\\n    }\\n\\n    function deployWithCreationCodeAndConstructorArgs(\\n        string memory _saltString,\\n        bytes memory creationCode,\\n        bytes memory constructionArgs\\n    ) external requiresAuth returns (address) {\\n        bytes memory _data = abi.encodePacked(creationCode, constructionArgs);\\n        return _deploy(_saltString, _data);\\n    }\\n\\n    function deployWithCreationCode(string memory _saltString, bytes memory creationCode)\\n        external\\n        requiresAuth\\n        returns (address)\\n    {\\n        return _deploy(_saltString, creationCode);\\n    }\\n\\n    function addressOf(string memory _saltString) external view returns (address) {\\n        bytes32 _salt = keccak256(abi.encodePacked(_saltString));\\n        return Create3.addressOf(_salt);\\n    }\\n\\n    function addressOfSalt(bytes32 _salt) external view returns (address) {\\n        return Create3.addressOf(_salt);\\n    }\\n\\n    /**\\n     * @notice Create the creation code for a contract with the given runtime code.\\n     *     @dev credit: https://github.com/0xsequence/create3/blob/master/contracts/test_utils/Create3Imp.sol\\n     */\\n    function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n        */\\n\\n        return abi.encodePacked(hex\\\"63\\\", uint32(_code.length), hex\\\"80600E6000396000F3\\\", _code);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/deployer/Create3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\n/**\\n  @title A library for deploying contracts EIP-3171 style.\\n  @author Agustin Aguilar <aa@horizon.io>\\n*/\\nlibrary Create3 {\\n    error ErrorCreatingProxy();\\n    error ErrorCreatingContract();\\n    error TargetAlreadyExists();\\n\\n    /**\\n    @notice The bytecode for a contract that proxies the creation of another contract\\n    @dev If this code is deployed using CREATE2 it can be used to decouple `creationCode` from the child contract address\\n\\n  0x67363d3d37363d34f03d5260086018f3:\\n      0x00  0x67  0x67XXXXXXXXXXXXXXXX  PUSH8 bytecode  0x363d3d37363d34f0\\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 0x363d3d37363d34f0\\n      0x02  0x52  0x52                  MSTORE\\n      0x03  0x60  0x6008                PUSH1 08        8\\n      0x04  0x60  0x6018                PUSH1 18        24 8\\n      0x05  0xf3  0xf3                  RETURN\\n\\n  0x363d3d37363d34f0:\\n      0x00  0x36  0x36                  CALLDATASIZE    cds\\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 cds\\n      0x02  0x3d  0x3d                  RETURNDATASIZE  0 0 cds\\n      0x03  0x37  0x37                  CALLDATACOPY\\n      0x04  0x36  0x36                  CALLDATASIZE    cds\\n      0x05  0x3d  0x3d                  RETURNDATASIZE  0 cds\\n      0x06  0x34  0x34                  CALLVALUE       val 0 cds\\n      0x07  0xf0  0xf0                  CREATE          addr\\n  */\\n\\n    bytes internal constant PROXY_CHILD_BYTECODE =\\n        hex\\\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\\\";\\n\\n    //                        KECCAK256_PROXY_CHILD_BYTECODE = keccak256(PROXY_CHILD_BYTECODE);\\n    bytes32 internal constant KECCAK256_PROXY_CHILD_BYTECODE =\\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Creates a new contract with given `_creationCode` and `_salt`\\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\\n    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address\\n    @return addr of the deployed contract, reverts on error\\n  */\\n    function create3(bytes32 _salt, bytes memory _creationCode) internal returns (address addr) {\\n        return create3(_salt, _creationCode, 0);\\n    }\\n\\n    /**\\n    @notice Creates a new contract with given `_creationCode` and `_salt`\\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\\n    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address\\n    @param _value In WEI of ETH to be forwarded to child contract\\n    @return addr of the deployed contract, reverts on error\\n  */\\n    function create3(\\n        bytes32 _salt,\\n        bytes memory _creationCode,\\n        uint256 _value\\n    ) internal returns (address addr) {\\n        // Creation code\\n        bytes memory creationCode = PROXY_CHILD_BYTECODE;\\n\\n        // Get target final address\\n        addr = addressOf(_salt);\\n        if (codeSize(addr) != 0) revert TargetAlreadyExists();\\n\\n        // Create CREATE2 proxy\\n        address proxy;\\n        assembly {\\n            proxy := create2(0, add(creationCode, 32), mload(creationCode), _salt)\\n        }\\n        if (proxy == address(0)) revert ErrorCreatingProxy();\\n\\n        // Call proxy with final init code\\n        (bool success, ) = proxy.call{value: _value}(_creationCode);\\n        if (!success || codeSize(addr) == 0) revert ErrorCreatingContract();\\n    }\\n\\n    /**\\n    @notice Computes the resulting address of a contract deployed using address(this) and the given `_salt`\\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\\n    @return addr of the deployed contract, reverts on error\\n\\n    @dev The address creation formula is: keccak256(rlp([keccak256(0xff ++ address(this) ++ _salt ++ keccak256(childBytecode))[12:], 0x01]))\\n  */\\n    function addressOf(bytes32 _salt) internal view returns (address) {\\n        address proxy = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            address(this),\\n                            _salt,\\n                            KECCAK256_PROXY_CHILD_BYTECODE\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        return address(uint160(uint256(keccak256(abi.encodePacked(hex\\\"d6_94\\\", proxy, hex\\\"01\\\")))));\\n    }\\n}\"\r\n    },\r\n    \"lib/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnershipTransferred(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"arbitrum-token-bridge/=lib/token-bridge-contracts/contracts/\",\r\n      \"corn-standard-solidity/=lib/corn-standard-solidity/src/\",\r\n      \"bitcorn-token/=lib/bitcorn-token/src/\",\r\n      \"@arbitrum/=lib/token-bridge-contracts/node_modules/@arbitrum/\",\r\n      \"@offchainlabs/=lib/token-bridge-contracts/node_modules/@offchainlabs/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/token-bridge-contracts/node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=lib/token-bridge-contracts/node_modules/@openzeppelin/contracts/\",\r\n      \"halmos-cheatcodes/=lib/bitcorn-token/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"token-bridge-contracts/=lib/token-bridge-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ErrorCreatingContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCreatingProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TargetAlreadyExists\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_saltString\",\"type\":\"string\"}],\"name\":\"addressOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"addressOfSalt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_saltString\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_creationCode\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_saltString\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"creationCode\",\"type\":\"bytes\"}],\"name\":\"deployWithCreationCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_saltString\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"creationCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"constructionArgs\",\"type\":\"bytes\"}],\"name\":\"deployWithCreationCodeAndConstructorArgs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CornDeployer", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}