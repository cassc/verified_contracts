{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/ERC20Lib.sol\": {\r\n      \"content\": \"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./TokenStorage.sol\\\";\\n\\n/**\\n * @title ERC20Lib\\n * @dev Standard ERC20 token functionality.\\n * https://github.com/ethereum/EIPs/issues/20\\n */\\nlibrary ERC20Lib {\\n    /**\\n     * @dev Transfers tokens [ERC20].\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transfer(\\n        TokenStorage db,\\n        address caller,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        db.subBalance(caller, amount);\\n        db.addBalance(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from a specific address [ERC20].\\n     * The address owner has to approve the spender beforehand.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param from Address to debet the tokens from.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transferFrom(\\n        TokenStorage db,\\n        address caller,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        uint256 allowance_ = db.getAllowed(from, caller);\\n        db.subBalance(from, amount);\\n        db.addBalance(to, amount);\\n        db.setAllowed(from, caller, allowance_ - amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a spender [ERC20].\\n     * Note that using the approve/transferFrom presents a possible\\n     * security vulnerability described in:\\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\\n     * Use transferAndCall to mitigate.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param spender The address of the future spender.\\n     * @param amount The allowance of the spender.\\n     */\\n    function approve(\\n        TokenStorage db,\\n        address caller,\\n        address spender,\\n        uint256 amount\\n    ) public returns (bool success) {\\n        db.setAllowed(caller, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the number tokens associated with an address.\\n     * @param db Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return balance Balance of address.\\n     */\\n    function balanceOf(\\n        TokenStorage db,\\n        address who\\n    ) external view returns (uint256 balance) {\\n        return db.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender\\n     * @param db Token storage to operate on.\\n     * @param owner The address of the owner of the tokens.\\n     * @param spender The address of the spender.\\n     * @return remaining Number of tokens the spender is allowed to spend.\\n     */\\n    function allowance(\\n        TokenStorage db,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256 remaining) {\\n        return db.getAllowed(owner, spender);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20Basic _token,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        require(_token.transfer(_to, _value));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/token/ERC20/ERC20Basic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function balanceOf(address _who) public view virtual returns (uint256);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public virtual returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0));\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/NoOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./HasNoEther.sol\\\";\\nimport \\\"./HasNoContracts.sol\\\";\\n\\n/**\\n * @title Base contract for contracts that should not own things.\\n * @author Remco Bloemen <remco@2\u03c0.com>\\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\\n * Owned contracts. See respective base contracts for details.\\n */\\ncontract NoOwner is HasNoEther, HasNoContracts {\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/HasNoEther.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Ether\\n * @author Remco Bloemen <remco@2\u03c0.com>\\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\\n * in the contract, it will allow the owner to reclaim this Ether.\\n * @notice Ether can still be sent to this contract by:\\n * calling functions labeled `payable`\\n * `selfdestruct(contract_address)`\\n * mining directly to the contract address\\n */\\ncontract HasNoEther is Ownable {\\n    /**\\n     * @dev Constructor that rejects incoming Ether\\n     * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\\n     * leave out payable, then Solidity will allow inheriting contracts to implement a payable\\n     * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\\n     * we could use assembly to access msg.value.\\n     */\\n    constructor() payable {\\n        require(msg.value == 0);\\n    }\\n\\n    /**\\n     * @dev Disallows direct send by setting a default function without the `payable` flag.\\n     */\\n    fallback() external {}\\n\\n    /**\\n     * @dev Transfer all Ether held by the contract to the owner.\\n     */\\n    function reclaimEther() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/HasNoContracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Contracts\\n * @author Remco Bloemen <remco@2\u03c0.com>\\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\\n * of this contract to reclaim ownership of the contracts.\\n */\\ncontract HasNoContracts is Ownable {\\n    /**\\n     * @dev Reclaim ownership of Ownable contracts\\n     * @param _contractAddr The address of the Ownable to be reclaimed.\\n     */\\n    function reclaimContract(address _contractAddr) external onlyOwner {\\n        Ownable contractInst = Ownable(_contractAddr);\\n        contractInst.transferOwnership(owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\nabstract contract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    /**\\n     * @dev emitted when the pendingOwner address is changed\\n     * @param previousPendingOwner previous pendingOwner address\\n     * @param newPendingOwner new pendingOwner address\\n     */\\n    event OwnershipTransferPending(\\n        address indexed previousPendingOwner,\\n        address indexed newPendingOwner\\n    );\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingOwner.\\n     */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to set the pendingOwner address.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public virtual override onlyOwner {\\n        emit OwnershipTransferPending(pendingOwner, newOwner);\\n        pendingOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\n     */\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ownership/CanReclaimToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"../token/ERC20/ERC20Basic.sol\\\";\\nimport \\\"../token/ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @title Contracts that should be able to recover tokens\\n * @author SylTi\\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\\n * This will prevent any accidental loss of tokens.\\n */\\ncontract CanReclaimToken is Ownable {\\n    using SafeERC20 for ERC20Basic;\\n\\n    /**\\n     * @dev Reclaim all ERC20Basic compatible tokens\\n     * @param _token ERC20Basic The address of the token contract\\n     */\\n    function reclaimToken(ERC20Basic _token) external onlyOwner {\\n        uint256 balance = _token.balanceOf(address(this));\\n        _token.safeTransfer(owner, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/TokenStorageLib.sol\": {\r\n      \"content\": \"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\n/*\\n * @title TokenStorageLib\\n * @dev Implementation of an[external storage for tokens.\\n */\\nlibrary TokenStorageLib {\\n    struct TokenStorage {\\n        mapping(address => uint) balances;\\n        mapping(address => mapping(address => uint)) allowed;\\n        uint256 totalSupply;\\n    }\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(\\n        TokenStorage storage self,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply + amount;\\n        self.balances[to] = self.balances[to] + amount;\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(\\n        TokenStorage storage self,\\n        address from,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply - amount;\\n        self.balances[from] = self.balances[from] - amount;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Qunatity of allowance.\\n     */\\n    function setAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external {\\n        self.allowed[owner][spender] = amount;\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @param self Token storage to operate on.\\n     * @return Total supply.\\n     */\\n    function getSupply(TokenStorage storage self) external view returns (uint) {\\n        return self.totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(\\n        TokenStorage storage self,\\n        address who\\n    ) external view returns (uint) {\\n        return self.balances[who];\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender\\n    ) external view returns (uint) {\\n        return self.allowed[owner][spender];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/TokenStorage.sol\": {\r\n      \"content\": \"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./ownership/Claimable.sol\\\";\\nimport \\\"./ownership/CanReclaimToken.sol\\\";\\nimport \\\"./ownership/NoOwner.sol\\\";\\nimport \\\"./TokenStorageLib.sol\\\";\\n\\n/**\\n * @title TokenStorage\\n * @dev External storage for tokens.\\n * The storage is implemented in a separate contract to maintain state\\n * between token upgrades.\\n */\\ncontract TokenStorage is Claimable, CanReclaimToken, NoOwner {\\n    using TokenStorageLib for TokenStorageLib.TokenStorage;\\n\\n    TokenStorageLib.TokenStorage internal tokenStorage;\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(address to, uint256 amount) external onlyOwner {\\n        tokenStorage.addBalance(to, amount);\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(address from, uint256 amount) external onlyOwner {\\n        tokenStorage.subBalance(from, amount);\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Quantity of allowance.\\n     */\\n    function setAllowed(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external onlyOwner {\\n        tokenStorage.setAllowed(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @return Total supply.\\n     */\\n    function getSupply() external view returns (uint256) {\\n        return tokenStorage.getSupply();\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(address who) external view returns (uint256) {\\n        return tokenStorage.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256) {\\n        return tokenStorage.getAllowed(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Explicit override of transferOwnership from Claimable and Ownable\\n     * @param newOwner Address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public override(Claimable, Ownable) {\\n        Claimable.transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TokenStorage\",\"name\":\"db\",\"type\":\"TokenStorage\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TokenStorage\",\"name\":\"db\",\"type\":\"TokenStorage\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ERC20Lib", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}