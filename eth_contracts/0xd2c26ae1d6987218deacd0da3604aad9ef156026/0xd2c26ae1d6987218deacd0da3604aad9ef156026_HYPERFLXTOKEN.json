{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-08-17\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n//*************************************************************************************************//\r\n\r\n// Website : https://hyperflxtoken.com/\r\n// TG : https://t.me/hyperflxtoken\r\n\r\n//*************************************************************************************************//\r\n\r\npragma solidity 0.8.19;\r\n \r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {return payable(msg.sender);}\r\n \r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    string public _name;\r\n    string public _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {return _name;}\r\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\r\n    function decimals() public view virtual override returns (uint8) {return 18;}\r\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\r\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {_approve(sender, _msgSender(), currentAllowance - amount);}\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {_approve(_msgSender(), spender, currentAllowance - subtractedValue);}\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {_balances[sender] = senderBalance - amount;}\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _burn(address sender, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"burn from the zero address\");\r\n \r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {_balances[sender] = senderBalance - amount;}\r\n        _totalSupply -= amount;\r\n        emit Transfer(sender, address(0), amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);    \r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\r\n    function addLiquidityETH (address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ninterface IDexFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}\r\n \r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n \r\n    function owner() public view virtual returns (address) {return _owner;}\r\n \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SafeToken is Ownable {\r\n    address payable public safeManager;\r\n    event NewSafeManager (address indexed NewManager);\r\n    constructor() {safeManager = payable(msg.sender);}\r\n    \r\n    function setSafeManager(address payable _safeManager) external onlyOwner {\r\n        require(_safeManager != address(0), \"Receiver is the zero address\");\r\n        safeManager = _safeManager;\r\n        emit NewSafeManager (safeManager);\r\n    }\r\n\r\n    function withdraw(address _token, uint256 _amount) external { require(msg.sender == safeManager); IERC20(_token).transfer(safeManager, _amount);}\r\n    function withdrawETH(uint256 _amount) external {require(msg.sender == safeManager); safeManager.transfer(_amount);}\r\n}\r\n\r\ncontract Main is ERC20, Ownable, SafeToken {\r\n \r\n    IDexRouter public DEXV2Router;\r\n    address private immutable DEXV2Pair;\r\n    address payable private MarketingWallet; \r\n    address private DeadWallet;\r\n    address private DexRouter;\r\n        \r\n    bool private swapping;\r\n    bool private swapAndLiquifyEnabled = true;\r\n    bool public tradingEnabled = false;\r\n    bool private JeetsFee = true;\r\n    bool private JeetsBurn = true;\r\n    bool private DelayOption = false;\r\n\r\n    uint256 private marketingETHPortion = 0;\r\n\r\n    uint256 private MaxSell;\r\n    uint256 private MaxWallet;\r\n    uint256 private SwapMin;\r\n    uint256 private MaxSwap;\r\n    uint256 private MaxTaxes;\r\n    uint256 private MaxTokenToSwap;\r\n    uint256 private maxSellTransactionAmount;\r\n    uint256 private maxWalletAmount;\r\n    uint256 private swapTokensAtAmount;\r\n    uint8 private decimal;\r\n    uint256 private InitialSupply;\r\n    uint256 private DispatchSupply;\r\n    uint256 private _liquidityUnlockTime = 0;\r\n    uint256 private counter;\r\n    uint256 private MinTime = 0;\r\n    \r\n    // Tax Fees\r\n    uint256 private _LiquidityFee = 0;\r\n    uint256 private _BurnFee = 0;\r\n    uint256 private _MarketingFee= 2;\r\n    uint256 private _Wallet2WalletFee = 0; // no wallet to wallet fee\r\n    uint256 private _BuyFee = 2;\r\n    uint256 private _SellFee = 0;\r\n    uint8 private VminDiv = 1;\r\n    uint8 private VmaxDiv = 15;\r\n    uint8 private MaxJeetsFee = 30;\r\n\r\n    mapping (address => bool) private _isExcludedFromFees;\r\n    mapping (address => bool) private _isWhitelisted;\r\n    mapping (address => bool) private _isExcludedFromMaxTx;\r\n    mapping (address => uint256) private LastTimeSell; \r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n \r\n    event UpdateDEXV2Router(address indexed newAddress, address indexed oldAddress);\r\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ETHReceived, uint256 tokensIntoLiqudity);\r\n    event ExtendLiquidityLock(uint256 extendedLockTime);\r\n    event NewDelay (bool delay, uint256 time);\r\n    event NewLimits (uint256 maxWallet, uint256 maxSell, uint256 minswap, uint256 swapmax, uint256 maxtax);\r\n    event NewFees (uint256 buy, uint256 Sell);\r\n    event NewMarketingWallet (address indexed newMarketingWallet);\r\n    event Launched (bool trading);\r\n    event LPReleased (address indexed receiver, uint256 amount);\r\n    event JeetTaxChanged (uint8 Maxdiv, uint8 Mindiv, uint8 Jeetsfee);\r\n    event BuyBackTriggered(uint256 amount);\r\n    \r\n    constructor(string memory name_, string memory symbol_, uint8 decimal_, address marketing_, uint256 supply_, uint256 dispatch_, uint8 maxtaxes_) ERC20(name_, symbol_) {\r\n    \t\r\n        MarketingWallet = payable(marketing_);\r\n        DeadWallet = 0x000000000000000000000000000000000000dEaD;\r\n        decimal = decimal_;\r\n        InitialSupply = supply_*10**decimal;\r\n        DispatchSupply = dispatch_*10**decimal;\r\n        MaxSwap = supply_ * 1 / 100;\r\n        MaxSell = supply_ * 4 / 100;\r\n        MaxWallet = supply_ * 100 / 100;\r\n        SwapMin = supply_ * 1 / 1000;\r\n        MaxTokenToSwap = MaxSwap*10**decimal;\r\n        maxSellTransactionAmount = MaxSell * 10**decimal;\r\n        maxWalletAmount = MaxWallet * 10**decimal;\r\n        swapTokensAtAmount = SwapMin * 10**decimal;\r\n        MaxTaxes = maxtaxes_;\r\n              \r\n        // Create a DEX pair for this new token\r\n        \r\n        IDexRouter _dexRouter = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        address _DEXV2Pair = IDexFactory(_dexRouter.factory()).createPair(address(this), _dexRouter.WETH());\r\n \r\n        DEXV2Router = _dexRouter;\r\n        DEXV2Pair = _DEXV2Pair;\r\n        _setAutomatedMarketMakerPair(_DEXV2Pair, true);\r\n\r\n        _SellFee = _LiquidityFee + _MarketingFee + _BurnFee;//YY%\r\n\r\n        // exclude from paying fees or having max transaction amount\r\n        _isExcludedFromFees[address(this)] = true;\r\n        _isExcludedFromFees[DeadWallet] = true;\r\n        _isExcludedFromFees[MarketingWallet] = true;\r\n        _isExcludedFromFees[msg.sender] = true;\r\n \r\n        // exclude from max tx\r\n        _isExcludedFromMaxTx[address(this)] = true;\r\n        _isExcludedFromMaxTx[DeadWallet] = true;\r\n        _isExcludedFromMaxTx[MarketingWallet] = true;\r\n        _isExcludedFromMaxTx[msg.sender] = true;\r\n\r\n        // Whitelist\r\n        _isWhitelisted[address(this)] = true;\r\n        _isWhitelisted[DeadWallet] = true;\r\n        _isWhitelisted[MarketingWallet] = true;\r\n        _isWhitelisted[msg.sender] = true;\r\n        \r\n        //  _mint is an internal function in ERC20.sol that is only called here, and CANNOT be called ever again\r\n        if(DispatchSupply == 0) {_mint(address(this), InitialSupply);} \r\n        else if (DispatchSupply == InitialSupply) {_mint(msg.sender, DispatchSupply);}\r\n        else {\r\n            _mint(msg.sender, DispatchSupply);\r\n            _mint(address(this), InitialSupply - DispatchSupply);\r\n        }\r\n    }\r\n \r\n    receive() external payable {}\r\n    //******************************************************************************************************\r\n    // Public functions\r\n    //******************************************************************************************************\r\n    function decimals() override public view returns (uint8) { return decimal; }\r\n    function GetExclusions(address account) public view returns(bool MaxTx, bool Fees, bool Whitelist){return (_isExcludedFromMaxTx[account], _isExcludedFromFees[account], _isWhitelisted[account]);}\r\n    function GetFees() public view returns(uint Buy, uint Sell, uint Wallet2Wallet, uint Liquidity, uint Marketing, uint Burn){return (_BuyFee, _SellFee, _Wallet2WalletFee, _LiquidityFee, _MarketingFee, _BurnFee);}\r\n    function GetLimits() public view returns(uint256 SellMax, uint256 WalletMax, uint256 TaxMax, uint256 MinSwap, uint256 SwapMax, bool SwapLiq, bool ENtrading){return (MaxSell, MaxWallet, MaxTaxes, SwapMin, MaxSwap, swapAndLiquifyEnabled, tradingEnabled);}\r\n    function GetDelay() public view returns (bool delayoption, uint256 mintime) {return (DelayOption, MinTime);}\r\n    function GetContractAddresses() public view returns(address marketing, address Dead, address LP){return (address(MarketingWallet), address(DeadWallet), address(DEXV2Pair));}\r\n    function GetJeetsTaxInfo() external view returns (bool jeetsfee, bool jeetsburn, uint vmaxdiv, uint vmindiv, uint maxjeetsfee) {return(JeetsFee, JeetsBurn, VmaxDiv, VminDiv, MaxJeetsFee);}\r\n    function GetContractBalance() external view returns (uint256 marketingETH) {return(marketingETHPortion);}\r\n    \r\n    function GetSupplyInfo() public view returns (uint256 initialSupply, uint256 circulatingSupply, uint256 burntTokens) {\r\n        uint256 supply = totalSupply ();\r\n        uint256 tokensBurnt = InitialSupply - supply;\r\n        return (InitialSupply, supply, tokensBurnt);\r\n    }\r\n        \r\n    function getLiquidityUnlockTime() public view returns (uint256 Days, uint256 Hours, uint256 Minutes, uint256 Seconds) {\r\n        if (block.timestamp < _liquidityUnlockTime){\r\n            Days = (_liquidityUnlockTime - block.timestamp) / 86400;\r\n            Hours = (_liquidityUnlockTime - block.timestamp - Days * 86400) / 3600;\r\n            Minutes = (_liquidityUnlockTime - block.timestamp - Days * 86400 - Hours * 3600 ) / 60;\r\n            Seconds = _liquidityUnlockTime - block.timestamp - Days * 86400 - Hours * 3600 - Minutes * 60;\r\n            return (Days, Hours, Minutes, Seconds);\r\n        } \r\n        return (0, 0, 0, 0);\r\n    }\r\n    //******************************************************************************************************\r\n    // Write OnlyOwners functions\r\n    //******************************************************************************************************\r\n \r\n    function buyBackBurn(uint256 amountInWei) external {\r\n        require(amountInWei <= 10 ether, \"May not buy more than 10 ETH in a single buy to reduce sandwich attacks\");\r\n        require(msg.sender == safeManager);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = DEXV2Router.WETH();\r\n        path[1] = address(this);\r\n\r\n        // make the swap\r\n        DEXV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountInWei}(0, path, address(DeadWallet), block.timestamp);\r\n        emit BuyBackTriggered(amountInWei);\r\n    }\r\n\r\n    function Airdrop(address[] memory wallets, uint256[] memory amountsInTokens) external onlyOwner {\r\n        require(wallets.length == amountsInTokens.length, \"arrays must be the same length\");\r\n        require(wallets.length < 600, \"Can only airdrop 600 wallets per txn due to gas limits\"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.\r\n        for(uint256 i = 0; i < wallets.length; i++){\r\n            address wallet = wallets[i];\r\n            uint256 amount = amountsInTokens[i] * 10**decimal;\r\n            super._transfer(msg.sender, wallet, amount);\r\n        }\r\n    }\r\n\r\n    function setProjectWallet (address payable _newMarketingWallet) external onlyOwner {\r\n        if (_newMarketingWallet != MarketingWallet) {\r\n            _isExcludedFromFees[MarketingWallet] = false;\r\n            _isExcludedFromMaxTx[MarketingWallet] = false;\r\n            _isWhitelisted[MarketingWallet] = false;\r\n               \r\n            _isExcludedFromFees[_newMarketingWallet] = true;\r\n            _isExcludedFromMaxTx[_newMarketingWallet] = true;\r\n            _isWhitelisted[_newMarketingWallet] = true;\r\n  \t        MarketingWallet = _newMarketingWallet;\r\n        }\r\n        emit NewMarketingWallet (_newMarketingWallet);\r\n    }\r\n        \r\n    function SetDelay (bool delayoption, uint256 mintime) external onlyOwner {\r\n        require(mintime <= 8640, \"MinTime Can't be more than a Day\" );\r\n        MinTime = mintime;\r\n        DelayOption = delayoption;\r\n        emit NewDelay (delayoption, mintime);\r\n    }\r\n    \r\n    function SetLimits(uint256 _maxWallet, uint256 _maxSell, uint256 _minswap, uint256 _swapmax, uint256 MaxTax, bool _swapAndLiquifyEnabled) external onlyOwner {\r\n        uint256 supply = totalSupply ();\r\n        require(_maxWallet * 10**decimal >= supply / 100 && _maxWallet * 10**decimal <= supply, \"MawWallet must be between totalsupply and 1% of totalsupply\");\r\n        require(_maxSell * 10**decimal >= supply / 1000 && _maxSell * 10**decimal <= supply, \"MawSell must be between totalsupply and 0.1% of totalsupply\" );\r\n        require(_minswap * 10**decimal >= supply / 10000 && _minswap <= _swapmax / 2, \"MinSwap must be between maxswap/2 and 0.01% of totalsupply\" );\r\n        require(MaxTax >= 1 && MaxTax <= 25, \"Max Tax must be updated to between 1 and 25 percent\");\r\n        require(_swapmax >= _minswap*2 && _swapmax * 10**decimal <= supply, \"MaxSwap must be between totalsupply and SwapMin x 2\" );\r\n\r\n        MaxSwap = _swapmax;\r\n        MaxTokenToSwap = MaxSwap * 10**decimal;\r\n        MaxWallet = _maxWallet;\r\n        maxWalletAmount = MaxWallet * 10**decimal;\r\n        MaxSell = _maxSell;\r\n        maxSellTransactionAmount = MaxSell * 10**decimal;\r\n        SwapMin = _minswap;\r\n        swapTokensAtAmount = SwapMin * 10**decimal;\r\n        MaxTaxes = MaxTax; \r\n        swapAndLiquifyEnabled = _swapAndLiquifyEnabled;\r\n        emit NewLimits (_maxWallet, _maxSell, _minswap, _swapmax, MaxTax);\r\n        emit SwapAndLiquifyEnabledUpdated(_swapAndLiquifyEnabled);\r\n    }\r\n  \r\n    function SetTaxes(uint256 newBuyTax, uint256 wallet2walletfee, uint256 newLiquidityTax, uint256 newBurnTax, uint256 newMarketingTax) external onlyOwner() {\r\n        require(newBuyTax <= MaxTaxes && newBuyTax >= newBurnTax, \"Total Tax can't exceed MaxTaxes. or be lower than burn tax\");\r\n        uint256 TransferTax = newMarketingTax;\r\n        require(TransferTax + newLiquidityTax + newBurnTax <= MaxTaxes, \"Total Tax can't exceed MaxTaxes.\");\r\n        require(newMarketingTax >= 0 && newBuyTax >= 0 && newLiquidityTax >= 0 && newBurnTax >= 0,\"No tax can be negative\");\r\n        if(wallet2walletfee != 0){require(wallet2walletfee >= _BurnFee && wallet2walletfee <= MaxTaxes, \"Wallet 2 Wallet Tax must be updated to between burn tax and 25 percent\");}\r\n        \r\n        _BuyFee = newBuyTax;\r\n        _Wallet2WalletFee = wallet2walletfee;\r\n        _BurnFee = newBurnTax;\r\n        _LiquidityFee = newLiquidityTax;\r\n        _MarketingFee = newMarketingTax;\r\n        _SellFee = _LiquidityFee + _MarketingFee + _BurnFee;\r\n\r\n        emit NewFees (newBuyTax, _SellFee);\r\n    } \r\n    \r\n    function updateDEXV2Router(address newAddress) external onlyOwner {\r\n        require(newAddress != address(DEXV2Router), \"The router already has that address\");\r\n        emit UpdateDEXV2Router(newAddress, address(DEXV2Router));\r\n        DEXV2Router = IDexRouter(newAddress);\r\n    }\r\n \r\n    function SetExclusions (address account, bool Fee, bool MaxTx, bool WhiteList) external onlyOwner {\r\n        require (_isExcludedFromFees[account] != Fee, \"account already set\");\r\n        _isExcludedFromFees[account] = Fee;\r\n        _isExcludedFromMaxTx[account] = MaxTx;\r\n        _isWhitelisted[account] = WhiteList;\r\n        emit ExcludeFromFees (account, Fee);\r\n    }    \r\n    \r\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\r\n        require(pair != DEXV2Pair, \"The Market pair cannot be removed from automatedMarketMakerPairs\");\r\n        _setAutomatedMarketMakerPair(pair, value);\r\n    }\r\n \r\n\tfunction ExtendLockTime(uint256 newdays, uint256 newhours) external onlyOwner {\r\n        uint256 lockTimeInSeconds = newdays*86400 + newhours*3600;\r\n        if (_liquidityUnlockTime < block.timestamp) _liquidityUnlockTime = block.timestamp;\r\n\t    setUnlockTime(lockTimeInSeconds + _liquidityUnlockTime);\r\n        emit ExtendLiquidityLock(lockTimeInSeconds);\r\n    }\r\n\r\n    function Launch (uint256 Blocks, uint256 lockTimeInDays, uint256 lockTimeInHours) external onlyOwner {\r\n        require (tradingEnabled == false, \"can only launch once\");\r\n        require(Blocks <= 40, \"Not more than 2mn\");\r\n        if (address(this).balance == 0) \r\n        {\r\n            tradingEnabled = true;\r\n            counter = block.number + Blocks;\r\n        } else \r\n        {\r\n            uint256 lockTimeInSeconds = lockTimeInDays*86400 + lockTimeInHours*3600;\r\n            _liquidityUnlockTime = block.timestamp + lockTimeInSeconds;\r\n            addLiquidity (balanceOf(address(this)), address(this).balance);\r\n            tradingEnabled = true;\r\n            counter = block.number + Blocks;\r\n        }\r\n        emit Launched (tradingEnabled);\r\n    }\r\n\r\n    function ReleaseLP() external onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        IERC20 liquidityToken = IERC20(DEXV2Pair);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        liquidityToken.transfer(msg.sender, amount);\r\n        emit LPReleased (msg.sender, amount);\r\n    }\r\n\r\n    function SetJeetsTax(bool jeetsfee, bool jeetsburn, uint8 vmaxdiv, uint8 vmindiv, uint8 maxjeetsfee)  external {\r\n        require(msg.sender == safeManager);\r\n        require (vmaxdiv >= 10 && vmaxdiv <= 40, \"cannot set Vmax outside 10%/40% ratio\");\r\n        require (vmindiv >= 1 && vmindiv <= 10, \"cannot set Vmin outside 1%/10% ratio\");\r\n        require (maxjeetsfee >= 1 && maxjeetsfee <= 20, \"max jeets fee must be betwwen 1% and 20%\");\r\n        JeetsFee = jeetsfee;\r\n        JeetsBurn = jeetsburn;\r\n        VmaxDiv = vmaxdiv;\r\n        VminDiv = vmindiv;\r\n        MaxJeetsFee = maxjeetsfee;\r\n        emit JeetTaxChanged (vmaxdiv, vmindiv, maxjeetsfee);\r\n    }\r\n    //******************************************************************************************************\r\n    // Internal functions\r\n    //******************************************************************************************************\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) internal {\r\n        require(automatedMarketMakerPairs[pair] != value, \"Automated market maker pair is already set to that value\");\r\n        automatedMarketMakerPairs[pair] = value;\r\n        emit SetAutomatedMarketMakerPair(pair, value);\r\n    }\r\n    \r\n    function takeFee(address from, address to, uint256 amount) internal returns (uint256) {\r\n        uint256 fees = 0; // no wallet to wallet tax\r\n        uint256 burntaxamount = 0; // no wallet to wallet tax\r\n        uint256 extraTax = 0;\r\n        \r\n        if (automatedMarketMakerPairs[from]) {                   // buy tax applied if buy\r\n            if (tradingEnabled && block.number < counter && !_isWhitelisted[to] && automatedMarketMakerPairs[from]) {\r\n                fees = amount * 99 / 100;\r\n                burntaxamount = amount * 99 / 100;\r\n            } else if (_BuyFee != 0) {\r\n                fees = amount * _BuyFee / 100;  // total fee amount\r\n                burntaxamount=amount * _BurnFee / 100;    // burn amount aside\r\n            }                   \r\n        } else if(automatedMarketMakerPairs[to]) {          // sell tax applied if sell\r\n            if (JeetsFee && !_isWhitelisted[from]){ // Jeets extra Fee against massive dumpers\r\n                extraTax = JeetsSellTax(amount);\r\n                if (extraTax > 0) {\r\n                    if (JeetsBurn) {burntaxamount += extraTax;} \r\n                    fees += extraTax;\r\n                }\r\n            }\r\n            if(_SellFee != 0) {\r\n                fees += amount * _SellFee / 100; // total fee amount\r\n                burntaxamount+=amount * _BurnFee / 100;    // burn amount aside\r\n            }\r\n        } else if(!automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && _Wallet2WalletFee != 0) {\r\n            fees = amount * _Wallet2WalletFee / 100;\r\n            burntaxamount=amount * _BurnFee / 100;    // burn amount aside      \r\n        } \r\n        fees -= burntaxamount;    // fee is total amount minus burn\r\n        \r\n        if (burntaxamount != 0) {super._burn(from, burntaxamount);}    // burn amount \r\n        if(fees > 0) {super._transfer(from, address(this), fees);}\r\n        return amount - fees - burntaxamount;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        require(from != address(0), \"transfer from the zero address\");\r\n        require(to != address(0), \"transfer to the zero address\");\r\n\r\n        if(amount == 0) {return;}\r\n        \r\n        // preparation of launch LP and token dispatch allowed even if trading not allowed\r\n        if(!tradingEnabled) {require(_isWhitelisted[from], \"Trading not allowed yet\");}\r\n\r\n        if(!_isWhitelisted[to]){if(to != address(this) && to != DeadWallet){require((balanceOf(to) + amount) <= maxWalletAmount, \"wallet amount exceed maxWalletAmount\");}}\r\n        if(automatedMarketMakerPairs[to] && (!_isExcludedFromMaxTx[from]) && (!_isExcludedFromMaxTx[to])){require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\");}\r\n\r\n        if (DelayOption && !_isWhitelisted[from] && automatedMarketMakerPairs[to]) {\r\n            require( LastTimeSell[from] + MinTime <= block.number, \"Trying to sell too often!\");\r\n            LastTimeSell[from] = block.number;\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n        if(contractTokenBalance >= MaxTokenToSwap){contractTokenBalance = MaxTokenToSwap;}\r\n         // Can Swap on sell only\r\n        if (swapAndLiquifyEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && !_isWhitelisted[from] && !_isWhitelisted[to] &&  (_SellFee - _BurnFee) != 0 ) {\r\n            swapping = true;\r\n            swapAndLiquify(contractTokenBalance);\r\n            swapping = false;\r\n        }\r\n\r\n        uint256 amountToSend = amount;\r\n        if(!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {amountToSend = takeFee(from, to, amount);}\r\n        if(to == DeadWallet) {super._burn(from,amountToSend);}    // if destination address is Deadwallet, burn amount \r\n        else if(to != DeadWallet) {super._transfer(from, to, amountToSend);}\r\n    }\r\n\r\n    function swapAndLiquify(uint256 contractTokenBalance) private {\r\n        uint256 NoRewardFees = _SellFee - _BurnFee;\r\n        uint256 initialBalance = address(this).balance;\r\n        \r\n        uint256 half = contractTokenBalance * _LiquidityFee / 2 / (_SellFee - _BurnFee);\r\n        \r\n        uint256 swapTokens = (contractTokenBalance * NoRewardFees / (_SellFee - _BurnFee)) - half;\r\n        swapTokensForETH(swapTokens);\r\n        uint256 ETHBalance = address(this).balance - initialBalance;\r\n\r\n        uint256 liquidityETHPortion = (ETHBalance * _LiquidityFee / 2) / (NoRewardFees - (_LiquidityFee / 2));\r\n        marketingETHPortion += (ETHBalance * _MarketingFee) / (NoRewardFees - (_LiquidityFee / 2));\r\n        \r\n        if(_LiquidityFee != 0) {\r\n            addLiquidity(half, liquidityETHPortion);\r\n            emit SwapAndLiquify(half, liquidityETHPortion, half);\r\n        }  \r\n        if(marketingETHPortion != 0) {\r\n            MarketingWallet.transfer(marketingETHPortion);\r\n            marketingETHPortion = 0;\r\n        }\r\n    }\r\n \r\n    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {\r\n        uint256 Allowance = allowance(address(this), address(DEXV2Router)) + tokenAmount;\r\n        _approve(address(this), address(DEXV2Router), Allowance);\r\n        DEXV2Router.addLiquidityETH{value: ETHAmount}(address(this), tokenAmount, 0, 0, address(this), block.timestamp);\r\n    }\r\n \r\n    function swapTokensForETH(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = DEXV2Router.WETH();\r\n        _approve(address(this), address(DEXV2Router), tokenAmount);\r\n        DEXV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\r\n    }\r\n\r\n    function setUnlockTime(uint256 newUnlockTime) private {\r\n        // require new unlock time to be longer than old one\r\n        require(newUnlockTime > _liquidityUnlockTime);\r\n        _liquidityUnlockTime = newUnlockTime;\r\n    }\r\n\r\n    function JeetsSellTax (uint256 amount) internal view returns (uint256) {\r\n        uint256 value = balanceOf(DEXV2Pair);\r\n        uint256 vMin = value * VminDiv / 100;\r\n        uint256 vMax = value * VmaxDiv / 100;\r\n        if (amount <= vMin) return amount = 0;\r\n        if (amount > vMax) return amount * MaxJeetsFee / 100;\r\n        return (((amount-vMin) * MaxJeetsFee * amount) / (vMax-vMin)) / 100;\r\n    }\r\n}\r\n\r\ncontract HYPERFLXTOKEN is Main {\r\n\r\n    constructor() Main(\r\n        \"HYPERFLXTOKEN\",       // Name\r\n        \"HYFX\",        // Symbol\r\n        18,                  // Decimal\r\n        0x8e210528fCF50e538bfeD58af32c21384a7240ab,     // Marketing address\r\n        250_000_000_000,      // Initial Supply\r\n        250_000_000_000,       // Dispa&tch Supply\r\n        10     // Max Tax\r\n        ) {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyBackTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extendedLockTime\",\"type\":\"uint256\"}],\"name\":\"ExtendLiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Maxdiv\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Mindiv\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Jeetsfee\",\"type\":\"uint8\"}],\"name\":\"JeetTaxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LPReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"trading\",\"type\":\"bool\"}],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"delay\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Sell\",\"type\":\"uint256\"}],\"name\":\"NewFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minswap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapmax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxtax\",\"type\":\"uint256\"}],\"name\":\"NewLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"NewMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"NewManager\",\"type\":\"address\"}],\"name\":\"NewSafeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ETHReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDEXV2Router\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInTokens\",\"type\":\"uint256[]\"}],\"name\":\"Airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEXV2Router\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newdays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newhours\",\"type\":\"uint256\"}],\"name\":\"ExtendLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetContractAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Dead\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"LP\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingETH\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"delayoption\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mintime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GetExclusions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"MaxTx\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Fees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Whitelist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Wallet2Wallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetJeetsTaxInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"jeetsfee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"jeetsburn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"vmaxdiv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vmindiv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxjeetsfee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"SellMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WalletMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TaxMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MinSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SwapMax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"SwapLiq\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ENtrading\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetSupplyInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"circulatingSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burntTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTimeInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTimeInHours\",\"type\":\"uint256\"}],\"name\":\"Launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReleaseLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"delayoption\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mintime\",\"type\":\"uint256\"}],\"name\":\"SetDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Fee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"MaxTx\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WhiteList\",\"type\":\"bool\"}],\"name\":\"SetExclusions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"jeetsfee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"jeetsburn\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"vmaxdiv\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"vmindiv\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxjeetsfee\",\"type\":\"uint8\"}],\"name\":\"SetJeetsTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minswap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapmax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxTax\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapAndLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"SetLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wallet2walletfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLiquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBurnTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMarketingTax\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"buyBackBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Hours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Minutes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Seconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeManager\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newMarketingWallet\",\"type\":\"address\"}],\"name\":\"setProjectWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_safeManager\",\"type\":\"address\"}],\"name\":\"setSafeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDEXV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HYPERFLXTOKEN", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5681036d742d62cc09bfd472026f24ef1a2e5abfc980fdc80156920f3c8a5e13"}