{"SourceCode": "// SPDX-License-Identifier: No\r\n\r\npragma solidity 0.7.6;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Sqrt {\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n// For Uniswap v1\r\ninterface IUniswapV1 {\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 );\r\n}\r\n// For Uniswap v2, Quickswap v2, Sushiswap v2, pancakeswap v2\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n// For Uniswap v3, Sushiswap v3, Pancakeswap v3\r\ninterface IUniswapV3Pool {\r\n    function slot0() external view returns (uint160 sqrtPriceX96, int24, uint16, uint16, uint16, uint8, bool);\r\n    function ticks(int24 tick) external view returns (uint128, int128, uint256, uint256, int56, uint160, uint32, bool);\r\n    function tickSpacing() external view returns (int24);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function liquidity() external view returns (uint128);\r\n}\r\n// For Quickswap v3\r\ninterface IAlgebraPool {\r\n    function globalState() external view returns (uint160 price, int24 tick, uint16 fee, uint16 timepointIndex, uint8 communityFeeToken0, uint8 communityFeeToken1, bool unlocked);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function liquidity() external view returns (uint128);\r\n}\r\n// For Meshswap\r\ninterface IMeshswapPool {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function reserve0() external view returns (uint112);\r\n    function reserve1() external view returns (uint112);\r\n}\r\n// For Balancer v2\r\ninterface IWeightedPool {\r\n    function getPoolId() external view returns (bytes32);\r\n    function getNormalizedWeights() external view returns (uint256[] memory);\r\n}\r\n// For Balancer v2\r\ninterface IVault {\r\n    function getPoolTokens(bytes32 poolId) external view returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\r\n}\r\n// For Kyber swap\r\ninterface IKyberDmmPool {\r\n    function getTradeInfo() external view returns (uint112 reserve0, uint112 reserve1, uint112 _vReserve0, uint112 _vReserve1, uint256 feeInPrecision);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n// For Curve v2\r\ninterface ICurveV2Pool {\r\n    function coins(uint256 arg0) external view returns (address); \r\n    function balances(uint256 arg0) external view returns (uint256);\r\n}\r\n// For Dodoex\r\ninterface IDodoDVM {\r\n    function _BASE_RESERVE_() external view returns (uint112); \r\n    function _BASE_TOKEN_() external view returns (address);\r\n    function _QUOTE_RESERVE_() external view returns (uint112); \r\n    function _QUOTE_TOKEN_() external view returns (address);\r\n}\r\ncontract OffchainOracle {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint112;\r\n    using Sqrt for uint256;\r\n\r\n    function getRate(address tokenFrom, address tokenTo, address poolAddress, uint8 ver) external view returns (uint256 rate, uint8 decimalsFrom, uint8 decimalsTo) {\r\n        if(ver == 2 || ver == 5 || ver == 7 || ver == 8 || ver == 9) {\r\n            address token0;\r\n            address token1;\r\n            uint256 reserve0;\r\n            uint256 reserve1;\r\n            // version = 2 : Uniswap V2 like\r\n            if(ver == 2) {\r\n                token0 = IUniswapV2Pair(poolAddress).token0();\r\n                token1 = IUniswapV2Pair(poolAddress).token1();\r\n                (reserve0, reserve1,) = IUniswapV2Pair(poolAddress).getReserves(); \r\n            } \r\n            // version = 5 : Meshswap\r\n            else if(ver == 5) {\r\n                token0 = IMeshswapPool(poolAddress).token0();\r\n                token1 = IMeshswapPool(poolAddress).token1();\r\n                reserve0 = IMeshswapPool(poolAddress).reserve0();\r\n                reserve1 = IMeshswapPool(poolAddress).reserve1();\r\n            }\r\n            // version = 7 : Kyber swap\r\n            else if(ver == 7) {\r\n                token0 = IKyberDmmPool(poolAddress).token0();\r\n                token1 = IKyberDmmPool(poolAddress).token1();\r\n                (,, reserve0, reserve1,) = IKyberDmmPool(poolAddress).getTradeInfo();\r\n            }\r\n            // version = 8 : Curve v2\r\n            else if(ver == 8) {\r\n                token0 = ICurveV2Pool(poolAddress).coins(0);\r\n                token1 = ICurveV2Pool(poolAddress).coins(1);\r\n                reserve0 = ICurveV2Pool(poolAddress).balances(0);\r\n                reserve1 = ICurveV2Pool(poolAddress).balances(1);\r\n            }\r\n            // version = 9 : Dodoex\r\n            else if(ver == 9) {\r\n                token0 = IDodoDVM(poolAddress)._BASE_TOKEN_();\r\n                token1 = IDodoDVM(poolAddress)._QUOTE_TOKEN_();\r\n                reserve0 = IDodoDVM(poolAddress)._BASE_RESERVE_();\r\n                reserve1 = IDodoDVM(poolAddress)._QUOTE_RESERVE_();\r\n            }\r\n            if(token0 == tokenFrom) {\r\n                decimalsFrom = IERC20Metadata(token0).decimals();\r\n                decimalsTo = IERC20Metadata(token1).decimals();\r\n                rate = reserve1.mul(1e18).div(reserve0);\r\n            } else {\r\n                decimalsFrom = IERC20Metadata(token1).decimals();\r\n                decimalsTo = IERC20Metadata(token0).decimals();\r\n                rate = reserve0.mul(1e18).div(reserve1);\r\n            }\r\n        }\r\n        // version = 1 : Uniswap V1\r\n        else if(ver == 1) {\r\n            decimalsFrom = IERC20Metadata(tokenFrom).decimals();\r\n            decimalsTo = 18;\r\n            rate = IUniswapV1(poolAddress).getTokenToEthInputPrice(10**decimalsFrom);\r\n        }\r\n        // version = 3 : Uniswap V3\r\n        else if(ver == 3) {\r\n            address token0 = IUniswapV3Pool(poolAddress).token0();\r\n            address token1 = IUniswapV3Pool(poolAddress).token1();\r\n            (uint256 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\r\n            if(token0 == tokenFrom) {\r\n                decimalsFrom = IERC20Metadata(token0).decimals();\r\n                decimalsTo = IERC20Metadata(token1).decimals();\r\n                rate = (((1e18 * sqrtPriceX96) >> 96) * sqrtPriceX96) >> 96;\r\n            } else {\r\n                decimalsFrom = IERC20Metadata(token1).decimals();\r\n                decimalsTo = IERC20Metadata(token0).decimals();\r\n                rate = (1e18 << 192) / sqrtPriceX96 / sqrtPriceX96;\r\n            }\r\n        } \r\n        // version = 4 : QuickSwap V3\r\n        else if(ver == 4) {\r\n            address token0 = IAlgebraPool(poolAddress).token0();\r\n            address token1 = IAlgebraPool(poolAddress).token1();\r\n            (uint256 sqrtPriceX96,,,,,,) = IAlgebraPool(poolAddress).globalState();\r\n            if(token0 == tokenFrom) {\r\n                decimalsFrom = IERC20Metadata(token0).decimals();\r\n                decimalsTo = IERC20Metadata(token1).decimals();\r\n                rate = (((1e18 * sqrtPriceX96) >> 96) * sqrtPriceX96) >> 96;\r\n            } else {\r\n                decimalsFrom = IERC20Metadata(token1).decimals();\r\n                decimalsTo = IERC20Metadata(token0).decimals();\r\n                rate = (1e18 << 192) / sqrtPriceX96 / sqrtPriceX96;\r\n            }\r\n        }\r\n        // version = 6 : balancer v2\r\n        else if(ver == 6) {\r\n            address balancerVaultAddress = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\r\n            bytes32 poolId = IWeightedPool(poolAddress).getPoolId();\r\n            (uint256[] memory weights) = IWeightedPool(poolAddress).getNormalizedWeights();\r\n            (address[] memory tokens, uint256[] memory balances,) = IVault(balancerVaultAddress).getPoolTokens(poolId);\r\n            uint256 balanceOfTokenFrom = 0;\r\n            uint256 balanceOfTokenTo = 0;\r\n            for(uint8 i = 0; i < tokens.length; i++ ){\r\n                if(tokens[i] == tokenFrom) {\r\n                    balanceOfTokenFrom = balances[i].mul(1e18).div(weights[i]);\r\n                }\r\n                if(tokens[i] == tokenTo) {\r\n                    balanceOfTokenTo = balances[i].mul(1e18).div(weights[i]);\r\n                }\r\n            }\r\n            decimalsFrom = IERC20Metadata(tokenFrom).decimals();\r\n            decimalsTo = IERC20Metadata(tokenTo).decimals();\r\n            rate = balanceOfTokenTo.mul(1e18).div(balanceOfTokenFrom);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"ver\",\"type\":\"uint8\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimalsFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"decimalsTo\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OffchainOracle", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e24fdabfeadf55eb4f5fe284a815113b5571dc2ff5be44edde903fcbc259a4be"}