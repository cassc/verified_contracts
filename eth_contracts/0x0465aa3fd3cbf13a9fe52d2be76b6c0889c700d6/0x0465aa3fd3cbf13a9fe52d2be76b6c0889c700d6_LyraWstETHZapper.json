{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/helpers/LyraWstETHZapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ISocketVault} from \\\"../interfaces/ISocketVault.sol\\\";\\nimport {ILightAccountFactory} from \\\"../interfaces/ILightAccountFactory.sol\\\";\\nimport {Ownable} from \\\"../../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport {IWstETH} from \\\"../interfaces/wstETH/IWstETH.sol\\\";\\nimport {IStETH} from \\\"../interfaces/wstETH/IStETH.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\n\\n/**\\n * @title  LyraWstETHZapper\\n * @dev    Helper contract to wrap ETH/WETH/stETH into Lido wstETH, and then deposit to lyra chain via socket bridge.\\n */\\ncontract LyraWstETHZapper is Ownable {\\n    IWETH public immutable weth;\\n    IWstETH public immutable wstETH;\\n    IStETH public immutable stETH;\\n\\n    ///@dev Light Account factory address.\\n    address public constant lightAccountFactory = 0x000000893A26168158fbeaDD9335Be5bC96592E2;\\n\\n    constructor(address _weth, address _wstETH) Ownable() {\\n        weth = IWETH(_weth);\\n        wstETH = IWstETH(_wstETH);\\n        stETH = IStETH(wstETH.stETH());\\n    }\\n\\n    function recover(address token, uint256 amount) external onlyOwner {\\n        IERC20(token).transfer(msg.sender, amount);\\n        _returnAllEth();\\n    }\\n\\n    function estimateWstethReceived(\\n        uint256 amountEth,\\n        address socketVault,\\n        uint256 gasLimit,\\n        address connector,\\n        bool takeOutFee\\n    ) external view returns (uint256) {\\n        uint256 socketFee = 0;\\n        if (takeOutFee) {\\n            socketFee = ISocketVault(socketVault).getMinFees(connector, gasLimit);\\n        }\\n        uint256 depositAmount = amountEth - socketFee;\\n        return wstETH.stETH().getSharesByPooledEth(depositAmount);\\n    }\\n\\n    ///////////////////////////\\n    // ETH and WETH deposits //\\n    ///////////////////////////\\n    /**\\n     * @notice Wrap ETH into wstETH and deposit to Lyra Chain via socket vault\\n     */\\n    function zapETH(address socketVault, bool isSCW, uint256 gasLimit, address connector) external payable {\\n        _wrapETHAndDeposit(socketVault, isSCW, gasLimit, connector);\\n    }\\n\\n    /**\\n     * @notice Wrap ETH into wstETH and deposit to Lyra Chain via socket vault\\n     */\\n    function zapWETH(uint256 amount, address socketVault, bool isSCW, uint256 gasLimit, address connector)\\n        external\\n        payable\\n    {\\n        // unrwap weth to eth\\n        weth.transferFrom(msg.sender, address(this), amount);\\n        weth.withdraw(weth.balanceOf(address(this)));\\n\\n        _wrapETHAndDeposit(socketVault, isSCW, gasLimit, connector);\\n    }\\n\\n    function _wrapETHAndDeposit(address socketVault, bool isSCW, uint256 gasLimit, address connector) internal {\\n        uint256 ethBalance = address(this).balance;\\n\\n        uint256 socketFee = ISocketVault(socketVault).getMinFees(connector, gasLimit);\\n        uint256 depositAmount = ethBalance - socketFee;\\n\\n        stETH.submit{value: depositAmount}(address(this));\\n        stETH.approve(address(wstETH), depositAmount);\\n        wstETH.wrap(depositAmount);\\n\\n        _depositAllWstETH(socketVault, gasLimit, connector, socketFee, _getL2Receiver(isSCW));\\n    }\\n\\n    ///////////\\n    // stETH //\\n    ///////////\\n    /**\\n     * @notice Wrap stETH into wstETH and deposit to Lyra Chain via socket vault.\\n     * Must pay eth as well to cover the socket fee.\\n     */\\n    function zapStETH(uint256 amount, address socketVault, bool isSCW, uint256 gasLimit, address connector)\\n        external\\n        payable\\n    {\\n        // unrwap weth to eth\\n        stETH.transferFrom(msg.sender, address(this), amount);\\n        stETH.approve(address(wstETH), amount);\\n        // we dont get the wstETH amount as we always just deposit balance of this contract\\n        wstETH.wrap(amount);\\n\\n        uint256 socketFee = ISocketVault(socketVault).getMinFees(connector, gasLimit);\\n\\n        // We assume the user transfers enough ETH to cover the fee. The depositToAppchain call will fail if not\\n        _depositAllWstETH(socketVault, gasLimit, connector, socketFee, _getL2Receiver(isSCW));\\n    }\\n\\n    /////////////\\n    // Helpers //\\n    /////////////\\n\\n    /**\\n     * @notice Deposit wstETH held in this contract on behalf of the sender\\n     */\\n    function _depositAllWstETH(\\n        address socketVault,\\n        uint256 gasLimit,\\n        address connector,\\n        uint256 socketFee,\\n        address recipient\\n    ) internal {\\n        uint256 amount = wstETH.balanceOf(address(this));\\n        wstETH.approve(socketVault, type(uint256).max);\\n\\n        ISocketVault(socketVault).depositToAppChain{value: socketFee}(recipient, amount, gasLimit, connector);\\n\\n        _returnAllEth();\\n    }\\n\\n    /**\\n     * @notice Return the receiver address on L2\\n     */\\n    function _getL2Receiver(bool isScwWallet) internal view returns (address) {\\n        if (isScwWallet) {\\n            return ILightAccountFactory(lightAccountFactory).getAddress(msg.sender, 0);\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _returnAllEth() internal {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    // Needs to be able to receive ETH from unwrapping WETH\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISocketVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\ninterface ISocketVault {\\n    function depositToAppChain(address receiver_, uint256 amount_, uint256 msgGasLimit_, address connector_)\\n        external\\n        payable;\\n\\n    function __token() external view returns (address);\\n\\n    function getMinFees(address connector, uint256 minGasLimit) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILightAccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface ILightAccountFactory {\\n    /**\\n     * @notice Create an account, and return its address.\\n     * Returns the address even if the account is already deployed.\\n     * @dev During UserOperation execution, this method is called only if the account is not deployed.\\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation.\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return ret The address of either the newly deployed account or an existing account with this owner and salt\\n     */\\n    function createAccount(address owner, uint256 salt) external returns (address ret);\\n\\n    /**\\n     * @notice Calculate the counterfactual address of this account as it would be returned by createAccount()\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return The address of the account that would be created with createAccount()\\n     */\\n    function getAddress(address owner, uint256 salt) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/wstETH/IWstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IStETH} from \\\"./IStETH.sol\\\";\\n\\ninterface IWstETH is IERC20 {\\n    function stETH() external view returns (IStETH);\\n    function wrap(uint256 _stETHAmount) external returns (uint256 wstETHAmount);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/wstETH/IStETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IStETH is IERC20 {\\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\\n    function submit(address _referral) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport {IERC20} from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"relay-context-contracts/=lib/relay-context-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wstETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"takeOutFee\",\"type\":\"bool\"}],\"name\":\"estimateWstethReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightAccountFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETH\",\"outputs\":[{\"internalType\":\"contract IStETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstETH\",\"outputs\":[{\"internalType\":\"contract IWstETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSCW\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"zapETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSCW\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"zapStETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"socketVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSCW\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"zapWETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LyraWstETHZapper", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}