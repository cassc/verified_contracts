{"SourceCode": "// SPDX-License-Identifier: MIT\r\n/*\r\n\r\n        d88888b db    db d888888b d8888b.  .d8b.       d88888b d888888b db   db d88888b d8888b.\r\n        88'     `8b  d8' `~~88~~' 88  `8D d8' `8b      88'     `~~88~~' 88   88 88'     88  `8D\r\n        88ooooo  `8bd8'     88    88oobY' 88ooo88      88ooooo    88    88ooo88 88ooooo 88oobY'\r\n        88~~~~~  .dPYb.     88    88`8b   88~~~88      88~~~~~    88    88~~~88 88~~~~~ 88`8b\r\n        88.     .8P  Y8.    88    88 `88. 88   88      88.        88    88   88 88.     88 `88.\r\n        Y88888P YP    YP    YP    88   YD YP   YP      Y88888P    YP    YP   YP Y88888P 88   YD\r\n\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Locker {\r\n    function lockLPToken (address _lpToken, uint256 _amount, uint256 _unlock_date, address payable _referral, bool _fee_in_eth, address payable _withdrawer) external payable;\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n    }\r\n\r\n}\r\n\r\ncontract RoleBasedAcl is Ownable {\r\n\r\n    bytes32 public constant SUPER_ADMIN = keccak256(\"SUPER_ADMIN\");\r\n    bytes32 public constant POOL_MANAGER = keccak256(\"POOL_MANAGER\");\r\n\r\n    mapping(address => mapping(bytes32 => bool)) private roles;\r\n\r\n    constructor() public {\r\n        roles[msg.sender][SUPER_ADMIN] = true;\r\n    }\r\n\r\n    function assignRole (address _entity, bytes32 _role) public hasRole(SUPER_ADMIN) {\r\n        roles[_entity][_role] = true;\r\n    }\r\n\r\n    function unassignRole (address _entity, bytes32 _role) public hasRole(SUPER_ADMIN) {\r\n        roles[_entity][_role] = false;\r\n    }\r\n\r\n    function isAssignedRole (address _entity, bytes32 _role) public view returns (bool) {\r\n        return roles[_entity][_role];\r\n    }\r\n\r\n    modifier hasRole (bytes32 role) {\r\n        require(roles[msg.sender][role] || msg.sender == owner, \"Sender has not access role\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ERC20 is RoleBasedAcl {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n    uint public totalSupply;\r\n    bool public tradingEnabled = false;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor (string memory _name, string memory _symbol, uint _decimals, uint _initialSupply) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _initialSupply * 10 ** _decimals;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        _transfer(_from, _to, _value);\r\n        _approve(_from, msg.sender, allowance[_from][msg.sender].sub(_value));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) private {\r\n        require(_from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(balanceOf[_from] >= _value, \"Sender amount must be greater than value\");\r\n\r\n        if (_from != owner && _from != address(this))\r\n            require(tradingEnabled, \"Trading not opened\");\r\n\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        _approve(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address _owner, address _spender, uint256 _value) private {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowance[_owner][_spender] = _value;\r\n        emit Approval(_owner, _spender, _value);\r\n    }\r\n}\r\n\r\ncontract Token is ERC20 {\r\n\r\n    struct PoolInfo {\r\n        uint128 reverseToken;\r\n        uint128 reverseWETH;\r\n    }\r\n\r\n    address public pair;\r\n    PoolInfo[] private poolInfo;\r\n    IUniswapV2Locker public constant locker = IUniswapV2Locker(0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214);\r\n    IUniswapV2Router public constant router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    constructor (string memory _name, string memory _symbol, uint _decimals, uint _initialSupply)\r\n    ERC20(_name, _symbol, _decimals, _initialSupply) public {\r\n        balanceOf[owner] = totalSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function launchTrading() public onlyOwner {\r\n        tradingEnabled = true;\r\n    }\r\n\r\n    function addLiquidityETH() public payable hasRole(POOL_MANAGER) {\r\n        transfer(address(this), totalSupply);\r\n        if (allowance[address(this)][address(router)] < totalSupply) {\r\n            allowance[address(this)][address(router)] = totalSupply;\r\n        }\r\n\r\n        (uint amountToken, uint amountETH, ) = router.addLiquidityETH.value(address(this).balance)(\r\n            address(this),\r\n            totalSupply,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        pair = IUniswapV2Factory(router.factory()).getPair(address(this), router.WETH());\r\n        poolInfo.push(PoolInfo(uint128(amountToken), uint128(amountETH)));\r\n    }\r\n\r\n    function removeLiquidityETH() public hasRole(POOL_MANAGER) {\r\n        uint256 liquidity = IERC20(pair).balanceOf(address(this));\r\n        TransferHelper.safeApprove(pair, address(router), liquidity);\r\n        poolInfo.length --;\r\n        if (liquidity > 0) {\r\n            (uint amountToken, uint amountETH) = router.removeLiquidityETH(\r\n                address(this),\r\n                liquidity,\r\n                0,\r\n                0,\r\n                owner,\r\n                block.timestamp\r\n            );\r\n            if (amountToken > 0 && amountETH > 0)\r\n                poolInfo.push(PoolInfo(uint128(amountToken), uint128(amountETH)));\r\n        }\r\n    }\r\n\r\n    function updatePoolInfo(uint _poolId, uint128 reverseToken, uint128 reverseWETH) public hasRole(POOL_MANAGER) {\r\n        poolInfo[_poolId] = PoolInfo(reverseToken, reverseWETH);\r\n    }\r\n\r\n    function lockLpToken() public payable onlyOwner {\r\n        uint256 liquidity = IERC20(pair).balanceOf(address(this));\r\n        TransferHelper.safeApprove(pair, address(locker), liquidity);\r\n\r\n        locker.lockLPToken.value(msg.value)(pair, liquidity, block.timestamp + 30000000, address(0), true, msg.sender);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"isAssignedRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"assignRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"unassignRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"uint256\"},{\"name\":\"reverseToken\",\"type\":\"uint128\"},{\"name\":\"reverseWETH\",\"type\":\"uint128\"}],\"name\":\"updatePoolInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"POOL_MANAGER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"launchTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPER_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeLiquidityETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockLpToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addLiquidityETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "Token", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000989680000000000000000000000000000000000000000000000000000000000000000b457874726120457468657200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045845544800000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ce5ba56e6459c43207db860aed217055462cea2883c407d1c02576d51250bcdb"}