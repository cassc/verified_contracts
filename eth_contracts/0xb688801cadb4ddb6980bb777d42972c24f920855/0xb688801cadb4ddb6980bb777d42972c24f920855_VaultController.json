{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"solidity/contracts/core/VaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\\nimport {CurveMaster} from '@contracts/periphery/CurveMaster.sol';\\n\\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\\nimport {IVault} from '@interfaces/core/IVault.sol';\\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\\nimport {IOracleRelay} from '@interfaces/periphery/IOracleRelay.sol';\\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\\nimport {IVaultDeployer} from '@interfaces/core/IVaultDeployer.sol';\\n\\nimport {IERC20, IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\\n\\n/// @notice Controller of all vaults in the USDA borrow/lend system\\n///         VaultController contains all business logic for borrowing and lending through the protocol.\\n///         It is also in charge of accruing interest.\\ncontract VaultController is Pausable, IVaultController, ExponentialNoError, Ownable {\\n  /// @dev The max decimals allowed for a listed token\\n  uint8 public constant MAX_DECIMALS = 18;\\n\\n  /// @dev The max allowed to be set as borrowing fee\\n  uint192 public constant MAX_INIT_BORROWING_FEE = 0.05e18;\\n\\n  /// @dev The convex booster interface\\n  IBooster public immutable BOOSTER;\\n\\n  /// @dev The vault deployer interface\\n  IVaultDeployer public immutable VAULT_DEPLOYER;\\n\\n  /// @dev Mapping of vault id to vault address\\n  mapping(uint96 => address) public vaultIdVaultAddress;\\n\\n  /// @dev Mapping of wallet address to vault IDs arrays\\n  mapping(address => uint96[]) public walletVaultIDs;\\n\\n  /// @dev Mapping of token address to collateral info\\n  mapping(address => CollateralInfo) public tokenAddressCollateralInfo;\\n\\n  /// @dev Mapping of all the approved BaseRewardContracts from convex\\n  mapping(address => bool) public baseRewardContracts;\\n\\n  /// @dev Array of enabled tokens addresses\\n  address[] public enabledTokens;\\n\\n  /// @dev The curve master contract\\n  CurveMaster public curveMaster;\\n\\n  /// @dev The interest contract\\n  Interest public interest;\\n\\n  /// @dev The usda interface\\n  IUSDA public usda;\\n\\n  /// @dev The amphora claimer interface\\n  IAMPHClaimer public claimerContract;\\n\\n  /// @dev Total number of minted vaults\\n  uint96 public vaultsMinted;\\n  /// @dev Total number of tokens registered\\n  uint256 public tokensRegistered;\\n  /// @dev Total base liability\\n  uint192 public totalBaseLiability;\\n  /// @dev The protocol's fee\\n  uint192 public protocolFee;\\n  /// @dev The initial borrowing fee (1e18 == 100%)\\n  uint192 public initialBorrowingFee;\\n  /// @dev The fee taken from the liquidator profit (1e18 == 100%)\\n  uint192 public liquidationFee;\\n\\n  /// @notice Any function with this modifier will call the _payInterest() function before\\n  modifier paysInterest() {\\n    _payInterest();\\n    _;\\n  }\\n\\n  ///@notice Any function with this modifier can be paused or unpaused by USDA._pauser() in the case of an emergency\\n  modifier onlyPauser() {\\n    if (_msgSender() != usda.pauser()) revert VaultController_OnlyPauser();\\n    _;\\n  }\\n\\n  /// @notice Can initialize collaterals from an older vault controller\\n  /// @param _oldVaultController The old vault controller\\n  /// @param _tokenAddresses The addresses of the collateral we want to take information for\\n  /// @param _claimerContract The claimer contract\\n  /// @param _vaultDeployer The deployer contract\\n  /// @param _initialBorrowingFee The initial borrowing fee\\n  /// @param _booster The convex booster address\\n  /// @param _liquidationFee The liquidation fee\\n  constructor(\\n    IVaultController _oldVaultController,\\n    address[] memory _tokenAddresses,\\n    IAMPHClaimer _claimerContract,\\n    IVaultDeployer _vaultDeployer,\\n    uint192 _initialBorrowingFee,\\n    address _booster,\\n    uint192 _liquidationFee\\n  ) {\\n    VAULT_DEPLOYER = _vaultDeployer;\\n    interest = Interest(uint64(block.timestamp), 1 ether);\\n    protocolFee = 1e14;\\n    initialBorrowingFee = _initialBorrowingFee;\\n    liquidationFee = _liquidationFee;\\n\\n    claimerContract = _claimerContract;\\n\\n    BOOSTER = IBooster(_booster);\\n\\n    if (address(_oldVaultController) != address(0)) _migrateCollateralsFrom(_oldVaultController, _tokenAddresses);\\n  }\\n\\n  /// @notice Returns the latest interest factor\\n  /// @return _interestFactor The latest interest factor\\n  function interestFactor() external view override returns (uint192 _interestFactor) {\\n    _interestFactor = interest.factor;\\n  }\\n\\n  /// @notice Returns the block timestamp when pay interest was last called\\n  /// @return _lastInterestTime The block timestamp when pay interest was last called\\n  function lastInterestTime() external view override returns (uint64 _lastInterestTime) {\\n    _lastInterestTime = interest.lastTime;\\n  }\\n\\n  /// @notice Returns an array of all the vault ids a specific wallet has\\n  /// @param _wallet The address of the wallet to target\\n  /// @return _vaultIDs The ids of the vaults the wallet has\\n  function vaultIDs(address _wallet) external view override returns (uint96[] memory _vaultIDs) {\\n    _vaultIDs = walletVaultIDs[_wallet];\\n  }\\n\\n  /// @notice Returns an array of all enabled tokens\\n  /// @return _enabledTokens The array containing the token addresses\\n  function getEnabledTokens() external view override returns (address[] memory _enabledTokens) {\\n    _enabledTokens = enabledTokens;\\n  }\\n\\n  /// @notice Returns the token id given a token's address\\n  /// @param _tokenAddress The address of the token to target\\n  /// @return _tokenId The id of the token\\n  function tokenId(address _tokenAddress) external view override returns (uint256 _tokenId) {\\n    _tokenId = tokenAddressCollateralInfo[_tokenAddress].tokenId;\\n  }\\n\\n  /// @notice Returns the oracle given a token's address\\n  /// @param _tokenAddress The id of the token\\n  /// @return _oracle The address of the token's oracle\\n  function tokensOracle(address _tokenAddress) external view override returns (IOracleRelay _oracle) {\\n    _oracle = tokenAddressCollateralInfo[_tokenAddress].oracle;\\n  }\\n\\n  /// @notice Returns the ltv of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _ltv The loan-to-value of a token\\n  function tokenLTV(address _tokenAddress) external view override returns (uint256 _ltv) {\\n    _ltv = tokenAddressCollateralInfo[_tokenAddress].ltv;\\n  }\\n\\n  /// @notice Returns the liquidation incentive of an accepted token collateral\\n  /// @param _tokenAddress The address of the token\\n  /// @return _liquidationIncentive The liquidation incentive of the token\\n  function tokenLiquidationIncentive(address _tokenAddress)\\n    external\\n    view\\n    override\\n    returns (uint256 _liquidationIncentive)\\n  {\\n    _liquidationIncentive = tokenAddressCollateralInfo[_tokenAddress].liquidationIncentive;\\n  }\\n\\n  /// @notice Returns the cap of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _cap The cap of the token\\n  function tokenCap(address _tokenAddress) external view override returns (uint256 _cap) {\\n    _cap = tokenAddressCollateralInfo[_tokenAddress].cap;\\n  }\\n\\n  /// @notice Returns the total deposited of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _totalDeposited The total deposited of a token\\n  function tokenTotalDeposited(address _tokenAddress) external view override returns (uint256 _totalDeposited) {\\n    _totalDeposited = tokenAddressCollateralInfo[_tokenAddress].totalDeposited;\\n  }\\n\\n  /// @notice Returns the collateral type of a token\\n  /// @param _tokenAddress The address of the token\\n  /// @return _type The collateral type of a token\\n  function tokenCollateralType(address _tokenAddress) external view override returns (CollateralType _type) {\\n    _type = tokenAddressCollateralInfo[_tokenAddress].collateralType;\\n  }\\n\\n  /// @notice Returns the address of the crvRewards contract\\n  /// @param _tokenAddress The address of the token\\n  /// @return _crvRewardsContract The address of the crvRewards contract\\n  function tokenCrvRewardsContract(address _tokenAddress)\\n    external\\n    view\\n    override\\n    returns (IBaseRewardPool _crvRewardsContract)\\n  {\\n    _crvRewardsContract = tokenAddressCollateralInfo[_tokenAddress].crvRewardsContract;\\n  }\\n\\n  /// @notice Returns the pool id of a curve LP type token\\n  /// @dev    If the token is not of type CurveLPStakedOnConvex then it returns 0\\n  /// @param _tokenAddress The address of the token\\n  /// @return _poolId The pool id of a curve LP type token\\n  function tokenPoolId(address _tokenAddress) external view override returns (uint256 _poolId) {\\n    _poolId = tokenAddressCollateralInfo[_tokenAddress].poolId;\\n  }\\n\\n  /// @notice Returns the collateral info of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _collateralInfo The complete collateral info of the token\\n  function tokenCollateralInfo(address _tokenAddress)\\n    external\\n    view\\n    override\\n    returns (CollateralInfo memory _collateralInfo)\\n  {\\n    _collateralInfo = tokenAddressCollateralInfo[_tokenAddress];\\n  }\\n\\n  /// @notice Returns the selected collaterals info. Will iterate from `_start` (included) until `_end` (not included)\\n  /// @param _start The start number to loop on the array\\n  /// @param _end The end number to loop on the array\\n  /// @return _collateralsInfo The array containing all the collateral info\\n  function getCollateralsInfo(\\n    uint256 _start,\\n    uint256 _end\\n  ) external view override returns (CollateralInfo[] memory _collateralsInfo) {\\n    // check if `_end` is bigger than the tokens length\\n    uint256 _enabledTokensLength = enabledTokens.length;\\n    _end = _enabledTokensLength < _end ? _enabledTokensLength : _end;\\n\\n    _collateralsInfo = new CollateralInfo[](_end - _start);\\n\\n    for (uint256 _i = _start; _i < _end;) {\\n      _collateralsInfo[_i - _start] = tokenAddressCollateralInfo[enabledTokens[_i]];\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Migrates all collateral information from previous vault controller\\n  /// @param _oldVaultController The address of the vault controller to take the information from\\n  /// @param _tokenAddresses The addresses of the tokens we want to target\\n  function _migrateCollateralsFrom(IVaultController _oldVaultController, address[] memory _tokenAddresses) internal {\\n    uint256 _tokenId;\\n    uint256 _tokensRegistered;\\n    for (uint256 _i; _i < _tokenAddresses.length;) {\\n      _tokenId = _oldVaultController.tokenId(_tokenAddresses[_i]);\\n      if (_tokenId == 0) revert VaultController_WrongCollateralAddress();\\n      _tokensRegistered++;\\n\\n      CollateralInfo memory _collateral = _oldVaultController.tokenCollateralInfo(_tokenAddresses[_i]);\\n      _collateral.tokenId = _tokensRegistered;\\n      _collateral.totalDeposited = 0;\\n\\n      enabledTokens.push(_tokenAddresses[_i]);\\n      tokenAddressCollateralInfo[_tokenAddresses[_i]] = _collateral;\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n    tokensRegistered += _tokensRegistered;\\n\\n    emit CollateralsMigratedFrom(_oldVaultController, _tokenAddresses);\\n  }\\n\\n  /// @notice Creates a new vault and returns it's address\\n  /// @return _vaultAddress The address of the newly created vault\\n  function mintVault() public override whenNotPaused returns (address _vaultAddress) {\\n    // increment  minted vaults\\n    vaultsMinted += 1;\\n    // mint the vault itself, deploying the contract\\n    _vaultAddress = _createVault(vaultsMinted, _msgSender());\\n    // add the vault to our system\\n    vaultIdVaultAddress[vaultsMinted] = _vaultAddress;\\n\\n    //push new vault ID onto mapping\\n    walletVaultIDs[_msgSender()].push(vaultsMinted);\\n\\n    // emit the event\\n    emit NewVault(_vaultAddress, vaultsMinted, _msgSender());\\n  }\\n\\n  /// @notice Pauses the functionality of the contract\\n  function pause() external override onlyPauser {\\n    _pause();\\n  }\\n\\n  /// @notice Unpauses the functionality of the contract\\n  function unpause() external override onlyPauser {\\n    _unpause();\\n  }\\n\\n  /// @notice Registers the USDA contract\\n  /// @param _usdaAddress The address to register as USDA\\n  function registerUSDA(address _usdaAddress) external override onlyOwner {\\n    usda = IUSDA(_usdaAddress);\\n    emit RegisterUSDA(_usdaAddress);\\n  }\\n\\n  /// @notice Emited when the owner registers a curve master\\n  /// @param _masterCurveAddress The address of the curve master\\n  function registerCurveMaster(address _masterCurveAddress) external override onlyOwner {\\n    curveMaster = CurveMaster(_masterCurveAddress);\\n    emit RegisterCurveMaster(_masterCurveAddress);\\n  }\\n\\n  /// @notice Updates the protocol fee\\n  /// @param _newProtocolFee The new protocol fee in terms of 1e18=100%\\n  function changeProtocolFee(uint192 _newProtocolFee) external override onlyOwner paysInterest {\\n    if (_newProtocolFee >= 1e18) revert VaultController_FeeTooLarge();\\n    protocolFee = _newProtocolFee;\\n    emit NewProtocolFee(_newProtocolFee);\\n  }\\n\\n  /// @notice Register a new token to be used as collateral\\n  /// @dev Rebasing tokens are not compatible with amphora due to internal balance tracking\\n  /// @param _tokenAddress The address of the token to register\\n  /// @param _ltv The ltv of the token, 1e18=100%\\n  /// @param _oracleAddress The address of oracle to fetch the price of the token\\n  /// @param _liquidationIncentive The liquidation penalty for the token, 1e18=100%\\n  /// @param _cap The maximum amount to be deposited\\n  function registerErc20(\\n    address _tokenAddress,\\n    uint256 _ltv,\\n    address _oracleAddress,\\n    uint256 _liquidationIncentive,\\n    uint256 _cap,\\n    uint256 _poolId\\n  ) external override onlyOwner {\\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\\n    if (_collateral.tokenId != 0) revert VaultController_TokenAlreadyRegistered();\\n    uint8 _tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\\n    if (_tokenDecimals > MAX_DECIMALS) revert VaultController_TooManyDecimals();\\n    if (_poolId != 0) {\\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\\n      _collateral.poolId = _poolId;\\n      baseRewardContracts[_crvRewards] = true;\\n    } else {\\n      _collateral.collateralType = CollateralType.Single;\\n      _collateral.crvRewardsContract = IBaseRewardPool(address(0));\\n      _collateral.poolId = 0;\\n    }\\n    // ltv must be compatible with liquidation incentive\\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\\n    // increment the amount of registered token\\n    tokensRegistered = tokensRegistered + 1;\\n    // set & give the token an id\\n    _collateral.tokenId = tokensRegistered;\\n    // set the token's oracle\\n    _collateral.oracle = IOracleRelay(_oracleAddress);\\n    // set the token's ltv\\n    _collateral.ltv = _ltv;\\n    // set the token's liquidation incentive\\n    _collateral.liquidationIncentive = _liquidationIncentive;\\n    // set the cap\\n    _collateral.cap = _cap;\\n    // save the decimals\\n    _collateral.decimals = _tokenDecimals;\\n    // finally, add the token to the array of enabled tokens\\n    enabledTokens.push(_tokenAddress);\\n\\n    emit RegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap);\\n  }\\n\\n  /// @notice Updates an existing collateral with new collateral parameters\\n  /// @param _tokenAddress The address of the token to modify\\n  /// @param _ltv The new loan-to-value of the token, 1e18=100%\\n  /// @param _oracleAddress The address of oracle to modify for the price of the token\\n  /// @param _liquidationIncentive The new liquidation penalty for the token, 1e18=100%\\n  /// @param _cap The maximum amount to be deposited\\n  /// @param _poolId The convex pool id of a crv lp token\\n  function updateRegisteredErc20(\\n    address _tokenAddress,\\n    uint256 _ltv,\\n    address _oracleAddress,\\n    uint256 _liquidationIncentive,\\n    uint256 _cap,\\n    uint256 _poolId\\n  ) external override onlyOwner {\\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\\n    if (_collateral.tokenId == 0) revert VaultController_TokenNotRegistered();\\n    // _ltv must be compatible with liquidation incentive\\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\\n    if (_poolId != 0) {\\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\\n      _collateral.poolId = _poolId;\\n      baseRewardContracts[_crvRewards] = true;\\n    } else {\\n      _collateral.collateralType = CollateralType.Single;\\n      _collateral.crvRewardsContract = IBaseRewardPool(address(0));\\n      _collateral.poolId = 0;\\n    }\\n    // set the oracle of the token\\n    _collateral.oracle = IOracleRelay(_oracleAddress);\\n    // set the ltv of the token\\n    _collateral.ltv = _ltv;\\n    // set the liquidation incentive of the token\\n    _collateral.liquidationIncentive = _liquidationIncentive;\\n    // set the cap\\n    _collateral.cap = _cap;\\n\\n    emit UpdateRegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap, _poolId);\\n  }\\n\\n  /// @notice Change the claimer contract, used to exchange a fee from curve lp rewards for AMPH tokens\\n  /// @param _newClaimerContract The new claimer contract\\n  function changeClaimerContract(IAMPHClaimer _newClaimerContract) external override onlyOwner {\\n    IAMPHClaimer _oldClaimerContract = claimerContract;\\n    claimerContract = _newClaimerContract;\\n\\n    emit ChangedClaimerContract(_oldClaimerContract, _newClaimerContract);\\n  }\\n\\n  /// @notice Change the initial borrowing fee\\n  /// @param _newBorrowingFee The new borrowing fee\\n  function changeInitialBorrowingFee(uint192 _newBorrowingFee) external override onlyOwner {\\n    if (_newBorrowingFee >= MAX_INIT_BORROWING_FEE) revert VaultController_FeeTooLarge();\\n    uint192 _oldBorrowingFee = initialBorrowingFee;\\n    initialBorrowingFee = _newBorrowingFee;\\n\\n    emit ChangedInitialBorrowingFee(_oldBorrowingFee, _newBorrowingFee);\\n  }\\n\\n  /// @notice Change the liquidation fee\\n  /// @param _newLiquidationFee The new liquidation fee\\n  function changeLiquidationFee(uint192 _newLiquidationFee) external override onlyOwner {\\n    if (_newLiquidationFee >= 1e18) revert VaultController_FeeTooLarge();\\n    uint192 _oldLiquidationFee = liquidationFee;\\n    liquidationFee = _newLiquidationFee;\\n\\n    emit ChangedLiquidationFee(_oldLiquidationFee, _newLiquidationFee);\\n  }\\n\\n  /// @notice Check a vault for over-collateralization\\n  /// @dev This function calls peekVaultBorrowingPower so no state change is done\\n  /// @param _id The id of vault we want to target\\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\\n  function peekCheckVault(uint96 _id) public view override returns (bool _overCollateralized) {\\n    // grab the vault by id if part of our system. revert if not\\n    IVault _vault = _getVault(_id);\\n    // calculate the total value of the vault's liquidity\\n    uint256 _totalLiquidityValue = _peekVaultBorrowingPower(_vault);\\n    // calculate the total liability of the vault\\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\\n    // if the ltv >= liability, the vault is solvent\\n    _overCollateralized = (_totalLiquidityValue >= _usdaLiability);\\n  }\\n\\n  /// @notice Check a vault for over-collateralization\\n  /// @dev This function calls getVaultBorrowingPower to allow state changes to happen if an oracle need them\\n  /// @param _id The id of vault we want to target\\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\\n  function checkVault(uint96 _id) public returns (bool _overCollateralized) {\\n    // grab the vault by id if part of our system. revert if not\\n    IVault _vault = _getVault(_id);\\n    // calculate the total value of the vault's liquidity\\n    uint256 _totalLiquidityValue = _getVaultBorrowingPower(_vault);\\n    // calculate the total liability of the vault\\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\\n    // if the ltv >= liability, the vault is solvent\\n    _overCollateralized = (_totalLiquidityValue >= _usdaLiability);\\n  }\\n\\n  /// @notice Borrows USDA from a vault. Only the vault minter may borrow from their vault\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to borrow\\n  function borrowUSDA(uint96 _id, uint192 _amount) external override {\\n    _borrow(_id, _amount, _msgSender(), true);\\n  }\\n\\n  /// @notice Borrows USDA from a vault and send the USDA to a specific address\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to borrow\\n  /// @param _target The address to receive borrowed USDA\\n  function borrowUSDAto(uint96 _id, uint192 _amount, address _target) external override {\\n    _borrow(_id, _amount, _target, true);\\n  }\\n\\n  /// @notice Borrows sUSD directly from reserve, liability is still in USDA, and USDA must be repaid\\n  /// @param _id The id of vault we want to target\\n  /// @param _susdAmount The amount of sUSD to borrow\\n  /// @param _target The address to receive borrowed sUSD\\n  function borrowsUSDto(uint96 _id, uint192 _susdAmount, address _target) external override {\\n    _borrow(_id, _susdAmount, _target, false);\\n  }\\n\\n  /// @notice Returns the initial borrowing fee\\n  /// @param _amount The base amount\\n  /// @return _fee The fee calculated based on a base amount\\n  function getBorrowingFee(uint192 _amount) public view override returns (uint192 _fee) {\\n    // _amount * (100% + initialBorrowingFee)\\n    _fee = _safeu192(_truncate(uint256(_amount * (1e18 + initialBorrowingFee)))) - _amount;\\n  }\\n\\n  /// @notice Returns the liquidation fee\\n  /// @param _tokensToLiquidate The collateral amount\\n  /// @param _assetAddress The collateral address to liquidate\\n  /// @return _fee The fee calculated based on amount\\n  function getLiquidationFee(\\n    uint192 _tokensToLiquidate,\\n    address _assetAddress\\n  ) public view override returns (uint192 _fee) {\\n    uint256 _liquidationIncentive = tokenAddressCollateralInfo[_assetAddress].liquidationIncentive;\\n    // _tokensToLiquidate * (100% + _liquidationIncentive)\\n    uint192 _liquidatorExpectedProfit =\\n      _safeu192(_truncate(uint256(_tokensToLiquidate * (1e18 + _liquidationIncentive)))) - _tokensToLiquidate;\\n    // _liquidatorExpectedProfit * (100% + liquidationFee)\\n    _fee =\\n      _safeu192(_truncate(uint256(_liquidatorExpectedProfit * (1e18 + liquidationFee)))) - _liquidatorExpectedProfit;\\n  }\\n\\n  /// @notice Business logic to perform the USDA loan\\n  /// @dev Pays interest\\n  /// @param _id The vault's id to borrow against\\n  /// @param _amount The amount of USDA to borrow\\n  /// @param _target The address to receive borrowed USDA\\n  /// @param _isUSDA Boolean indicating if the borrowed asset is USDA (if FALSE is sUSD)\\n  function _borrow(uint96 _id, uint192 _amount, address _target, bool _isUSDA) internal paysInterest whenNotPaused {\\n    // grab the vault by id if part of our system. revert if not\\n    IVault _vault = _getVault(_id);\\n    // only the minter of the vault may borrow from their vault\\n    if (_msgSender() != _vault.minter()) revert VaultController_OnlyMinter();\\n    // add the fee\\n    uint192 _fee = getBorrowingFee(_amount);\\n    // the base amount is the amount of USDA they wish to borrow divided by the interest factor, accounting for the fee\\n    uint192 _baseAmount = _safeu192(uint256((_amount + _fee) * EXP_SCALE) / uint256(interest.factor));\\n    // _baseLiability should contain the vault's new liability, in terms of base units\\n    // true indicates that we are adding to the liability\\n    uint256 _baseLiability = _vault.modifyLiability(true, _baseAmount);\\n    // increase the total base liability by the _baseAmount\\n    // the same amount we added to the vault's liability\\n    totalBaseLiability += _baseAmount;\\n    // now take the vault's total base liability and multiply it by the interest factor\\n    uint256 _usdaLiability = _truncate(uint256(interest.factor) * _baseLiability);\\n    // now get the ltv of the vault, aka their borrowing power, in usda\\n    uint256 _totalLiquidityValue = _getVaultBorrowingPower(_vault);\\n    // the ltv must be above the newly calculated _usdaLiability, else revert\\n    if (_totalLiquidityValue < _usdaLiability) revert VaultController_VaultInsolvent();\\n\\n    if (_isUSDA) {\\n      // now send usda to the target, equal to the amount they are owed\\n      usda.vaultControllerMint(_target, _amount);\\n    } else {\\n      // send sUSD to the target from reserve instead of mint\\n      usda.vaultControllerTransfer(_target, _amount);\\n    }\\n\\n    // also send the fee to the treasury\\n    if (_fee > 0) usda.vaultControllerMint(owner(), _fee);\\n\\n    // emit the event\\n    emit BorrowUSDA(_id, address(_vault), _amount, _fee);\\n  }\\n\\n  /// @notice Repays a vault's USDA loan. Anyone may repay\\n  /// @dev Pays interest\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to repay\\n  function repayUSDA(uint96 _id, uint192 _amount) external override {\\n    _repay(_id, _amount, false);\\n  }\\n\\n  /// @notice Repays all of a vault's USDA. Anyone may repay a vault's liabilities\\n  /// @dev Pays interest\\n  /// @param _id The id of vault we want to target\\n  function repayAllUSDA(uint96 _id) external override {\\n    _repay(_id, 0, true);\\n  }\\n\\n  /// @notice Business logic to perform the USDA repay\\n  /// @dev Pays interest\\n  /// @param _id The vault's id to repay\\n  /// @param _amountInUSDA The amount of USDA to borrow\\n  /// @param _repayAll Boolean if TRUE, repay all debt\\n  function _repay(uint96 _id, uint192 _amountInUSDA, bool _repayAll) internal paysInterest whenNotPaused {\\n    // grab the vault by id if part of our system. revert if not\\n    IVault _vault = _getVault(_id);\\n    uint192 _baseAmount;\\n\\n    // if _repayAll == TRUE, repay total liability\\n    if (_repayAll) {\\n      // store the vault baseLiability in memory\\n      _baseAmount = _safeu192(_vault.baseLiability());\\n      // get the total USDA liability, equal to the interest factor * vault's base liabilty\\n      _amountInUSDA = _safeu192(_truncate(interest.factor * _baseAmount));\\n    } else {\\n      // the base amount is the amount of USDA entered divided by the interest factor\\n      _baseAmount = _safeu192((_amountInUSDA * EXP_SCALE) / interest.factor);\\n    }\\n    // decrease the total base liability by the calculated base amount\\n    totalBaseLiability -= _baseAmount;\\n    // ensure that _baseAmount is lower than the vault's base liability.\\n    // this may not be needed, since modifyLiability *should* revert if is not true\\n    if (_baseAmount > _vault.baseLiability()) revert VaultController_RepayTooMuch();\\n    // decrease the vault's liability by the calculated base amount\\n    _vault.modifyLiability(false, _baseAmount);\\n    // burn the amount of USDA submitted from the sender\\n    usda.vaultControllerBurn(_msgSender(), _amountInUSDA);\\n\\n    emit RepayUSDA(_id, address(_vault), _amountInUSDA);\\n  }\\n\\n  /// @notice Simulates the liquidation of an underwater vault\\n  /// @param _id The id of vault we want to target\\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\\n  /// @param _tokensToLiquidate The number of tokens to liquidate\\n  /// @return _collateralLiquidated The number of collateral tokens the liquidator will receive\\n  /// @return _usdaPaid The amount of USDA the liquidator will have to pay\\n  function simulateLiquidateVault(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) external view override returns (uint256 _collateralLiquidated, uint256 _usdaPaid) {\\n    // cannot liquidate 0\\n    if (_tokensToLiquidate == 0) revert VaultController_LiquidateZeroTokens();\\n    // check for registered asset\\n    if (tokenAddressCollateralInfo[_assetAddress].tokenId == 0) revert VaultController_TokenNotRegistered();\\n\\n    // calculate the amount to liquidate and the 'bad fill price' using liquidationMath\\n    // see _liquidationMath for more detailed explaination of the math\\n    (uint256 _tokenAmount, uint256 _badFillPrice) = _peekLiquidationMath(_id, _assetAddress, _tokensToLiquidate);\\n    // set _tokensToLiquidate to this calculated amount if the function does not fail\\n    _collateralLiquidated = _tokenAmount != 0 ? _tokenAmount : _tokensToLiquidate;\\n    // the USDA to repurchase is equal to the bad fill price multiplied by the amount of tokens to liquidate\\n    _usdaPaid = _truncate(_badFillPrice * _collateralLiquidated);\\n    // extract fee\\n    _collateralLiquidated -= getLiquidationFee(uint192(_collateralLiquidated), _assetAddress);\\n  }\\n\\n  /// @notice Liquidates an underwater vault\\n  /// @dev Pays interest before liquidation. Vaults may be liquidated up to the point where they are exactly solvent\\n  /// @param _id The id of vault we want to target\\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\\n  /// @param _tokensToLiquidate The number of tokens to liquidate\\n  /// @return _toLiquidate The number of tokens that got liquidated\\n  function liquidateVault(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) external override paysInterest whenNotPaused returns (uint256 _toLiquidate) {\\n    // cannot liquidate 0\\n    if (_tokensToLiquidate == 0) revert VaultController_LiquidateZeroTokens();\\n    // check for registered asset\\n    if (tokenAddressCollateralInfo[_assetAddress].tokenId == 0) revert VaultController_TokenNotRegistered();\\n\\n    // calculate the amount to liquidate and the 'bad fill price' using liquidationMath\\n    // see _liquidationMath for more detailed explaination of the math\\n    (uint256 _tokenAmount, uint256 _badFillPrice) = _liquidationMath(_id, _assetAddress, _tokensToLiquidate);\\n    // set _tokensToLiquidate to this calculated amount if the function does not fail\\n    if (_tokenAmount > 0) _tokensToLiquidate = _tokenAmount;\\n    // the USDA to repurchase is equal to the bad fill price multiplied by the amount of tokens to liquidate\\n    uint256 _usdaToRepurchase = _truncate(_badFillPrice * _tokensToLiquidate);\\n    // get the vault that the liquidator wishes to liquidate\\n    IVault _vault = _getVault(_id);\\n\\n    // decrease the vault's liability\\n    _vault.modifyLiability(false, (_usdaToRepurchase * 1e18) / interest.factor);\\n\\n    // decrease the total base liability\\n    totalBaseLiability -= _safeu192((_usdaToRepurchase * 1e18) / interest.factor);\\n\\n    // decrease liquidator's USDA balance\\n    usda.vaultControllerBurn(_msgSender(), _usdaToRepurchase);\\n\\n    // withdraw from convex\\n    if (_vault.currentPoolIds(_assetAddress) != 0) {\\n      _vault.controllerWithdrawAndUnwrap(_assetAddress, _tokensToLiquidate);\\n    }\\n\\n    uint192 _liquidationFee = getLiquidationFee(uint192(_tokensToLiquidate), _assetAddress);\\n\\n    // finally, deliver tokens to liquidator\\n    _vault.controllerTransfer(_assetAddress, _msgSender(), _tokensToLiquidate - _liquidationFee);\\n    // and the fee to the treasury\\n    _vault.controllerTransfer(_assetAddress, owner(), _liquidationFee);\\n    // and reduces total\\n    _modifyTotalDeposited(_tokensToLiquidate, _assetAddress, false);\\n\\n    // this mainly prevents reentrancy\\n    if (_getVaultBorrowingPower(_vault) > _vaultLiability(_id)) revert VaultController_OverLiquidation();\\n\\n    // emit the event\\n    emit Liquidate(_id, _assetAddress, _usdaToRepurchase, _tokensToLiquidate - _liquidationFee, _liquidationFee);\\n    // return the amount of tokens liquidated (including fee)\\n    _toLiquidate = _tokensToLiquidate;\\n  }\\n\\n  /// @notice Returns the calculated amount of tokens to liquidate for a vault\\n  /// @dev The amount of tokens owed is a moving target and changes with each block as payInterest is called\\n  ///      This function can serve to give an indication of how many tokens can be liquidated\\n  ///      All this function does is call _liquidationMath with 2**256-1 as the amount\\n  /// @param _id The id of vault we want to target\\n  /// @param _assetAddress The address of token to calculate how many tokens to liquidate\\n  /// @return _tokensToLiquidate The amount of tokens liquidatable\\n  function tokensToLiquidate(\\n    uint96 _id,\\n    address _assetAddress\\n  ) external view override returns (uint256 _tokensToLiquidate) {\\n    (\\n      _tokensToLiquidate, // bad fill price\\n    ) = _peekLiquidationMath(_id, _assetAddress, 2 ** 256 - 1);\\n  }\\n\\n  /// @notice Internal function with business logic for liquidation math without any state changes\\n  /// @param _id The vault to get info for\\n  /// @param _assetAddress The token to calculate how many tokens to liquidate\\n  /// @param _tokensToLiquidate The max amount of tokens one wishes to liquidate\\n  /// @return _actualTokensToLiquidate The amount of tokens underwater this vault is\\n  /// @return _badFillPrice The bad fill price for the token\\n  function _peekLiquidationMath(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) internal view returns (uint256 _actualTokensToLiquidate, uint256 _badFillPrice) {\\n    //require that the vault is not solvent\\n    if (peekCheckVault(_id)) revert VaultController_VaultSolvent();\\n\\n    CollateralInfo memory _collateral = tokenAddressCollateralInfo[_assetAddress];\\n    uint256 _price = _collateral.oracle.peekValue();\\n    uint256 _usdaToSolvency = _peekAmountToSolvency(_id);\\n\\n    (_actualTokensToLiquidate, _badFillPrice) =\\n      _calculateTokensToLiquidate(_collateral, _id, _tokensToLiquidate, _assetAddress, _price, _usdaToSolvency);\\n  }\\n\\n  /// @notice Internal function with business logic for liquidation math\\n  /// @param _id The vault to get info for\\n  /// @param _assetAddress The token to calculate how many tokens to liquidate\\n  /// @param _tokensToLiquidate The max amount of tokens one wishes to liquidate\\n  /// @return _actualTokensToLiquidate The amount of tokens underwater this vault is\\n  /// @return _badFillPrice The bad fill price for the token\\n  function _liquidationMath(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) internal returns (uint256 _actualTokensToLiquidate, uint256 _badFillPrice) {\\n    //require that the vault is not solvent\\n    if (checkVault(_id)) revert VaultController_VaultSolvent();\\n\\n    CollateralInfo memory _collateral = tokenAddressCollateralInfo[_assetAddress];\\n    uint256 _price = _collateral.oracle.currentValue();\\n    uint256 _usdaToSolvency = _amountToSolvency(_id);\\n\\n    (_actualTokensToLiquidate, _badFillPrice) =\\n      _calculateTokensToLiquidate(_collateral, _id, _tokensToLiquidate, _assetAddress, _price, _usdaToSolvency);\\n  }\\n\\n  /// @notice Calculates the amount of tokens to liquidate for a vault\\n  /// @param _collateral The collateral to liquidate\\n  /// @param _id The vault to calculate the liquidation\\n  /// @param _tokensToLiquidate The max amount of tokens one wishes to liquidate\\n  /// @param _assetAddress The token to calculate how many tokens to liquidate\\n  /// @param _price The price of the collateral\\n  /// @param _usdaToSolvency The amount of USDA needed to make the vault solvent\\n  /// @return _actualTokensToLiquidate The amount of tokens underwater this vault is\\n  /// @return _badFillPrice The bad fill price for the token\\n  function _calculateTokensToLiquidate(\\n    CollateralInfo memory _collateral,\\n    uint96 _id,\\n    uint256 _tokensToLiquidate,\\n    address _assetAddress,\\n    uint256 _price,\\n    uint256 _usdaToSolvency\\n  ) internal view returns (uint256 _actualTokensToLiquidate, uint256 _badFillPrice) {\\n    IVault _vault = _getVault(_id);\\n    uint256 _priceWithDecimals = _getPriceWithDecimals(_price, _collateral.decimals);\\n    // get price discounted by liquidation penalty\\n    // price * (100% - liquidationIncentive)\\n    _badFillPrice = _truncate(_priceWithDecimals * (1e18 - _collateral.liquidationIncentive));\\n\\n    // the ltv discount is the amount of collateral value that one token provides\\n    uint256 _ltvDiscount = _truncate(_priceWithDecimals * _collateral.ltv);\\n    // this number is the denominator when calculating the _maxTokensToLiquidate\\n    // it is simply the badFillPrice - ltvDiscount\\n    uint256 _denominator = _badFillPrice - _ltvDiscount;\\n\\n    // the maximum amount of tokens to liquidate is the amount that will bring the vault to solvency\\n    // divided by the denominator\\n    uint256 _maxTokensToLiquidate = (_usdaToSolvency * 1e18) / _denominator;\\n    //Cannot liquidate more than is necessary to make vault over-collateralized\\n    if (_tokensToLiquidate > _maxTokensToLiquidate) _tokensToLiquidate = _maxTokensToLiquidate;\\n\\n    uint256 _balance = _vault.balances(_assetAddress);\\n\\n    //Cannot liquidate more collateral than there is in the vault\\n    if (_tokensToLiquidate > _balance) _tokensToLiquidate = _balance;\\n\\n    _actualTokensToLiquidate = _tokensToLiquidate;\\n  }\\n\\n  /// @notice Internal helper function to wrap getting of vaults\\n  /// @dev It will revert if the vault does not exist\\n  /// @param _id The id of vault\\n  /// @return _vault The vault for that id\\n  function _getVault(uint96 _id) internal view returns (IVault _vault) {\\n    address _vaultAddress = vaultIdVaultAddress[_id];\\n    if (_vaultAddress == address(0)) revert VaultController_VaultDoesNotExist();\\n    _vault = IVault(_vaultAddress);\\n  }\\n\\n  /// @notice Returns the amount of USDA needed to reach even solvency without state changes\\n  /// @dev This amount is a moving target and changes with each block as payInterest is called\\n  /// @param _id The id of vault we want to target\\n  /// @return _usdaToSolvency The amount of USDA needed to reach even solvency\\n  function amountToSolvency(uint96 _id) external view override returns (uint256 _usdaToSolvency) {\\n    if (peekCheckVault(_id)) revert VaultController_VaultSolvent();\\n    _usdaToSolvency = _peekAmountToSolvency(_id);\\n  }\\n\\n  /// @notice Bussiness logic for amountToSolvency without any state changes\\n  /// @param _id The id of vault\\n  /// @return _usdaToSolvency The amount of USDA needed to reach even solvency\\n  function _peekAmountToSolvency(uint96 _id) internal view returns (uint256 _usdaToSolvency) {\\n    _usdaToSolvency = _vaultLiability(_id) - _peekVaultBorrowingPower(_getVault(_id));\\n  }\\n\\n  /// @notice Bussiness logic for amountToSolvency\\n  /// @param _id The id of vault\\n  /// @return _usdaToSolvency The amount of USDA needed to reach even solvency\\n  function _amountToSolvency(uint96 _id) internal returns (uint256 _usdaToSolvency) {\\n    _usdaToSolvency = _vaultLiability(_id) - _getVaultBorrowingPower(_getVault(_id));\\n  }\\n\\n  /// @notice Returns vault liability of vault\\n  /// @param _id The id of vault\\n  /// @return _liability The amount of USDA the vault owes\\n  function vaultLiability(uint96 _id) external view override returns (uint192 _liability) {\\n    _liability = _vaultLiability(_id);\\n  }\\n\\n  /// @notice Returns the liability of a vault\\n  /// @dev Implementation in _vaultLiability\\n  /// @param _id The id of vault we want to target\\n  /// @return _liability The amount of USDA the vault owes\\n  function _vaultLiability(uint96 _id) internal view returns (uint192 _liability) {\\n    address _vaultAddress = vaultIdVaultAddress[_id];\\n    if (_vaultAddress == address(0)) revert VaultController_VaultDoesNotExist();\\n    IVault _vault = IVault(_vaultAddress);\\n    _liability = _safeu192(_truncate(_vault.baseLiability() * interest.factor));\\n  }\\n\\n  /// @notice Returns the vault borrowing power for vault\\n  /// @dev Implementation in getVaultBorrowingPower\\n  /// @param _id The id of vault we want to target\\n  /// @return _borrowPower The amount of USDA the vault can borrow\\n  function vaultBorrowingPower(uint96 _id) external view override returns (uint192 _borrowPower) {\\n    uint192 _bp = _peekVaultBorrowingPower(_getVault(_id));\\n    _borrowPower = _bp - getBorrowingFee(_bp);\\n  }\\n\\n  /// @notice Returns the borrowing power of a vault\\n  /// @param _vault The vault to get the borrowing power of\\n  /// @return _borrowPower The borrowing power of the vault\\n  //solhint-disable-next-line code-complexity\\n  function _getVaultBorrowingPower(IVault _vault) private returns (uint192 _borrowPower) {\\n    CollateralInfo memory _collateral;\\n    address _tokenAddress;\\n    uint256 _balance;\\n    uint192 _rawPrice;\\n    uint192 _tokenValue;\\n\\n    // loop over each registered token, adding the individuals ltv to the total ltv of the vault\\n    for (uint192 _i; _i < enabledTokens.length;) {\\n      unchecked {\\n        ++_i;\\n      }\\n      _collateral = tokenAddressCollateralInfo[enabledTokens[_i - 1]];\\n      // if the ltv is 0, continue\\n      if (_collateral.ltv == 0) continue;\\n      // get the address of the token through the array of enabled tokens\\n      // note that index 0 of enabledTokens corresponds to a vaultId of 1, so we must subtract 1 from i to get the correct index\\n      _tokenAddress = enabledTokens[_i - 1];\\n      // the balance is the vault's token balance of the current collateral token in the loop\\n      _balance = _vault.balances(_tokenAddress);\\n      if (_balance == 0) continue;\\n      // the raw price is simply the oracle price of the token\\n      _rawPrice = _safeu192(_collateral.oracle.currentValue());\\n      if (_rawPrice == 0) continue;\\n      // the token value is equal to the price * balance * tokenLTV\\n      _tokenValue = _safeu192(\\n        _truncate(_truncate(_balance * _collateral.ltv * _getPriceWithDecimals(_rawPrice, _collateral.decimals)))\\n      );\\n      // increase the ltv of the vault by the token value\\n      _borrowPower += _tokenValue;\\n    }\\n  }\\n\\n  /// @notice Returns the borrowing power of a vault without making state changes\\n  /// @param _vault The vault to get the borrowing power of\\n  /// @return _borrowPower The borrowing power of the vault\\n  //solhint-disable-next-line code-complexity\\n  function _peekVaultBorrowingPower(IVault _vault) private view returns (uint192 _borrowPower) {\\n    // loop over each registed token, adding the indivuduals ltv to the total ltv of the vault\\n    for (uint192 _i; _i < enabledTokens.length; ++_i) {\\n      CollateralInfo memory _collateral = tokenAddressCollateralInfo[enabledTokens[_i]];\\n      // if the ltv is 0, continue\\n      if (_collateral.ltv == 0) continue;\\n      // get the address of the token through the array of enabled tokens\\n      // note that index 0 of enabledTokens corresponds to a vaultId of 1, so we must subtract 1 from i to get the correct index\\n      address _tokenAddress = enabledTokens[_i];\\n      // the balance is the vault's token balance of the current collateral token in the loop\\n      uint256 _balance = _vault.balances(_tokenAddress);\\n      if (_balance == 0) continue;\\n      // the raw price is simply the oracle price of the token\\n      uint192 _rawPrice = _safeu192(_collateral.oracle.peekValue());\\n      if (_rawPrice == 0) continue;\\n      // the token value is equal to the price * balance * tokenLTV\\n      uint192 _tokenValue = _safeu192(\\n        _truncate(_truncate(_balance * _collateral.ltv * _getPriceWithDecimals(_rawPrice, _collateral.decimals)))\\n      );\\n      // increase the ltv of the vault by the token value\\n      _borrowPower += _tokenValue;\\n    }\\n  }\\n\\n  /// @notice Returns the increase amount of the interest factor. Accrues interest to borrowers and distribute it to USDA holders\\n  /// @dev Implementation in payInterest\\n  /// @return _interest The increase amount of the interest factor\\n  function calculateInterest() external override returns (uint256 _interest) {\\n    _interest = _payInterest();\\n  }\\n\\n  /// @notice Accrue interest to borrowers and distribute it to USDA holders.\\n  /// @dev This function is called before any function that changes the reserve ratio\\n  /// @return _interest The interest to distribute to USDA holders\\n  function _payInterest() private returns (uint256 _interest) {\\n    // calculate the time difference between the current block and the last time the block was called\\n    uint64 _timeDifference = uint64(block.timestamp) - interest.lastTime;\\n    // if the time difference is 0, there is no interest. this saves gas in the case that\\n    // if multiple users call interest paying functions in the same block\\n    if (_timeDifference == 0) return 0;\\n    // the current reserve ratio, cast to a uint256\\n    uint256 _ui18 = uint256(usda.reserveRatio());\\n    // cast the reserve ratio now to an int in order to get a curve value\\n    int256 _reserveRatio = int256(_ui18);\\n    // calculate the value at the curve. this vault controller is a USDA vault and will reference\\n    // the vault at address 0\\n    int256 _intCurveVal = curveMaster.getValueAt(address(0), _reserveRatio);\\n    // cast the integer curve value to a u192\\n    uint192 _curveVal = _safeu192(uint256(_intCurveVal));\\n    // calculate the amount of total outstanding loans before and after this interest accrual\\n    // first calculate how much the interest factor should increase by\\n    // this is equal to (timedifference * (curve value) / (seconds in a year)) * (interest factor)\\n    uint192 _e18FactorIncrease = _safeu192(\\n      _truncate(\\n        _truncate((uint256(_timeDifference) * uint256(1e18) * uint256(_curveVal)) / (365 days + 6 hours))\\n          * uint256(interest.factor)\\n      )\\n    );\\n    // get the total outstanding value before we increase the interest factor\\n    uint192 _valueBefore = _safeu192(_truncate(uint256(totalBaseLiability) * uint256(interest.factor)));\\n    // interest is a struct which contains the last timestamp and the current interest factor\\n    // set the value of this struct to a struct containing {(current block timestamp), (interest factor + increase)}\\n    // this should save ~5000 gas/call\\n    interest = Interest(uint64(block.timestamp), interest.factor + _e18FactorIncrease);\\n    // using that new value, calculate the new total outstanding value\\n    uint192 _valueAfter = _safeu192(_truncate(uint256(totalBaseLiability) * uint256(interest.factor)));\\n    // valueAfter - valueBefore is now equal to the true amount of interest accured\\n    // this mitigates rounding errors\\n    // the protocol's fee amount is equal to this value multiplied by the protocol fee percentage, 1e18=100%\\n    uint192 _protocolAmount = _safeu192(_truncate(uint256(_valueAfter - _valueBefore) * uint256(protocolFee)));\\n    // donate the true amount of interest less the amount which the protocol is taking for itself\\n    // this donation is what pays out interest to USDA holders\\n    usda.vaultControllerDonate(_valueAfter - _valueBefore - _protocolAmount);\\n    // send the protocol's fee to the owner of this contract.\\n    usda.vaultControllerMint(owner(), _protocolAmount);\\n    // emit the event\\n    emit InterestEvent(uint64(block.timestamp), _e18FactorIncrease, _curveVal);\\n    // return the interest factor increase\\n    _interest = _e18FactorIncrease;\\n  }\\n\\n  /// @notice Deploys a new Vault\\n  /// @param _id The id of the vault\\n  /// @param _minter The address of the minter of the vault\\n  /// @return _vault The vault that was created\\n  function _createVault(uint96 _id, address _minter) internal virtual returns (address _vault) {\\n    _vault = address(VAULT_DEPLOYER.deployVault(_id, _minter));\\n  }\\n\\n  /// @notice Returns the status of a range of vaults\\n  /// @dev Special view only function to help liquidators\\n  /// @param _start The id of the vault to start looping\\n  /// @param _stop The id of vault to stop looping\\n  /// @return _vaultSummaries An array of vault information\\n  function vaultSummaries(\\n    uint96 _start,\\n    uint96 _stop\\n  ) public view override returns (VaultSummary[] memory _vaultSummaries) {\\n    if (_stop > vaultsMinted) _stop = vaultsMinted;\\n    _vaultSummaries = new VaultSummary[](_stop - _start + 1);\\n    for (uint96 _i = _start; _i <= _stop;) {\\n      IVault _vault = _getVault(_i);\\n      uint256[] memory _tokenBalances = new uint256[](enabledTokens.length);\\n\\n      for (uint256 _j; _j < enabledTokens.length;) {\\n        _tokenBalances[_j] = _vault.balances(enabledTokens[_j]);\\n\\n        unchecked {\\n          ++_j;\\n        }\\n      }\\n      _vaultSummaries[_i - _start] =\\n        VaultSummary(_i, _peekVaultBorrowingPower(_vault), this.vaultLiability(_i), enabledTokens, _tokenBalances);\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Modifies the total deposited in the protocol\\n  function _modifyTotalDeposited(uint256 _amount, address _token, bool _increase) internal {\\n    CollateralInfo memory _collateral = tokenAddressCollateralInfo[_token];\\n    if (_collateral.tokenId == 0) revert VaultController_TokenNotRegistered();\\n    if (_increase && (_collateral.totalDeposited + _amount) > _collateral.cap) revert VaultController_CapReached();\\n\\n    tokenAddressCollateralInfo[_token].totalDeposited =\\n      _increase ? _collateral.totalDeposited + _amount : _collateral.totalDeposited - _amount;\\n  }\\n\\n  /// @notice External function used by vaults to increase or decrease the `totalDeposited`.\\n  /// @dev Should only be called by a valid vault\\n  /// @param _vaultID The id of vault which is calling (used to verify)\\n  /// @param _amount The amount to modify\\n  /// @param _token The token address which should modify the total\\n  /// @param _increase Boolean that indicates if should increase or decrease (TRUE -> increase, FALSE -> decrease)\\n  function modifyTotalDeposited(uint96 _vaultID, uint256 _amount, address _token, bool _increase) external override {\\n    if (_msgSender() != vaultIdVaultAddress[_vaultID]) revert VaultController_NotValidVault();\\n    _modifyTotalDeposited(_amount, _token, _increase);\\n  }\\n\\n  // @notice Returns the price adjusting to the decimals of the token\\n  // @param _price The price to adjust\\n  // @param _decimals The decimals of the token\\n  // @return _priceWithDecimals The price with the decimals of the token\\n  function _getPriceWithDecimals(uint256 _price, uint256 _decimals) internal pure returns (uint256 _priceWithDecimals) {\\n    _priceWithDecimals = _price * 10 ** (18 - _decimals);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/ExponentialNoError.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// @title Exponential module for storing fixed-precision decimals\\n// @author Compound\\n// @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n//        Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n//        `Exp({mantissa: 5100000000000000000})`.\\ncontract ExponentialNoError {\\n  uint256 public constant EXP_SCALE = 1e18;\\n  uint256 public constant DOUBLE_SCALE = 1e36;\\n  uint256 public constant HALF_EXP_SCALE = EXP_SCALE / 2;\\n  uint256 public constant MANTISSA_ONE = EXP_SCALE;\\n  uint256 public constant UINT192_MAX = type(uint192).max;\\n  uint256 public constant UINT128_MAX = type(uint128).max;\\n\\n  struct Exp {\\n    uint256 mantissa;\\n  }\\n\\n  struct Double {\\n    uint256 mantissa;\\n  }\\n\\n  // @dev Truncates the given exp to a whole number value.\\n  //      For example, truncate(Exp{mantissa: 15 * EXP_SCALE}) = 15\\n  function _truncate(Exp memory _exp) internal pure returns (uint256 _result) {\\n    return _exp.mantissa / EXP_SCALE;\\n  }\\n\\n  function _truncate(uint256 _u) internal pure returns (uint256 _result) {\\n    return _u / EXP_SCALE;\\n  }\\n\\n  function _safeu192(uint256 _u) internal pure returns (uint192 _result) {\\n    require(_u < UINT192_MAX, 'overflow');\\n    return uint192(_u);\\n  }\\n\\n  function _safeu128(uint256 _u) internal pure returns (uint128 _result) {\\n    require(_u < UINT128_MAX, 'overflow');\\n    return uint128(_u);\\n  }\\n\\n  // @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n  function _mulScalarTruncate(Exp memory _a, uint256 _scalar) internal pure returns (uint256 _result) {\\n    Exp memory _product = _mul(_a, _scalar);\\n    return _truncate(_product);\\n  }\\n\\n  // @dev Multiply an Exp by a scalar, truncate, then _add an to an unsigned integer, returning an unsigned integer.\\n  function _mulScalarTruncateAddUInt(\\n    Exp memory _a,\\n    uint256 _scalar,\\n    uint256 _addend\\n  ) internal pure returns (uint256 _result) {\\n    Exp memory _product = _mul(_a, _scalar);\\n    return _add(_truncate(_product), _addend);\\n  }\\n\\n  // @dev Checks if first Exp is less than second Exp.\\n  function _lessThanExp(Exp memory _left, Exp memory _right) internal pure returns (bool _result) {\\n    return _left.mantissa < _right.mantissa;\\n  }\\n\\n  // @dev Checks if left Exp <= right Exp.\\n  function _lessThanOrEqualExp(Exp memory _left, Exp memory _right) internal pure returns (bool _result) {\\n    return _left.mantissa <= _right.mantissa;\\n  }\\n\\n  // @dev Checks if left Exp > right Exp.\\n  function _greaterThanExp(Exp memory _left, Exp memory _right) internal pure returns (bool _result) {\\n    return _left.mantissa > _right.mantissa;\\n  }\\n\\n  // @dev returns true if Exp is exactly zero\\n  function _isZeroExp(Exp memory _value) internal pure returns (bool _result) {\\n    return _value.mantissa == 0;\\n  }\\n\\n  function _safe224(uint256 _n, string memory _errorMessage) internal pure returns (uint224 _result) {\\n    require(_n < 2 ** 224, _errorMessage);\\n    return uint224(_n);\\n  }\\n\\n  function _safe32(uint256 _n, string memory _errorMessage) internal pure returns (uint32 _result) {\\n    require(_n < 2 ** 32, _errorMessage);\\n    return uint32(_n);\\n  }\\n\\n  function _add(Exp memory _a, Exp memory _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _add(_a.mantissa, _b.mantissa)});\\n  }\\n\\n  function _add(Double memory _a, Double memory _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _add(_a.mantissa, _b.mantissa)});\\n  }\\n\\n  function _add(uint256 _a, uint256 _b) internal pure returns (uint256 _result) {\\n    return _add(_a, _b, 'addition overflow');\\n  }\\n\\n  function _add(uint256 _a, uint256 _b, string memory _errorMessage) internal pure returns (uint256 _result) {\\n    uint256 _c = _a + _b;\\n    require(_c >= _a, _errorMessage);\\n    return _c;\\n  }\\n\\n  function _sub(Exp memory _a, Exp memory _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _sub(_a.mantissa, _b.mantissa)});\\n  }\\n\\n  function _sub(Double memory _a, Double memory _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _sub(_a.mantissa, _b.mantissa)});\\n  }\\n\\n  function _sub(uint256 _a, uint256 _b) internal pure returns (uint256 _result) {\\n    return _sub(_a, _b, 'subtraction underflow');\\n  }\\n\\n  function _sub(uint256 _a, uint256 _b, string memory _errorMessage) internal pure returns (uint256 _result) {\\n    require(_b <= _a, _errorMessage);\\n    return _a - _b;\\n  }\\n\\n  function _mul(Exp memory _a, Exp memory _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _mul(_a.mantissa, _b.mantissa) / EXP_SCALE});\\n  }\\n\\n  function _mul(Exp memory _a, uint256 _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _mul(_a.mantissa, _b)});\\n  }\\n\\n  function _mul(uint256 _a, Exp memory _b) internal pure returns (uint256 _result) {\\n    return _mul(_a, _b.mantissa) / EXP_SCALE;\\n  }\\n\\n  function _mul(Double memory _a, Double memory _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _mul(_a.mantissa, _b.mantissa) / DOUBLE_SCALE});\\n  }\\n\\n  function _mul(Double memory _a, uint256 _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _mul(_a.mantissa, _b)});\\n  }\\n\\n  function _mul(uint256 _a, Double memory _b) internal pure returns (uint256 _result) {\\n    return _mul(_a, _b.mantissa) / DOUBLE_SCALE;\\n  }\\n\\n  function _mul(uint256 _a, uint256 _b) internal pure returns (uint256 _result) {\\n    return _mul(_a, _b, 'multiplication overflow');\\n  }\\n\\n  function _mul(uint256 _a, uint256 _b, string memory _errorMessage) internal pure returns (uint256 _result) {\\n    if (_a == 0 || _b == 0) return 0;\\n    uint256 _c = _a * _b;\\n    require(_c / _a == _b, _errorMessage);\\n    return _c;\\n  }\\n\\n  function _div(Exp memory _a, Exp memory _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _div(_mul(_a.mantissa, EXP_SCALE), _b.mantissa)});\\n  }\\n\\n  function _div(Exp memory _a, uint256 _b) internal pure returns (Exp memory _result) {\\n    return Exp({mantissa: _div(_a.mantissa, _b)});\\n  }\\n\\n  function _div(uint256 _a, Exp memory _b) internal pure returns (uint256 _result) {\\n    return _div(_mul(_a, EXP_SCALE), _b.mantissa);\\n  }\\n\\n  function _div(Double memory _a, Double memory _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _div(_mul(_a.mantissa, DOUBLE_SCALE), _b.mantissa)});\\n  }\\n\\n  function _div(Double memory _a, uint256 _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _div(_a.mantissa, _b)});\\n  }\\n\\n  function _div(uint256 _a, Double memory _b) internal pure returns (uint256 _result) {\\n    return _div(_mul(_a, DOUBLE_SCALE), _b.mantissa);\\n  }\\n\\n  function _div(uint256 _a, uint256 _b) internal pure returns (uint256 _result) {\\n    return _div(_a, _b, 'divide by zero');\\n  }\\n\\n  function _div(uint256 _a, uint256 _b, string memory _errorMessage) internal pure returns (uint256 _result) {\\n    require(_b > 0, _errorMessage);\\n    return _a / _b;\\n  }\\n\\n  function _fraction(uint256 _a, uint256 _b) internal pure returns (Double memory _result) {\\n    return Double({mantissa: _div(_mul(_a, DOUBLE_SCALE), _b)});\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/periphery/CurveMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ICurveMaster} from '@interfaces/periphery/ICurveMaster.sol';\\nimport {ICurveSlave} from '@interfaces/utils/ICurveSlave.sol';\\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/// @notice Curve master keeps a record of CurveSlave contracts and links it with an address\\n/// @dev All numbers should be scaled to 1e18. for instance, number 5e17 represents 50%\\ncontract CurveMaster is ICurveMaster, Ownable {\\n  /// @dev Mapping of token to address\\n  mapping(address => address) public curves;\\n\\n  /// @dev The vault controller address\\n  address public vaultControllerAddress;\\n\\n  /// @notice Returns the value of curve labled _tokenAddress at _xValue\\n  /// @param _tokenAddress The key to lookup the curve with in the mapping\\n  /// @param _xValue The x value to pass to the slave\\n  /// @return _value The y value of the curve\\n  function getValueAt(address _tokenAddress, int256 _xValue) external view override returns (int256 _value) {\\n    if (curves[_tokenAddress] == address(0)) revert CurveMaster_TokenNotEnabled();\\n    ICurveSlave _curve = ICurveSlave(curves[_tokenAddress]);\\n    _value = _curve.valueAt(_xValue);\\n    if (_value == 0) revert CurveMaster_ZeroResult();\\n  }\\n\\n  /// @notice Set the VaultController addr in order to pay interest on curve setting\\n  /// @param _vaultMasterAddress The address of vault master\\n  function setVaultController(address _vaultMasterAddress) external override onlyOwner {\\n    address _oldCurveAddress = vaultControllerAddress;\\n    vaultControllerAddress = _vaultMasterAddress;\\n\\n    emit VaultControllerSet(_oldCurveAddress, _vaultMasterAddress);\\n  }\\n\\n  /// @notice Setting a new curve should pay interest\\n  /// @param _tokenAddress The address of the token\\n  /// @param _curveAddress The address of the curve for the contract\\n  function setCurve(address _tokenAddress, address _curveAddress) external override onlyOwner {\\n    if (vaultControllerAddress != address(0)) IVaultController(vaultControllerAddress).calculateInterest();\\n    address _oldCurve = curves[_tokenAddress];\\n    curves[_tokenAddress] = _curveAddress;\\n\\n    emit CurveSet(_oldCurve, _tokenAddress, _curveAddress);\\n  }\\n\\n  /// @notice Special function that does not calculate interest, used for deployment\\n  /// @param _tokenAddress The address of the token\\n  /// @param _curveAddress The address of the curve for the contract\\n  function forceSetCurve(address _tokenAddress, address _curveAddress) external override onlyOwner {\\n    address _oldCurve = curves[_tokenAddress];\\n    curves[_tokenAddress] = _curveAddress;\\n\\n    emit CurveForceSet(_oldCurve, _tokenAddress, _curveAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/core/IUSDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IRoles} from '@interfaces/utils/IRoles.sol';\\n\\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\n\\n/// @title USDA Interface\\n/// @notice extends IERC20Metadata\\ninterface IUSDA is IERC20Metadata, IRoles {\\n  /*///////////////////////////////////////////////////////////////\\n                              EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Emitted when a deposit is made\\n  // @param _from The address which made the deposit\\n  // @param _value The value deposited\\n\\n  event Deposit(address indexed _from, uint256 _value);\\n\\n  // @notice Emitted when a withdraw is made\\n  // @param _from The address which made the withdraw\\n  // @param _value The value withdrawn\\n\\n  event Withdraw(address indexed _from, uint256 _value);\\n\\n  // @notice Emitted when a mint is made\\n  // @param _to The address which made the mint\\n  // @param _value The value minted\\n\\n  event Mint(address _to, uint256 _value);\\n\\n  // @notice Emitted when a burn is made\\n  // @param _from The address which made the burn\\n  // @param _value The value burned\\n\\n  event Burn(address _from, uint256 _value);\\n\\n  // @notice Emitted when a donation is made\\n  // @param _from The address which made the donation\\n  // @param _value The value of the donation\\n  // @param _totalSupply The new total supply\\n\\n  event Donation(address indexed _from, uint256 _value, uint256 _totalSupply);\\n\\n  // @notice Emitted when the owner recovers dust\\n  // @param _receiver The address which made the recover\\n  // @param _amount The value recovered\\n\\n  event RecoveredDust(address indexed _receiver, uint256 _amount);\\n\\n  // @notice Emitted when the owner sets a pauser\\n  // @param _pauser The new pauser address\\n\\n  event PauserSet(address indexed _pauser);\\n\\n  // @notice Emitted when a sUSD transfer is made from the vaultController\\n  // @param _target The receiver of the transfer\\n  // @param _susdAmount The amount sent\\n\\n  event VaultControllerTransfer(address _target, uint256 _susdAmount);\\n\\n  // @notice Emitted when the owner adds a new vaultController giving special roles\\n  // @param _vaultController The address of the vault controller\\n\\n  event VaultControllerAdded(address indexed _vaultController);\\n\\n  // @notice Emitted when the owner removes a vaultController removing special roles\\n  // @param _vaultController The address of the vault controller\\n\\n  event VaultControllerRemoved(address indexed _vaultController);\\n\\n  // @notice Emitted when the owner removes a vaultController from the list\\n  // @param _vaultController The address of the vault controller\\n\\n  event VaultControllerRemovedFromList(address indexed _vaultController);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Thrown when trying to deposit zero amount\\n  error USDA_ZeroAmount();\\n\\n  /// @notice Thrown when trying to withdraw more than the balance\\n  error USDA_InsufficientFunds();\\n\\n  /// @notice Thrown when trying to withdraw all but the reserve amount is 0\\n  error USDA_EmptyReserve();\\n\\n  /// @notice Thrown when _msgSender is not the pauser of the contract\\n  error USDA_OnlyPauser();\\n\\n  /// @notice Thrown when vault controller is trying to burn more than the balance\\n  error USDA_NotEnoughBalance();\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Returns sUSD contract (reserve)\\n  /// @return _sUSD The sUSD contract\\n  function sUSD() external view returns (IERC20 _sUSD);\\n\\n  /// @notice Returns the reserve ratio\\n  /// @return _reserveRatio The reserve ratio\\n  function reserveRatio() external view returns (uint192 _reserveRatio);\\n\\n  /// @notice Returns the reserve amount\\n  /// @return _reserveAmount The reserve amount\\n  function reserveAmount() external view returns (uint256 _reserveAmount);\\n\\n  /// @notice The address of the pauser\\n  function pauser() external view returns (address _pauser);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Deposit sUSD to mint USDA\\n  /// @dev Caller should obtain 1 USDA for each sUSD\\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\\n  /// 'gons' are the internal accounting unit, used to keep scale.\\n  /// We use the variable _gonsPerFragment in order to convert between the two\\n  /// try dimensional analysis when doing the math in order to verify units are correct\\n  /// @param _susdAmount The amount of sUSD to deposit\\n  function deposit(uint256 _susdAmount) external;\\n\\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\\n  /// @param _susdAmount The amount of sUSD to deposit\\n  /// @param _target The address to receive the USDA tokens\\n  function depositTo(uint256 _susdAmount, address _target) external;\\n\\n  /// @notice Withdraw sUSD by burning USDA\\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\\n  /// @param _susdAmount The amount of sUSD to withdraw\\n  function withdraw(uint256 _susdAmount) external;\\n\\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\\n  /// @param _susdAmount amount of sUSD to withdraw\\n  /// @param _target address to receive the sUSD\\n  function withdrawTo(uint256 _susdAmount, address _target) external;\\n\\n  /// @notice Withdraw sUSD by burning USDA\\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\\n  function withdrawAll() external returns (uint256 _susdWithdrawn);\\n\\n  /// @notice Withdraw sUSD by burning USDA\\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\\n  function withdrawAllTo(address _target) external returns (uint256 _susdWithdrawn);\\n\\n  /// @notice Donates susd to the protocol reserve\\n  /// @param _susdAmount The amount of sUSD to donate\\n  function donate(uint256 _susdAmount) external;\\n\\n  /// @notice Recovers accidentally sent sUSD to this contract\\n  /// @param _to The receiver of the dust\\n  function recoverDust(address _to) external;\\n\\n  /// @notice Sets the pauser for both USDA and VaultController\\n  /// @dev The pauser is a separate role from the owner\\n  function setPauser(address _pauser) external;\\n\\n  /// @notice Pause contract\\n  /// @dev Can only be called by the pauser\\n  function pause() external;\\n\\n  /// @notice Unpause contract, pauser only\\n  /// @dev Can only be called by the pauser\\n  function unpause() external;\\n\\n  /// @notice Admin function to mint USDA\\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\\n  function mint(uint256 _susdAmount) external;\\n\\n  /// @notice Admin function to burn USDA\\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\\n  function burn(uint256 _susdAmount) external;\\n\\n  /// @notice Function for the vaultController to burn\\n  /// @param _target The address to burn the USDA from\\n  /// @param _amount The amount of USDA to burn\\n  function vaultControllerBurn(address _target, uint256 _amount) external;\\n\\n  /// @notice Function for the vaultController to mint\\n  /// @param _target The address to mint the USDA to\\n  /// @param _amount The amount of USDA to mint\\n  function vaultControllerMint(address _target, uint256 _amount) external;\\n\\n  /// @notice Allows VaultController to send sUSD from the reserve\\n  /// @param _target The address to receive the sUSD from reserve\\n  /// @param _susdAmount The amount of sUSD to send\\n  function vaultControllerTransfer(address _target, uint256 _susdAmount) external;\\n\\n  /// @notice Function for the vaultController to scale all USDA balances\\n  /// @param _amount The amount of USDA (e18) to donate\\n  function vaultControllerDonate(uint256 _amount) external;\\n\\n  /// @notice Adds a new vault controller\\n  /// @param _vaultController The new vault controller to add\\n  function addVaultController(address _vaultController) external;\\n\\n  /// @notice Removes a vault controller\\n  /// @param _vaultController The vault controller to remove\\n  function removeVaultController(address _vaultController) external;\\n\\n  /// @notice Removes a vault controller from the loop list\\n  /// @param _vaultController The vault controller to remove\\n  function removeVaultControllerFromList(address _vaultController) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/core/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\\nimport {ICVX} from '@interfaces/utils/ICVX.sol';\\n\\n/// @title Vault Interface\\ninterface IVault {\\n  /*///////////////////////////////////////////////////////////////\\n                              EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Emited after depositing a token\\n  // @param _token The address of the token to deposit\\n  // @param _amount The amount to deposit\\n  event Deposit(address _token, uint256 _amount);\\n\\n  // @notice Emited after withdrawing a token\\n  // @param _token The address of the token to withdraw\\n  // @param _amount The amount to withdraw\\n  event Withdraw(address _token, uint256 _amount);\\n\\n  // @notice Emited when claiming a reward\\n  // @param _token The address of the token that was claimed\\n  // @param _amount The amount that was claimed\\n  event ClaimedReward(address _token, uint256 _amount);\\n\\n  // @notice Emited when migrating a crvLP token on convex manually\\n  // @param _token The address of the token to stake\\n  // @param _amount The amount to stake\\n  event Migrated(address _token, uint256 _amount);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Thrown when trying to deposit a token that is not registered\\n  error Vault_TokenNotRegistered();\\n\\n  // @notice Thrown when trying to deposit 0 amount\\n  error Vault_AmountZero();\\n\\n  /// @notice Thrown when trying to withdraw more than it's possible\\n  error Vault_OverWithdrawal();\\n\\n  /// @notice Thrown when trying to repay more than is needed\\n  error Vault_RepayTooMuch();\\n\\n  /// @notice Thrown when _msgSender is not the minter of the vault\\n  error Vault_NotMinter();\\n\\n  /// @notice Thrown when _msgSender is not the controller of the vault\\n  error Vault_NotVaultController();\\n\\n  /// @notice Thrown when depositing and staking on convex fails\\n  error Vault_DepositAndStakeOnConvexFailed();\\n\\n  /// @notice Thrown when trying to withdraw and unstake from convex\\n  error Vault_WithdrawAndUnstakeOnConvexFailed();\\n\\n  /// @notice Thrown when trying to claim rewards with a non staked token\\n  error Vault_TokenNotStaked();\\n\\n  /// @notice Thrown when trying to stake with 0 balance\\n  error Vault_TokenZeroBalance();\\n\\n  /// @notice Thrown when a token is already migrated and trying to migrate again\\n  error Vault_TokenAlreadyMigrated();\\n\\n  /// @notice Thrown when the base reward contract was not approved by governance\\n  error Vault_InvalidBaseRewardContract();\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              STRUCTS\\n    //////////////////////////////////////////////////////////////*/\\n  /// @title VaultInfo struct\\n  /// @notice this struct is used to store the vault metadata\\n  /// this should reduce the cost of minting by ~15,000\\n  /// by limiting us to max 2**96-1 vaults\\n  struct VaultInfo {\\n    uint96 id;\\n    address minter;\\n  }\\n\\n  struct Reward {\\n    IERC20 token;\\n    uint256 amount;\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Returns the struct containing the vault information\\n  // @return _id Id of the vault\\n  // @return _minter Minter of the vault\\n  function vaultInfo() external view returns (uint96 _id, address _minter);\\n\\n  // @notice Returns the vault's balance of a token\\n  // @param _token The address of the token\\n  // @return _balance The token's balance of the vault\\n  function balances(address _token) external view returns (uint256 _balance);\\n\\n  // @notice Returns the pool that the token is staked on\\n  // @dev Returns 0 if not staked\\n  // @param _token The address of the token\\n  // @return _poolId The poolId that the token is staked on\\n  function currentPoolIds(address _token) external view returns (uint256 _poolId);\\n\\n  // @notice Returns the current vault base liability\\n  // @return _liability The current vault base liability of the vault\\n  function baseLiability() external view returns (uint256 _liability);\\n\\n  // @notice Returns the minter's address of the vault\\n  // @return _minter The minter's address\\n  function minter() external view returns (address _minter);\\n\\n  // @notice Returns the id of the vault\\n  // @return _id The id of the vault\\n  function id() external view returns (uint96 _id);\\n\\n  // @notice Returns the vault controller\\n  // @return _vaultController The vault controller\\n  function CONTROLLER() external view returns (IVaultController _vaultController);\\n\\n  /// @notice Returns the CRV token address\\n  /// @return _crv The CRV token address\\n  function CRV() external view returns (IERC20 _crv);\\n\\n  /// @notice Returns the CVX token address\\n  /// @return _cvx The CVX token address\\n  function CVX() external view returns (ICVX _cvx);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Used to deposit a token to the vault\\n  // @param _token The address of the token to deposit\\n  // @param _amount The amount of the token to deposit\\n  function depositERC20(address _token, uint256 _amount) external;\\n\\n  // @notice Used to withdraw a token from the vault. This can only be called by the minter\\n  // @dev The withdraw will be denied if ones vault would become insolvent\\n  // @param _token The address of the token\\n  // @param _amount The amount of the token to withdraw\\n  function withdrawERC20(address _token, uint256 _amount) external;\\n\\n  /// @notice Let's the user manually stake their crvLP\\n  /// @dev    This can be called if the convex pool didn't exist when the token was registered\\n  ///         and was later updated\\n  /// @param _tokenAddress The address of erc20 crvLP token\\n  function migrateCrvLPCollateral(address _tokenAddress) external;\\n\\n  /// @notice Returns true when user can manually stake their token balance\\n  /// @param _token The address of the token to check\\n  /// @return _canMigrate Returns true if the token can be staked manually\\n  function canMigrate(address _token) external view returns (bool _canMigrate);\\n\\n  /// @notice Claims available rewards from multiple tokens\\n  /// @dev    Transfers a percentage of the crv and cvx rewards to claim AMPH tokens\\n  /// @param _tokenAddresses The addresses of the erc20 tokens\\n  /// @param _claimExtraRewards True if it should claim the extra rewards from convex\\n  function claimRewards(address[] memory _tokenAddresses, bool _claimExtraRewards) external;\\n\\n  /// @notice Returns an array of tokens and amounts available for claim\\n  /// @param _tokenAddress The address of erc20 token\\n  /// @param _claimExtraRewards True if it should claim the extra rewards from convex\\n  /// @return _rewards The array of tokens and amount available for claim\\n  function claimableRewards(\\n    address _tokenAddress,\\n    bool _claimExtraRewards\\n  ) external view returns (Reward[] memory _rewards);\\n\\n  /// @notice Used to claim rewards from past baseRewardContract\\n  /// @param _baseRewardContract The base reward contract to claim from\\n  /// @param _claimMainReward True to claim the base rewards also (CRV and CVX)\\n  /// @param _extraIndexesToClaim Indexes to claim the extra rewards\\n  function claimPreviousRewards(\\n    IBaseRewardPool _baseRewardContract,\\n    bool _claimMainReward,\\n    uint256[] memory _extraIndexesToClaim\\n  ) external;\\n\\n  /// @notice Function used by the VaultController to transfer tokens\\n  /// @param _token The address of the token to transfer\\n  /// @param _to The address of the person to send the coins to\\n  /// @param _amount The amount of coins to move\\n  function controllerTransfer(address _token, address _to, uint256 _amount) external;\\n\\n  /// @notice function used by the VaultController to withdraw from convex\\n  /// callable by the VaultController only\\n  /// @param _tokenAddress The token address to withdraw from the rewards contract\\n  /// @param _amount amount of coins to withdraw\\n  function controllerWithdrawAndUnwrap(address _tokenAddress, uint256 _amount) external;\\n\\n  // @notice Modifies a vault's liability. Can only be called by VaultController\\n  // @param _increase True to increase liability, false to decrease\\n  // @param _baseAmount The change amount in base liability\\n  // @return _liability The new base liability\\n  function modifyLiability(bool _increase, uint256 _baseAmount) external returns (uint256 _liability);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/core/IVaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {CurveMaster} from '@contracts/periphery/CurveMaster.sol';\\nimport {IOracleRelay} from '@interfaces/periphery/IOracleRelay.sol';\\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\\nimport {IVaultDeployer} from '@interfaces/core/IVaultDeployer.sol';\\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\\n\\n/// @title VaultController Interface\\ninterface IVaultController {\\n  /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Emited when payInterest is called to accrue interest and distribute it\\n  // @param _epoch The block timestamp when the function called\\n  // @param _amount The increase amount of the interest factor\\n  // @param _curveVal The value at the curve\\n  event InterestEvent(uint64 _epoch, uint192 _amount, uint256 _curveVal);\\n\\n  // @notice Emited when a new protocol fee is being set\\n  // @param _protocolFee The new fee for the protocol\\n  event NewProtocolFee(uint192 _protocolFee);\\n\\n  // @notice Emited when a new erc20 token is being registered as acceptable collateral\\n  // @param _tokenAddress The addres of the erc20 token\\n  // @param _ltv The loan to value amount of the erc20\\n  // @param _oracleAddress The address of the oracle to use to fetch the price\\n  // @param _liquidationIncentive The liquidation penalty for the token\\n  // @param _cap The maximum amount that can be deposited\\n  event RegisteredErc20(\\n    address _tokenAddress, uint256 _ltv, address _oracleAddress, uint256 _liquidationIncentive, uint256 _cap\\n  );\\n\\n  // @notice Emited when the information about an acceptable erc20 token is being update\\n  // @param _tokenAddress The addres of the erc20 token to update\\n  // @param _ltv The new loan to value amount of the erc20\\n  // @param _oracleAddress The new address of the oracle to use to fetch the price\\n  // @param _liquidationIncentive The new liquidation penalty for the token\\n  // @param _cap The maximum amount that can be deposited\\n  // @param _poolId The convex pool id of a crv lp token\\n  event UpdateRegisteredErc20(\\n    address _tokenAddress,\\n    uint256 _ltv,\\n    address _oracleAddress,\\n    uint256 _liquidationIncentive,\\n    uint256 _cap,\\n    uint256 _poolId\\n  );\\n\\n  // @notice Emited when a new vault is being minted\\n  // @param _vaultAddress The address of the new vault\\n  // @param _vaultId The id of the vault\\n  // @param _vaultOwner The address of the owner of the vault\\n  event NewVault(address _vaultAddress, uint256 _vaultId, address _vaultOwner);\\n\\n  // @notice Emited when the owner registers a curve master\\n  // @param _curveMasterAddress The address of the curve master\\n  event RegisterCurveMaster(address _curveMasterAddress);\\n\\n  // @notice Emited when someone successfully borrows USDA\\n  // @param _vaultId The id of the vault that borrowed against\\n  // @param _vaultAddress The address of the vault that borrowed against\\n  // @param _borrowAmount The amounnt that was borrowed\\n  // @param _fee The fee assigned to the treasury\\n  event BorrowUSDA(uint256 _vaultId, address _vaultAddress, uint256 _borrowAmount, uint256 _fee);\\n\\n  // @notice Emited when someone successfully repayed a vault's loan\\n  // @param _vaultId The id of the vault that was repayed\\n  // @param _vaultAddress The address of the vault that was repayed\\n  // @param _repayAmount The amount that was repayed\\n  event RepayUSDA(uint256 _vaultId, address _vaultAddress, uint256 _repayAmount);\\n\\n  // @notice Emited when someone successfully liquidates a vault\\n  // @param _vaultId The id of the vault that was liquidated\\n  // @param _assetAddress The address of the token that was liquidated\\n  // @param _usdaToRepurchase The amount of USDA that was repurchased\\n  // @param _tokensToLiquidate The number of tokens that were taken from the vault and sent to the liquidator\\n  // @param _liquidationFee The number of tokens that were taken from the fee and sent to the treasury\\n  event Liquidate(\\n    uint256 _vaultId,\\n    address _assetAddress,\\n    uint256 _usdaToRepurchase,\\n    uint256 _tokensToLiquidate,\\n    uint256 _liquidationFee\\n  );\\n\\n  // @notice Emited when governance changes the claimer contract\\n  //  @param _oldClaimerContract The old claimer contract\\n  //  @param _newClaimerContract The new claimer contract\\n  event ChangedClaimerContract(IAMPHClaimer _oldClaimerContract, IAMPHClaimer _newClaimerContract);\\n\\n  // @notice Emited when the owner registers the USDA contract\\n  // @param _usdaContractAddress The address of the USDA contract\\n  event RegisterUSDA(address _usdaContractAddress);\\n\\n  // @notice Emited when governance changes the initial borrowing fee\\n  //  @param _oldBorrowingFee The old borrowing fee\\n  //  @param _newBorrowingFee The new borrowing fee\\n  event ChangedInitialBorrowingFee(uint192 _oldBorrowingFee, uint192 _newBorrowingFee);\\n\\n  // @notice Emited when governance changes the liquidation fee\\n  //  @param _oldLiquidationFee The old liquidation fee\\n  //  @param _newLiquidationFee The new liquidation fee\\n  event ChangedLiquidationFee(uint192 _oldLiquidationFee, uint192 _newLiquidationFee);\\n\\n  // @notice Emited when collaterals are migrated from old vault controller\\n  //  @param _oldVaultController The old vault controller migrated from\\n  //  @param _tokenAddresses The list of new collaterals\\n  event CollateralsMigratedFrom(IVaultController _oldVaultController, address[] _tokenAddresses);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Thrown when token has invalid amount of decimals\\n  error VaultController_TooManyDecimals();\\n\\n  /// @notice Thrown when _msgSender is not the pauser of the contract\\n  error VaultController_OnlyPauser();\\n\\n  /// @notice Thrown when the fee is too large\\n  error VaultController_FeeTooLarge();\\n\\n  /// @notice Thrown when oracle does not exist\\n  error VaultController_OracleNotRegistered();\\n\\n  /// @notice Thrown when the token is already registered\\n  error VaultController_TokenAlreadyRegistered();\\n\\n  /// @notice Thrown when the token is not registered\\n  error VaultController_TokenNotRegistered();\\n\\n  /// @notice Thrown when the _ltv is incompatible\\n  error VaultController_LTVIncompatible();\\n\\n  /// @notice Thrown when _msgSender is not the minter\\n  error VaultController_OnlyMinter();\\n\\n  /// @notice Thrown when vault is insolvent\\n  error VaultController_VaultInsolvent();\\n\\n  /// @notice Thrown when repay is grater than borrow\\n  error VaultController_RepayTooMuch();\\n\\n  /// @notice Thrown when trying to liquidate 0 tokens\\n  error VaultController_LiquidateZeroTokens();\\n\\n  /// @notice Thrown when trying to liquidate more than is possible\\n  error VaultController_OverLiquidation();\\n\\n  /// @notice Thrown when vault is solvent\\n  error VaultController_VaultSolvent();\\n\\n  /// @notice Thrown when vault does not exist\\n  error VaultController_VaultDoesNotExist();\\n\\n  /// @notice Thrown when migrating collaterals to a new vault controller\\n  error VaultController_WrongCollateralAddress();\\n\\n  /// @notice Thrown when a not valid vault is trying to modify the total deposited\\n  error VaultController_NotValidVault();\\n\\n  /// @notice Thrown when a deposit surpass the cap\\n  error VaultController_CapReached();\\n\\n  /// @notice Thrown when registering a crv lp token with wrong address\\n  error VaultController_TokenAddressDoesNotMatchLpAddress();\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            ENUMS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  enum CollateralType {\\n    Single,\\n    CurveLPStakedOnConvex\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            STRUCTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  struct VaultSummary {\\n    uint96 id;\\n    uint192 borrowingPower;\\n    uint192 vaultLiability;\\n    address[] tokenAddresses;\\n    uint256[] tokenBalances;\\n  }\\n\\n  struct Interest {\\n    uint64 lastTime;\\n    uint192 factor;\\n  }\\n\\n  struct CollateralInfo {\\n    uint256 tokenId;\\n    uint256 ltv;\\n    uint256 cap;\\n    uint256 totalDeposited;\\n    uint256 liquidationIncentive;\\n    IOracleRelay oracle;\\n    CollateralType collateralType;\\n    IBaseRewardPool crvRewardsContract;\\n    uint256 poolId;\\n    uint256 decimals;\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Total number of tokens registered\\n  function tokensRegistered() external view returns (uint256 _tokensRegistered);\\n\\n  /// @notice Total number of minted vaults\\n  function vaultsMinted() external view returns (uint96 _vaultsMinted);\\n\\n  /// @notice Returns the block timestamp when pay interest was last called\\n  /// @return _lastInterestTime The block timestamp when pay interest was last called\\n  function lastInterestTime() external view returns (uint64 _lastInterestTime);\\n\\n  /// @notice Total base liability\\n  function totalBaseLiability() external view returns (uint192 _totalBaseLiability);\\n\\n  /// @notice Returns the latest interest factor\\n  /// @return _interestFactor The latest interest factor\\n  function interestFactor() external view returns (uint192 _interestFactor);\\n\\n  /// @notice The protocol's fee\\n  function protocolFee() external view returns (uint192 _protocolFee);\\n\\n  /// @notice The max allowed to be set as borrowing fee\\n  function MAX_INIT_BORROWING_FEE() external view returns (uint192 _maxInitBorrowingFee);\\n\\n  /// @notice The initial borrowing fee (1e18 == 100%)\\n  function initialBorrowingFee() external view returns (uint192 _initialBorrowingFee);\\n\\n  /// @notice The fee taken from the liquidator profit (1e18 == 100%)\\n  function liquidationFee() external view returns (uint192 _liquidationFee);\\n\\n  /// @notice Returns an array of all the vault ids a specific wallet has\\n  /// @param _wallet The address of the wallet to target\\n  /// @return _vaultIDs The ids of the vaults the wallet has\\n  function vaultIDs(address _wallet) external view returns (uint96[] memory _vaultIDs);\\n\\n  /// @notice Returns an array of all enabled tokens\\n  /// @return _enabledToken The array containing the token addresses\\n  function enabledTokens(uint256 _index) external view returns (address _enabledToken);\\n\\n  /// @notice Returns the address of the curve master\\n  function curveMaster() external view returns (CurveMaster _curveMaster);\\n\\n  /// @notice Returns the token id given a token's address\\n  /// @param _tokenAddress The address of the token to target\\n  /// @return _tokenId The id of the token\\n  function tokenId(address _tokenAddress) external view returns (uint256 _tokenId);\\n\\n  /// @notice Returns the oracle given a token's address\\n  /// @param _tokenAddress The id of the token\\n  /// @return _oracle The address of the token's oracle\\n  function tokensOracle(address _tokenAddress) external view returns (IOracleRelay _oracle);\\n\\n  /// @notice Returns the ltv of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _ltv The loan-to-value of a token\\n  function tokenLTV(address _tokenAddress) external view returns (uint256 _ltv);\\n\\n  /// @notice Returns the liquidation incentive of an accepted token collateral\\n  /// @param _tokenAddress The address of the token\\n  /// @return _liquidationIncentive The liquidation incentive of the token\\n  function tokenLiquidationIncentive(address _tokenAddress) external view returns (uint256 _liquidationIncentive);\\n\\n  /// @notice Returns the cap of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _cap The cap of the token\\n  function tokenCap(address _tokenAddress) external view returns (uint256 _cap);\\n\\n  /// @notice Returns the total deposited of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _totalDeposited The total deposited of a token\\n  function tokenTotalDeposited(address _tokenAddress) external view returns (uint256 _totalDeposited);\\n\\n  /// @notice Returns the collateral type of a token\\n  /// @param _tokenAddress The address of the token\\n  /// @return _type The collateral type of a token\\n  function tokenCollateralType(address _tokenAddress) external view returns (CollateralType _type);\\n\\n  /// @notice Returns the address of the crvRewards contract\\n  /// @param _tokenAddress The address of the token\\n  /// @return _crvRewardsContract The address of the crvRewards contract\\n  function tokenCrvRewardsContract(address _tokenAddress) external view returns (IBaseRewardPool _crvRewardsContract);\\n\\n  /// @notice Returns the pool id of a curve LP type token\\n  /// @dev    If the token is not of type CurveLPStakedOnConvex then it returns 0\\n  /// @param _tokenAddress The address of the token\\n  /// @return _poolId The pool id of a curve LP type token\\n  function tokenPoolId(address _tokenAddress) external view returns (uint256 _poolId);\\n\\n  /// @notice Returns the collateral info of a given token address\\n  /// @param _tokenAddress The address of the token\\n  /// @return _collateralInfo The complete collateral info of the token\\n  function tokenCollateralInfo(address _tokenAddress) external view returns (CollateralInfo memory _collateralInfo);\\n\\n  /// @notice The convex booster interface\\n  function BOOSTER() external view returns (IBooster _booster);\\n\\n  /// @notice The amphora claimer interface\\n  function claimerContract() external view returns (IAMPHClaimer _claimerContract);\\n\\n  /// @notice The vault deployer interface\\n  function VAULT_DEPLOYER() external view returns (IVaultDeployer _vaultDeployer);\\n\\n  /// @notice The max decimals allowed for a listed token\\n  function MAX_DECIMALS() external view returns (uint8 _maxDecimals);\\n\\n  /// @notice Returns an array of all enabled tokens\\n  /// @return _enabledTokens The array containing the token addresses\\n  function getEnabledTokens() external view returns (address[] memory _enabledTokens);\\n\\n  /// @notice Returns the selected collaterals info. Will iterate from `_start` (included) until `_end` (not included)\\n  /// @param _start The start number to loop on the array\\n  /// @param _end The end number to loop on the array\\n  /// @return _collateralsInfo The array containing all the collateral info\\n  function getCollateralsInfo(\\n    uint256 _start,\\n    uint256 _end\\n  ) external view returns (CollateralInfo[] memory _collateralsInfo);\\n\\n  /// @notice Returns the address of a vault given it's id\\n  /// @param _vaultID The id of the vault to target\\n  /// @return _vaultAddress The address of the targetted vault\\n  function vaultIdVaultAddress(uint96 _vaultID) external view returns (address _vaultAddress);\\n\\n  /// @notice Returns true if a base reward contract was approved by governance\\n  /// @param _baseRewardContract The address of the baseRewardcontract to check\\n  /// @return _approved True if approved by governance\\n  function baseRewardContracts(address _baseRewardContract) external view returns (bool _approved);\\n\\n  /// @notice Mapping of token address to collateral info\\n  function tokenAddressCollateralInfo(address _token)\\n    external\\n    view\\n    returns (\\n      uint256 _tokenId,\\n      uint256 _ltv,\\n      uint256 _cap,\\n      uint256 _totalDeposited,\\n      uint256 _liquidationIncentive,\\n      IOracleRelay _oracle,\\n      CollateralType _collateralType,\\n      IBaseRewardPool _crvRewardsContract,\\n      uint256 _poolId,\\n      uint256 _decimals\\n    );\\n\\n  /// @notice The interest contract\\n  function interest() external view returns (uint64 _lastTime, uint192 _factor);\\n\\n  /// @notice The usda interface\\n  function usda() external view returns (IUSDA _usda);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Returns the amount of USDA needed to reach even solvency without state changes\\n  /// @dev This amount is a moving target and changes with each block as payInterest is called\\n  /// @param _id The id of vault we want to target\\n  /// @return _usdaToSolvency The amount of USDA needed to reach even solvency\\n  function amountToSolvency(uint96 _id) external view returns (uint256 _usdaToSolvency);\\n\\n  /// @notice Returns vault liability of vault\\n  /// @param _id The id of vault\\n  /// @return _liability The amount of USDA the vault owes\\n  function vaultLiability(uint96 _id) external view returns (uint192 _liability);\\n\\n  /// @notice Returns the vault borrowing power for vault\\n  /// @dev Implementation in getVaultBorrowingPower\\n  /// @param _id The id of vault we want to target\\n  /// @return _borrowPower The amount of USDA the vault can borrow\\n  function vaultBorrowingPower(uint96 _id) external view returns (uint192 _borrowPower);\\n\\n  /// @notice Returns the calculated amount of tokens to liquidate for a vault\\n  /// @dev The amount of tokens owed is a moving target and changes with each block as payInterest is called\\n  ///      This function can serve to give an indication of how many tokens can be liquidated\\n  ///      All this function does is call _liquidationMath with 2**256-1 as the amount\\n  /// @param _id The id of vault we want to target\\n  /// @param _token The address of token to calculate how many tokens to liquidate\\n  /// @return _tokensToLiquidate The amount of tokens liquidatable\\n  function tokensToLiquidate(uint96 _id, address _token) external view returns (uint256 _tokensToLiquidate);\\n\\n  /// @notice Check a vault for over-collateralization\\n  /// @dev This function calls peekVaultBorrowingPower so no state change is done\\n  /// @param _id The id of vault we want to target\\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\\n  function peekCheckVault(uint96 _id) external view returns (bool _overCollateralized);\\n\\n  /// @notice Check a vault for over-collateralization\\n  /// @dev This function calls getVaultBorrowingPower to allow state changes to happen if an oracle need them\\n  /// @param _id The id of vault we want to target\\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\\n  function checkVault(uint96 _id) external returns (bool _overCollateralized);\\n\\n  /// @notice Returns the status of a range of vaults\\n  /// @dev Special view only function to help liquidators\\n  /// @param _start The id of the vault to start looping\\n  /// @param _stop The id of vault to stop looping\\n  /// @return _vaultSummaries An array of vault information\\n  function vaultSummaries(uint96 _start, uint96 _stop) external view returns (VaultSummary[] memory _vaultSummaries);\\n\\n  /// @notice Returns the initial borrowing fee\\n  /// @param _amount The base amount\\n  /// @return _fee The fee calculated based on a base amount\\n  function getBorrowingFee(uint192 _amount) external view returns (uint192 _fee);\\n\\n  /// @notice Returns the liquidation fee\\n  /// @param _tokensToLiquidate The collateral amount\\n  /// @param _assetAddress The collateral address to liquidate\\n  /// @return _fee The fee calculated based on amount\\n  function getLiquidationFee(uint192 _tokensToLiquidate, address _assetAddress) external view returns (uint192 _fee);\\n\\n  /// @notice Returns the increase amount of the interest factor. Accrues interest to borrowers and distribute it to USDA holders\\n  /// @dev Implementation in payInterest\\n  /// @return _interest The increase amount of the interest factor\\n  function calculateInterest() external returns (uint256 _interest);\\n\\n  /// @notice Creates a new vault and returns it's address\\n  /// @return _vaultAddress The address of the newly created vault\\n  function mintVault() external returns (address _vaultAddress);\\n\\n  /// @notice Simulates the liquidation of an underwater vault\\n  /// @param _id The id of vault we want to target\\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\\n  /// @param _tokensToLiquidate The number of tokens to liquidate\\n  /// @return _collateralLiquidated The number of collateral tokens the liquidator will receive\\n  /// @return _usdaPaid The amount of USDA the liquidator will have to pay\\n  function simulateLiquidateVault(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) external view returns (uint256 _collateralLiquidated, uint256 _usdaPaid);\\n\\n  /// @notice Liquidates an underwater vault\\n  /// @dev Pays interest before liquidation. Vaults may be liquidated up to the point where they are exactly solvent\\n  /// @param _id The id of vault we want to target\\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\\n  /// @param _tokensToLiquidate The number of tokens to liquidate\\n  /// @return _toLiquidate The number of tokens that got liquidated\\n  function liquidateVault(\\n    uint96 _id,\\n    address _assetAddress,\\n    uint256 _tokensToLiquidate\\n  ) external returns (uint256 _toLiquidate);\\n\\n  /// @notice Borrows USDA from a vault. Only the vault minter may borrow from their vault\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to borrow\\n  function borrowUSDA(uint96 _id, uint192 _amount) external;\\n\\n  /// @notice Borrows USDA from a vault and send the USDA to a specific address\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to borrow\\n  /// @param _target The address to receive borrowed USDA\\n  function borrowUSDAto(uint96 _id, uint192 _amount, address _target) external;\\n\\n  /// @notice Borrows sUSD directly from reserve, liability is still in USDA, and USDA must be repaid\\n  /// @param _id The id of vault we want to target\\n  /// @param _susdAmount The amount of sUSD to borrow\\n  /// @param _target The address to receive borrowed sUSD\\n  function borrowsUSDto(uint96 _id, uint192 _susdAmount, address _target) external;\\n\\n  /// @notice Repays a vault's USDA loan. Anyone may repay\\n  /// @dev Pays interest\\n  /// @param _id The id of vault we want to target\\n  /// @param _amount The amount of USDA to repay\\n  function repayUSDA(uint96 _id, uint192 _amount) external;\\n\\n  /// @notice Repays all of a vault's USDA. Anyone may repay a vault's liabilities\\n  /// @dev Pays interest\\n  /// @param _id The id of vault we want to target\\n  function repayAllUSDA(uint96 _id) external;\\n\\n  /// @notice External function used by vaults to increase or decrease the `totalDeposited`.\\n  /// @dev Should only be called by a valid vault\\n  /// @param _vaultID The id of vault which is calling (used to verify)\\n  /// @param _amount The amount to modify\\n  /// @param _token The token address which should modify the total\\n  /// @param _increase Boolean that indicates if should increase or decrease (TRUE -> increase, FALSE -> decrease)\\n  function modifyTotalDeposited(uint96 _vaultID, uint256 _amount, address _token, bool _increase) external;\\n\\n  /// @notice Pauses the functionality of the contract\\n  function pause() external;\\n\\n  /// @notice Unpauses the functionality of the contract\\n  function unpause() external;\\n\\n  /// @notice Emited when the owner registers a curve master\\n  /// @param _masterCurveAddress The address of the curve master\\n  function registerCurveMaster(address _masterCurveAddress) external;\\n\\n  /// @notice Updates the protocol fee\\n  /// @param _newProtocolFee The new protocol fee in terms of 1e18=100%\\n  function changeProtocolFee(uint192 _newProtocolFee) external;\\n\\n  /// @notice Register a new token to be used as collateral\\n  /// @param _tokenAddress The address of the token to register\\n  /// @param _ltv The ltv of the token, 1e18=100%\\n  /// @param _oracleAddress The address of oracle to fetch the price of the token\\n  /// @param _liquidationIncentive The liquidation penalty for the token, 1e18=100%\\n  /// @param _cap The maximum amount to be deposited\\n  function registerErc20(\\n    address _tokenAddress,\\n    uint256 _ltv,\\n    address _oracleAddress,\\n    uint256 _liquidationIncentive,\\n    uint256 _cap,\\n    uint256 _poolId\\n  ) external;\\n\\n  /// @notice Registers the USDA contract\\n  /// @param _usdaAddress The address to register as USDA\\n  function registerUSDA(address _usdaAddress) external;\\n\\n  /// @notice Updates an existing collateral with new collateral parameters\\n  /// @param _tokenAddress The address of the token to modify\\n  /// @param _ltv The new loan-to-value of the token, 1e18=100%\\n  /// @param _oracleAddress The address of oracle to modify for the price of the token\\n  /// @param _liquidationIncentive The new liquidation penalty for the token, 1e18=100%\\n  /// @param _cap The maximum amount to be deposited\\n  /// @param _poolId The convex pool id of a crv lp token\\n  function updateRegisteredErc20(\\n    address _tokenAddress,\\n    uint256 _ltv,\\n    address _oracleAddress,\\n    uint256 _liquidationIncentive,\\n    uint256 _cap,\\n    uint256 _poolId\\n  ) external;\\n\\n  /// @notice Change the claimer contract, used to exchange a fee from curve lp rewards for AMPH tokens\\n  /// @param _newClaimerContract The new claimer contract\\n  function changeClaimerContract(IAMPHClaimer _newClaimerContract) external;\\n\\n  /// @notice Change the initial borrowing fee\\n  /// @param _newBorrowingFee The new borrowing fee\\n  function changeInitialBorrowingFee(uint192 _newBorrowingFee) external;\\n\\n  /// @notice Change the liquidation fee\\n  /// @param _newLiquidationFee The new liquidation fee\\n  function changeLiquidationFee(uint192 _newLiquidationFee) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/periphery/IOracleRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title OracleRelay Interface\\n/// @notice Interface for interacting with OracleRelay\\ninterface IOracleRelay {\\n  /// @notice Emited when the underlyings are different in the anchored view\\n  error OracleRelay_DifferentUnderlyings();\\n\\n  enum OracleType {\\n    Chainlink,\\n    Uniswap,\\n    Price\\n  }\\n\\n  /// @notice returns the price with 18 decimals\\n  /// @return _currentValue the current price\\n  function currentValue() external returns (uint256 _currentValue);\\n\\n  /// @notice returns the price with 18 decimals without any state changes\\n  /// @dev some oracles require a state change to get the exact current price.\\n  ///      This is updated when calling other state changing functions that query the price\\n  /// @return _price the current price\\n  function peekValue() external view returns (uint256 _price);\\n\\n  /// @notice returns the type of the oracle\\n  /// @return _type the type (Chainlink/Uniswap/Price)\\n  function oracleType() external view returns (OracleType _type);\\n\\n  /// @notice returns the underlying asset the oracle is pricing\\n  /// @return _underlying the address of the underlying asset\\n  function underlying() external view returns (address _underlying);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/IBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IBooster {\\n  function owner() external view returns (address _owner);\\n  function setVoteDelegate(address _voteDelegate) external;\\n  function vote(uint256 _voteId, address _votingAddress, bool _support) external returns (bool _success);\\n  function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight) external returns (bool _success);\\n  function poolInfo(uint256 _pid)\\n    external\\n    view\\n    returns (address _lptoken, address _token, address _gauge, address _cprvRewards, address _stash, bool _shutdown);\\n  function earmarkRewards(uint256 _pid) external returns (bool _claimed);\\n  function earmarkFees() external returns (bool _claimed);\\n  function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool _success);\\n  function isShutdown() external view returns (bool _isShutdown);\\n  function shutdownSystem() external;\\n  function poolManager() external returns (address _poolManager);\\n  function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns (bool _success);\\n  function poolLength() external returns (uint256 _poolLength);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/IBaseRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IVirtualBalanceRewardPool} from '@interfaces/utils/IVirtualBalanceRewardPool.sol';\\n\\ninterface IBaseRewardPool {\\n  function stake(uint256 _amount) external returns (bool _staked);\\n  function stakeFor(address _for, uint256 _amount) external returns (bool _staked);\\n  function withdraw(uint256 _amount, bool _claim) external returns (bool _success);\\n  function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns (bool _success);\\n  function getReward(address _account, bool _claimExtras) external returns (bool _success);\\n  function rewardToken() external view returns (IERC20 _rewardToken);\\n  function earned(address _ad) external view returns (uint256 _reward);\\n  function extraRewardsLength() external view returns (uint256 _extraRewardsLength);\\n  function extraRewards(uint256 _position) external view returns (IVirtualBalanceRewardPool _virtualReward);\\n  function queueNewRewards(uint256 _rewards) external returns (bool _success);\\n  function operator() external view returns (address _operator);\\n  function stakingToken() external view returns (address _stakingToken);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/core/IAMPHClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\\n\\n/// @title AMPHClaimer Interface\\ninterface IAMPHClaimer {\\n  /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Emited when a vault claims AMPH\\n  // @param _vaultClaimer The address of the vault that claimed\\n  // @param _cvxTotalRewards The amount of CVX sent in exchange of AMPH\\n  // @param _crvTotalRewards The amount of CRV sent in exchange of AMPH\\n  // @param _amphAmount The amount of AMPH received\\n\\n  event ClaimedAmph(\\n    address indexed _vaultClaimer, uint256 _cvxTotalRewards, uint256 _crvTotalRewards, uint256 _amphAmount\\n  );\\n\\n  // @notice Emited when governance changes the vault controller\\n  // @param _newVaultController The address of the new vault controller\\n\\n  event ChangedVaultController(address indexed _newVaultController);\\n\\n  // @notice Emited when governance recovers a token from the contract\\n  // @param _token the token recovered\\n  // @param _receiver the receiver of the tokens\\n  // @param _amount the amount recovered\\n\\n  event RecoveredDust(address indexed _token, address _receiver, uint256 _amount);\\n\\n  // @notice Emited when governance changes the CVX reward fee\\n  // @param _newCvxReward the new fee\\n\\n  event ChangedCvxRewardFee(uint256 _newCvxReward);\\n\\n  // @notice Emited when governance changes the CRV reward fee\\n  // @param _newCrvReward the new fee\\n\\n  event ChangedCrvRewardFee(uint256 _newCrvReward);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice The address of the CVX token\\n  function CVX() external view returns (IERC20 _cvx);\\n\\n  /// @notice The address of the CRV token\\n  function CRV() external view returns (IERC20 _crv);\\n\\n  /// @notice The address of the AMPH token\\n  function AMPH() external view returns (IERC20 _amph);\\n\\n  /// @notice The base supply of AMPH per cliff, denominated in 1e6\\n  function BASE_SUPPLY_PER_CLIFF() external view returns (uint256 _baseSupplyPerCliff);\\n\\n  /// @notice The total amount of AMPH minted for rewards in CRV, denominated in 1e6\\n  function distributedAmph() external view returns (uint256 _distributedAmph);\\n\\n  /// @notice The total number of cliffs (for both tokens)\\n  function TOTAL_CLIFFS() external view returns (uint256 _totalCliffs);\\n\\n  /// @notice Percentage of rewards taken in CVX (1e18 == 100%)\\n  function cvxRewardFee() external view returns (uint256 _cvxRewardFee);\\n\\n  /// @notice Percentage of rewards taken in CRV (1e18 == 100%)\\n  function crvRewardFee() external view returns (uint256 _crvRewardFee);\\n\\n  /// @notice The vault controller\\n  function vaultController() external view returns (IVaultController _vaultController);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Claims an amount of AMPH given a CVX and CRV quantity\\n  /// @param _vaultId The vault id that is claiming\\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\\n  /// @param _beneficiary The receiver of the AMPH rewards\\n  /// @return _cvxAmountToSend The amount of CVX that the treasury got\\n  /// @return _crvAmountToSend The amount of CRV that the treasury got\\n  /// @return _claimedAmph The amount of AMPH received by the beneficiary\\n  function claimAmph(\\n    uint96 _vaultId,\\n    uint256 _cvxTotalRewards,\\n    uint256 _crvTotalRewards,\\n    address _beneficiary\\n  ) external returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimedAmph);\\n\\n  /// @notice Returns the claimable amount of AMPH given a CVX and CRV quantity\\n  /// @param _sender The address of the account claiming\\n  /// @param _vaultId The vault id that is claiming\\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\\n  /// @return _cvxAmountToSend The amount of CVX the user will have to send\\n  /// @return _crvAmountToSend The amount of CRV the user will have to send\\n  /// @return _claimableAmph The amount of AMPH that would be received by the beneficiary\\n  function claimable(\\n    address _sender,\\n    uint96 _vaultId,\\n    uint256 _cvxTotalRewards,\\n    uint256 _crvTotalRewards\\n  ) external view returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph);\\n\\n  /// @notice Used by governance to change the vault controller\\n  /// @param _newVaultController The new vault controller\\n  function changeVaultController(address _newVaultController) external;\\n\\n  /// @notice Used by governance to recover tokens from the contract\\n  /// @param _token The token to recover\\n  /// @param _amount The amount to recover\\n  function recoverDust(address _token, uint256 _amount) external;\\n\\n  /// @notice Used by governance to change the fee taken from the CVX reward\\n  /// @param _newFee The new reward fee\\n  function changeCvxRewardFee(uint256 _newFee) external;\\n\\n  /// @notice Used by governance to change the fee taken from the CRV reward\\n  /// @param _newFee The new reward fee\\n  function changeCrvRewardFee(uint256 _newFee) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/core/IVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport {IVault} from '@interfaces/core/IVault.sol';\\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n// @notice Deployer of Vaults\\n// @dev    This contract is needed to reduce the size of the VaultController contract\\ninterface IVaultDeployer {\\n  /*///////////////////////////////////////////////////////////////\\n                              ERRORS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Thrown when someone other than the vault controller tries to call the method\\n  error VaultDeployer_OnlyVaultController();\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              VARIABLES\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice The address of the CVX token\\n  /// @return _cvx The address of the CVX token\\n  function CVX() external view returns (IERC20 _cvx);\\n\\n  /// @notice The address of the CRV token\\n  /// @return _crv The address of the CRV token\\n  function CRV() external view returns (IERC20 _crv);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              LOGIC\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Deploys a new Vault\\n  /// @param _id The id of the vault\\n  /// @param _minter The address of the minter of the vault\\n  /// @return _vault The vault that was created\\n  function deployVault(uint96 _id, address _minter) external returns (IVault _vault);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/periphery/ICurveMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title CurveMaster Interface\\n/// @notice Interface for interacting with CurveMaster\\ninterface ICurveMaster {\\n  /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Emited when the owner changes the vault controller address\\n  // @param _oldVaultControllerAddress The old address of the vault controller\\n  // @param _newVaultControllerAddress The new address of the vault controller\\n  event VaultControllerSet(address _oldVaultControllerAddress, address _newVaultControllerAddress);\\n\\n  // @notice Emited when the owner changes the curve address\\n  // @param _oldCurveAddress The old address of the curve\\n  // @param _token The token to set\\n  // @param _newCurveAddress The new address of the curve\\n  event CurveSet(address _oldCurveAddress, address _token, address _newCurveAddress);\\n\\n  // @notice Emited when the owner changes the curve address skipping the checks\\n  // @param _oldCurveAddress The old address of the curve\\n  // @param _token The token to set\\n  // @param _newCurveAddress The new address of the curve\\n  event CurveForceSet(address _oldCurveAddress, address _token, address _newCurveAddress);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Thrown when the token is not enabled\\n  error CurveMaster_TokenNotEnabled();\\n\\n  /// @notice Thrown when result is zero\\n  error CurveMaster_ZeroResult();\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice The vault controller address\\n  function vaultControllerAddress() external view returns (address _vaultController);\\n\\n  /// @notice Returns the value of curve labled _tokenAddress at _xValue\\n  /// @param _tokenAddress The key to lookup the curve with in the mapping\\n  /// @param _xValue The x value to pass to the slave\\n  /// @return _value The y value of the curve\\n  function getValueAt(address _tokenAddress, int256 _xValue) external view returns (int256 _value);\\n\\n  /// @notice Mapping of token to address\\n  function curves(address _tokenAddress) external view returns (address _curve);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                            LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Set the VaultController addr in order to pay interest on curve setting\\n  /// @param _vaultMasterAddress The address of vault master\\n  function setVaultController(address _vaultMasterAddress) external;\\n\\n  /// @notice Setting a new curve should pay interest\\n  /// @param _tokenAddress The address of the token\\n  /// @param _curveAddress The address of the curve for the contract\\n  function setCurve(address _tokenAddress, address _curveAddress) external;\\n\\n  /// @notice Special function that does not calculate interest, used for deployment\\n  /// @param _tokenAddress The address of the token\\n  /// @param _curveAddress The address of the curve for the contract\\n  function forceSetCurve(address _tokenAddress, address _curveAddress) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/ICurveSlave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title CurveSlave Interface\\n/// @notice Interface for interacting with CurveSlaves\\ninterface ICurveSlave {\\n  function valueAt(int256 _xValue) external view returns (int256 _value);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/IRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\\n\\n// @title Roles contract\\n//   @notice Manages the roles for interactions with a contract\\ninterface IRoles is IAccessControl {\\n  /*///////////////////////////////////////////////////////////////\\n                              ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  // @notice Thrown when the caller of the function is not an authorized role\\n  error Roles_Unauthorized(address _account, bytes32 _role);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/ICVX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n// @title The interface for the CVX token\\ninterface ICVX is IERC20 {\\n  function totalCliffs() external view returns (uint256 _totalCliffs);\\n  function reductionPerCliff() external view returns (uint256 _reduction);\\n  function maxSupply() external view returns (uint256 _maxSupply);\\n  function operator() external view returns (address _operator);\\n  function updateOperator() external;\\n  function vecrvProxy() external view returns (address _vecrvProxy);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/utils/IVirtualBalanceRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IVirtualBalanceRewardPool {\\n  function rewardToken() external view returns (IERC20 _rewardToken);\\n  function earned(address _ad) external view returns (uint256 _reward);\\n  function getReward() external;\\n  function queueNewRewards(uint256 _rewards) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"isolmate/=node_modules/@defi-wonderland/isolmate/src/\",\r\n      \"uni-v2-core/=node_modules/@uniswap/v2-core/contracts/\",\r\n      \"uni-v2-periphery/=node_modules/@uniswap/v2-periphery/contracts/\",\r\n      \"uni-v3-core/=node_modules/@uniswap/v3-core/contracts/\",\r\n      \"uni-v3-periphery/=node_modules/@uniswap/v3-periphery/contracts/\",\r\n      \"solidity-utils/=node_modules/@defi-wonderland/solidity-utils/solidity/\",\r\n      \"solady/=node_modules/solady/src/\",\r\n      \"@chainlink/=node_modules/@chainlink/contracts/src/v0.8/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@uniswap/v2-core/=node_modules/@uniswap/v2-core/\",\r\n      \"@uniswap/v2-periphery/=node_modules/@uniswap/v2-periphery/\",\r\n      \"@uniswap/v3-core/=node_modules/@uniswap/v3-core/\",\r\n      \"@uniswap/v3-periphery/=node_modules/@uniswap/v3-periphery/\",\r\n      \"@contracts/=solidity/contracts/\",\r\n      \"@interfaces/=solidity/interfaces/\",\r\n      \"@test/=solidity/test/\",\r\n      \"@scripts/=solidity/scripts/\",\r\n      \"@defi-wonderland/=node_modules/@defi-wonderland/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"base64-sol/=node_modules/base64-sol/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVaultController\",\"name\":\"_oldVaultController\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"contract IAMPHClaimer\",\"name\":\"_claimerContract\",\"type\":\"address\"},{\"internalType\":\"contract IVaultDeployer\",\"name\":\"_vaultDeployer\",\"type\":\"address\"},{\"internalType\":\"uint192\",\"name\":\"_initialBorrowingFee\",\"type\":\"uint192\"},{\"internalType\":\"address\",\"name\":\"_booster\",\"type\":\"address\"},{\"internalType\":\"uint192\",\"name\":\"_liquidationFee\",\"type\":\"uint192\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"VaultController_CapReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_LTVIncompatible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_LiquidateZeroTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_NotValidVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_OnlyMinter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_OnlyPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_OracleNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_OverLiquidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_RepayTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_TokenAddressDoesNotMatchLpAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_TokenAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_TokenNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_TooManyDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_VaultDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_VaultInsolvent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_VaultSolvent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultController_WrongCollateralAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"BorrowUSDA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IAMPHClaimer\",\"name\":\"_oldClaimerContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IAMPHClaimer\",\"name\":\"_newClaimerContract\",\"type\":\"address\"}],\"name\":\"ChangedClaimerContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_oldBorrowingFee\",\"type\":\"uint192\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_newBorrowingFee\",\"type\":\"uint192\"}],\"name\":\"ChangedInitialBorrowingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_oldLiquidationFee\",\"type\":\"uint192\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_newLiquidationFee\",\"type\":\"uint192\"}],\"name\":\"ChangedLiquidationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IVaultController\",\"name\":\"_oldVaultController\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"CollateralsMigratedFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_epoch\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_amount\",\"type\":\"uint192\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_curveVal\",\"type\":\"uint256\"}],\"name\":\"InterestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_usdaToRepurchase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokensToLiquidate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidationFee\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"_protocolFee\",\"type\":\"uint192\"}],\"name\":\"NewProtocolFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vaultOwner\",\"type\":\"address\"}],\"name\":\"NewVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_curveMasterAddress\",\"type\":\"address\"}],\"name\":\"RegisterCurveMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_usdaContractAddress\",\"type\":\"address\"}],\"name\":\"RegisterUSDA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"RegisteredErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"}],\"name\":\"RepayUSDA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"UpdateRegisteredErc20\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOOSTER\",\"outputs\":[{\"internalType\":\"contract IBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOUBLE_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXP_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HALF_EXP_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANTISSA_ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INIT_BORROWING_FEE\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UINT128_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UINT192_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_DEPLOYER\",\"outputs\":[{\"internalType\":\"contract IVaultDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"amountToSolvency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdaToSolvency\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseRewardContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"uint192\",\"name\":\"_amount\",\"type\":\"uint192\"}],\"name\":\"borrowUSDA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"uint192\",\"name\":\"_amount\",\"type\":\"uint192\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"borrowUSDAto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"uint192\",\"name\":\"_susdAmount\",\"type\":\"uint192\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"borrowsUSDto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_interest\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAMPHClaimer\",\"name\":\"_newClaimerContract\",\"type\":\"address\"}],\"name\":\"changeClaimerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_newBorrowingFee\",\"type\":\"uint192\"}],\"name\":\"changeInitialBorrowingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_newLiquidationFee\",\"type\":\"uint192\"}],\"name\":\"changeLiquidationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_newProtocolFee\",\"type\":\"uint192\"}],\"name\":\"changeProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"checkVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_overCollateralized\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimerContract\",\"outputs\":[{\"internalType\":\"contract IAMPHClaimer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveMaster\",\"outputs\":[{\"internalType\":\"contract CurveMaster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enabledTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_amount\",\"type\":\"uint192\"}],\"name\":\"getBorrowingFee\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"_fee\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getCollateralsInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"contract IOracleRelay\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum IVaultController.CollateralType\",\"name\":\"collateralType\",\"type\":\"uint8\"},{\"internalType\":\"contract IBaseRewardPool\",\"name\":\"crvRewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct IVaultController.CollateralInfo[]\",\"name\":\"_collateralsInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEnabledTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_enabledTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_tokensToLiquidate\",\"type\":\"uint192\"},{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"getLiquidationFee\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"_fee\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBorrowingFee\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"lastTime\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"factor\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestFactor\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"_interestFactor\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastInterestTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"_lastInterestTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensToLiquidate\",\"type\":\"uint256\"}],\"name\":\"liquidateVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_toLiquidate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationFee\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_vaultID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_increase\",\"type\":\"bool\"}],\"name\":\"modifyTotalDeposited\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"peekCheckVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_overCollateralized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCurveAddress\",\"type\":\"address\"}],\"name\":\"registerCurveMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"registerErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdaAddress\",\"type\":\"address\"}],\"name\":\"registerUSDA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"repayAllUSDA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"uint192\",\"name\":\"_amount\",\"type\":\"uint192\"}],\"name\":\"repayUSDA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensToLiquidate\",\"type\":\"uint256\"}],\"name\":\"simulateLiquidateVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdaPaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAddressCollateralInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"contract IOracleRelay\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum IVaultController.CollateralType\",\"name\":\"collateralType\",\"type\":\"uint8\"},{\"internalType\":\"contract IBaseRewardPool\",\"name\":\"crvRewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenCollateralInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"contract IOracleRelay\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum IVaultController.CollateralType\",\"name\":\"collateralType\",\"type\":\"uint8\"},{\"internalType\":\"contract IBaseRewardPool\",\"name\":\"crvRewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct IVaultController.CollateralInfo\",\"name\":\"_collateralInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenCollateralType\",\"outputs\":[{\"internalType\":\"enum IVaultController.CollateralType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenCrvRewardsContract\",\"outputs\":[{\"internalType\":\"contract IBaseRewardPool\",\"name\":\"_crvRewardsContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenLTV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenLiquidationIncentive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDeposited\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokensOracle\",\"outputs\":[{\"internalType\":\"contract IOracleRelay\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensRegistered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"tokensToLiquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToLiquidate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBaseLiability\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"updateRegisteredErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usda\",\"outputs\":[{\"internalType\":\"contract IUSDA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"vaultBorrowingPower\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"_borrowPower\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"vaultIDs\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"_vaultIDs\",\"type\":\"uint96[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"name\":\"vaultIdVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"}],\"name\":\"vaultLiability\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"_liability\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_start\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_stop\",\"type\":\"uint96\"}],\"name\":\"vaultSummaries\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"},{\"internalType\":\"uint192\",\"name\":\"borrowingPower\",\"type\":\"uint192\"},{\"internalType\":\"uint192\",\"name\":\"vaultLiability\",\"type\":\"uint192\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IVaultController.VaultSummary[]\",\"name\":\"_vaultSummaries\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultsMinted\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletVaultIDs\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultController", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000008b66d70953ad233976812f4b5b92bbafeba90a7500000000000000000000000059cbd5670ce8d25a9450f8a2b4ce67aa58278526000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000f403c135812408bfbe8713b5a23a04b3d48aae310000000000000000000000000000000000000000000000000011c37937e080000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}