{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// @title DN404Mirror\r\n/// @notice DN404Mirror provides an interface for interacting with the\r\n/// NFT tokens in a DN404 implementation.\r\n///\r\n/// @author vectorized.eth (@optimizoor)\r\n/// @author Quit (@0xQuit)\r\n/// @author Michael Amadi (@AmadiMichaels)\r\n/// @author cygaar (@0xCygaar)\r\n/// @author Thomas (@0xjustadev)\r\n/// @author Harrison (@PopPunkOnChain)\r\n///\r\n/// @dev Note:\r\n/// - The ERC721 data is stored in the base DN404 contract.\r\ncontract DN404Mirror {\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                           EVENTS                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Thrown when a call for an NFT function did not originate\r\n    /// from the base DN404 contract.\r\n    error Unauthorized();\r\n\r\n    /// @dev Thrown when transferring an NFT to a contract address that\r\n    /// does not implement ERC721Receiver.\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /// @dev Thrown when linking to the DN404 base contract and the\r\n    /// DN404 supportsInterface check fails or the call reverts.\r\n    error CannotLink();\r\n\r\n    /// @dev Thrown when a linkMirrorContract call is received and the\r\n    /// NFT mirror contract has already been linked to a DN404 base contract.\r\n    error AlreadyLinked();\r\n\r\n    /// @dev Thrown when retrieving the rootERC20 address when a link has not\r\n    /// been established.\r\n    error NotLinked();\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                          STORAGE                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct contain the NFT mirror contract storage.\r\n    struct DN404NFTStorage {\r\n        address rootERC20;\r\n        address deployer;\r\n    }\r\n\r\n    /// @dev Returns a storage pointer for DN404NFTStorage.\r\n    function _getDN404NFTStorage() internal pure returns (DN404NFTStorage storage $) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // keccak256(abi.encode(uint256(keccak256(\"dn404.nft\")) - 1)) & ~bytes32(uint256(0xff))\r\n            $.slot := 0xe8cb618a1de8ad2a6a7b358523c369cb09f40cc15da64205134c7e55c6a86700\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CONSTRUCTOR                         */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    constructor(address deployer) {\r\n        // For non-proxies, we will store the deployer so that only the deployer can\r\n        // link the root contract.\r\n        _getDN404NFTStorage().deployer = deployer;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     ERC721 OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the token collection name from the base DN404 contract.\r\n    function name() public view virtual returns (string memory result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            mstore(result, 0x06fdde03) // `name()`.\r\n            if iszero(staticcall(gas(), root, add(result, 0x1c), 0x04, 0x00, 0x00)) {\r\n                returndatacopy(result, 0x00, returndatasize())\r\n                revert(result, returndatasize())\r\n            }\r\n            returndatacopy(0x00, 0x00, 0x20)\r\n            returndatacopy(result, mload(0x00), 0x20)\r\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n            mstore(0x40, add(add(result, 0x20), mload(result)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the token collection symbol from the base DN404 contract.\r\n    function symbol() public view virtual returns (string memory result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            mstore(result, 0x95d89b41) // `symbol()`.\r\n            if iszero(staticcall(gas(), root, add(result, 0x1c), 0x04, 0x00, 0x00)) {\r\n                returndatacopy(result, 0x00, returndatasize())\r\n                revert(result, returndatasize())\r\n            }\r\n            returndatacopy(0x00, 0x00, 0x20)\r\n            returndatacopy(result, mload(0x00), 0x20)\r\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n            mstore(0x40, add(add(result, 0x20), mload(result)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from the base DN404 contract.\r\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            mstore(result, 0xc87b56dd) // `tokenURI()`.\r\n            mstore(add(result, 0x20), id)\r\n            if iszero(staticcall(gas(), root, add(result, 0x1c), 0x24, 0x00, 0x00)) {\r\n                returndatacopy(result, 0x00, returndatasize())\r\n                revert(result, returndatasize())\r\n            }\r\n            returndatacopy(0x00, 0x00, 0x20)\r\n            returndatacopy(result, mload(0x00), 0x20)\r\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\r\n            mstore(0x40, add(add(result, 0x20), mload(result)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the total NFT supply from the base DN404 contract.\r\n    function totalSupply() public view returns (uint256 result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), root, 0x1c, 0x04, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(mload(0x40), 0x00, returndatasize())\r\n                revert(mload(0x40), returndatasize())\r\n            }\r\n            result := mload(0x00)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - `owner` must not be the zero address.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\r\n            mstore(0x20, shr(96, shl(96, owner)))\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), root, 0x1c, 0x24, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(mload(0x40), 0x00, returndatasize())\r\n                revert(mload(0x40), returndatasize())\r\n            }\r\n            result := mload(0x00)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function ownerOf(uint256 id) public view virtual returns (address result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\r\n            mstore(0x20, id)\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), root, 0x1c, 0x24, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(mload(0x40), 0x00, returndatasize())\r\n                revert(mload(0x40), returndatasize())\r\n            }\r\n            result := shr(96, shl(96, mload(0x00)))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `spender` as the approved account to manage token `id` in the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    /// - The caller must be the owner of the token,\r\n    ///   or an approved operator for the token owner.\r\n    ///\r\n    /// Emits an {Approval} event.\r\n    function approve(address spender, uint256 id) public virtual {\r\n        address root = rootERC20();\r\n        address owner;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\r\n            mstore(0x20, shr(96, shl(96, spender)))\r\n            mstore(0x40, id)\r\n            mstore(0x60, caller())\r\n            if iszero(\r\n                and(\r\n                    gt(returndatasize(), 0x1f),\r\n                    call(gas(), root, callvalue(), 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n            owner := shr(96, shl(96, mload(0x00)))\r\n        }\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id` from the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function getApproved(uint256 id) public view virtual returns (address result) {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\r\n            mstore(0x20, id)\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), root, 0x1c, 0x24, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(mload(0x40), 0x00, returndatasize())\r\n                revert(mload(0x40), returndatasize())\r\n            }\r\n            result := shr(96, shl(96, mload(0x00)))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in the base DN404 contract.\r\n    ///\r\n    /// Emits an {ApprovalForAll} event.\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\r\n            mstore(0x20, shr(96, shl(96, operator)))\r\n            mstore(0x40, iszero(iszero(approved)))\r\n            mstore(0x60, caller())\r\n            if iszero(\r\n                and(\r\n                    and(eq(mload(0x00), 1), gt(returndatasize(), 0x1f)),\r\n                    call(gas(), root, callvalue(), 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from the base DN404 contract.\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool result)\r\n    {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(0x00, 0xe985e9c5) // `isApprovedForAll(address,address)`.\r\n            mstore(0x20, shr(96, shl(96, owner)))\r\n            mstore(0x40, shr(96, shl(96, operator)))\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), root, 0x1c, 0x44, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            result := iszero(iszero(mload(0x00)))\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 id) public virtual {\r\n        address root = rootERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\r\n            mstore(add(m, 0x20), shr(96, shl(96, from)))\r\n            mstore(add(m, 0x40), shr(96, shl(96, to)))\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), caller())\r\n            if iszero(\r\n                and(\r\n                    and(eq(mload(0x00), 1), gt(returndatasize(), 0x1f)),\r\n                    call(gas(), root, callvalue(), add(m, 0x1c), 0x84, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n        }\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\r\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\r\n        public\r\n        virtual\r\n    {\r\n        transferFrom(from, to, id);\r\n\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n    }\r\n\r\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-165\r\n    /// This function call must use less than 30000 gas.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let s := shr(224, interfaceId)\r\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\r\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\r\n    /// Reverts if the target does not support the function correctly.\r\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\r\n        private\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the calldata.\r\n            let m := mload(0x40)\r\n            let onERC721ReceivedSelector := 0x150b7a02\r\n            mstore(m, onERC721ReceivedSelector)\r\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\r\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), 0x80)\r\n            let n := mload(data)\r\n            mstore(add(m, 0xa0), n)\r\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\r\n            // Revert if the call reverts.\r\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\r\n                if returndatasize() {\r\n                    // Bubble up the revert if the call reverts.\r\n                    returndatacopy(m, 0x00, returndatasize())\r\n                    revert(m, returndatasize())\r\n                }\r\n            }\r\n            // Load the returndata and compare it.\r\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\r\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     MIRROR OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the address of the base DN404 contract.\r\n    function rootERC20() public view returns (address root) {\r\n        root = _getDN404NFTStorage().rootERC20;\r\n        if (root == address(0)) revert NotLinked();\r\n    }\r\n\r\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\r\n    modifier dn404NFTFallback() virtual {\r\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\r\n\r\n        uint256 fnSelector = _calldataload(0x00) >> 224;\r\n\r\n        // `logTransfer(uint256[])`.\r\n        if (fnSelector == 0x263c69d6) {\r\n            if (msg.sender != $.rootERC20) revert Unauthorized();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\r\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\r\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\r\n\r\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\r\n                    let d := calldataload(o) // Entry in the packed logs.\r\n                    let a := shr(96, d) // The address.\r\n                    let b := and(1, d) // Whether it is a burn.\r\n                    log4(\r\n                        codesize(),\r\n                        0x00,\r\n                        _TRANSFER_EVENT_SIGNATURE,\r\n                        mul(a, b),\r\n                        mul(a, iszero(b)),\r\n                        shr(168, shl(160, d))\r\n                    )\r\n                }\r\n                mstore(0x00, 0x01)\r\n                return(0x00, 0x20)\r\n            }\r\n        }\r\n        // `linkMirrorContract(address)`.\r\n        if (fnSelector == 0x0f4599e5) {\r\n            if ($.deployer != address(0)) {\r\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\r\n                    revert Unauthorized();\r\n                }\r\n            }\r\n            if ($.rootERC20 != address(0)) revert AlreadyLinked();\r\n            $.rootERC20 = msg.sender;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                mstore(0x00, 0x01)\r\n                return(0x00, 0x20)\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function for calls from base DN404 contract.\r\n    fallback() external payable virtual dn404NFTFallback {}\r\n\r\n    receive() external payable virtual {}\r\n\r\n    /// @dev Returns the calldata value at `offset`.\r\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            value := calldataload(offset)\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotLink\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"root\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DN404Mirror", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000baa168f8f58d656b1fe38c30b037777bca1c3094", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de6d43c7d0f6d9f4e4f8311547d3637d54f93fdbbbfdfd19a162672f6777093b"}