{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LCPoolUniV2Ledger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IFeeTierStrate.sol\\\";\\r\\n\\r\\nimport \\\"./utils/Ownable.sol\\\";\\r\\nimport \\\"./utils/Address.sol\\\";\\r\\nimport \\\"./utils/StringUtils.sol\\\";\\r\\n\\r\\ncontract LCPoolUniV2Ledger is Ownable {\\r\\n  address public v2MasterChef;\\r\\n  address public pool;\\r\\n  address public feeStrate;\\r\\n  string public pendingRewardsFunctionName;\\r\\n\\r\\n  uint256 private constant MULTIPLIER = 1_0000_0000_0000_0000;\\r\\n\\r\\n  struct RewardTVLRate {\\r\\n    uint256 reward;\\r\\n    uint256 prevReward;\\r\\n    uint256 tvl;\\r\\n    uint256 rtr;\\r\\n    uint256 reInvestIndex;\\r\\n    bool reInvested;\\r\\n    uint256 updatedAt;\\r\\n  }\\r\\n\\r\\n  struct ReinvestInfo {\\r\\n    uint256 reward;\\r\\n    uint256 liquidity;\\r\\n    uint256 updatedAt;\\r\\n  }\\r\\n\\r\\n  struct StakeInfo {\\r\\n    uint256 amount;   // Staked liquidity\\r\\n    uint256 debtReward;\\r\\n    uint256 rtrIndex; // RewardTVLRate index\\r\\n    uint256 updatedAt;\\r\\n  }\\r\\n\\r\\n  // account -> poolId -> basketId -> info basketid=0?lcpool\\r\\n  mapping (address => mapping (uint256 => mapping (uint256 => StakeInfo))) public userInfo;\\r\\n  // poolId => info\\r\\n  mapping (uint256 => RewardTVLRate[]) public poolInfoAll;\\r\\n  // poolId -> reinvest\\r\\n  mapping (uint256 => ReinvestInfo[]) public reInvestInfo;\\r\\n\\r\\n  mapping (address => bool) public managers;\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"LC pool ledger: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor (\\r\\n    address _v2MasterChef,\\r\\n    address _feeStrate,\\r\\n    string memory _pendingRewardsFunctionName\\r\\n  ) {\\r\\n    require(_v2MasterChef != address(0), \\\"LC pool ledger: master chef\\\");\\r\\n    require(_feeStrate != address(0), \\\"LC pool ledger: feeStrate\\\");\\r\\n\\r\\n    v2MasterChef = _v2MasterChef;\\r\\n    feeStrate = _feeStrate;\\r\\n    pendingRewardsFunctionName = _pendingRewardsFunctionName;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function getLastRewardAmount(uint256 poolId) public view returns(uint256) {\\r\\n    if (poolInfoAll[poolId].length > 0) {\\r\\n      return poolInfoAll[poolId][poolInfoAll[poolId].length-1].prevReward;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  function getUserLiquidity(address account, uint256 poolId, uint256 basketId) public view returns(uint256) {\\r\\n    return userInfo[account][poolId][basketId].amount;\\r\\n  }\\r\\n\\r\\n  function updateInfo(address acc, uint256 tId, uint256 bId, uint256 liquidity, uint256 reward, uint256 rewardAfter, uint256 exLp, bool increase) public onlyManager {\\r\\n    uint256[] memory ivar = new uint256[](6);\\r\\n    ivar[0] = 0;      // prevTvl\\r\\n    ivar[1] = 0;      // prevTotalReward\\r\\n    ivar[2] = reward; // blockReward\\r\\n    ivar[3] = 0;      // exUserLp\\r\\n    ivar[4] = 0;      // userReward\\r\\n    ivar[5] = 0;      // rtr\\r\\n    if (poolInfoAll[tId].length > 0) {\\r\\n      RewardTVLRate memory prevRTR = poolInfoAll[tId][poolInfoAll[tId].length-1];\\r\\n      ivar[0] = prevRTR.tvl;\\r\\n      ivar[1] = prevRTR.reward;\\r\\n      ivar[2] = (ivar[2] >= prevRTR.prevReward) ? (ivar[2] - prevRTR.prevReward) : 0;\\r\\n      ivar[5] = prevRTR.rtr;\\r\\n    }\\r\\n    ivar[5] += (ivar[0] > 0 ? ivar[2] * MULTIPLIER / ivar[0] : 0);\\r\\n    \\r\\n    (ivar[3], ivar[4]) = getSingleReward(acc, tId, bId, reward, false);\\r\\n\\r\\n    bool reInvested = false;\\r\\n    if (exLp > 0) {\\r\\n      ReinvestInfo memory tmp = ReinvestInfo({\\r\\n        reward: reward,\\r\\n        liquidity: exLp,\\r\\n        updatedAt: block.timestamp\\r\\n      });\\r\\n      reInvestInfo[tId].push(tmp);\\r\\n      reInvested = true;\\r\\n      ivar[3] += ivar[4] * exLp / reward;\\r\\n      ivar[0] += exLp;\\r\\n      userInfo[acc][tId][bId].amount += ivar[3];\\r\\n      ivar[4] = 0;\\r\\n    }\\r\\n\\r\\n    RewardTVLRate memory tmpRTR = RewardTVLRate({\\r\\n      reward: ivar[1] + ivar[2],\\r\\n      prevReward: rewardAfter,\\r\\n      tvl: increase ? ivar[0] + liquidity : (ivar[0] >= liquidity ? ivar[0] - liquidity : 0),\\r\\n      rtr: ivar[5],\\r\\n      reInvestIndex: reInvestInfo[tId].length,\\r\\n      reInvested: reInvested,\\r\\n      updatedAt: block.timestamp\\r\\n    });\\r\\n    poolInfoAll[tId].push(tmpRTR);\\r\\n    \\r\\n    if (increase) {\\r\\n      userInfo[acc][tId][bId].amount += liquidity;\\r\\n      userInfo[acc][tId][bId].debtReward = ivar[4];\\r\\n    }\\r\\n    else {\\r\\n      if (userInfo[acc][tId][bId].amount >= liquidity) {\\r\\n        userInfo[acc][tId][bId].amount -= liquidity;\\r\\n      }\\r\\n      else {\\r\\n        userInfo[acc][tId][bId].amount = 0;\\r\\n      }\\r\\n      userInfo[acc][tId][bId].debtReward = 0;\\r\\n    }\\r\\n    userInfo[acc][tId][bId].rtrIndex = poolInfoAll[tId].length - 1;\\r\\n    userInfo[acc][tId][bId].updatedAt = block.timestamp;\\r\\n  }\\r\\n\\r\\n  function getSingleReward(address acc, uint256 tId, uint256 bId, uint256 currentReward, bool cutfee) public view returns(uint256, uint256) {\\r\\n    uint256[] memory jvar = new uint256[](7);\\r\\n    jvar[0] = 0;  // extraLp\\r\\n    jvar[1] = userInfo[acc][tId][bId].debtReward; // reward\\r\\n    jvar[2] = userInfo[acc][tId][bId].amount;     // stake[j]\\r\\n    jvar[3] = 0; // reward for one stage\\r\\n\\r\\n    if (jvar[2] > 0) {\\r\\n      uint256 t0 = userInfo[acc][tId][bId].rtrIndex;\\r\\n      uint256 tn = poolInfoAll[tId].length;\\r\\n      uint256 index = t0;\\r\\n      while (index < tn) {\\r\\n        if (poolInfoAll[tId][index].rtr >= poolInfoAll[tId][t0].rtr) {\\r\\n          jvar[3] = (jvar[2] + jvar[0]) * (poolInfoAll[tId][index].rtr - poolInfoAll[tId][t0].rtr) / MULTIPLIER;\\r\\n        }\\r\\n        else {\\r\\n          jvar[3] = 0;\\r\\n        }\\r\\n        if (poolInfoAll[tId][index].reInvested) {\\r\\n          jvar[0] += jvar[3] * reInvestInfo[tId][poolInfoAll[tId][index].reInvestIndex-1].liquidity / reInvestInfo[tId][poolInfoAll[tId][index].reInvestIndex-1].reward;\\r\\n          t0 = index;\\r\\n          jvar[3] = 0;\\r\\n        }\\r\\n        index ++;\\r\\n      }\\r\\n      jvar[1] += jvar[3];\\r\\n\\r\\n      if (poolInfoAll[tId][tn-1].tvl > 0 && currentReward >= poolInfoAll[tId][tn-1].prevReward) {\\r\\n        jvar[1] = jvar[1] + (jvar[2] + jvar[0]) * (currentReward - poolInfoAll[tId][tn-1].prevReward) / poolInfoAll[tId][tn-1].tvl;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (cutfee == false) {\\r\\n      return (jvar[0], jvar[1]);\\r\\n    }\\r\\n\\r\\n    (jvar[4], jvar[5]) = IFeeTierStrate(feeStrate).getTotalFee(bId);\\r\\n    require(jvar[5] > 0, \\\"LC pool ledger: wrong fee configure\\\");\\r\\n    jvar[6] = jvar[1] * jvar[4] / jvar[5]; // rewardLc\\r\\n\\r\\n    if (jvar[6] > 0) {\\r\\n      uint256[] memory feeIndexs = IFeeTierStrate(feeStrate).getAllTier();\\r\\n      uint256 len = feeIndexs.length;\\r\\n      uint256 maxFee = IFeeTierStrate(feeStrate).getMaxFee();\\r\\n      for (uint256 i=0; i<len; i++) {\\r\\n        (, ,uint256 fee) = IFeeTierStrate(feeStrate).getTier(feeIndexs[i]);\\r\\n        uint256 feeAmount = jvar[6] * fee / maxFee;\\r\\n        if (feeAmount > 0 && jvar[1] >= feeAmount) {\\r\\n          jvar[1] -= feeAmount;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (jvar[0], jvar[1]);\\r\\n  }\\r\\n\\r\\n  function getReward(address account, uint256[] memory poolId, uint256[] memory basketIds) public view\\r\\n    returns(uint256[] memory, uint256[] memory)\\r\\n  {\\r\\n    uint256 bLen = basketIds.length;\\r\\n    uint256 len = poolId.length * bLen;\\r\\n    uint256[] memory extraLp = new uint256[](len);\\r\\n    uint256[] memory reward = new uint256[](len);\\r\\n    for (uint256 x = 0; x < poolId.length; x ++) {\\r\\n      uint256 currentReward = _rewardsAvailable(poolId[x]);\\r\\n      if (poolInfoAll[poolId[x]].length > 0) {\\r\\n        currentReward += poolInfoAll[poolId[x]][poolInfoAll[poolId[x]].length-1].prevReward;\\r\\n      }\\r\\n      for (uint256 y = 0; y < bLen; y ++) {\\r\\n        (extraLp[x*bLen + y], reward[x*bLen + y]) = getSingleReward(account, poolId[x], basketIds[y], currentReward, true);\\r\\n      }\\r\\n    }\\r\\n    return (extraLp, reward);\\r\\n  }\\r\\n\\r\\n  function _rewardsAvailable(uint256 poolId) internal view returns (uint256) {\\r\\n    string memory signature = StringUtils.concat(pendingRewardsFunctionName, \\\"(uint256,address)\\\");\\r\\n    bytes memory result = Address.functionStaticCall(\\r\\n      v2MasterChef, \\r\\n      abi.encodeWithSignature(\\r\\n        signature,\\r\\n        poolId,\\r\\n        pool\\r\\n      )\\r\\n    );  \\r\\n    return abi.decode(result, (uint256));\\r\\n  }\\r\\n\\r\\n  function poolInfoLength(uint256 poolId) public view returns(uint256) {\\r\\n    return poolInfoAll[poolId].length;\\r\\n  }\\r\\n\\r\\n  function reInvestInfoLength(uint256 poolId) public view returns(uint256) {\\r\\n    return reInvestInfo[poolId].length;\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setPool(address _pool) public onlyManager {\\r\\n    pool = _pool;\\r\\n    managers[pool] = true;\\r\\n  }\\r\\n\\r\\n  function setFeeStrate(address _feeStrate) external onlyManager {\\r\\n    require(_feeStrate != address(0), \\\"LC pool ledger: Fee Strate\\\");\\r\\n    feeStrate = _feeStrate;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary StringUtils {\\r\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\r\\n    return string(abi.encodePacked(a, b));\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IFeeTierStrate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IFeeTierStrate {\\r\\n  function getMaxFee() external view returns(uint256);\\r\\n  function getDepositFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getTotalFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getWithdrawFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getAllTier() external view returns(uint256[] memory);\\r\\n  function getTier(uint256 index) external view returns(address, string memory, uint256);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_v2MasterChef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_pendingRewardsFunctionName\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"feeStrate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getLastRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"poolId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"basketIds\",\"type\":\"uint256[]\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentReward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cutfee\",\"type\":\"bool\"}],\"name\":\"getSingleReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"}],\"name\":\"getUserLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewardsFunctionName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfoAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tvl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rtr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reInvestIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reInvested\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"poolInfoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reInvestInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"reInvestInfoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"}],\"name\":\"setFeeStrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exLp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"}],\"name\":\"updateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rtrIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2MasterChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LCPoolUniV2Ledger", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2edad668740f1aa35e4d8f227fb8e17dca888cd000000000000000000000000471200ce99a9608b5676660c98d31167825af1de0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000c70656e64696e6753757368690000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}