{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/payloads/IGP11/PayloadIGP11.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IGovernorBravo {\\n    function _acceptAdmin() external;\\n\\n    function _setVotingDelay(uint newVotingDelay) external;\\n\\n    function _setVotingPeriod(uint newVotingPeriod) external;\\n\\n    function _acceptAdminOnTimelock() external;\\n\\n    function _setImplementation(address implementation_) external;\\n\\n    function propose(\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) external returns (uint);\\n\\n    function admin() external view returns (address);\\n\\n    function pendingAdmin() external view returns (address);\\n\\n    function timelock() external view returns (address);\\n\\n    function votingDelay() external view returns (uint256);\\n\\n    function votingPeriod() external view returns (uint256);\\n}\\n\\ninterface ITimelock {\\n    function acceptAdmin() external;\\n\\n    function setDelay(uint delay_) external;\\n\\n    function setPendingAdmin(address pendingAdmin_) external;\\n\\n    function queueTransaction(\\n        address target,\\n        uint value,\\n        string memory signature,\\n        bytes memory data,\\n        uint eta\\n    ) external returns (bytes32);\\n\\n    function executeTransaction(\\n        address target,\\n        uint value,\\n        string memory signature,\\n        bytes memory data,\\n        uint eta\\n    ) external payable returns (bytes memory);\\n\\n    function pendingAdmin() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function delay() external view returns (uint256);\\n}\\n\\ninterface IInstaIndex {\\n    function changeMaster(address _newMaster) external;\\n\\n    function updateMaster() external;\\n\\n    function master() external view returns (address);\\n}\\n\\ninterface AdminModuleStructs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    struct RateDataV1Params {\\n        address token;\\n        uint256 kink;\\n        uint256 rateAtUtilizationZero;\\n        uint256 rateAtUtilizationKink;\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    struct RateDataV2Params {\\n        address token;\\n        uint256 kink1;\\n        uint256 kink2;\\n        uint256 rateAtUtilizationZero;\\n        uint256 rateAtUtilizationKink1;\\n        uint256 rateAtUtilizationKink2;\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    struct TokenConfig {\\n        address token;\\n        uint256 fee;\\n        uint256 threshold;\\n    }\\n\\n    struct UserSupplyConfig {\\n        address user;\\n        address token;\\n        uint8 mode;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    struct UserBorrowConfig {\\n        address user;\\n        address token;\\n        uint8 mode;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseDebtCeiling;\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\\ninterface IFluidLiquidityAdmin {\\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\\n    /// @param authsStatus_ array of structs setting allowed status for an address.\\n    ///                     status true => add auth, false => remove auth\\n    function updateAuths(\\n        AdminModuleStructs.AddressBool[] calldata authsStatus_\\n    ) external;\\n\\n    /// @notice adds/removes guardians. Only callable by Governance.\\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\\n    ///                         status true => add guardian, false => remove guardian\\n    function updateGuardians(\\n        AdminModuleStructs.AddressBool[] calldata guardiansStatus_\\n    ) external;\\n\\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\\n    /// @param revenueCollector_  new revenue collector address\\n    function updateRevenueCollector(address revenueCollector_) external;\\n\\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\\n    /// @param newStatus_ new status\\n    ///        status = 2 -> pause, status = 1 -> resume.\\n    function changeStatus(uint256 newStatus_) external;\\n\\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\\n    function updateRateDataV1s(\\n        AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_\\n    ) external;\\n\\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\\n    function updateRateDataV2s(\\n        AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_\\n    ) external;\\n\\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\\n    ///         Only callable by Auths.\\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\\n    function updateTokenConfigs(\\n        AdminModuleStructs.TokenConfig[] calldata tokenConfigs_\\n    ) external;\\n\\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\\n    ///         Only callable by Auths.\\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\\n    function updateUserClasses(\\n        AdminModuleStructs.AddressUint256[] calldata userClasses_\\n    ) external;\\n\\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\\n    function updateUserSupplyConfigs(\\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_\\n    ) external;\\n\\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\\n    function updateUserBorrowConfigs(\\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_\\n    ) external;\\n\\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to pause operations for\\n    /// @param supplyTokens_  token addresses to pause withdrawals for\\n    /// @param borrowTokens_  token addresses to pause borrowings for\\n    function pauseUser(\\n        address user_,\\n        address[] calldata supplyTokens_,\\n        address[] calldata borrowTokens_\\n    ) external;\\n\\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to unpause operations for\\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\\n    /// @param borrowTokens_  token addresses to unpause borrowings for\\n    function unpauseUser(\\n        address user_,\\n        address[] calldata supplyTokens_,\\n        address[] calldata borrowTokens_\\n    ) external;\\n\\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\\n    /// @param tokens_  array of tokens to collect revenue for\\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\\n    function collectRevenue(address[] calldata tokens_) external;\\n\\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\\n    /// @param tokens_ tokens to update exchange prices for\\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\\n    function updateExchangePrices(\\n        address[] calldata tokens_\\n    )\\n        external\\n        returns (\\n            uint256[] memory supplyExchangePrices_,\\n            uint256[] memory borrowExchangePrices_\\n        );\\n}\\n\\ninterface IFluidVaultT1Factory {\\n    function deployVault(\\n        address vaultDeploymentLogic_,\\n        bytes calldata vaultDeploymentData_\\n    ) external returns (address vault_);\\n}\\n\\ninterface IFluidVaultT1DeploymentLogic {\\n    function vaultT1(address supplyToken_, address borrowToken_) external;\\n}\\n\\ninterface IFluidVaultT1 {\\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\\n    function updateOracle(address newOracle_) external;\\n\\n    /// @notice updates the all Vault core settings according to input params.\\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCoreSettings(\\n        uint256 supplyRateMagnifier_,\\n        uint256 borrowRateMagnifier_,\\n        uint256 collateralFactor_,\\n        uint256 liquidationThreshold_,\\n        uint256 liquidationMaxLimit_,\\n        uint256 withdrawGap_,\\n        uint256 liquidationPenalty_,\\n        uint256 borrowFee_\\n    ) external;\\n\\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\\n    function updateRebalancer(address newRebalancer_) external;\\n\\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) external;\\n}\\n\\ncontract PayloadIGP11 {\\n    uint256 public constant PROPOSAL_ID = 11;\\n\\n    address public constant PROPOSER =\\n        0xA45f7bD6A5Ff45D31aaCE6bCD3d426D9328cea01;\\n\\n    IGovernorBravo public constant GOVERNOR =\\n        IGovernorBravo(0x0204Cd037B2ec03605CFdFe482D8e257C765fA1B);\\n    ITimelock public constant TIMELOCK =\\n        ITimelock(0x2386DC45AdDed673317eF068992F19421B481F4c);\\n\\n    address public constant TEAM_MULTISIG =\\n        0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\\n\\n    address public immutable ADDRESS_THIS;\\n\\n    IFluidLiquidityAdmin public constant LIQUIDITY =\\n        IFluidLiquidityAdmin(0x52Aa899454998Be5b000Ad077a46Bbe360F4e497);\\n    IFluidVaultT1Factory public constant VAULT_T1_FACTORY =\\n        IFluidVaultT1Factory(0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d);\\n    IFluidVaultT1DeploymentLogic public constant VAULT_T1_DEPLOYMENT_LOGIC =\\n        IFluidVaultT1DeploymentLogic(\\n            0x15f6F562Ae136240AB9F4905cb50aCA54bCbEb5F\\n        );\\n\\n    address public constant ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant weETH_ADDRESS =\\n        0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\\n    address public constant wstETH_ADDRESS =\\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n\\n    constructor() {\\n        ADDRESS_THIS = address(this);\\n    }\\n\\n    function propose(string memory description) external {\\n        require(\\n            msg.sender == PROPOSER || msg.sender == TEAM_MULTISIG,\\n            \\\"msg.sender-not-proposer-or-multisig\\\"\\n        );\\n\\n        uint256 totalActions = 1;\\n        address[] memory targets = new address[](totalActions);\\n        uint256[] memory values = new uint256[](totalActions);\\n        string[] memory signatures = new string[](totalActions);\\n        bytes[] memory calldatas = new bytes[](totalActions);\\n\\n        // Action 1: call executePayload on timelock contract to execute payload related to Fluid\\n        targets[0] = address(TIMELOCK);\\n        values[0] = 0;\\n        signatures[0] = \\\"executePayload(address,string,bytes)\\\";\\n        calldatas[0] = abi.encode(ADDRESS_THIS, \\\"execute()\\\", abi.encode());\\n\\n        uint256 proposedId = GOVERNOR.propose(\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            description\\n        );\\n\\n        require(proposedId == PROPOSAL_ID, \\\"PROPOSAL_IS_NOT_SAME\\\");\\n    }\\n\\n    function execute() external {\\n        require(address(this) == address(TIMELOCK), \\\"not-valid-caller\\\");\\n\\n        // Action 1: Set market rates for weETH on Liquidity.\\n        action1();\\n\\n        // Action 2: Set token config for weETH on Liquidity.\\n        action2();\\n\\n        //  Action 3: Deploy weETH/wstETH vault.\\n        address vault_ = action3();\\n\\n        // Action 4: Set user supply config for the vault on Liquidity Layer.\\n        action4(vault_);\\n\\n        // Action 5: Set user borrow config for the vault on Liquidity Layer.\\n        action5(vault_);\\n\\n        // Action 6: Update core settings on weETH/wstETH vault.\\n        action6(vault_);\\n\\n        // Action 7: Update oracle on weETH/wstETH vault.\\n        action7(vault_);\\n\\n        // Action 8: Update rebalancer on weETH/wstETH vault.\\n        action8(vault_);\\n\\n        // Action 9: Update supply magnifier on wstETH/ETH, wstETH/USDC & wstETH/USDT vault\\n        action9();\\n\\n        // Action 10: Update market rates for wstETH on Liquidity.\\n        action10();\\n\\n        // Action 11: Update token config for wstETH on Liquidity.\\n        action11();\\n    }\\n\\n    function verifyProposal() external view {}\\n\\n    /***********************************|\\n    |     Proposal Payload Actions      |\\n    |__________________________________*/\\n\\n    /// @notice Action 1: Set market rates for weETH on Liquidity.\\n    function action1() internal {\\n        AdminModuleStructs.RateDataV2Params[]\\n            memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\\n\\n        params_[0] = AdminModuleStructs.RateDataV2Params({\\n            token: weETH_ADDRESS, // weETH\\n            kink1: 50 * 1e2, // 50%\\n            kink2: 80 * 1e2, // 80%\\n            rateAtUtilizationZero: 0, // 0%\\n            rateAtUtilizationKink1: 20 * 1e2, // 20%\\n            rateAtUtilizationKink2: 40 * 1e2, // 40%\\n            rateAtUtilizationMax: 100 * 1e2 // 100%\\n        });\\n\\n        LIQUIDITY.updateRateDataV2s(params_);\\n    }\\n\\n    /// @notice Action 2: Set token config for weETH on Liquidity.\\n    function action2() internal {\\n        AdminModuleStructs.TokenConfig[]\\n            memory params_ = new AdminModuleStructs.TokenConfig[](1);\\n\\n        params_[0] = AdminModuleStructs.TokenConfig({\\n            token: weETH_ADDRESS, // weETH\\n            threshold: 0.3 * 1e2, // 0.3\\n            fee: 10 * 1e2 // 10%\\n        });\\n\\n        LIQUIDITY.updateTokenConfigs(params_);\\n    }\\n\\n    /// @notice Action 3: Deploy weETH/wstETH vault.\\n    function action3() internal returns (address vault_) {\\n        vault_ = VAULT_T1_FACTORY.deployVault(\\n            address(VAULT_T1_DEPLOYMENT_LOGIC),\\n            abi.encodeWithSelector(\\n                IFluidVaultT1DeploymentLogic.vaultT1.selector,\\n                weETH_ADDRESS, // weETH,\\n                wstETH_ADDRESS // wstETH\\n            )\\n        );\\n    }\\n\\n    /// @notice Action 4: Set user supply config for the vault on Liquidity Layer.\\n    function action4(address vault_) internal {\\n        AdminModuleStructs.UserSupplyConfig[]\\n            memory configs_ = new AdminModuleStructs.UserSupplyConfig[](1);\\n\\n        configs_[0] = AdminModuleStructs.UserSupplyConfig({\\n            user: address(vault_),\\n            token: weETH_ADDRESS,\\n            mode: 1,\\n            expandPercent: 25 * 1e2,\\n            expandDuration: 12 hours,\\n            baseWithdrawalLimit: 4000 * 1e18\\n        });\\n\\n        LIQUIDITY.updateUserSupplyConfigs(configs_);\\n    }\\n\\n    /// @notice Action 5: Set user borrow config for the vault on Liquidity Layer.\\n    function action5(address vault_) internal {\\n        AdminModuleStructs.UserBorrowConfig[]\\n            memory configs_ = new AdminModuleStructs.UserBorrowConfig[](1);\\n\\n        configs_[0] = AdminModuleStructs.UserBorrowConfig({\\n            user: address(vault_),\\n            token: wstETH_ADDRESS,\\n            mode: 1,\\n            expandPercent: 25 * 1e2,\\n            expandDuration: 12 hours,\\n            baseDebtCeiling: 4000 * 1e18,\\n            maxDebtCeiling: 10000 * 1e18\\n        });\\n\\n        LIQUIDITY.updateUserBorrowConfigs(configs_);\\n    }\\n\\n    /// @notice Action 6: Update core settings on weETH/wstETH vault.\\n    function action6(address vault_) internal {\\n        IFluidVaultT1(vault_).updateCoreSettings(\\n            100 * 1e2, // 1x     supplyRateMagnifier\\n            100 * 1e2, // 1x     borrowRateMagnifier\\n            90.5 * 1e2, // 90.5%  collateralFactor\\n            93 * 1e2, // 93%    liquidationThreshold\\n            95 * 1e2, // 95%    liquidationMaxLimit\\n            5 * 1e2, // 5%     withdrawGap\\n            1 * 1e2, // 1%     liquidationPenalty\\n            0 // 0%     borrowFee\\n        );\\n    }\\n\\n    /// @notice Action 7: Update oracle on weETH/wstETH vault.\\n    function action7(address vault_) internal {\\n        IFluidVaultT1(vault_).updateOracle(\\n            0x9eC721a12b6005aF8c6E8CFa9c86B5f12ff473E4\\n        );\\n    }\\n\\n    /// @notice Action 8: Update rebalancer on weETH/wstETH vault.\\n    function action8(address vault_) internal {\\n        IFluidVaultT1(vault_).updateRebalancer(\\n            0x264786EF916af64a1DB19F513F24a3681734ce92\\n        );\\n    }\\n\\n    /// @notice Action 9: UpdateSupplyMagnifier on wstETH/ETH, wstETH/USDC & wstETH/USDT vault\\n    function action9() internal {\\n        // wstETH/ETH\\n        IFluidVaultT1(0xA0F83Fc5885cEBc0420ce7C7b139Adc80c4F4D91)\\n            .updateSupplyRateMagnifier(1 * 1e4); // 1x\\n        // wstETH/USDC\\n        IFluidVaultT1(0x51197586F6A9e2571868b6ffaef308f3bdfEd3aE)\\n            .updateSupplyRateMagnifier(1 * 1e4); // 1x\\n        // wstETH/USDT\\n        IFluidVaultT1(0x1c2bB46f36561bc4F05A94BD50916496aa501078)\\n            .updateSupplyRateMagnifier(1 * 1e4); // 1x\\n    }\\n\\n    /// @notice Action 10: Update market rates for wstETH on Liquidity.\\n    function action10() internal {\\n        AdminModuleStructs.RateDataV2Params[]\\n            memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\\n\\n        params_[0] = AdminModuleStructs.RateDataV2Params({\\n            token: wstETH_ADDRESS, // wstETH\\n            kink1: 50 * 1e2, // 50%\\n            kink2: 80 * 1e2, // 80%\\n            rateAtUtilizationZero: 0, // 0%\\n            rateAtUtilizationKink1: 15 * 1e2, // 15%\\n            rateAtUtilizationKink2: 30 * 1e2, // 30%\\n            rateAtUtilizationMax: 150 * 1e2 // 150%\\n        });\\n\\n        LIQUIDITY.updateRateDataV2s(params_);\\n    }\\n\\n    /// @notice Action 11: Update token config for wstETH on Liquidity.\\n    function action11() internal {\\n        AdminModuleStructs.TokenConfig[]\\n            memory params_ = new AdminModuleStructs.TokenConfig[](1);\\n\\n        params_[0] = AdminModuleStructs.TokenConfig({\\n            token: wstETH_ADDRESS, // wstETH\\n            threshold: 0.3 * 1e2, // 0.3\\n            fee: 70 * 1e2 // 70%\\n        });\\n\\n        LIQUIDITY.updateTokenConfigs(params_);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESS_THIS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNOR\",\"outputs\":[{\"internalType\":\"contract IGovernorBravo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"contract IFluidLiquidityAdmin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROPOSAL_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROPOSER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_MULTISIG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK\",\"outputs\":[{\"internalType\":\"contract ITimelock\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_T1_DEPLOYMENT_LOGIC\",\"outputs\":[{\"internalType\":\"contract IFluidVaultT1DeploymentLogic\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_T1_FACTORY\",\"outputs\":[{\"internalType\":\"contract IFluidVaultT1Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifyProposal\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PayloadIGP11", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}