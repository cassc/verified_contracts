// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

contract ClaimGLC is IERC721Receiver  {

  uint256 immutable chainId;
  uint256[] public receivedTokenIds;
  uint256 public minAgeForClaim;
  uint256 public arrayFront;
  
  address public signer;
  address public acceptedTokenAddress;
  
  // Mapping to keep track of all the signatures that are already verified
  mapping (bytes  => bool) isVerified;
  mapping (uint256 => uint256) private maturityTime;
  // Mapping to store the addresses that can perform admin only functions
  mapping (address => bool) isAllowed;

  event Claimed(address indexed claimer, uint256 indexed tokenId);

  constructor(address _signer, address _acceptedTokenAddress, uint256 _minAgeForClaimInDays) {
    require(_signer != address(0), "Signer should not be a zero address");
    require(_acceptedTokenAddress != address(0), "Accepted token address should not be a zero address");
    uint256 _id;
    assembly {
      _id := chainid()
    }
    chainId = _id;
    arrayFront = 0;
    signer  = _signer;
    acceptedTokenAddress = _acceptedTokenAddress;
    minAgeForClaim = _minAgeForClaimInDays * 1 days;
    isAllowed[msg.sender] = true;
  }

  /**
   * @dev Get the final message hash that will be signed while using EIP-191
   * @param message - The message to be signed
   */
  function getMessageHash(bytes32 message) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", message));
  }

  /**
   * @dev Called by user to claim an NFT. Verifies the signature then transfers the NFT and emit respective event
   * @param signature - The signature genereated by the website
   * @param deadline - The deadline till which the signature is valid
   * @param nonce - The nonce generated by the website
   */
  function claim(bytes memory signature, uint256 deadline, uint256 nonce) external {
    require(verifySignature(msg.sender, deadline, nonce, signature), "Invalid signature");
    uint256 tokenIdOfTokenToSend = receivedTokenIds[arrayFront];
    
    require(canClaimToken(tokenIdOfTokenToSend), "No token available for claim");
    
    delete receivedTokenIds[arrayFront];
    delete maturityTime[tokenIdOfTokenToSend]; 
    arrayFront ++;
    isVerified[signature] = true;
    IERC721(acceptedTokenAddress).safeTransferFrom(address(this), msg.sender, tokenIdOfTokenToSend);
    emit Claimed(msg.sender, tokenIdOfTokenToSend);
  }

  /**
   * @dev For the passed tokenId, returns whether the token has passed the maturity time
   * @param tokenId - The tokenId of the token to be checked
   */
  function canClaimToken(uint256 tokenId) public view returns(bool) {
    return (block.timestamp >= maturityTime[tokenId]);
  }

  /**
   * @dev Verifies whether the passed signature is valid w.r.t the passed userAddress. Also checks if signature is expired
   * @param userAddress - The address of the user to whom the signature was assigned to
   * @param deadline - The deadline till which the signature is valid
   * @param nonce - The nonce generated by the website
   * @param signature - The signature genereated by the website
   */
  function verifySignature(address userAddress, uint256 deadline, uint256 nonce, bytes memory signature) public view returns(bool) {
    require(!isVerified[signature], "Signature already verified");
    require(block.timestamp <= deadline, "Signature expired");
    
    bytes32 message = keccak256(abi.encodePacked(chainId, address(this), userAddress, deadline, nonce));
    bytes32 messageHash = getMessageHash(message);
    return SignatureChecker.isValidSignatureNow(signer, messageHash, signature);
  }

  /**
   * @dev Function invoked when safeTransferFrom is use to transfer an NFT to this contract. Refer to 
   * https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-
   */
  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external override returns (bytes4) {
    // Make sure that only the accepted token is transferred to this contract
    require(msg.sender == acceptedTokenAddress);
    receivedTokenIds.push(tokenId);
    uint256 remainder = block.timestamp % (1 days);
    // Calculate and store the time when this token will be matured and up for claim
    maturityTime[tokenId] = block.timestamp - remainder + minAgeForClaim + (1 days);
    return this.onERC721Received.selector;
  }

  /**
   * dev Function to make return any NFT that was mistakenly sent to this contract
   * @param _tokenAddress - The address of the token to be returned
   * @param _tokenId - The tokenId of the token to be returned
   * @param _receiver - The address to which the token is to be returned
   */
  function transferNonAcceptedNFTs(address _tokenAddress, uint256 _tokenId, address _receiver) external  {
    require(isAllowed[msg.sender], "Not allowed");
    IERC721(_tokenAddress).safeTransferFrom(address(this), _receiver, _tokenId);
  }

  /**
   * dev Change the signer used for generating the signature
   * note This requires modification in the backend as older signatures needs to be modified
   * @param _signer - The new signer address
   */
  function setSigner(address _signer) external {
    require(isAllowed[msg.sender], "Not allowed");
    require(_signer != address(0), "Signer should not be a zero address");
    signer = _signer;
  }

  /**
   * dev Allow/Porhibit passed account to make admin only changes in smart contract
   * @param _account - The account to be allowed or prohibited
   * @param _allowed - Whether the account is allowed or prohibited
   */
  function whitelistAccount(address _account, bool _allowed) external {
    require(isAllowed[msg.sender], "Not allowed");
    isAllowed[_account] = _allowed;
  }

  /**
   * dev Get the number of NFTs that are still present in the smart contract (is or will be ready for claim)
   */
  function getQueueLength() external view returns(uint256) {
    return receivedTokenIds.length - arrayFront;
  }

  function setMaturityTime(uint256[] memory tokenIds, uint256[] memory maturityTimes) external {
    require(isAllowed[msg.sender]);
    for(uint256 i = 0; i < tokenIds.length; i++) {
      maturityTime[tokenIds[i]] = maturityTimes[i];
    }
  }
}