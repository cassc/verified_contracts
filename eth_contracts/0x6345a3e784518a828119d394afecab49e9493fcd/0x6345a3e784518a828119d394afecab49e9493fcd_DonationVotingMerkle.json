{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/interfaces/IAllo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n// Interfaces\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\nimport {IStrategy} from \\\"./IStrategy.sol\\\";\\n// Internal Libraries\\nimport {Metadata} from \\\"../libraries/Metadata.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Allo Interface\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice Interface for the Allo contract. It exposes all functions needed to use the Allo protocol.\\ninterface IAllo {\\n    /// ======================\\n    /// ======= Structs ======\\n    /// ======================\\n\\n    /// @notice the Pool struct that all strategy pools are based from\\n    struct Pool {\\n        bytes32 profileId;\\n        IStrategy strategy;\\n        address token;\\n        Metadata metadata;\\n        bytes32 managerRole;\\n        bytes32 adminRole;\\n    }\\n\\n    /// ======================\\n    /// ======= Events =======\\n    /// ======================\\n\\n    /// @notice Event emitted when a new pool is created\\n    /// @param poolId ID of the pool created\\n    /// @param profileId ID of the profile the pool is associated with\\n    /// @param strategy Address of the strategy contract\\n    /// @param token Address of the token pool was funded with when created\\n    /// @param amount Amount pool was funded with when created\\n    /// @param metadata Pool metadata\\n    event PoolCreated(\\n        uint256 indexed poolId,\\n        bytes32 indexed profileId,\\n        IStrategy strategy,\\n        address token,\\n        uint256 amount,\\n        Metadata metadata\\n    );\\n\\n    /// @notice Emitted when a pools metadata is updated\\n    /// @param poolId ID of the pool updated\\n    /// @param metadata Pool metadata that was updated\\n    event PoolMetadataUpdated(uint256 indexed poolId, Metadata metadata);\\n\\n    /// @notice Emitted when a pool is funded\\n    /// @param poolId ID of the pool funded\\n    /// @param amount Amount funded to the pool\\n    /// @param fee Amount of the fee paid to the treasury\\n    event PoolFunded(uint256 indexed poolId, uint256 amount, uint256 fee);\\n\\n    /// @notice Emitted when the base fee is paid\\n    /// @param poolId ID of the pool the base fee was paid for\\n    /// @param amount Amount of the base fee paid\\n    event BaseFeePaid(uint256 indexed poolId, uint256 amount);\\n\\n    /// @notice Emitted when the treasury address is updated\\n    /// @param treasury Address of the new treasury\\n    event TreasuryUpdated(address treasury);\\n\\n    /// @notice Emitted when the percent fee is updated\\n    /// @param percentFee New percentage for the fee\\n    event PercentFeeUpdated(uint256 percentFee);\\n\\n    /// @notice Emitted when the base fee is updated\\n    /// @param baseFee New base fee amount\\n    event BaseFeeUpdated(uint256 baseFee);\\n\\n    /// @notice Emitted when the registry address is updated\\n    /// @param registry Address of the new registry\\n    event RegistryUpdated(address registry);\\n\\n    /// @notice Emitted when a strategy is approved and added to the cloneable strategies\\n    /// @param strategy Address of the strategy approved\\n    event StrategyApproved(address strategy);\\n\\n    /// @notice Emitted when a strategy is removed from the cloneable strategies\\n    /// @param strategy Address of the strategy removed\\n    event StrategyRemoved(address strategy);\\n\\n    /// ====================================\\n    /// ==== External/Public Functions =====\\n    /// ====================================\\n\\n    /// @notice Initialize the Allo contract\\n    /// @param _owner Address of the owner\\n    /// @param _registry Address of the registry contract\\n    /// @param _treasury Address of the treasury\\n    /// @param _percentFee Percentage for the fee\\n    /// @param _baseFee Base fee amount\\n    function initialize(\\n        address _owner,\\n        address _registry,\\n        address payable _treasury,\\n        uint256 _percentFee,\\n        uint256 _baseFee\\n    ) external;\\n\\n    /// @notice Creates a new pool (with a custom strategy)\\n    /// @dev 'msg.sender' must be a member or owner of a profile to create a pool with or without a custom strategy, The encoded data\\n    ///      will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'. The strategy\\n    ///      address passed must not be a cloneable strategy. The strategy address passed must not be the zero address. 'msg.sender' must\\n    ///      be a member or owner of the profile id passed as '_profileId'.\\n    /// @param _profileId The 'profileId' of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\\n    /// @param _strategy The address of the deployed custom strategy\\n    /// @param _initStrategyData The data to initialize the strategy\\n    /// @param _token The address of the token you want to use in your pool\\n    /// @param _amount The amount of the token you want to deposit into the pool on initialization\\n    /// @param _metadata The 'Metadata' of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)\\n    /// @param _managers The managers of the pool, and can be added/removed later by the pool admin\\n    /// @return poolId The ID of the pool\\n    function createPoolWithCustomStrategy(\\n        bytes32 _profileId,\\n        address _strategy,\\n        bytes memory _initStrategyData,\\n        address _token,\\n        uint256 _amount,\\n        Metadata memory _metadata,\\n        address[] memory _managers\\n    ) external payable returns (uint256 poolId);\\n\\n    /// @notice Creates a new pool (by cloning a cloneable strategies).\\n    /// @dev 'msg.sender' must be owner or member of the profile id passed as '_profileId'.\\n    /// @param _profileId The ID of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\\n    /// @param _strategy The address of the strategy contract the pool will use.\\n    /// @param _initStrategyData The data to initialize the strategy\\n    /// @param _token The address of the token\\n    /// @param _amount The amount of the token\\n    /// @param _metadata The metadata of the pool\\n    /// @param _managers The managers of the pool\\n    /// @custom:initstrategydata The encoded data will be specific to a given strategy requirements,\\n    ///    reference the strategy implementation of 'initialize()'\\n    function createPool(\\n        bytes32 _profileId,\\n        address _strategy,\\n        bytes memory _initStrategyData,\\n        address _token,\\n        uint256 _amount,\\n        Metadata memory _metadata,\\n        address[] memory _managers\\n    ) external payable returns (uint256 poolId);\\n\\n    /// @notice Updates a pools metadata.\\n    /// @dev 'msg.sender' must be a pool admin.\\n    /// @param _poolId The ID of the pool to update\\n    /// @param _metadata The new metadata to set\\n    function updatePoolMetadata(uint256 _poolId, Metadata memory _metadata) external;\\n\\n    /// @notice Update the registry address.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _registry The new registry address\\n    function updateRegistry(address _registry) external;\\n\\n    /// @notice Updates the treasury address.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _treasury The new treasury address\\n    function updateTreasury(address payable _treasury) external;\\n\\n    /// @notice Updates the percentage for the fee.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _percentFee The new percentage for the fee\\n    function updatePercentFee(uint256 _percentFee) external;\\n\\n    /// @notice Updates the base fee.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _baseFee The new base fee\\n    function updateBaseFee(uint256 _baseFee) external;\\n\\n    /// @notice Adds a strategy to the cloneable strategies.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _strategy The address of the strategy to add\\n    function addToCloneableStrategies(address _strategy) external;\\n\\n    /// @notice Removes a strategy from the cloneable strategies.\\n    /// @dev 'msg.sender' must be the Allo contract owner.\\n    /// @param _strategy The address of the strategy to remove\\n    function removeFromCloneableStrategies(address _strategy) external;\\n\\n    /// @notice Adds a pool manager to the pool.\\n    /// @dev 'msg.sender' must be a pool admin.\\n    /// @param _poolId The ID of the pool to add the manager to\\n    /// @param _manager The address of the manager to add\\n    function addPoolManager(uint256 _poolId, address _manager) external;\\n\\n    /// @notice Removes a pool manager from the pool.\\n    /// @dev 'msg.sender' must be a pool admin.\\n    /// @param _poolId The ID of the pool to remove the manager from\\n    /// @param _manager The address of the manager to remove\\n    function removePoolManager(uint256 _poolId, address _manager) external;\\n\\n    /// @notice Recovers funds from a pool.\\n    /// @dev 'msg.sender' must be a pool admin.\\n    /// @param _token The token to recover\\n    /// @param _recipient The address to send the recovered funds to\\n    function recoverFunds(address _token, address _recipient) external;\\n\\n    /// @notice Registers a recipient and emits {Registered} event if successful and may be handled differently by each strategy.\\n    /// @param _poolId The ID of the pool to register the recipient for\\n    function registerRecipient(uint256 _poolId, bytes memory _data) external payable returns (address);\\n\\n    /// @notice Registers a batch of recipients.\\n    /// @param _poolIds The pool ID's to register the recipients for\\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy\\n    function batchRegisterRecipient(uint256[] memory _poolIds, bytes[] memory _data)\\n        external\\n        returns (address[] memory);\\n\\n    /// @notice Funds a pool.\\n    /// @dev 'msg.value' must be greater than 0 if the token is the native token\\n    ///       or '_amount' must be greater than 0 if the token is not the native token.\\n    /// @param _poolId The ID of the pool to fund\\n    /// @param _amount The amount to fund the pool with\\n    function fundPool(uint256 _poolId, uint256 _amount) external payable;\\n\\n    /// @notice Allocates funds to a recipient.\\n    /// @dev Each strategy will handle the allocation of funds differently.\\n    /// @param _poolId The ID of the pool to allocate funds from\\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy.\\n    function allocate(uint256 _poolId, bytes memory _data) external payable;\\n\\n    /// @notice Allocates funds to multiple recipients.\\n    /// @dev Each strategy will handle the allocation of funds differently\\n    function batchAllocate(uint256[] calldata _poolIds, bytes[] memory _datas) external;\\n\\n    /// @notice Distributes funds to recipients and emits {Distributed} event if successful\\n    /// @dev Each strategy will handle the distribution of funds differently\\n    /// @param _poolId The ID of the pool to distribute from\\n    /// @param _recipientIds The recipient ids to distribute to\\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy\\n    function distribute(uint256 _poolId, address[] memory _recipientIds, bytes memory _data) external;\\n\\n    /// =========================\\n    /// ==== View Functions =====\\n    /// =========================\\n\\n    /// @notice Checks if an address is a pool admin.\\n    /// @param _poolId The ID of the pool to check\\n    /// @param _address The address to check\\n    /// @return 'true' if the '_address' is a pool admin, otherwise 'false'\\n    function isPoolAdmin(uint256 _poolId, address _address) external view returns (bool);\\n\\n    /// @notice Checks if an address is a pool manager.\\n    /// @param _poolId The ID of the pool to check\\n    /// @param _address The address to check\\n    /// @return 'true' if the '_address' is a pool manager, otherwise 'false'\\n    function isPoolManager(uint256 _poolId, address _address) external view returns (bool);\\n\\n    /// @notice Checks if a strategy is cloneable (is in the cloneableStrategies mapping).\\n    /// @param _strategy The address of the strategy to check\\n    /// @return 'true' if the '_strategy' is cloneable, otherwise 'false'\\n    function isCloneableStrategy(address _strategy) external view returns (bool);\\n\\n    /// @notice Returns the address of the strategy for a given 'poolId'\\n    /// @param _poolId The ID of the pool to check\\n    /// @return strategy The address of the strategy for the ID of the pool passed in\\n    function getStrategy(uint256 _poolId) external view returns (address);\\n\\n    /// @notice Returns the current percent fee\\n    /// @return percentFee The current percentage for the fee\\n    function getPercentFee() external view returns (uint256);\\n\\n    /// @notice Returns the current base fee\\n    /// @return baseFee The current base fee\\n    function getBaseFee() external view returns (uint256);\\n\\n    /// @notice Returns the current treasury address\\n    /// @return treasury The current treasury address\\n    function getTreasury() external view returns (address payable);\\n\\n    /// @notice Returns the current registry address\\n    /// @return registry The current registry address\\n    function getRegistry() external view returns (IRegistry);\\n\\n    /// @notice Returns the 'Pool' struct for a given 'poolId'\\n    /// @param _poolId The ID of the pool to check\\n    /// @return pool The 'Pool' struct for the ID of the pool passed in\\n    function getPool(uint256 _poolId) external view returns (Pool memory);\\n\\n    /// @notice Returns the current fee denominator\\n    /// @dev 1e18 represents 100%\\n    /// @return feeDenominator The current fee denominator\\n    function getFeeDenominator() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n// Internal Libraries\\nimport {Metadata} from \\\"../libraries/Metadata.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title IRegistry Interface\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice Interface for the Registry contract and exposes all functions needed to use the Registry\\n///         within the Allo protocol.\\n/// @dev The Registry Interface is used to interact with the Allo protocol and create profiles\\n///      that can be used to interact with the Allo protocol. The Registry is the main contract\\n///      that all other contracts interact with to get the 'Profile' information needed to\\n///      interact with the Allo protocol. The Registry is also used to create new profiles\\n///      and update existing profiles. The Registry is also used to add and remove members\\n///      from a profile. The Registry will not always be used in a strategy and will depend on\\n///      the strategy being used.\\ninterface IRegistry {\\n    /// ======================\\n    /// ======= Structs ======\\n    /// ======================\\n\\n    /// @dev The Profile struct that all profiles are based from\\n    struct Profile {\\n        bytes32 id;\\n        uint256 nonce;\\n        string name;\\n        Metadata metadata;\\n        address owner;\\n        address anchor;\\n    }\\n\\n    /// ======================\\n    /// ======= Events =======\\n    /// ======================\\n\\n    /// @dev Emitted when a profile is created. This will return your anchor address.\\n    event ProfileCreated(\\n        bytes32 indexed profileId, uint256 nonce, string name, Metadata metadata, address owner, address anchor\\n    );\\n\\n    /// @dev Emitted when a profile name is updated. This will update the anchor when the name is updated and return it.\\n    event ProfileNameUpdated(bytes32 indexed profileId, string name, address anchor);\\n\\n    /// @dev Emitted when a profile's metadata is updated.\\n    event ProfileMetadataUpdated(bytes32 indexed profileId, Metadata metadata);\\n\\n    /// @dev Emitted when a profile owner is updated.\\n    event ProfileOwnerUpdated(bytes32 indexed profileId, address owner);\\n\\n    /// @dev Emitted when a profile pending owner is updated.\\n    event ProfilePendingOwnerUpdated(bytes32 indexed profileId, address pendingOwner);\\n\\n    /// =========================\\n    /// ==== View Functions =====\\n    /// =========================\\n\\n    /// @dev Returns the 'Profile' for a '_profileId' passed\\n    /// @param _profileId The 'profileId' to return the 'Profile' for\\n    /// @return profile The 'Profile' for the '_profileId' passed\\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory profile);\\n\\n    /// @dev Returns the 'Profile' for an '_anchor' passed\\n    /// @param _anchor The 'anchor' to return the 'Profile' for\\n    /// @return profile The 'Profile' for the '_anchor' passed\\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory profile);\\n\\n    /// @dev Returns a boolean if the '_account' is a member or owner of the '_profileId' passed in\\n    /// @param _profileId The 'profileId' to check if the '_account' is a member or owner of\\n    /// @param _account The 'account' to check if they are a member or owner of the '_profileId' passed in\\n    /// @return isOwnerOrMemberOfProfile A boolean if the '_account' is a member or owner of the '_profileId' passed in\\n    function isOwnerOrMemberOfProfile(bytes32 _profileId, address _account)\\n        external\\n        view\\n        returns (bool isOwnerOrMemberOfProfile);\\n\\n    /// @dev Returns a boolean if the '_account' is an owner of the '_profileId' passed in\\n    /// @param _profileId The 'profileId' to check if the '_account' is an owner of\\n    /// @param _owner The 'owner' to check if they are an owner of the '_profileId' passed in\\n    /// @return isOwnerOfProfile A boolean if the '_account' is an owner of the '_profileId' passed in\\n    function isOwnerOfProfile(bytes32 _profileId, address _owner) external view returns (bool isOwnerOfProfile);\\n\\n    /// @dev Returns a boolean if the '_account' is a member of the '_profileId' passed in\\n    /// @param _profileId The 'profileId' to check if the '_account' is a member of\\n    /// @param _member The 'member' to check if they are a member of the '_profileId' passed in\\n    /// @return isMemberOfProfile A boolean if the '_account' is a member of the '_profileId' passed in\\n    function isMemberOfProfile(bytes32 _profileId, address _member) external view returns (bool isMemberOfProfile);\\n\\n    /// ====================================\\n    /// ==== External/Public Functions =====\\n    /// ====================================\\n\\n    /// @dev Creates a new 'Profile' and returns the 'profileId' of the new profile\\n    ///\\n    /// Note: The 'name' and 'nonce' are used to generate the 'anchor' address\\n    ///\\n    /// Requirements: None, anyone can create a new profile\\n    ///\\n    /// @param _nonce The nonce to use to generate the 'anchor' address\\n    /// @param _name The name to use to generate the 'anchor' address\\n    /// @param _metadata The 'Metadata' to use to generate the 'anchor' address\\n    /// @param _owner The 'owner' to use to generate the 'anchor' address\\n    /// @param _members The 'members' to use to generate the 'anchor' address\\n    /// @return profileId The 'profileId' of the new profile\\n    function createProfile(\\n        uint256 _nonce,\\n        string memory _name,\\n        Metadata memory _metadata,\\n        address _owner,\\n        address[] memory _members\\n    ) external returns (bytes32 profileId);\\n\\n    /// @dev Updates the 'name' of the '_profileId' passed in and returns the new 'anchor' address\\n    ///\\n    /// Requirements: Only the 'Profile' owner can update the name\\n    ///\\n    /// Note: The 'name' and 'nonce' are used to generate the 'anchor' address and this will update the 'anchor'\\n    ///       so please use caution. You can always recreate your 'anchor' address by updating the name back\\n    ///       to the original name used to create the profile.\\n    ///\\n    /// @param _profileId The 'profileId' to update the name for\\n    /// @param _name The new 'name' value\\n    /// @return anchor The new 'anchor' address\\n    function updateProfileName(bytes32 _profileId, string memory _name) external returns (address anchor);\\n\\n    /// @dev Updates the 'Metadata' of the '_profileId' passed in\\n    ///\\n    /// Requirements: Only the 'Profile' owner can update the metadata\\n    ///\\n    /// @param _profileId The 'profileId' to update the metadata for\\n    /// @param _metadata The new 'Metadata' value\\n    function updateProfileMetadata(bytes32 _profileId, Metadata memory _metadata) external;\\n\\n    /// @dev Updates the pending 'owner' of the '_profileId' passed in\\n    ///\\n    /// Requirements: Only the 'Profile' owner can update the pending owner\\n    ///\\n    /// @param _profileId The 'profileId' to update the pending owner for\\n    /// @param _pendingOwner The new pending 'owner' value\\n    function updateProfilePendingOwner(bytes32 _profileId, address _pendingOwner) external;\\n\\n    /// @dev Accepts the pending 'owner' of the '_profileId' passed in\\n    ///\\n    /// Requirements: Only the pending owner can accept the ownership\\n    ///\\n    /// @param _profileId The 'profileId' to accept the ownership for\\n    function acceptProfileOwnership(bytes32 _profileId) external;\\n\\n    /// @dev Adds members to the '_profileId' passed in\\n    ///\\n    /// Requirements: Only the 'Profile' owner can add members\\n    ///\\n    /// @param _profileId The 'profileId' to add members to\\n    /// @param _members The members to add to the '_profileId' passed in\\n    function addMembers(bytes32 _profileId, address[] memory _members) external;\\n\\n    /// @dev Removes members from the '_profileId' passed in\\n    ///\\n    /// Requirements: Only the 'Profile' owner can remove members\\n    ///\\n    /// @param _profileId The 'profileId' to remove members from\\n    /// @param _members The members to remove from the '_profileId' passed in\\n    function removeMembers(bytes32 _profileId, address[] memory _members) external;\\n\\n    /// @dev Recovers funds from the contract\\n    ///\\n    /// Requirements: Must be the Allo owner\\n    ///\\n    /// @param _token The token you want to use to recover funds\\n    /// @param _recipient The recipient of the recovered funds\\n    function recoverFunds(address _token, address _recipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n// Interfaces\\nimport {IAllo} from \\\"./IAllo.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title IStrategy Interface\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co> @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice BaseStrategy is the base contract that all strategies should inherit from and uses this interface.\\n\\ninterface IStrategy {\\n    /// ======================\\n    /// ======= Storage ======\\n    /// ======================\\n\\n    /// @notice The Status enum that all recipients are based from\\n    enum Status {\\n        None,\\n        Pending,\\n        Accepted,\\n        Rejected,\\n        Appealed,\\n        InReview,\\n        Canceled\\n    }\\n\\n    /// @notice Payout summary struct to hold the payout data\\n    struct PayoutSummary {\\n        address recipientAddress;\\n        uint256 amount;\\n    }\\n\\n    /// ======================\\n    /// ======= Events =======\\n    /// ======================\\n\\n    /// @notice Emitted when strategy is initialized.\\n    /// @param poolId The ID of the pool\\n    /// @param data The data passed to the 'initialize' function\\n    event Initialized(uint256 poolId, bytes data);\\n\\n    /// @notice Emitted when a recipient is registered.\\n    /// @param recipientId The ID of the recipient\\n    /// @param data The data passed to the 'registerRecipient' function\\n    /// @param sender The sender\\n    event Registered(address indexed recipientId, bytes data, address sender);\\n\\n    /// @notice Emitted when a recipient is allocated to.\\n    /// @param recipientId The ID of the recipient\\n    /// @param amount The amount allocated\\n    /// @param token The token allocated\\n    event Allocated(address indexed recipientId, uint256 amount, address token, address sender);\\n\\n    /// @notice Emitted when tokens are distributed.\\n    /// @param recipientId The ID of the recipient\\n    /// @param recipientAddress The recipient\\n    /// @param amount The amount distributed\\n    /// @param sender The sender\\n    event Distributed(address indexed recipientId, address recipientAddress, uint256 amount, address sender);\\n\\n    /// @notice Emitted when pool is set to active status.\\n    /// @param active The status of the pool\\n    event PoolActive(bool active);\\n\\n    /// ======================\\n    /// ======= Views ========\\n    /// ======================\\n\\n    /// @notice Getter for the address of the Allo contract.\\n    /// @return The 'Allo' contract\\n    function getAllo() external view returns (IAllo);\\n\\n    /// @notice Getter for the 'poolId' for this strategy.\\n    /// @return The ID of the pool\\n    function getPoolId() external view returns (uint256);\\n\\n    /// @notice Getter for the 'id' of the strategy.\\n    /// @return The ID of the strategy\\n    function getStrategyId() external view returns (bytes32);\\n\\n    /// @notice Checks whether a allocator is valid or not, will usually be true for all strategies\\n    ///      and will depend on the strategy implementation.\\n    /// @param _allocator The allocator to check\\n    /// @return Whether the allocator is valid or not\\n    function isValidAllocator(address _allocator) external view returns (bool);\\n\\n    /// @notice whether pool is active.\\n    /// @return Whether the pool is active or not\\n    function isPoolActive() external returns (bool);\\n\\n    /// @notice Checks the amount of tokens in the pool.\\n    /// @return The balance of the pool\\n    function getPoolAmount() external view returns (uint256);\\n\\n    /// @notice Increases the balance of the pool.\\n    /// @param _amount The amount to increase the pool by\\n    function increasePoolAmount(uint256 _amount) external;\\n\\n    /// @notice Checks the status of a recipient probably tracked in a mapping, but will depend on the implementation\\n    ///      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those\\n    ///      since there is no need for Pending or Rejected.\\n    /// @param _recipientId The ID of the recipient\\n    /// @return The status of the recipient\\n    function getRecipientStatus(address _recipientId) external view returns (Status);\\n\\n    /// @notice Checks the amount allocated to a recipient for distribution.\\n    /// @dev Input the values you would send to distribute(), get the amounts each recipient in the array would receive.\\n    ///      The encoded '_data' will be determined by the strategy, and will be used to determine the payout.\\n    /// @param _recipientIds The IDs of the recipients\\n    /// @param _data The encoded data\\n    function getPayouts(address[] memory _recipientIds, bytes[] memory _data)\\n        external\\n        view\\n        returns (PayoutSummary[] memory);\\n\\n    /// ======================\\n    /// ===== Functions ======\\n    /// ======================\\n\\n    /// @notice\\n    /// @dev The default BaseStrategy version will not use the data  if a strategy wants to use it, they will overwrite it,\\n    ///      use it, and then call super.initialize().\\n    /// @param _poolId The ID of the pool\\n    /// @param _data The encoded data\\n    function initialize(uint256 _poolId, bytes memory _data) external;\\n\\n    /// @notice This will register a recipient, set their status (and any other strategy specific values), and\\n    ///         return the ID of the recipient.\\n    /// @dev Able to change status all the way up to 'Accepted', or to 'Pending' and if there are more steps, additional\\n    ///      functions should be added to allow the owner to check this. The owner could also check attestations directly\\n    ///      and then accept for instance. The '_data' will be determined by the strategy implementation.\\n    /// @param _data The data to use to register the recipient\\n    /// @param _sender The address of the sender\\n    /// @return The ID of the recipient\\n    function registerRecipient(bytes memory _data, address _sender) external payable returns (address);\\n\\n    /// @notice This will allocate to a recipient.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\\n    /// @param _data The data to use to allocate to the recipient\\n    /// @param _sender The address of the sender\\n    function allocate(bytes memory _data, address _sender) external payable;\\n\\n    /// @notice This will distribute funds (tokens) to recipients.\\n    /// @dev most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference\\n    /// this contract will need to track the amount paid already, so that it doesn't double pay.\\n    function distribute(address[] memory _recipientIds, bytes memory _data, address _sender) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Errors\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @KurtMerbeth <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>\\n/// @notice Library containing all custom errors the protocol may revert with.\\ncontract Errors {\\n    /// ======================\\n    /// ====== Generic =======\\n    /// ======================\\n\\n    /// @notice Thrown as a general error when input / data is invalid\\n    error INVALID();\\n\\n    /// @notice Thrown when mismatch in decoding data\\n    error MISMATCH();\\n\\n    /// @notice Thrown when not enough funds are available\\n    error NOT_ENOUGH_FUNDS();\\n\\n    /// @notice Thrown when user is not authorized\\n    error UNAUTHORIZED();\\n\\n    /// @notice Thrown when address is the zero address\\n    error ZERO_ADDRESS();\\n\\n    /// @notice Thrown when the function is not implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @notice Thrown when the value is non-zero\\n    error NON_ZERO_VALUE();\\n\\n    /// ======================\\n    /// ====== Registry ======\\n    /// ======================\\n\\n    /// @dev Thrown when the nonce passed has been used or not available\\n    error NONCE_NOT_AVAILABLE();\\n\\n    /// @dev Thrown when the 'msg.sender' is not the pending owner on ownership transfer\\n    error NOT_PENDING_OWNER();\\n\\n    /// @dev Thrown if the anchor creation fails\\n    error ANCHOR_ERROR();\\n\\n    /// ======================\\n    /// ======== Allo ========\\n    /// ======================\\n\\n    /// @notice Thrown when the strategy is not approved\\n    error NOT_APPROVED_STRATEGY();\\n\\n    /// @notice Thrown when the strategy is approved and should be cloned\\n    error IS_APPROVED_STRATEGY();\\n\\n    /// @notice Thrown when the fee is below 1e18 which is the fee percentage denominator\\n    error INVALID_FEE();\\n\\n    /// ======================\\n    /// ===== IStrategy ======\\n    /// ======================\\n\\n    /// @notice Thrown when data is already intialized\\n    error ALREADY_INITIALIZED();\\n\\n    /// @notice Thrown when data is yet to be initialized\\n    error NOT_INITIALIZED();\\n\\n    /// @notice Thrown when an invalid address is used\\n    error INVALID_ADDRESS();\\n\\n    /// @notice Thrown when a pool is inactive\\n    error POOL_INACTIVE();\\n\\n    /// @notice Thrown when a pool is already active\\n    error POOL_ACTIVE();\\n\\n    /// @notice Thrown when two arrays length are not equal\\n    error ARRAY_MISMATCH();\\n\\n    /// @notice Thrown when the registration is invalid.\\n    error INVALID_REGISTRATION();\\n\\n    /// @notice Thrown when the metadata is invalid.\\n    error INVALID_METADATA();\\n\\n    /// @notice Thrown when the recipient is not accepted.\\n    error RECIPIENT_NOT_ACCEPTED();\\n\\n    /// @notice Thrown when recipient is already accepted.\\n    error RECIPIENT_ALREADY_ACCEPTED();\\n\\n    /// @notice Thrown when registration is not active.\\n    error REGISTRATION_NOT_ACTIVE();\\n\\n    /// @notice Thrown when registration is active.\\n    error REGISTRATION_ACTIVE();\\n\\n    /// @notice Thrown when there is an error in recipient.\\n    error RECIPIENT_ERROR(address recipientId);\\n\\n    /// @notice Thrown when the allocation is not active.\\n    error ALLOCATION_NOT_ACTIVE();\\n\\n    /// @notice Thrown when the allocation is not ended.\\n    error ALLOCATION_NOT_ENDED();\\n\\n    /// @notice Thrown when the allocation is active.\\n    error ALLOCATION_ACTIVE();\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Metadata\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice Metadata is used to define the metadata for the protocol that is used throughout the system.\\nstruct Metadata {\\n    /// @notice Protocol ID corresponding to a specific protocol (currently using IPFS = 1)\\n    uint256 protocol;\\n    /// @notice Pointer (hash) to fetch metadata for the specified protocol\\n    string pointer;\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/Native.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Native token information\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice This is used to define the address of the native token for the protocol\\ncontract Native {\\n    /// @notice Address of the native token\\n    address public constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n// External Libraries\\nimport {SafeTransferLib} from \\\"lib/solady/src/utils/SafeTransferLib.sol\\\";\\n// Internal Libraries\\nimport \\\"./Native.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Transfer contract\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice A helper contract to transfer tokens within Allo protocol\\n/// @dev Handles the transfer of tokens to an address\\ncontract Transfer is Native {\\n    /// @notice Thrown when the amount of tokens sent does not match the amount of tokens expected\\n    error AMOUNT_MISMATCH();\\n\\n    /// @notice This holds the details for a transfer\\n    struct TransferData {\\n        address from;\\n        address to;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Transfer an amount of a token to an array of addresses\\n    /// @param _token The address of the token\\n    /// @param _transferData TransferData[]\\n    /// @return Whether the transfer was successful or not\\n    function _transferAmountsFrom(address _token, TransferData[] memory _transferData)\\n        internal\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 msgValue = msg.value;\\n\\n        for (uint256 i; i < _transferData.length;) {\\n            TransferData memory transferData = _transferData[i];\\n\\n            if (_token == NATIVE) {\\n                msgValue -= transferData.amount;\\n                SafeTransferLib.safeTransferETH(transferData.to, transferData.amount);\\n            } else {\\n                SafeTransferLib.safeTransferFrom(_token, transferData.from, transferData.to, transferData.amount);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (msgValue != 0) revert AMOUNT_MISMATCH();\\n\\n        return true;\\n    }\\n\\n    /// @notice Transfer an amount of a token to an address\\n    /// @param _token The address of the token\\n    /// @param _transferData Individual TransferData\\n    /// @return Whether the transfer was successful or not\\n    function _transferAmountFrom(address _token, TransferData memory _transferData) internal virtual returns (bool) {\\n        uint256 amount = _transferData.amount;\\n        if (_token == NATIVE) {\\n            // Native Token\\n            if (msg.value < amount) revert AMOUNT_MISMATCH();\\n\\n            SafeTransferLib.safeTransferETH(_transferData.to, amount);\\n        } else {\\n            SafeTransferLib.safeTransferFrom(_token, _transferData.from, _transferData.to, amount);\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Transfer an amount of a token to an address\\n    /// @param _token The token to transfer\\n    /// @param _to The address to transfer to\\n    /// @param _amount The amount to transfer\\n    function _transferAmount(address _token, address _to, uint256 _amount) internal virtual {\\n        if (_token == NATIVE) {\\n            SafeTransferLib.safeTransferETH(_to, _amount);\\n        } else {\\n            SafeTransferLib.safeTransfer(_token, _to, _amount);\\n        }\\n    }\\n\\n    /// @notice Get the balance of a token for an account\\n    /// @param _token The token to get the balance of\\n    /// @param _account The account to get the balance for\\n    /// @return The balance of the token for the account\\n    function _getBalance(address _token, address _account) internal view returns (uint256) {\\n        if (_token == NATIVE) {\\n            return payable(_account).balance;\\n        } else {\\n            return SafeTransferLib.balanceOf(_token, _account);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/strategies/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n// Interfaces\\nimport \\\"../core/interfaces/IStrategy.sol\\\";\\n\\n// Libraries\\nimport {Transfer} from \\\"../core/libraries/Transfer.sol\\\";\\nimport {Errors} from \\\"../core/libraries/Errors.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title BaseStrategy Contract\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice This contract is the base contract for all strategies\\n/// @dev This contract is implemented by all strategies.\\nabstract contract BaseStrategy is IStrategy, Transfer, Errors {\\n    /// ==========================\\n    /// === Storage Variables ====\\n    /// ==========================\\n\\n    IAllo internal immutable allo;\\n    bytes32 internal immutable strategyId;\\n    bool internal poolActive;\\n    uint256 internal poolId;\\n    uint256 internal poolAmount;\\n\\n    /// ====================================\\n    /// ========== Constructor =============\\n    /// ====================================\\n\\n    /// @notice Constructor to set the Allo contract and \\\"strategyId'.\\n    /// @param _allo Address of the Allo contract.\\n    /// @param _name Name of the strategy\\n    constructor(address _allo, string memory _name) {\\n        allo = IAllo(_allo);\\n        strategyId = keccak256(abi.encode(_name));\\n    }\\n\\n    /// ====================================\\n    /// =========== Modifiers ==============\\n    /// ====================================\\n\\n    /// @notice Modifier to check if the 'msg.sender' is the Allo contract.\\n    /// @dev Reverts if the 'msg.sender' is not the Allo contract.\\n    modifier onlyAllo() {\\n        _checkOnlyAllo();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the '_sender' is a pool manager.\\n    /// @dev Reverts if the '_sender' is not a pool manager.\\n    /// @param _sender The address to check if they are a pool manager\\n    modifier onlyPoolManager(address _sender) {\\n        _checkOnlyPoolManager(_sender);\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the pool is active.\\n    /// @dev Reverts if the pool is not active.\\n    modifier onlyActivePool() {\\n        _checkOnlyActivePool();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the pool is inactive.\\n    /// @dev Reverts if the pool is active.\\n    modifier onlyInactivePool() {\\n        _checkInactivePool();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the pool is initialized.\\n    /// @dev Reverts if the pool is not initialized.\\n    modifier onlyInitialized() {\\n        _checkOnlyInitialized();\\n        _;\\n    }\\n\\n    /// ================================\\n    /// =========== Views ==============\\n    /// ================================\\n\\n    /// @notice Getter for the 'Allo' contract.\\n    /// @return The Allo contract\\n    function getAllo() external view override returns (IAllo) {\\n        return allo;\\n    }\\n\\n    /// @notice Getter for the 'poolId'.\\n    /// @return The ID of the pool\\n    function getPoolId() external view override returns (uint256) {\\n        return poolId;\\n    }\\n\\n    /// @notice Getter for the 'strategyId'.\\n    /// @return The ID of the strategy\\n    function getStrategyId() external view override returns (bytes32) {\\n        return strategyId;\\n    }\\n\\n    /// @notice Getter for the 'poolAmount'.\\n    /// @return The balance of the pool\\n    function getPoolAmount() external view virtual override returns (uint256) {\\n        return poolAmount;\\n    }\\n\\n    /// @notice Getter for whether or not the pool is active.\\n    /// @return 'true' if the pool is active, otherwise 'false'\\n    function isPoolActive() external view override returns (bool) {\\n        return _isPoolActive();\\n    }\\n\\n    /// @notice Getter for the status of a recipient.\\n    /// @param _recipientId The ID of the recipient\\n    /// @return The status of the recipient\\n    function getRecipientStatus(address _recipientId) external view virtual returns (Status) {\\n        return _getRecipientStatus(_recipientId);\\n    }\\n\\n    /// ====================================\\n    /// =========== Functions ==============\\n    /// ====================================\\n\\n    /// @notice Initializes the 'Basetrategy'.\\n    /// @dev Will revert if the poolId is invalid or already initialized\\n    /// @param _poolId ID of the pool\\n    function __BaseStrategy_init(uint256 _poolId) internal virtual onlyAllo {\\n        // check if pool ID is not initialized already, if it is, revert\\n        if (poolId != 0) revert ALREADY_INITIALIZED();\\n\\n        // check if pool ID is valid and not zero (0), if it is, revert\\n        if (_poolId == 0) revert INVALID();\\n        poolId = _poolId;\\n    }\\n\\n    /// @notice Increases the pool amount.\\n    /// @dev Increases the 'poolAmount' by '_amount'. Only 'Allo' contract can call this.\\n    /// @param _amount The amount to increase the pool by\\n    function increasePoolAmount(uint256 _amount) external override onlyAllo {\\n        _beforeIncreasePoolAmount(_amount);\\n        poolAmount += _amount;\\n        _afterIncreasePoolAmount(_amount);\\n    }\\n\\n    /// @notice Registers a recipient.\\n    /// @dev Registers a recipient and returns the ID of the recipient. The encoded '_data' will be determined by the\\n    ///      strategy implementation. Only 'Allo' contract can call this when it is initialized.\\n    /// @param _data The data to use to register the recipient\\n    /// @param _sender The address of the sender\\n    /// @return recipientId The recipientId\\n    function registerRecipient(bytes memory _data, address _sender)\\n        external\\n        payable\\n        onlyAllo\\n        onlyInitialized\\n        returns (address recipientId)\\n    {\\n        _beforeRegisterRecipient(_data, _sender);\\n        recipientId = _registerRecipient(_data, _sender);\\n        _afterRegisterRecipient(_data, _sender);\\n    }\\n\\n    /// @notice Allocates to a recipient.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation. Only 'Allo' contract can\\n    ///      call this when it is initialized.\\n    /// @param _data The data to use to allocate to the recipient\\n    /// @param _sender The address of the sender\\n    function allocate(bytes memory _data, address _sender) external payable onlyAllo onlyInitialized {\\n        _beforeAllocate(_data, _sender);\\n        _allocate(_data, _sender);\\n        _afterAllocate(_data, _sender);\\n    }\\n\\n    /// @notice Distributes funds (tokens) to recipients.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation. Only 'Allo' contract can\\n    ///      call this when it is initialized.\\n    /// @param _recipientIds The IDs of the recipients\\n    /// @param _data The data to use to distribute to the recipients\\n    /// @param _sender The address of the sender\\n    function distribute(address[] memory _recipientIds, bytes memory _data, address _sender)\\n        external\\n        onlyAllo\\n        onlyInitialized\\n    {\\n        _beforeDistribute(_recipientIds, _data, _sender);\\n        _distribute(_recipientIds, _data, _sender);\\n        _afterDistribute(_recipientIds, _data, _sender);\\n    }\\n\\n    /// @notice Gets the payout summary for recipients.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\\n    /// @param _recipientIds The IDs of the recipients\\n    /// @param _data The data to use to get the payout summary for the recipients\\n    /// @return The payout summary for the recipients\\n    function getPayouts(address[] memory _recipientIds, bytes[] memory _data)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (PayoutSummary[] memory)\\n    {\\n        uint256 recipientLength = _recipientIds.length;\\n        // check if the length of the recipient IDs and data arrays are equal, if they are not, revert\\n        if (recipientLength != _data.length) revert ARRAY_MISMATCH();\\n\\n        PayoutSummary[] memory payouts = new PayoutSummary[](recipientLength);\\n        for (uint256 i; i < recipientLength;) {\\n            payouts[i] = _getPayout(_recipientIds[i], _data[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return payouts;\\n    }\\n\\n    /// @notice Checks if the '_allocator' is a valid allocator.\\n    /// @dev How the allocator is determined is up to the strategy implementation.\\n    /// @param _allocator The address to check if it is a valid allocator for the strategy.\\n    /// @return 'true' if the address is a valid allocator, 'false' otherwise\\n    function isValidAllocator(address _allocator) external view virtual override returns (bool) {\\n        return _isValidAllocator(_allocator);\\n    }\\n\\n    /// ====================================\\n    /// ============ Internal ==============\\n    /// ====================================\\n\\n    /// @notice Checks if the 'msg.sender' is the Allo contract.\\n    /// @dev Reverts if the 'msg.sender' is not the Allo contract.\\n    function _checkOnlyAllo() internal view {\\n        if (msg.sender != address(allo)) revert UNAUTHORIZED();\\n    }\\n\\n    /// @notice Checks if the '_sender' is a pool manager.\\n    /// @dev Reverts if the '_sender' is not a pool manager.\\n    /// @param _sender The address to check if they are a pool manager\\n    function _checkOnlyPoolManager(address _sender) internal view {\\n        if (!allo.isPoolManager(poolId, _sender)) revert UNAUTHORIZED();\\n    }\\n\\n    /// @notice Checks if the pool is active.\\n    /// @dev Reverts if the pool is not active.\\n    function _checkOnlyActivePool() internal view {\\n        if (!poolActive) revert POOL_INACTIVE();\\n    }\\n\\n    /// @notice Checks if the pool is inactive.\\n    /// @dev Reverts if the pool is active.\\n    function _checkInactivePool() internal view {\\n        if (poolActive) revert POOL_ACTIVE();\\n    }\\n\\n    /// @notice Checks if the pool is initialized.\\n    /// @dev Reverts if the pool is not initialized.\\n    function _checkOnlyInitialized() internal view {\\n        if (poolId == 0) revert NOT_INITIALIZED();\\n    }\\n\\n    /// @notice Set the pool to active or inactive status.\\n    /// @dev This will emit a 'PoolActive()' event. Used by the strategy implementation.\\n    /// @param _active The status to set, 'true' means active, 'false' means inactive\\n    function _setPoolActive(bool _active) internal {\\n        poolActive = _active;\\n        emit PoolActive(_active);\\n    }\\n\\n    /// @notice Checks if the pool is active.\\n    /// @dev Used by the strategy implementation.\\n    /// @return 'true' if the pool is active, otherwise 'false'\\n    function _isPoolActive() internal view virtual returns (bool) {\\n        return poolActive;\\n    }\\n\\n    /// @notice Checks if the allocator is valid\\n    /// @param _allocator The allocator address\\n    /// @return 'true' if the allocator is valid, otherwise 'false'\\n    function _isValidAllocator(address _allocator) internal view virtual returns (bool);\\n\\n    /// @notice This will register a recipient, set their status (and any other strategy specific values), and\\n    ///         return the ID of the recipient.\\n    /// @dev Able to change status all the way up to Accepted, or to Pending and if there are more steps, additional\\n    ///      functions should be added to allow the owner to check this. The owner could also check attestations directly\\n    ///      and then Accept for instance.\\n    /// @param _data The data to use to register the recipient\\n    /// @param _sender The address of the sender\\n    /// @return The ID of the recipient\\n    function _registerRecipient(bytes memory _data, address _sender) internal virtual returns (address);\\n\\n    /// @notice This will allocate to a recipient.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\\n    /// @param _data The data to use to allocate to the recipient\\n    /// @param _sender The address of the sender\\n    function _allocate(bytes memory _data, address _sender) internal virtual;\\n\\n    /// @notice This will distribute funds (tokens) to recipients.\\n    /// @dev most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference\\n    /// this contract will need to track the amount paid already, so that it doesn't double pay.\\n    /// @param _recipientIds The ids of the recipients to distribute to\\n    /// @param _data Data required will depend on the strategy implementation\\n    /// @param _sender The address of the sender\\n    function _distribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual;\\n\\n    /// @notice This will get the payout summary for a recipient.\\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\\n    /// @param _recipientId The ID of the recipient\\n    /// @param _data The data to use to get the payout summary for the recipient\\n    /// @return The payout summary for the recipient\\n    function _getPayout(address _recipientId, bytes memory _data)\\n        internal\\n        view\\n        virtual\\n        returns (PayoutSummary memory);\\n\\n    /// @notice This will get the status of a recipient.\\n    /// @param _recipientId The ID of the recipient\\n    /// @return The status of the recipient\\n    function _getRecipientStatus(address _recipientId) internal view virtual returns (Status);\\n\\n    /// ===================================\\n    /// ============== Hooks ==============\\n    /// ===================================\\n\\n    /// @notice Hook called before increasing the pool amount.\\n    /// @param _amount The amount to increase the pool by\\n    function _beforeIncreasePoolAmount(uint256 _amount) internal virtual {}\\n\\n    /// @notice Hook called after increasing the pool amount.\\n    /// @param _amount The amount to increase the pool by\\n    function _afterIncreasePoolAmount(uint256 _amount) internal virtual {}\\n\\n    /// @notice Hook called before registering a recipient.\\n    /// @param _data The data to use to register the recipient\\n    /// @param _sender The address of the sender\\n    function _beforeRegisterRecipient(bytes memory _data, address _sender) internal virtual {}\\n\\n    /// @notice Hook called after registering a recipient.\\n    /// @param _data The data to use to register the recipient\\n    /// @param _sender The address of the sender\\n    function _afterRegisterRecipient(bytes memory _data, address _sender) internal virtual {}\\n\\n    /// @notice Hook called before allocating to a recipient.\\n    /// @param _data The data to use to allocate to the recipient\\n    /// @param _sender The address of the sender\\n    function _beforeAllocate(bytes memory _data, address _sender) internal virtual {}\\n\\n    /// @notice Hook called after allocating to a recipient.\\n    /// @param _data The data to use to allocate to the recipient\\n    /// @param _sender The address of the sender\\n    function _afterAllocate(bytes memory _data, address _sender) internal virtual {}\\n\\n    /// @notice Hook called before distributing funds (tokens) to recipients.\\n    /// @param _recipientIds The IDs of the recipients\\n    /// @param _data The data to use to distribute to the recipients\\n    /// @param _sender The address of the sender\\n    function _beforeDistribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual {}\\n\\n    /// @notice Hook called after distributing funds (tokens) to recipients.\\n    /// @param _recipientIds The IDs of the recipients\\n    /// @param _data The data to use to distribute to the recipients\\n    /// @param _sender The address of the sender\\n    function _afterDistribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n// External Libraries\\nimport {ISignatureTransfer} from \\\"lib/permit2/src/interfaces/ISignatureTransfer.sol\\\";\\nimport {MerkleProof} from \\\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport {Multicall} from \\\"lib/openzeppelin-contracts/contracts/utils/Multicall.sol\\\";\\n// Interfaces\\nimport {IAllo} from \\\"../../core/interfaces/IAllo.sol\\\";\\nimport {IRegistry} from \\\"../../core/interfaces/IRegistry.sol\\\";\\n// Core Contracts\\nimport {BaseStrategy} from \\\"../BaseStrategy.sol\\\";\\n// Internal Libraries\\nimport {Metadata} from \\\"../../core/libraries/Metadata.sol\\\";\\nimport {Native} from \\\"../../core/libraries/Native.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n\\n/// @title Donation Voting Merkle Distribution Strategy\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice Strategy for donation voting allocation with a merkle distribution\\nabstract contract DonationVotingMerkleDistributionBaseStrategy is Native, BaseStrategy, Multicall {\\n    /// ================================\\n    /// ========== Struct ==============\\n    /// ================================\\n\\n    /// @notice Struct to hold details of the application status\\n    /// @dev Application status is stored in a bitmap. Each 4 bits represents the status of a recipient,\\n    /// defined as 'index' here. The first 4 bits of the 256 bits represent the status of the first recipient,\\n    /// the second 4 bits represent the status of the second recipient, and so on.\\n    ///\\n    /// The 'rowIndex' is the index of the row in the bitmap, and the 'statusRow' is the value of the row.\\n    /// The 'statusRow' is updated when the status of a recipient changes.\\n    ///\\n    /// Note: Since we need 4 bits to store a status, one row of the bitmap can hold the status information of 256/4 recipients.\\n    ///\\n    /// For example, if we have 5 recipients, the bitmap will look like this:\\n    /// | recipient1 | recipient2 | recipient3 | recipient4 | recipient5 | 'rowIndex'\\n    /// |     0000   |    0001    |    0010    |    0011    |    0100    | 'statusRow'\\n    /// |     none   |   pending  |  accepted  |  rejected  |  appealed  | converted status (0, 1, 2, 3, 4)\\n    ///\\n    struct ApplicationStatus {\\n        uint256 index;\\n        uint256 statusRow;\\n    }\\n\\n    /// @notice Stores the details of the recipients.\\n    struct Recipient {\\n        // If false, the recipientAddress is the anchor of the profile\\n        bool useRegistryAnchor;\\n        address recipientAddress;\\n        Metadata metadata;\\n    }\\n\\n    /// @notice Stores the details of the distribution.\\n    struct Distribution {\\n        uint256 index;\\n        address recipientId;\\n        uint256 amount;\\n        bytes32[] merkleProof;\\n    }\\n\\n    /// @notice Stores the initialize data for the strategy\\n    struct InitializeData {\\n        bool useRegistryAnchor;\\n        bool metadataRequired;\\n        uint64 registrationStartTime;\\n        uint64 registrationEndTime;\\n        uint64 allocationStartTime;\\n        uint64 allocationEndTime;\\n        address[] allowedTokens;\\n    }\\n\\n    enum PermitType {\\n        None,\\n        Permit,\\n        PermitDAI,\\n        Permit2\\n    }\\n\\n    /// @notice Stores the permit2 data for the allocation\\n    struct Permit2Data {\\n        ISignatureTransfer.PermitTransferFrom permit;\\n        bytes signature;\\n    }\\n\\n    /// ===============================\\n    /// ========== Events =============\\n    /// ===============================\\n\\n    /// @notice Emitted when a recipient updates their registration\\n    /// @param recipientId Id of the recipient\\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\\n    /// @param sender The sender of the transaction\\n    /// @param status The updated status of the recipient\\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, uint8 status);\\n\\n    /// @notice Emitted when a recipient is registered and the status is updated\\n    /// @param rowIndex The index of the row in the bitmap\\n    /// @param fullRow The value of the row\\n    /// @param sender The sender of the transaction\\n    event RecipientStatusUpdated(uint256 indexed rowIndex, uint256 fullRow, address sender);\\n\\n    /// @notice Emitted when the timestamps are updated\\n    /// @param registrationStartTime The start time for the registration\\n    /// @param registrationEndTime The end time for the registration\\n    /// @param allocationStartTime The start time for the allocation\\n    /// @param allocationEndTime The end time for the allocation\\n    /// @param sender The sender of the transaction\\n    event TimestampsUpdated(\\n        uint64 registrationStartTime,\\n        uint64 registrationEndTime,\\n        uint64 allocationStartTime,\\n        uint64 allocationEndTime,\\n        address sender\\n    );\\n\\n    /// @notice Emitted when the distribution has been updated with a new merkle root or metadata\\n    /// @param merkleRoot The merkle root of the distribution\\n    /// @param metadata The metadata of the distribution\\n    event DistributionUpdated(bytes32 merkleRoot, Metadata metadata);\\n\\n    /// @notice Emitted when funds are distributed to a recipient\\n    /// @param amount The amount of tokens distributed\\n    /// @param grantee The address of the recipient\\n    /// @param token The address of the token\\n    /// @param recipientId The id of the recipient\\n    event FundsDistributed(uint256 amount, address grantee, address indexed token, address indexed recipientId);\\n\\n    /// @notice Emitted when a batch payout is successful\\n    /// @param sender The sender of the transaction\\n    event BatchPayoutSuccessful(address indexed sender);\\n\\n    /// @notice Emitted when a recipient is allocated funds\\n    /// @param recipientId The id of the recipient\\n    /// @param amount The amount of tokens allocated\\n    /// @param token The address of the token\\n    /// @param sender The sender of the transaction\\n    /// @param origin The original sender of the transaction\\n    event Allocated(address indexed recipientId, uint256 amount, address token, address sender, address origin);\\n\\n    /// ================================\\n    /// ========== Storage =============\\n    /// ================================\\n\\n    /// @notice Metadata containing the distribution data.\\n    Metadata public distributionMetadata;\\n\\n    /// @notice Flag to indicate whether to use the registry anchor or not.\\n    bool public useRegistryAnchor;\\n\\n    /// @notice Flag to indicate whether metadata is required or not.\\n    bool public metadataRequired;\\n\\n    /// @notice Flag to indicate whether the distribution has started or not.\\n    bool public distributionStarted;\\n\\n    /// @notice The timestamps in seconds for the start and end times.\\n    uint64 public registrationStartTime;\\n    uint64 public registrationEndTime;\\n    uint64 public allocationStartTime;\\n    uint64 public allocationEndTime;\\n\\n    /// @notice The total amount of tokens allocated to the payout.\\n    uint256 public totalPayoutAmount;\\n\\n    /// @notice The total number of recipients.\\n    uint256 public recipientsCounter;\\n\\n    /// @notice The registry contract interface.\\n    IRegistry private _registry;\\n\\n    /// @notice the permit2 interface\\n    ISignatureTransfer public immutable PERMIT2;\\n\\n    /// @notice The merkle root of the distribution will be set by the pool manager.\\n    bytes32 public merkleRoot;\\n\\n    /// @notice This is a packed array of booleans, 'statuses[0]' is the first row of the bitmap and allows to\\n    /// store 256 bits to describe the status of 256 projects. 'statuses[1]' is the second row, and so on\\n    /// Instead of using 1 bit for each recipient status, we will use 4 bits for each status\\n    /// to allow 5 statuses:\\n    /// 0: none\\n    /// 1: pending\\n    /// 2: accepted\\n    /// 3: rejected\\n    /// 4: appealed\\n    /// Since it's a mapping the storage it's pre-allocated with zero values, so if we check the\\n    /// status of an existing recipient, the value is by default 0 (none).\\n    /// If we want to check the status of an recipient, we take its index from the `recipients` array\\n    /// and convert it to the 2-bits position in the bitmap.\\n    mapping(uint256 => uint256) public statusesBitMap;\\n\\n    /// @notice 'recipientId' => 'statusIndex'\\n    /// @dev 'statusIndex' is the index of the recipient in the 'statusesBitMap' bitmap.\\n    mapping(address => uint256) public recipientToStatusIndexes;\\n\\n    /// @notice This is a packed array of booleans to keep track of claims distributed.\\n    /// @dev distributedBitMap[0] is the first row of the bitmap and allows to store 256 bits to describe\\n    /// the status of 256 claims\\n    mapping(uint256 => uint256) private distributedBitMap;\\n\\n    /// @notice 'token' address => boolean (allowed = true).\\n    /// @dev This can be updated by the pool manager.\\n    mapping(address => bool) public allowedTokens;\\n\\n    /// @notice 'recipientId' => 'Recipient' struct.\\n    mapping(address => Recipient) internal _recipients;\\n\\n    /// ================================\\n    /// ========== Modifier ============\\n    /// ================================\\n\\n    /// @notice Modifier to check if the registration is active\\n    /// @dev This will revert if the registration has not started or if the registration has ended.\\n    modifier onlyActiveRegistration() {\\n        _checkOnlyActiveRegistration();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the allocation is active\\n    /// @dev This will revert if the allocation has not started or if the allocation has ended.\\n    modifier onlyActiveAllocation() {\\n        _checkOnlyActiveAllocation();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the allocation has ended\\n    /// @dev This will revert if the allocation has not ended.\\n    modifier onlyAfterAllocation() {\\n        _checkOnlyAfterAllocation();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the allocation has ended\\n    /// @dev This will revert if the allocation has ended.\\n    modifier onlyBeforeAllocationEnds() {\\n        _checkOnlyBeforeAllocationEnds();\\n        _;\\n    }\\n\\n    /// ===============================\\n    /// ======== Constructor ==========\\n    /// ===============================\\n\\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\\n    /// @param _allo The 'Allo' contract\\n    /// @param _name The name of the strategy\\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2) BaseStrategy(_allo, _name) {\\n        if (address(_permit2) == address(0)) revert ZERO_ADDRESS();\\n        PERMIT2 = _permit2;\\n    }\\n\\n    /// ===============================\\n    /// ========= Initialize ==========\\n    /// ===============================\\n\\n    /// @notice Initializes the strategy\\n    /// @dev This will revert if the strategy is already initialized and 'msg.sender' is not the 'Allo' contract.\\n    /// @param _poolId The 'poolId' to initialize\\n    /// @param _data The data to be decoded to initialize the strategy\\n    /// @custom:data InitializeData(bool _useRegistryAnchor, bool _metadataRequired, uint64 _registrationStartTime,\\n    ///               uint64 _registrationEndTime, uint64 _allocationStartTime, uint64 _allocationEndTime,\\n    ///               address[] memory _allowedTokens)\\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\\n        InitializeData memory initializeData = abi.decode(_data, (InitializeData));\\n        __DonationVotingStrategy_init(_poolId, initializeData);\\n        emit Initialized(_poolId, _data);\\n    }\\n\\n    /// @notice Initializes this strategy as well as the BaseStrategy.\\n    /// @dev This will revert if the strategy is already initialized. Emits a 'TimestampsUpdated()' event.\\n    /// @param _poolId The 'poolId' to initialize\\n    /// @param _initializeData The data to be decoded to initialize the strategy\\n    function __DonationVotingStrategy_init(uint256 _poolId, InitializeData memory _initializeData) internal {\\n        // Initialize the BaseStrategy with the '_poolId'\\n        __BaseStrategy_init(_poolId);\\n\\n        // Initialize required values\\n        useRegistryAnchor = _initializeData.useRegistryAnchor;\\n        metadataRequired = _initializeData.metadataRequired;\\n        _registry = allo.getRegistry();\\n\\n        // Set the updated timestamps\\n        registrationStartTime = _initializeData.registrationStartTime;\\n        registrationEndTime = _initializeData.registrationEndTime;\\n        allocationStartTime = _initializeData.allocationStartTime;\\n        allocationEndTime = _initializeData.allocationEndTime;\\n\\n        recipientsCounter = 1;\\n\\n        // If the timestamps are invalid this will revert - See details in '_isPoolTimestampValid'\\n        _isPoolTimestampValid(registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime);\\n\\n        // Emit that the timestamps have been updated with the updated values\\n        emit TimestampsUpdated(\\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\\n        );\\n\\n        uint256 allowedTokensLength = _initializeData.allowedTokens.length;\\n\\n        // If the length of the allowed tokens is zero, we will allow all tokens\\n        if (allowedTokensLength == 0) {\\n            // all tokens\\n            allowedTokens[address(0)] = true;\\n        }\\n\\n        // Loop through the allowed tokens and set them to true\\n        for (uint256 i; i < allowedTokensLength;) {\\n            allowedTokens[_initializeData.allowedTokens[i]] = true;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /// ===============================\\n    /// ============ Views ============\\n    /// ===============================\\n\\n    /// @notice Get a recipient with a '_recipientId'\\n    /// @param _recipientId ID of the recipient\\n    /// @return recipient The recipient details\\n    function getRecipient(address _recipientId) external view returns (Recipient memory recipient) {\\n        return _getRecipient(_recipientId);\\n    }\\n\\n    /// @notice Get recipient status\\n    /// @dev This will return the 'Status' of the recipient, the 'Status' is used at the strategy\\n    ///      level and is different from the 'Status' which is used at the protocol level\\n    /// @param _recipientId ID of the recipient\\n    /// @return Status of the recipient\\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\\n        return Status(_getUintRecipientStatus(_recipientId));\\n    }\\n\\n    /// ===============================\\n    /// ======= External/Custom =======\\n    /// ===============================\\n\\n    /// @notice Sets recipient statuses.\\n    /// @dev The statuses are stored in a bitmap of 4 bits for each recipient. The first 4 bits of the 256 bits represent\\n    ///      the status of the first recipient, the second 4 bits represent the status of the second recipient, and so on.\\n    ///      'msg.sender' must be a pool manager and the registration must be active.\\n    /// Statuses:\\n    /// - 0: none\\n    /// - 1: pending\\n    /// - 2: accepted\\n    /// - 3: rejected\\n    /// - 4: appealed\\n    /// Emits the RecipientStatusUpdated() event.\\n    /// @param statuses new statuses\\n    /// @param refRecipientsCounter the recipientCounter the transaction is based on\\n    function reviewRecipients(ApplicationStatus[] memory statuses, uint256 refRecipientsCounter)\\n        external\\n        onlyBeforeAllocationEnds\\n        onlyPoolManager(msg.sender)\\n    {\\n        if (refRecipientsCounter != recipientsCounter) revert INVALID();\\n        // Loop through the statuses and set the status\\n        for (uint256 i; i < statuses.length;) {\\n            uint256 rowIndex = statuses[i].index;\\n            uint256 fullRow = statuses[i].statusRow;\\n\\n            statusesBitMap[rowIndex] = fullRow;\\n\\n            // Emit that the recipient status has been updated with the values\\n            emit RecipientStatusUpdated(rowIndex, fullRow, msg.sender);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Sets the start and end dates.\\n    /// @dev The timestamps are in seconds for the start and end times. The 'msg.sender' must be a pool manager.\\n    ///      Emits a 'TimestampsUpdated()' event.\\n    /// @param _registrationStartTime The start time for the registration\\n    /// @param _registrationEndTime The end time for the registration\\n    /// @param _allocationStartTime The start time for the allocation\\n    /// @param _allocationEndTime The end time for the allocation\\n    function updatePoolTimestamps(\\n        uint64 _registrationStartTime,\\n        uint64 _registrationEndTime,\\n        uint64 _allocationStartTime,\\n        uint64 _allocationEndTime\\n    ) external onlyPoolManager(msg.sender) {\\n        // If the timestamps are invalid this will revert - See details in '_isPoolTimestampValid'\\n        _isPoolTimestampValid(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\\n\\n        // Set the updated timestamps\\n        registrationStartTime = _registrationStartTime;\\n        registrationEndTime = _registrationEndTime;\\n        allocationStartTime = _allocationStartTime;\\n        allocationEndTime = _allocationEndTime;\\n\\n        // Emit that the timestamps have been updated with the updated values\\n        emit TimestampsUpdated(\\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\\n        );\\n    }\\n\\n    /// @notice Withdraw funds from pool\\n    /// @dev This can only be called after the allocation has ended and 30 days have passed.\\n    /// @param _token The token to be withdrawn\\n    function withdraw(address _token) external onlyPoolManager(msg.sender) {\\n        if (block.timestamp <= allocationEndTime + 30 days) {\\n            revert INVALID();\\n        }\\n\\n        // get the actual balance hold by the pool\\n        uint256 amount = _getBalance(_token, address(this));\\n\\n        // get the token amount in vault which belong to the recipients\\n        uint256 tokenInVault = _tokenAmountInVault(_token);\\n\\n        // calculate the amount which is accessible\\n        uint256 accessableAmount = amount - tokenInVault;\\n\\n        // transfer the amount to the pool manager\\n        _transferAmount(_token, msg.sender, accessableAmount);\\n    }\\n\\n    /// @notice Internal function to return the token amount locked in vault\\n    /// @dev This function will return 0 if all funds are accessible\\n    /// @param _token The address of the token\\n    function _tokenAmountInVault(address _token) internal view virtual returns (uint256);\\n\\n    /// ==================================\\n    /// ============ Merkle ==============\\n    /// ==================================\\n\\n    /// @notice Invoked by round operator to update the merkle root and distribution Metadata.\\n    /// @dev This can only be called after the allocation has ended and 'msg.sender' must be a pool manager and allocation must have ended.\\n    ///      Emits a 'DistributionUpdated()' event.\\n    /// @param _merkleRoot The merkle root of the distribution\\n    /// @param _distributionMetadata The metadata of the distribution\\n    function updateDistribution(bytes32 _merkleRoot, Metadata memory _distributionMetadata)\\n        external\\n        onlyAfterAllocation\\n        onlyPoolManager(msg.sender)\\n    {\\n        // If the distribution has already started this will revert, you can only\\n        // update the distribution before it has started\\n        if (distributionStarted) {\\n            revert INVALID();\\n        }\\n\\n        merkleRoot = _merkleRoot;\\n        distributionMetadata = _distributionMetadata;\\n\\n        // Emit that the distribution has been updated\\n        emit DistributionUpdated(merkleRoot, distributionMetadata);\\n    }\\n\\n    /// @notice Checks if distribution is set.\\n    /// @return 'true' if distribution is set, otherwise 'false'\\n    function isDistributionSet() external view returns (bool) {\\n        return merkleRoot != \\\"\\\";\\n    }\\n\\n    /// @notice Utility function to check if distribution is done.\\n    /// @param _index index of the distribution\\n    /// @return 'true' if distribution is completed, otherwise 'false'\\n    function hasBeenDistributed(uint256 _index) external view returns (bool) {\\n        return _hasBeenDistributed(_index);\\n    }\\n\\n    /// ====================================\\n    /// ============ Internal ==============\\n    /// ====================================\\n\\n    /// @notice Checks if the registration is active and reverts if not.\\n    /// @dev This will revert if the registration has not started or if the registration has ended.\\n    function _checkOnlyActiveRegistration() internal view {\\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\\n            revert REGISTRATION_NOT_ACTIVE();\\n        }\\n    }\\n\\n    /// @notice Checks if the allocation is active and reverts if not.\\n    /// @dev This will revert if the allocation has not started or if the allocation has ended.\\n    function _checkOnlyActiveAllocation() internal view {\\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\\n            revert ALLOCATION_NOT_ACTIVE();\\n        }\\n    }\\n\\n    /// @notice Checks if the allocation has ended and reverts if not.\\n    /// @dev This will revert if the allocation has not ended.\\n    function _checkOnlyAfterAllocation() internal view {\\n        if (block.timestamp <= allocationEndTime) {\\n            revert ALLOCATION_NOT_ENDED();\\n        }\\n    }\\n\\n    /// @notice Checks if the allocation has not ended and reverts if it has.\\n    /// @dev This will revert if the allocation has ended.\\n    function _checkOnlyBeforeAllocationEnds() internal view {\\n        if (block.timestamp > allocationEndTime) {\\n            revert ALLOCATION_NOT_ACTIVE();\\n        }\\n    }\\n\\n    /// @notice Checks if address is eligible allocator.\\n    /// @return Always returns true for this strategy\\n    function _isValidAllocator(address) internal pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /// @notice Checks if the timestamps are valid.\\n    /// @dev This will revert if any of the timestamps are invalid. This is determined by the strategy\\n    /// and may vary from strategy to strategy. Checks if '_registrationStartTime' is greater than the '_registrationEndTime'\\n    /// or if '_registrationStartTime' is greater than the '_allocationStartTime' or if '_registrationEndTime'\\n    /// is greater than the '_allocationEndTime' or if '_allocationStartTime' is greater than the '_allocationEndTime'.\\n    /// If any of these conditions are true, this will revert.\\n    /// @param _registrationStartTime The start time for the registration\\n    /// @param _registrationEndTime The end time for the registration\\n    /// @param _allocationStartTime The start time for the allocation\\n    /// @param _allocationEndTime The end time for the allocation\\n    function _isPoolTimestampValid(\\n        uint64 _registrationStartTime,\\n        uint64 _registrationEndTime,\\n        uint64 _allocationStartTime,\\n        uint64 _allocationEndTime\\n    ) internal pure {\\n        if (\\n            _registrationStartTime > _registrationEndTime || _registrationStartTime > _allocationStartTime\\n                || _allocationStartTime > _allocationEndTime || _registrationEndTime > _allocationEndTime\\n        ) {\\n            revert INVALID();\\n        }\\n    }\\n\\n    /// @notice Checks whether a pool is active or not.\\n    /// @dev This will return true if the current 'block timestamp' is greater than or equal to the\\n    /// 'registrationStartTime' and less than or equal to the 'registrationEndTime'.\\n    /// @return 'true' if pool is active, otherwise 'false'\\n    function _isPoolActive() internal view override returns (bool) {\\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice Submit recipient to pool and set their status.\\n    /// @param _data The data to be decoded.\\n    /// @custom:data if 'useRegistryAnchor' is 'true' (address recipientId, address recipientAddress, Metadata metadata)\\n    /// @custom:data if 'useRegistryAnchor' is 'false' (address registryAnchor, address recipientAddress, Metadata metadata)\\n    /// @param _sender The sender of the transaction\\n    /// @return recipientId The ID of the recipient\\n    function _registerRecipient(bytes memory _data, address _sender)\\n        internal\\n        override\\n        onlyActiveRegistration\\n        returns (address recipientId)\\n    {\\n        bool isUsingRegistryAnchor;\\n        address recipientAddress;\\n        address registryAnchor;\\n        Metadata memory metadata;\\n\\n        // decode data custom to this strategy\\n        if (useRegistryAnchor) {\\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\\n\\n            // If the sender is not a profile member this will revert\\n            if (!_isProfileMember(recipientId, _sender)) {\\n                revert UNAUTHORIZED();\\n            }\\n        } else {\\n            (registryAnchor, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\\n\\n            // Set this to 'true' if the registry anchor is not the zero address\\n            isUsingRegistryAnchor = registryAnchor != address(0);\\n\\n            // If using the 'registryAnchor' we set the 'recipientId' to the 'registryAnchor', otherwise we set it to the 'msg.sender'\\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\\n\\n            // Checks if the '_sender' is a member of the profile 'anchor' being used and reverts if not\\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) {\\n                revert UNAUTHORIZED();\\n            }\\n        }\\n\\n        // If the metadata is required and the metadata is invalid this will revert\\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\\n            revert INVALID_METADATA();\\n        }\\n\\n        // If the recipient address is the zero address this will revert\\n        if (recipientAddress == address(0)) {\\n            revert RECIPIENT_ERROR(recipientId);\\n        }\\n\\n        // Get the recipient\\n        Recipient storage recipient = _recipients[recipientId];\\n\\n        // update the recipients data\\n        recipient.recipientAddress = recipientAddress;\\n        recipient.metadata = metadata;\\n        recipient.useRegistryAnchor = useRegistryAnchor ? true : isUsingRegistryAnchor;\\n\\n        if (recipientToStatusIndexes[recipientId] == 0) {\\n            // recipient registering new application\\n            recipientToStatusIndexes[recipientId] = recipientsCounter;\\n            _setRecipientStatus(recipientId, uint8(Status.Pending));\\n\\n            bytes memory extendedData = abi.encode(_data, recipientsCounter);\\n            emit Registered(recipientId, extendedData, _sender);\\n\\n            recipientsCounter++;\\n        } else {\\n            uint8 currentStatus = _getUintRecipientStatus(recipientId);\\n            if (currentStatus == uint8(Status.Accepted)) {\\n                // recipient updating accepted application\\n                _setRecipientStatus(recipientId, uint8(Status.Pending));\\n            } else if (currentStatus == uint8(Status.Rejected)) {\\n                // recipient updating rejected application\\n                _setRecipientStatus(recipientId, uint8(Status.Appealed));\\n            }\\n            emit UpdatedRegistration(recipientId, _data, _sender, _getUintRecipientStatus(recipientId));\\n        }\\n    }\\n\\n    /// @notice Distribute funds to recipients.\\n    /// @dev 'distributionStarted' will be set to 'true' when called. Only the pool manager can call.\\n    ///      Emits a 'BatchPayoutSuccessful()' event.\\n    /// @param _data The data to be decoded\\n    /// @custom:data '(Distribution[] distributions)'\\n    /// @param _sender The sender of the transaction\\n    function _distribute(address[] memory, bytes memory _data, address _sender)\\n        internal\\n        virtual\\n        override\\n        onlyPoolManager(_sender)\\n    {\\n        if (merkleRoot == \\\"\\\") revert INVALID();\\n\\n        if (!distributionStarted) {\\n            distributionStarted = true;\\n        }\\n\\n        // Decode the '_data' to get the distributions\\n        Distribution[] memory distributions = abi.decode(_data, (Distribution[]));\\n        uint256 length = distributions.length;\\n\\n        // Loop through the distributions and distribute the funds\\n        for (uint256 i; i < length;) {\\n            _distributeSingle(distributions[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // Emit that the batch payout was successful\\n        emit BatchPayoutSuccessful(_sender);\\n    }\\n\\n    /// @notice Allocate tokens to recipient.\\n    /// @dev This can only be called during the allocation period. Emts an 'Allocated()' event.\\n    /// @param _data The data to be decoded\\n    /// @custom:data (address recipientId, uint256 amount, address token)\\n    /// @param _sender The sender of the transaction\\n    function _allocate(bytes memory _data, address _sender) internal virtual override onlyActiveAllocation {\\n        // Decode the '_data' to get the recipientId, amount and token\\n        (address recipientId,, Permit2Data memory p2Data) = abi.decode(_data, (address, PermitType, Permit2Data));\\n\\n        uint256 amount = p2Data.permit.permitted.amount;\\n        address token = p2Data.permit.permitted.token;\\n\\n        // If the recipient status is not 'Accepted' this will revert, the recipient must be accepted through registration\\n        if (Status(_getUintRecipientStatus(recipientId)) != Status.Accepted) {\\n            revert RECIPIENT_ERROR(recipientId);\\n        }\\n\\n        // The token must be in the allowed token list and not be native token or zero address\\n        if (!allowedTokens[token] && !allowedTokens[address(0)]) {\\n            revert INVALID();\\n        }\\n\\n        // If the token is native, the amount must be equal to the value sent, otherwise it reverts\\n        if ((msg.value > 0 && token != NATIVE) || (token == NATIVE && msg.value != amount)) {\\n            revert INVALID();\\n        }\\n\\n        // Emit that the amount has been allocated to the recipient by the sender\\n        emit Allocated(recipientId, amount, token, _sender, tx.origin);\\n    }\\n\\n    /// @notice Check if sender is profile owner or member.\\n    /// @param _anchor Anchor of the profile\\n    /// @param _sender The sender of the transaction\\n    /// @return 'true' if the '_sender' is a profile member, otherwise 'false'\\n    function _isProfileMember(address _anchor, address _sender) internal view virtual returns (bool) {\\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\\n    }\\n\\n    /// @notice Get the recipient details.\\n    /// @param _recipientId Id of the recipient\\n    /// @return Recipient details\\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\\n        return _recipients[_recipientId];\\n    }\\n\\n    /// @notice Returns the payout summary for the accepted recipient.\\n    /// @param _data The data to be decoded\\n    /// @custom:data '(Distribution)'\\n    /// @return 'PayoutSummary' for a recipient\\n    function _getPayout(address, bytes memory _data) internal view override returns (PayoutSummary memory) {\\n        // Decode the '_data' to get the distribution\\n        Distribution memory distribution = abi.decode(_data, (Distribution));\\n\\n        uint256 index = distribution.index;\\n        address recipientId = distribution.recipientId;\\n        uint256 amount = distribution.amount;\\n        bytes32[] memory merkleProof = distribution.merkleProof;\\n\\n        address recipientAddress = _getRecipient(recipientId).recipientAddress;\\n\\n        // Validate the distribution\\n        if (_validateDistribution(index, recipientId, recipientAddress, amount, merkleProof)) {\\n            // Return a 'PayoutSummary' with the 'recipientAddress' and 'amount'\\n            return PayoutSummary(recipientAddress, amount);\\n        }\\n\\n        // If the distribution is not valid, return a payout summary with the amount set to zero\\n        return PayoutSummary(recipientAddress, 0);\\n    }\\n\\n    /// @notice Validate the distribution for the payout.\\n    /// @param _index index of the distribution\\n    /// @param _recipientId Id of the recipient\\n    /// @param _recipientAddress Address of the recipient\\n    /// @param _amount Amount of tokens to be distributed\\n    /// @param _merkleProof Merkle proof of the distribution\\n    /// @return 'true' if the distribution is valid, otherwise 'false'\\n    function _validateDistribution(\\n        uint256 _index,\\n        address _recipientId,\\n        address _recipientAddress,\\n        uint256 _amount,\\n        bytes32[] memory _merkleProof\\n    ) internal view returns (bool) {\\n        // If the '_index' has been distributed this will return 'false'\\n        if (_hasBeenDistributed(_index)) {\\n            return false;\\n        }\\n\\n        // Generate the node that will be verified in the 'merkleRoot'\\n        bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(_index, _recipientId, _recipientAddress, _amount))));\\n\\n        // If the node is not verified in the 'merkleRoot' this will return 'false'\\n        if (!MerkleProof.verify(_merkleProof, merkleRoot, node)) {\\n            return false;\\n        }\\n\\n        // Return 'true', the distribution is valid at this point\\n        return true;\\n    }\\n\\n    /// @notice Check if the distribution has been distributed.\\n    /// @param _index index of the distribution\\n    /// @return 'true' if the distribution has been distributed, otherwise 'false'\\n    function _hasBeenDistributed(uint256 _index) internal view returns (bool) {\\n        // Get the word index by dividing the '_index' by 256\\n        uint256 distributedWordIndex = _index / 256;\\n\\n        // Get the bit index by getting the remainder of the '_index' divided by 256\\n        uint256 distributedBitIndex = _index % 256;\\n\\n        // Get the word from the 'distributedBitMap' using the 'distributedWordIndex'\\n        uint256 distributedWord = distributedBitMap[distributedWordIndex];\\n\\n        // Get the mask by shifting 1 to the left of the 'distributedBitIndex'\\n        uint256 mask = (1 << distributedBitIndex);\\n\\n        // Return 'true' if the 'distributedWord' and 'mask' are equal to the 'mask'\\n        return distributedWord & mask == mask;\\n    }\\n\\n    /// @notice Mark distribution as done.\\n    /// @param _index index of the distribution\\n    function _setDistributed(uint256 _index) private {\\n        // Get the word index by dividing the '_index' by 256\\n        uint256 distributedWordIndex = _index / 256;\\n\\n        // Get the bit index by getting the remainder of the '_index' divided by 256\\n        uint256 distributedBitIndex = _index % 256;\\n\\n        // Set the bit in the 'distributedBitMap' shifting 1 to the left of the 'distributedBitIndex'\\n        distributedBitMap[distributedWordIndex] |= (1 << distributedBitIndex);\\n    }\\n\\n    /// @notice Distribute funds to recipient.\\n    /// @dev Emits a 'FundsDistributed()' event\\n    /// @param _distribution Distribution to be distributed\\n    function _distributeSingle(Distribution memory _distribution) private {\\n        uint256 index = _distribution.index;\\n        address recipientId = _distribution.recipientId;\\n        uint256 amount = _distribution.amount;\\n        bytes32[] memory merkleProof = _distribution.merkleProof;\\n\\n        address recipientAddress = _recipients[recipientId].recipientAddress;\\n\\n        // Validate the distribution and transfer the funds to the recipient, otherwise revert if not valid\\n        if (_validateDistribution(index, recipientId, recipientAddress, amount, merkleProof)) {\\n            IAllo.Pool memory pool = allo.getPool(poolId);\\n\\n            // Set the distribution as distributed\\n            _setDistributed(index);\\n\\n            // Update the pool amount\\n            poolAmount -= amount;\\n\\n            // Transfer the amount to the recipient\\n            _transferAmount(pool.token, payable(recipientAddress), amount);\\n\\n            // Emit that the funds have been distributed to the recipient\\n            emit FundsDistributed(amount, recipientAddress, pool.token, recipientId);\\n        } else {\\n            revert RECIPIENT_ERROR(recipientId);\\n        }\\n    }\\n\\n    /// @notice Set the recipient status.\\n    /// @param _recipientId ID of the recipient\\n    /// @param _status Status of the recipient\\n    function _setRecipientStatus(address _recipientId, uint256 _status) internal {\\n        // Get the row index, column index and current row\\n        (uint256 rowIndex, uint256 colIndex, uint256 currentRow) = _getStatusRowColumn(_recipientId);\\n\\n        // Calculate the 'newRow'\\n        uint256 newRow = currentRow & ~(15 << colIndex);\\n\\n        // Add the status to the mapping\\n        statusesBitMap[rowIndex] = newRow | (_status << colIndex);\\n    }\\n\\n    /// @notice Get recipient status\\n    /// @param _recipientId ID of the recipient\\n    /// @return status The status of the recipient\\n    function _getUintRecipientStatus(address _recipientId) internal view returns (uint8 status) {\\n        if (recipientToStatusIndexes[_recipientId] == 0) return 0;\\n        // Get the column index and current row\\n        (, uint256 colIndex, uint256 currentRow) = _getStatusRowColumn(_recipientId);\\n\\n        // Get the status from the 'currentRow' shifting by the 'colIndex'\\n        status = uint8((currentRow >> colIndex) & 15);\\n\\n        // Return the status\\n        return status;\\n    }\\n\\n    /// @notice Get recipient status 'rowIndex', 'colIndex' and 'currentRow'.\\n    /// @param _recipientId ID of the recipient\\n    /// @return (rowIndex, colIndex, currentRow)\\n    function _getStatusRowColumn(address _recipientId) internal view returns (uint256, uint256, uint256) {\\n        uint256 recipientIndex = recipientToStatusIndexes[_recipientId] - 1;\\n\\n        uint256 rowIndex = recipientIndex / 64; // 256 / 4\\n        uint256 colIndex = (recipientIndex % 64) * 4;\\n\\n        return (rowIndex, colIndex, statusesBitMap[rowIndex]);\\n    }\\n\\n    /// @notice Contract should be able to receive NATIVE\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/strategies/donation-voting-merkle-base/IDAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IDAI {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/strategies/donation-voting-merkle-distribution-direct-transfer/DonationVotingMerkleDistributionDirectTransferStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\nimport {ISignatureTransfer} from \\\"lib/permit2/src/interfaces/ISignatureTransfer.sol\\\";\\nimport {DonationVotingMerkleDistributionBaseStrategy} from\\n    \\\"../donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solady/src/utils/SafeTransferLib.sol\\\";\\nimport {IERC20Permit} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IDAI} from \\\"../donation-voting-merkle-base/IDAI.sol\\\";\\n\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u28bf\u28ff\u28ff\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u285f\u2818\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28fe\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28f4\u28f6\u28f6\u28f6\u28e6\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u2840\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u287f\u280b\u2801\u2800\u2800\u2808\u2818\u2839\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u2840\u2800\u2800\\n// \u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u2800\u2840\u2880\u2800\u2840\u2880\u2800\u2840\u2888\u28bf\u285f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\\n// \u2800\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28ff\u28ff\u287f\u28bf\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u2802\u2800\u2800\\n// \u2800\u2800\u2819\u281b\u283f\u283b\u283b\u281b\u2809\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f0\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28f7\u28c0\u2880\u2800\u2800\u2800\u2840\u28f0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28d7\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u286f\u2800\u2800\u2800\u2800\u2839\u28bf\u28ff\u28ff\u28ff\u28ff\u28fe\u28fe\u28f7\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u281b\u2819\u280b\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u283f\u283b\u281f\u283f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u281f\u283f\u281f\u283f\u2806\u2800\u2838\u283f\u283f\u281f\u282f\u2800\u2800\u2800\u2838\u283f\u283f\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u283b\u283b\u287f\u28ff\u28bf\u287f\u287f\u283f\u281b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\\n//                    allo.gitcoin.co\\n/// @title Donation Voting Merkle Distribution Strategy\\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\\n/// @notice Strategy for donation voting allocation with a merkle distribution\\ncontract DonationVotingMerkleDistributionDirectTransferStrategy is DonationVotingMerkleDistributionBaseStrategy {\\n    /// ===============================\\n    /// ======== Constructor ==========\\n    /// ===============================\\n\\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\\n    /// @param _allo The 'Allo' contract\\n    /// @param _name The name of the strategy\\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2)\\n        DonationVotingMerkleDistributionBaseStrategy(_allo, _name, _permit2)\\n    {}\\n\\n    /// ================================\\n    /// ============ Hooks =============\\n    /// ================================\\n\\n    /// @notice After allocation hook to transfer the allocated tokens to the recipients\\n    /// @param _data The encoded recipientId, amount and token\\n    /// @param _sender The sender of the allocation\\n    function _afterAllocate(bytes memory _data, address _sender) internal override {\\n        // Decode the '_data' to get the recipientId, amount and token\\n        (address recipientId, PermitType permitType, Permit2Data memory p2Data) =\\n            abi.decode(_data, (address, PermitType, Permit2Data));\\n\\n        // Get the token address\\n        address token = p2Data.permit.permitted.token;\\n        uint256 amount = p2Data.permit.permitted.amount;\\n        address recipientAddress = _recipients[recipientId].recipientAddress;\\n        // Native or already approved\\n        if (permitType == PermitType.None) {\\n            _transferAmountFrom(token, TransferData(_sender, recipientAddress, amount));\\n        } else if (permitType == PermitType.Permit2) {\\n            PERMIT2.permitTransferFrom( // The permit message.\\n                p2Data.permit,\\n                // The transfer recipient and amount.\\n                ISignatureTransfer.SignatureTransferDetails({to: recipientAddress, requestedAmount: amount}),\\n                // Owner of the tokens and signer of the message.\\n                _sender,\\n                // The packed signature that was the result of signing\\n                // the EIP712 hash of `_permit`.\\n                p2Data.signature\\n            );\\n        } else if (permitType == PermitType.Permit) {\\n            (bytes32 r, bytes32 s, uint8 v) = splitSignature(p2Data.signature);\\n            // The tx can be front-run, and another user can use the permit message and signature to invalidate the nonce.\\n            // In this case the permit call will fail, but it means that the contract already has allowance for the token.\\n            try IERC20Permit(token).permit(_sender, address(this), amount, p2Data.permit.deadline, v, r, s) {}\\n            catch Error(string memory reason) {\\n                if (IERC20(token).allowance(_sender, address(this)) < amount) {\\n                    revert(reason);\\n                }\\n            } catch (bytes memory reason) {\\n                if (IERC20(token).allowance(_sender, address(this)) < amount) {\\n                    revert(string(reason));\\n                }\\n            }\\n            IERC20(token).transferFrom(_sender, recipientAddress, amount);\\n        } else if (permitType == PermitType.PermitDAI) {\\n            (bytes32 r, bytes32 s, uint8 v) = splitSignature(p2Data.signature);\\n            // The tx can be front-run, and another user can use the permit message and signature to invalidate the nonce.\\n            // In this case the permit call will fail, but it means that the contract already has allowance for the token.\\n            try IDAI(token).permit(_sender, address(this), p2Data.permit.nonce, p2Data.permit.deadline, true, v, r, s) {}\\n            catch Error(string memory reason) {\\n                if (IERC20(token).allowance(_sender, address(this)) < amount) {\\n                    revert(reason);\\n                }\\n            } catch (bytes memory reason) {\\n                if (IERC20(token).allowance(_sender, address(this)) < amount) {\\n                    revert(string(reason));\\n                }\\n            }\\n            IERC20(token).transferFrom(_sender, recipientAddress, amount);\\n        }\\n    }\\n\\n    function splitSignature(bytes memory sig) public pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        if (sig.length == 65) {\\n            (r, s) = abi.decode(sig, (bytes32, bytes32));\\n            v = uint8(sig[64]);\\n        } else if (sig.length == 64) {\\n            // EIP-2098\\n            bytes32 vs;\\n            (r, vs) = abi.decode(sig, (bytes32, bytes32));\\n            s = vs & (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            v = uint8(uint256(vs >> 255)) + 27;\\n        } else {\\n            revert INVALID();\\n        }\\n    }\\n\\n    /// @notice Internal function to return the token amount locked in vault\\n    /// @dev This function will return 0 since all funds are transferred directly to the recipient\\n    function _tokenAmountInVault(address) internal pure override returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/permit2/src/interfaces/IEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IEIP712 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/permit2/src/interfaces/ISignatureTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IEIP712} from \\\"./IEIP712.sol\\\";\\n\\n/// @title SignatureTransfer\\n/// @notice Handles ERC20 token transfers through signature based actions\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface ISignatureTransfer is IEIP712 {\\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\\n    /// @param maxAmount The maximum amount a spender can request to transfer\\n    error InvalidAmount(uint256 maxAmount);\\n\\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\\n    error LengthMismatch();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\\n\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\\n    /// @dev Note that a user still signs over a spender address\\n    struct PermitBatchTransferFrom {\\n        // the tokens and corresponding amounts permitted for a transfer\\n        TokenPermissions[] permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\\n    /// @dev It returns a uint256 bitmap\\n    /// @dev The index, or wordPosition is capped at type(uint248).max\\n    function nonceBitmap(address, uint256) external view returns (uint256);\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\\n    /// @dev The wordPos is maxed at type(uint248).max\\n    /// @param wordPos A number to index the nonceBitmap at\\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n/// responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// Note: This implementation does NOT protect against gas griefing.\\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0x00, 0x00) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overridden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, 0x00, 0x00, 0x00, 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0x00, 0x00) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` is already at 0x60. Load it for the function's return value.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` is already at 0x34. Load it for the function's return value.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // Store the function selector.\\n                // We can ignore the result of this call. Just need to check the next call.\\n                pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00))\\n                mstore(0x34, amount) // Store back the original `amount`.\\n\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    // Store the function selector of `ApproveFailed()`.\\n                    mstore(0x00, 0x3e3f8f73)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"contract ISignatureTransfer\",\"name\":\"_permit2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ALLOCATION_ACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ALLOCATION_NOT_ACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ALLOCATION_NOT_ENDED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ALREADY_INITIALIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AMOUNT_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ANCHOR_ERROR\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ARRAY_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_FEE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_METADATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_REGISTRATION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IS_APPROVED_STRATEGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NONCE_NOT_AVAILABLE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NON_ZERO_VALUE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_APPROVED_STRATEGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_ENOUGH_FUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_IMPLEMENTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_INITIALIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PENDING_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POOL_ACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POOL_INACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RECIPIENT_ALREADY_ACCEPTED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"}],\"name\":\"RECIPIENT_ERROR\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RECIPIENT_NOT_ACCEPTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"REGISTRATION_ACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"REGISTRATION_NOT_ACTIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"Allocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Allocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BatchPayoutSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"pointer\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct Metadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"name\":\"DistributionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"grantee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"}],\"name\":\"FundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"PoolActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fullRow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RecipientStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"registrationStartTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"registrationEndTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"allocationStartTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"allocationEndTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TimestampsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"UpdatedRegistration\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"contract ISignatureTransfer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"allocate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationEndTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationStartTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipientIds\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionMetadata\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"pointer\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllo\",\"outputs\":[{\"internalType\":\"contract IAllo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipientIds\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"}],\"name\":\"getPayouts\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategy.PayoutSummary[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipientId\",\"type\":\"address\"}],\"name\":\"getRecipient\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"useRegistryAnchor\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"pointer\",\"type\":\"string\"}],\"internalType\":\"struct Metadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct DonationVotingMerkleDistributionBaseStrategy.Recipient\",\"name\":\"recipient\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipientId\",\"type\":\"address\"}],\"name\":\"getRecipientStatus\",\"outputs\":[{\"internalType\":\"enum IStrategy.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategyId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"hasBeenDistributed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increasePoolAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDistributionSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocator\",\"type\":\"address\"}],\"name\":\"isValidAllocator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recipientToStatusIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipientsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"registerRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipientId\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationEndTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationStartTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statusRow\",\"type\":\"uint256\"}],\"internalType\":\"struct DonationVotingMerkleDistributionBaseStrategy.ApplicationStatus[]\",\"name\":\"statuses\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"refRecipientsCounter\",\"type\":\"uint256\"}],\"name\":\"reviewRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statusesBitMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"pointer\",\"type\":\"string\"}],\"internalType\":\"struct Metadata\",\"name\":\"_distributionMetadata\",\"type\":\"tuple\"}],\"name\":\"updateDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_registrationStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_registrationEndTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_allocationStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_allocationEndTime\",\"type\":\"uint64\"}],\"name\":\"updatePoolTimestamps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useRegistryAnchor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DonationVotingMerkleDistributionDirectTransferStrategy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "0000000000000000000000001133ea7af70876e64665ecd07c0a0476d09465a10000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba3000000000000000000000000000000000000000000000000000000000000003a446f6e6174696f6e566f74696e674d65726b6c65446973747269627574696f6e4469726563745472616e73666572537472617465677976322e31000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}