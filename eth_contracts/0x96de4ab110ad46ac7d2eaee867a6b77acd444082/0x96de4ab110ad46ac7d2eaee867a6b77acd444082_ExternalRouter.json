{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ExternalRouterExternalRouter\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x < y ? x : y;\\r\\n    }\\r\\n\\r\\n\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    function muldiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        uint256 prod0; // Least significant 256 bits of the product\\r\\n        uint256 prod1; // Most significant 256 bits of the product\\r\\n        assembly {\\r\\n            let mm := mulmod(a, b, not(0))\\r\\n            prod0 := mul(a, b)\\r\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n        }\\r\\n\\r\\n\\r\\n        if (prod1 == 0) {\\r\\n            require(denominator > 0);\\r\\n            assembly {\\r\\n                result := div(prod0, denominator)\\r\\n            }\\r\\n            return result;\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        require(denominator > prod1);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        uint256 remainder;\\r\\n        assembly {\\r\\n            remainder := mulmod(a, b, denominator)\\r\\n        }\\r\\n\\r\\n        assembly {\\r\\n            prod1 := sub(prod1, gt(remainder, prod0))\\r\\n            prod0 := sub(prod0, remainder)\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\r\\n\\r\\n        assembly {\\r\\n            denominator := div(denominator, twos)\\r\\n        }\\r\\n\\r\\n\\r\\n        assembly {\\r\\n            prod0 := div(prod0, twos)\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        assembly {\\r\\n            twos := add(div(sub(0, twos), twos), 1)\\r\\n        }\\r\\n        prod0 |= prod1 * twos;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        uint256 inv = (3 * denominator) ^ 2;\\r\\n\\r\\n\\r\\n\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        result = prod0 * inv;\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        result = muldiv(a, b, denominator);\\r\\n        if (mulmod(a, b, denominator) > 0) {\\r\\n            require(result < type(uint256).max);\\r\\n            result++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IWETH {\\r\\n    function withdraw(uint) external;\\r\\n    function deposit() external payable;\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n}\\r\\ninterface IUniswapV2Pair {\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV3Pair {\\r\\n    function slot0() external view returns (\\r\\n            uint160 sqrtPriceX96,\\r\\n            int24 tick,\\r\\n            uint16 observationIndex,\\r\\n            uint16 observationCardinality,\\r\\n            uint16 observationCardinalityNext,\\r\\n            uint8 feeProtocol,\\r\\n            bool unlocked\\r\\n    );\\r\\n    function liquidity() external view returns (uint128);\\r\\n    function ticks(int24 tick) external view  returns (\\r\\n            uint128 liquidityGross,\\r\\n            int128 liquidityNet,\\r\\n            uint256 feeGrowthOutside0X128,\\r\\n            uint256 feeGrowthOutside1X128,\\r\\n            int56 tickCumulativeOutside,\\r\\n            uint160 secondsPerLiquidityOutsideX128,\\r\\n            uint32 secondsOutside,\\r\\n            bool initialized\\r\\n    );\\r\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\r\\n    function positions(bytes32 key) external view returns (\\r\\n            uint128 _liquidity,\\r\\n            uint256 feeGrowthInside0LastX128,\\r\\n            uint256 feeGrowthInside1LastX128,\\r\\n            uint128 tokensOwed0,\\r\\n            uint128 tokensOwed1\\r\\n    );\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function fee() external view returns (uint24);\\r\\n    function tickSpacing() external view returns (int24);\\r\\n    function maxLiquidityPerTick() external view returns (uint128);\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96,\\r\\n        bytes calldata data\\r\\n    ) external returns (int256 amount0, int256 amount1);\\r\\n}\\r\\n\\r\\ninterface IPair {\\r\\n\\r\\n    function amountIn(address output, uint _amountOut, address caller) external view returns (uint _amountIn);\\r\\n    function amountOut(address input, uint _amountIn, address caller) external view returns (uint _amountOut);\\r\\n    function swap(\\r\\n        address to,\\r\\n        address caller,\\r\\n        address factory\\r\\n    ) external returns (uint);\\r\\n    function borrow(address to, uint _amountOut, bool isToken0, bytes calldata data) external;\\r\\n    function getReserves() external view returns (\\r\\n        uint112 _reserve0, \\r\\n        uint112 _reserve1, \\r\\n        uint32 _blockTimestampLast\\r\\n    );\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function factory() external view returns (address);\\r\\n}\\r\\ninterface IGenerator {\\r\\n    struct Info {\\r\\n        address owner;\\r\\n        uint16 burnFee;\\r\\n        address burnToken;\\r\\n        uint16 teamFee;\\r\\n        address teamAddress;\\r\\n        uint16 lpFee;\\r\\n        address referrer;\\r\\n        uint16 referFee;\\r\\n        uint16 labFee;\\r\\n    }\\r\\n    function factoryInfo(address) external view returns (Info memory);\\r\\n    function FEE_DENOMINATOR() external view returns (uint16);\\r\\n}\\r\\ninterface IFactory {\\r\\n    function generator() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IExternalRouter {\\r\\n    struct SwapParameters {\\r\\n        address pair;\\r\\n        address input;\\r\\n        uint48 fee;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n        uint256 minOutput;\\r\\n        int8 swapType;\\r\\n    }\\r\\n    function swapWithFees(\\r\\n        uint256 inputAmount,\\r\\n        SwapParameters[] memory swaps,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        address f\\r\\n    ) external;\\r\\n}\\r\\ncontract ExternalRouter is IExternalRouter {\\r\\n\\r\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\r\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\r\\n    event FeeCollected(address indexed collected, address indexed token, uint amount, address indexed factory);\\r\\n    struct SwapCallbackData {\\r\\n        address payer;\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint256 maxAmountIn;\\r\\n    }\\r\\n\\r\\n    bool private _swapping;\\r\\n\\r\\n    modifier inSwap() {\\r\\n        require(_swapping, \\\"Router: must be in swap\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier swapping() {  \\r\\n        _swapping = true;\\r\\n        _;\\r\\n        _swapping = false;\\r\\n    }\\r\\n\\r\\n    modifier ensure(uint deadline) {\\r\\n        require(deadline >= block.timestamp, \\\"EXPIRED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    IWETH public WETH;\\r\\n    constructor(address _weth) {\\r\\n        WETH = IWETH(_weth);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        assert(msg.sender == address(WETH)); // only accept ETH via fallback from the WETH contract\\r\\n    }\\r\\n\\r\\n    function pancakeV3SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata data\\r\\n    ) external inSwap() { //ensure that we are in a swap currently before just sending stuff places.\\r\\n        _v3Callback(amount0Delta, amount1Delta, data);\\r\\n    }\\r\\n\\r\\n    function uniswapV3SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata _data\\r\\n    ) external inSwap() { //ensure that we are in a swap currently before just sending stuff places.\\r\\n        _v3Callback(amount0Delta, amount1Delta, _data);\\r\\n    }\\r\\n\\r\\n    function solidlyV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external inSwap() {\\r\\n        _v3Callback(amount0Delta, amount1Delta, data);\\r\\n    }\\r\\n\\r\\n    function ramsesV2SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata data\\r\\n    ) external inSwap() { //ensure that we are in a swap currently before just sending stuff places.\\r\\n        _v3Callback(amount0Delta, amount1Delta, data);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _v3Callback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata _data\\r\\n    ) internal {\\r\\n        require(amount0Delta > 0 || amount1Delta > 0, \\\"Invalid output\\\"); // swaps entirely within 0-liquidity regions are not supported\\r\\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\\r\\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\\r\\n        require(data.maxAmountIn <= amountToPay, \\\"Invalid input amount\\\"); //ensure they are not trying to take more than we intended.\\r\\n        assert(data.payer == address(this) || data.payer == tx.origin); //ensure that the payer is either us or the original caller.\\r\\n        if (data.payer == address(this)) {\\r\\n            safeTransfer(data.tokenIn, msg.sender, amountToPay);\\r\\n        } else {\\r\\n            safeTransferFrom(data.tokenIn, data.payer, msg.sender, amountToPay);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(value <= uint256(type(int256).max));\\r\\n        return int256(value);\\r\\n    }\\r\\n\\r\\n    function _swapV3(address pairAddress, address input, uint256 inputAmount, uint160 sqrtPriceLimitX96, uint256 minOutput, address to, address from) internal returns (uint256 outputAmount) { //exactInput\\r\\n        IUniswapV3Pair pair = IUniswapV3Pair(pairAddress);\\r\\n        address token0 = pair.token0();\\r\\n        address token1 = pair.token1();\\r\\n        bool zeroForOne = token0 == input;\\r\\n        int256 amount0;\\r\\n        int256 amount1;\\r\\n        address _input = input;\\r\\n        uint256 _inputAmount = inputAmount;\\r\\n        {\\r\\n            (amount0, amount1) = pair.swap(\\r\\n                to,\\r\\n                zeroForOne,\\r\\n                toInt256(_inputAmount),\\r\\n                sqrtPriceLimitX96 == 0 ? (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1) : sqrtPriceLimitX96,\\r\\n                abi.encode(SwapCallbackData(from, _input, zeroForOne ? token1 : token0, _inputAmount))\\r\\n            );\\r\\n        }\\r\\n        outputAmount = uint256(-(zeroForOne ? amount1 : amount0));\\r\\n        require(outputAmount >= minOutput, \\\"S3:IO\\\");\\r\\n    }\\r\\n\\r\\n    function _swapV2(\\r\\n        address pairAddress,\\r\\n        address input,\\r\\n        uint256 inputAmount,\\r\\n        uint256 minOutput,\\r\\n        uint48 fee,\\r\\n        address to,\\r\\n        bool multihop,\\r\\n        bool t\\r\\n    ) internal returns (uint256 amountOutput) { //exactInput\\r\\n        if (!multihop) safeTransferFrom(input, msg.sender, pairAddress, inputAmount);\\r\\n        else if (t) safeTransfer(input, pairAddress, inputAmount);\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\r\\n        address token0 = pair.token0();\\r\\n        bool isInputToken0 = token0 == input;\\r\\n        {\\r\\n            (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\r\\n            (uint256 reserveInput, uint256 reserveOutput) = isInputToken0  ? (reserve0, reserve1)  : (reserve1, reserve0);\\r\\n            inputAmount = IERC20(input).balanceOf(pairAddress) - reserveInput;\\r\\n            uint amountInMinusFee = inputAmount * (10000 - fee);\\r\\n            uint256 numerator = amountInMinusFee * reserveOutput;\\r\\n            uint256 denominator = reserveInput * 10000 + amountInMinusFee;\\r\\n            amountOutput = numerator / denominator;\\r\\n        }\\r\\n        require(amountOutput >= minOutput, \\\"S2:IO\\\");\\r\\n        (uint256 amount0Out, uint256 amount1Out) = isInputToken0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\\r\\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\\r\\n    }\\r\\n\\r\\n\\r\\n    function _swapLab(\\r\\n        address pair,\\r\\n        address input,\\r\\n        uint256 inputAmount,\\r\\n        uint256 minOutput,\\r\\n        address to,\\r\\n        bool multihop,\\r\\n        bool t\\r\\n    ) internal returns (uint256 amountOut) {\\r\\n        if (!multihop) safeTransferFrom(input, msg.sender, pair, inputAmount);\\r\\n        else if (t) safeTransfer(input, msg.sender, inputAmount);\\r\\n        amountOut = IPair(pair).swap(to, msg.sender, address(this));\\r\\n        require(amountOut >= minOutput, \\\"S:IO\\\");\\r\\n    }\\r\\n\\r\\n    function _takeFees(address input, uint256 amountIn, address f, bool owned) internal returns (uint256) {\\r\\n        address generator = IFactory(f).generator();\\r\\n        IGenerator gen = IGenerator(generator);\\r\\n        IGenerator.Info memory fees = gen.factoryInfo(f);\\r\\n        uint16 totalFee = fees.teamFee + fees.referFee + fees.labFee;\\r\\n        if (totalFee > 0) {\\r\\n            uint amountFee = Math.muldiv(amountIn, totalFee, gen.FEE_DENOMINATOR());\\r\\n            amountIn -= amountFee;\\r\\n            if (amountFee > 0) {\\r\\n                uint256 amountTeam;\\r\\n                if (fees.teamFee > 0) {\\r\\n                    amountTeam = Math.muldiv(amountFee, fees.teamFee, totalFee);\\r\\n                    if (!owned) safeTransferFrom(input, msg.sender, fees.teamAddress, amountTeam);\\r\\n                    else safeTransfer(input, fees.teamAddress, amountTeam);\\r\\n                    emit FeeCollected(fees.teamAddress, input, amountTeam, f);\\r\\n                }\\r\\n                uint256 amountRefer;\\r\\n                if (fees.referFee > 0) {\\r\\n                    amountRefer = Math.min(amountFee - amountTeam, Math.muldiv(amountFee, fees.referFee, totalFee));\\r\\n                    if (amountRefer > 0) {\\r\\n                        if (!owned) safeTransferFrom(input, msg.sender, fees.referrer, amountRefer);\\r\\n                        else safeTransfer(input, fees.referrer, amountRefer);\\r\\n                        emit FeeCollected(fees.referrer, input, amountRefer, f);\\r\\n                    }\\r\\n                }\\r\\n                if (fees.labFee > 0) {\\r\\n                    uint labAmount = amountFee - amountTeam - amountRefer;\\r\\n                    if (labAmount > 0) {                       \\r\\n                        address team = gen.factoryInfo(generator).teamAddress;\\r\\n                        if (!owned) safeTransferFrom(input, msg.sender, team, labAmount);\\r\\n                        else safeTransfer(input, team, labAmount);\\r\\n                        emit FeeCollected(team, input, labAmount, generator);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return amountIn;\\r\\n    }\\r\\n\\r\\n\\r\\n    function _swap(\\r\\n        uint256 inputAmount,\\r\\n        SwapParameters[] memory swaps,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        address f,\\r\\n        bool owned\\r\\n    ) internal swapping() ensure(deadline) {\\r\\n        uint amountIn = _takeFees(swaps[0].input, inputAmount, f, owned);\\r\\n        for (uint i; i < swaps.length; i++) {\\r\\n            address _to = i == swaps.length - 1 ? to : (swaps[i+1].swapType != 2 ? swaps[i+1].pair : address(this));\\r\\n            if (swaps[i].swapType == 1) {\\r\\n                amountIn = _swapV2(swaps[i].pair, swaps[i].input, amountIn, swaps[i].minOutput, swaps[i].fee, _to, owned || i != 0, owned);\\r\\n            } else if (swaps[i].swapType == 2) {\\r\\n                amountIn = _swapV3(swaps[i].pair, swaps[i].input, amountIn, swaps[i].sqrtPriceLimitX96, swaps[i].minOutput, _to, (!owned && i == 0) ? msg.sender : address(this));\\r\\n            } else {\\r\\n                amountIn = _swapLab(swaps[i].pair, swaps[i].input, amountIn, swaps[i].minOutput, _to, owned || i != 0, owned);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapWithFees(\\r\\n        uint256 inputAmount,\\r\\n        SwapParameters[] memory swaps,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        address f\\r\\n    ) external  {\\r\\n        _swap(inputAmount, swaps, to, deadline, f, false);\\r\\n    }\\r\\n\\r\\n    function swapWithBase(\\r\\n        uint256 inputAmount,\\r\\n        SwapParameters[] memory swaps,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        address f,\\r\\n        bool unwrap\\r\\n    ) external payable {\\r\\n        uint256 v = msg.value;\\r\\n        IWETH weth = WETH;\\r\\n        if (v > 0) {\\r\\n            require(v >= inputAmount, \\\"II\\\"); \\r\\n            if (v > inputAmount) payable(msg.sender).transfer(v - inputAmount);\\r\\n            weth.deposit{value: inputAmount}();\\r\\n        }\\r\\n        _swap(\\r\\n            inputAmount,\\r\\n            swaps,\\r\\n            unwrap ? address(this) : to,\\r\\n            deadline,\\r\\n            f,\\r\\n            v > 0\\r\\n        );\\r\\n        if (unwrap) {\\r\\n            weth.withdraw(weth.balanceOf(address(this)));\\r\\n            payable(to).transfer(address(this).balance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\r\\n        );\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"TransferHelper: transferFrom failed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n  function safeTransfer(\\r\\n    address token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n) internal {\\r\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n    require(\\r\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n      \\\"TransferHelper::safeTransfer: transfer failed\\\"\\r\\n    );\\r\\n  }\\r\\n    \\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"viaIR\": true\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collected\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"pancakeV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ramsesV2SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"solidlyV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"fee\",\"type\":\"uint48\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"swapType\",\"type\":\"int8\"}],\"internalType\":\"struct IExternalRouter.SwapParameters[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"swapWithBase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"fee\",\"type\":\"uint48\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"swapType\",\"type\":\"int8\"}],\"internalType\":\"struct IExternalRouter.SwapParameters[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"}],\"name\":\"swapWithFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ExternalRouter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://95a8577c09970c56868e0a0727163a3d68e456c711e802275a752d159ff86ed7"}