{"SourceCode": "// SPDX-License-Identifier: MIT\r\n////powered by https://dx.app for https://base.fun\r\npragma solidity ^0.8.17;\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\r\n * consider using {ReentrancyGuardTransient} instead.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function decimals() external returns (uint8);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public voter;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVoter() {\r\n        require(msg.sender == voter);\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\ninterface UniswapRouter02 {\r\n    function factory() external pure returns(address);\r\n\r\n    function WETH() external pure returns(address);\r\n   // function WBNB() external pure returns(address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns(uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns(uint amountToken, uint amountETH, uint liquidity);\r\n\r\n\r\n\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns(uint[] memory amounts);\r\n\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns(uint[] memory amounts);\r\n}\r\n\r\ninterface UniswapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns(address pair);\r\n\r\n\r\n    function createPair(address tokenA, address tokenB) external returns(address pair);\r\n\r\n\r\n}\r\ninterface LPToken {\r\n\r\n    function sync() external;\r\n\r\n}\r\ninterface lpLockDeployerInterface {\r\n\r\n    function createLPLocker(address _lockingToken, uint256 _lockerEndTimeStamp, string memory _logo, uint256 _lockingAmount, address _funOwner) external payable returns (address);\r\n\r\n\r\n}\r\ninterface funDeployerInterface{\r\n\r\n    function getAffiliatePer(address _affiliateAddrs) external view returns (uint256);\r\n    function getOwnerPer() external view returns(uint256);\r\n    function emitRoyal(address funContract, address tokenAddress, address router,address baseAddress, uint256 liquidityAmount, uint256 tokenAmount, uint256 _time, uint256 totalVolume) external;\r\n\r\n\r\n}\r\n\r\ncontract fun is Ownable, ReentrancyGuard{\r\n    address public token;\r\n    address public baseToken;\r\n    address public router;\r\n    address public feeContract;\r\n    address public stableAddress;\r\n    address public lpLockDeployer;\r\n    address public lockerAddress;\r\n    address public eventTracker;\r\n\r\n    address public storedLPAddress;\r\n    address public deployer;\r\n    uint256 public reserveTokens;\r\n    uint256 public reserveETH;\r\n    uint256 public feePer;\r\n    uint256 public listThreshold;\r\n    uint256 public volume;\r\n    uint256 public nativePer = 50;\r\n    uint256 public royalPer = 50;\r\n    //bool public dexList = true;\r\n    bool public tradeActive;\r\n    //bool public lpBurn;\r\n    bool public royalemitted;  //eventTracker_txFee_lpLockDep_stableAddr_router\r\n    event LiquidityAdded(address indexed provider, uint tokenAmount, uint ethAmount);\r\n    //event LiquidityRemoved(address indexed provider, uint tokenAmount, uint ethAmount);\r\n    event sold(address indexed user, uint256 amountIn, uint256 amountOut, uint256 _time,uint256 reserveEth, uint256 reserveTokens, uint256 totalVolume);\r\n    event bought(address indexed user, uint256 amountIn, uint256 amountOut, uint256 _time,uint256 reserveEth, uint256 reserveTokens, uint256 totalVolume);\r\n    event funTradeCall(address indexed user, uint256 amountIn, uint256 amountOut, uint256 _time,uint256 reserveEth, uint256 reserveTokens, string tradeType, uint256 totalVolume);\r\n    event listed(address indexed user, address indexed tokenAddress,address indexed router, uint256 liquidityAmount, uint256 tokenAmount, uint256 _time, uint256 totalVolume);\r\n    constructor(address[3] memory _token_baseToken_deployer, address[5] memory eventTracker_txFee_lpLockDep_stableAddr_router, uint256[3] memory _feePer_listThreshold_initResEth) payable {\r\n        token = _token_baseToken_deployer[0];\r\n        baseToken = _token_baseToken_deployer[1];\r\n        deployer = _token_baseToken_deployer[2];\r\n        router = eventTracker_txFee_lpLockDep_stableAddr_router[4];\r\n        eventTracker = eventTracker_txFee_lpLockDep_stableAddr_router[0];\r\n        feePer = _feePer_listThreshold_initResEth[0];\r\n        listThreshold = _feePer_listThreshold_initResEth[1];\r\n        reserveETH = _feePer_listThreshold_initResEth[2];\r\n        feeContract = eventTracker_txFee_lpLockDep_stableAddr_router[1];\r\n        lpLockDeployer = eventTracker_txFee_lpLockDep_stableAddr_router[2];\r\n        stableAddress = eventTracker_txFee_lpLockDep_stableAddr_router[3];\r\n        //lpBurn = false;\r\n        if(baseToken == getWrapAddr()){\r\n\r\n            nativePer = 100;\r\n\r\n        }\r\n        //IERC20(token).transfer(address(this), IERC20(token).totalSupply()); // Send all tokens to this contract\r\n        //require(msg.value >= _liquidityAmount,\"no liquidity provided\");\r\n        // Check if any ETH is sent during deployment to add liquidity\r\n       // if (msg.value > 0) {\r\n            uint256 tokenAmount = IERC20(token).totalSupply();\r\n            addInitialLiquidity(tokenAmount, msg.value);\r\n       // }\r\n        tradeActive = true;\r\n        //owner = tx.origin;\r\n        //_transferOwnership(_router_eventTracker_creator[2]);\r\n        renounceOwnership();\r\n        //Ownable(token).transferOwnership(tx.origin);\r\n\r\n    }\r\n\r\n    function addInitialLiquidity(uint tokenAmount, uint ethAmount) private {\r\n        // Accepts the token and Ether amounts already calculated\r\n        reserveTokens += tokenAmount;\r\n        reserveETH += ethAmount;\r\n        emit LiquidityAdded(address(this), tokenAmount, ethAmount);\r\n    }\r\n\r\n\r\n\r\n    function getWrapAddr() public view returns (address){\r\n\r\n            return UniswapRouter02(router).WETH();\r\n\r\n    }\r\n    function Approve(address _token) internal returns (bool) {\r\n        IERC20 token_ = IERC20(_token);\r\n        if (token_.allowance(address(this), router) == 0) {\r\n          token_.approve(router, type(uint256).max);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function ApproveLock(address _lp, address _lockDeployer) internal returns (bool) {\r\n        IERC20 lp_ = IERC20(_lp);\r\n        if (lp_.allowance(address(this), _lockDeployer) == 0) {\r\n          lp_.approve(_lockDeployer, type(uint256).max);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function getAmountsMinToken(address _tokenAddress, uint256 _ethIN) public view returns(uint256) {\r\n\r\n      //  UniswapRouter02 pancakeRouter = UniswapRouter02(_router);\r\n        // generate the pair path of token -> weth\r\n        uint256[] memory amountMinArr;\r\n        address[] memory path = new address[](2);\r\n        path[0] = getWrapAddr();\r\n        path[1] = address(_tokenAddress);\r\n\r\n        amountMinArr = UniswapRouter02(router).getAmountsOut(_ethIN, path);\r\n        return uint256(amountMinArr[1]);\r\n    }\r\n\r\n    function swapEthToBase(address _baseAddress, uint256 _ethIN) internal returns(uint256) {\r\n\r\n        Approve(baseToken);\r\n      //  UniswapRouter02 pancakeRouter = UniswapRouter02(_router);\r\n        // generate the pair path of token -> weth\r\n        uint256[] memory amountMinArr;\r\n        address[] memory path = new address[](2);\r\n        path[0] = getWrapAddr();\r\n        path[1] = _baseAddress;\r\n        uint256 minBase = getAmountsMinToken(_baseAddress,_ethIN) * 90 / 100;\r\n        \r\n        amountMinArr = UniswapRouter02(router).swapExactETHForTokens{value: _ethIN}(minBase, path,address(this), block.timestamp + 300);\r\n\r\n        //UniswapRouter02(router).swapExactTokensForETH(_baseIN, minEth, path,address(this), block.timestamp + 300);\r\n        //amountMinArr = UniswapRouter02(router).getAmountsOut(_baseIN, path);\r\n        return amountMinArr[1];\r\n    }\r\n\r\n    function getpair(address _token1, address _token2) internal returns (address) {\r\n      address pair = UniswapFactory(UniswapRouter02(router).factory()).getPair(_token1, _token2);\r\n        if (pair != address(0)) {\r\n            return pair;\r\n        } else {\r\n            return UniswapFactory(UniswapRouter02(router).factory()).createPair(_token1, _token2);\r\n        }\r\n    }\r\n    function AddLiquidityETH(uint256 amountTokenDesired, uint256 nativeForDex) internal {\r\n     //   require(validPairPartner[_pairAlternative], \"This is not a valid pair partner\");\r\n\r\n        uint256 amountETH = nativeForDex;\r\n        uint256 amountETHMin = (amountETH * 90)/100;\r\n        uint256 amountTokenToAddLiq = amountTokenDesired;\r\n        uint256 amountTokenMin = (amountTokenToAddLiq * 90)/100;\r\n        uint256 LP_WBNB_exp_balance;\r\n        uint256 LP_token_balance;\r\n        uint256 tokenToSend = 0;\r\n\r\n\r\n            storedLPAddress =  getpair(token, getWrapAddr());\r\n            LP_WBNB_exp_balance = IERC20(getWrapAddr()).balanceOf(storedLPAddress);\r\n            LP_token_balance = IERC20(token).balanceOf(storedLPAddress);\r\n\r\n\r\n            if (storedLPAddress != address(0x0) && (LP_WBNB_exp_balance > 0 && LP_token_balance <= 0)) {\r\n                tokenToSend = (amountTokenToAddLiq * LP_WBNB_exp_balance) / amountETH;\r\n\r\n                IERC20(token).transfer(storedLPAddress, tokenToSend);\r\n\r\n                LPToken(storedLPAddress).sync();\r\n                // sync after adding token\r\n            }\r\n            Approve(token);\r\n\r\n\r\n\r\n                UniswapRouter02(router).addLiquidityETH{value:amountETH - LP_WBNB_exp_balance}(token, amountTokenToAddLiq - tokenToSend, amountTokenMin, amountETHMin, address(this), block.timestamp + (300));\r\n                ApproveLock(storedLPAddress,lpLockDeployer);\r\n                lockerAddress = lpLockDeployerInterface(lpLockDeployer).createLPLocker(storedLPAddress,32503698000,\"logo\",IERC20(storedLPAddress).balanceOf(address(this)), owner);\r\n\r\n            \r\n        FunEventTracker(eventTracker).listEvent(msg.sender,token,router,amountETH - LP_WBNB_exp_balance,amountTokenToAddLiq - tokenToSend,block.timestamp,volume);\r\n        emit listed(msg.sender,token,router,amountETH - LP_WBNB_exp_balance,amountTokenToAddLiq - tokenToSend,block.timestamp,volume);\r\n\r\n    }\r\n\r\n    function AddLiquidity(uint256 amountTokenDesired, uint256 baseForDex) internal {\r\n     //   require(validPairPartner[_pairAlternative], \"This is not a valid pair partner\");\r\n\r\n        uint256 amountBase = baseForDex;\r\n        uint256 amountBaseMin = (amountBase * 90)/100;\r\n        uint256 amountTokenToAddLiq = amountTokenDesired;\r\n        uint256 amountTokenMin = (amountTokenToAddLiq * 90)/100;\r\n        uint256 LP_WBNB_exp_balance;\r\n        uint256 LP_token_balance;\r\n        uint256 tokenToSend = 0;\r\n\r\n\r\n            storedLPAddress =  getpair(token, baseToken);\r\n            LP_WBNB_exp_balance = IERC20(baseToken).balanceOf(storedLPAddress);\r\n            LP_token_balance = IERC20(token).balanceOf(storedLPAddress);\r\n\r\n\r\n            if (storedLPAddress != address(0x0) && (LP_WBNB_exp_balance > 0 && LP_token_balance <= 0)) {\r\n                tokenToSend = (amountTokenToAddLiq * LP_WBNB_exp_balance) / amountBase;\r\n\r\n                IERC20(token).transfer(storedLPAddress, tokenToSend);\r\n\r\n                LPToken(storedLPAddress).sync();\r\n                // sync after adding token\r\n            }\r\n            Approve(token);\r\n            Approve(baseToken);\r\n\r\n         \r\n\r\n                UniswapRouter02(router).addLiquidity(token,baseToken, amountTokenToAddLiq - tokenToSend,amountBase - LP_WBNB_exp_balance, amountTokenMin, amountBaseMin, address(this), block.timestamp + (300));\r\n                ApproveLock(storedLPAddress,lpLockDeployer);\r\n                lockerAddress = lpLockDeployerInterface(lpLockDeployer).createLPLocker(storedLPAddress,32503698000,\"logo\",IERC20(storedLPAddress).balanceOf(address(this)), owner);\r\n\r\n            \r\n        FunEventTracker(eventTracker).listEvent(msg.sender,token,router,amountBase - LP_WBNB_exp_balance,amountTokenToAddLiq - tokenToSend,block.timestamp,volume);\r\n        emit listed(msg.sender,token,router,amountBase - LP_WBNB_exp_balance,amountTokenToAddLiq - tokenToSend,block.timestamp,volume);\r\n\r\n    }\r\n\r\n\r\n\r\n    function sellTokens(uint256 tokenAmount, uint256 minEth, address _affiliate) public nonReentrant returns(bool,bool) {\r\n        require(tradeActive, \"Trading not active\");\r\n        uint256 tokenToSell = tokenAmount;\r\n        uint256 ethAmount = getAmountOut(tokenToSell, reserveTokens, reserveETH);\r\n        uint256 ethAmountFee = ethAmount * feePer / 10000;\r\n        uint256 ethAmountOwnerFee = ethAmountFee * (funDeployerInterface(deployer).getOwnerPer()) / 10000;\r\n        uint256 affiliateFee = ethAmountFee * (funDeployerInterface(deployer).getAffiliatePer(_affiliate)) / 10000;\r\n        require(ethAmount > 0 && ethAmount >= minEth, \"Slippage too high\");\r\n\r\n        reserveTokens += tokenAmount;\r\n        reserveETH -= ethAmount;\r\n        volume = volume + ethAmount;\r\n\r\n        IERC20(token).transferFrom(msg.sender, address(this), tokenToSell);\r\n        (bool feeSuccess, ) = feeContract.call{value: ethAmountFee - ethAmountOwnerFee - affiliateFee}(\"\"); // paying plat fee\r\n        (bool feeAffiliateSuccess, ) = _affiliate.call{value: affiliateFee}(\"\"); // paying affiliate fee which is same amount as plat fee %\r\n        (bool ownerFeeSuccess, ) = owner.call{value: ethAmountOwnerFee}(\"\"); // paying owner fee per tx\r\n        //payable(msg.sender).transfer(ethAmount);\r\n        (bool sellerSuccess, ) = msg.sender.call{value: ethAmount - ethAmountFee}(\"\");\r\n       // require(feeSuccess && feeAffiliateSuccess && ownerFeeSuccess && sellerSuccess, \"ETH transfer failed\");\r\n        require(feeSuccess, \"fee ETH transfer failed\");\r\n        require(feeAffiliateSuccess, \"aff ETH transfer failed\");\r\n        require(ownerFeeSuccess, \"ownr ETH transfer failed\");\r\n        require(sellerSuccess, \"ownr ETH transfer failed\");\r\n        emit sold(msg.sender, tokenAmount, ethAmount, block.timestamp,reserveETH,reserveTokens,volume);\r\n        emit funTradeCall(msg.sender, tokenAmount, ethAmount, block.timestamp,reserveETH,reserveTokens,\"sell\",volume);\r\n        FunEventTracker(eventTracker).sellEvent(msg.sender,address(this),tokenToSell,ethAmount);\r\n\r\n        return (sellerSuccess,feeSuccess);\r\n    }\r\n\r\n    function buyTokens(uint256 minTokens, address _affiliate) public nonReentrant payable {\r\n        require(msg.value > 0, \"Invalid buy value\");\r\n        require(tradeActive, \"Trading not active\");\r\n        uint256 ethAmount = msg.value;\r\n        uint256 ethAmountFee = ethAmount * feePer / 10000;\r\n        uint256 ethAmountOwnerFee = ethAmountFee * (funDeployerInterface(deployer).getOwnerPer()) / 10000;\r\n        uint256 affiliateFee = ethAmountFee * (funDeployerInterface(deployer).getAffiliatePer(_affiliate)) / 10000;\r\n        uint256 tokenAmount = getAmountOut(ethAmount - ethAmountFee, reserveETH, reserveTokens);\r\n        require(tokenAmount >= minTokens, \"Slippage too high\");\r\n\r\n        reserveETH += (ethAmount - ethAmountFee);\r\n        reserveTokens -= tokenAmount;\r\n        volume = volume + ethAmount;\r\n\r\n        (bool feeSuccess, ) = feeContract.call{value: ethAmountFee - ethAmountOwnerFee - affiliateFee}(\"\"); // paying plat fee\r\n        (bool feeAffiliateSuccess, ) = _affiliate.call{value: affiliateFee}(\"\"); // paying affiliate fee which is same amount as plat fee %\r\n        (bool ownerFeeSuccess, ) = owner.call{value: ethAmountOwnerFee}(\"\"); // paying owner fee per tx\r\n        require(feeSuccess, \"fee ETH transfer failed\");\r\n        require(feeAffiliateSuccess, \"aff ETH transfer failed\");\r\n        require(ownerFeeSuccess, \"ownr ETH transfer failed\");\r\n        \r\n        IERC20(token).transfer(msg.sender, tokenAmount);\r\n        emit bought(msg.sender, msg.value, tokenAmount, block.timestamp,reserveETH,reserveTokens,volume);\r\n        emit funTradeCall(msg.sender, msg.value, tokenAmount, block.timestamp,reserveETH,reserveTokens,\"buy\",volume);\r\n        FunEventTracker(eventTracker).buyEvent(msg.sender,address(this),msg.value,tokenAmount);\r\n\r\n        // using liquidity value inside contract to check when to add liquidity to DEX\r\n        //if(getAmountsMinToken(stableAddress,reserveETH) >= listThreshold * 10 ** IERC20(stableAddress).decimals()){\r\n        if(getCurrentCap() >= (listThreshold * 10 ** IERC20(stableAddress).decimals()) * royalPer / 100 && !royalemitted){\r\n            funDeployerInterface(deployer).emitRoyal(address(this), token, router, baseToken,reserveETH,reserveTokens,block.timestamp,volume);\r\n            royalemitted = true;\r\n        }   \r\n        // using marketcap value of token to check when to add liquidity to DEX\r\n        if(getCurrentCap() >= listThreshold * 10 ** IERC20(stableAddress).decimals()){\r\n            tradeActive = false;\r\n            funTokenInterface(token).initiateDex();\r\n            //Approve(token);\r\n\r\n            if(nativePer > 0){\r\n\r\n                AddLiquidityETH((IERC20(token).balanceOf(address(this)) * nativePer)/100,(address(this).balance * nativePer)/100);\r\n\r\n            }\r\n            if(nativePer < 100){\r\n                swapEthToBase(baseToken,address(this).balance);\r\n                AddLiquidity(IERC20(token).balanceOf(address(this)),IERC20(baseToken).balanceOf(address(this)));                \r\n                \r\n            }\r\n            //AddLiquidityETH(IERC20(token).balanceOf(address(this)),address(this).balance, lpBurn);\r\n            \r\n            /*\r\n            if(lpBurn){\r\n                UniswapRouter02(router).addLiquidityETH{value:address(this).balance}(token, IERC20(token).balanceOf(address(this)), IERC20(token).balanceOf(address(this)), address(this).balance, dead, block.timestamp + (300));\r\n                SimpleERC20(token).initiateDex();\r\n            }\r\n            else{\r\n\r\n                 UniswapRouter02(router).addLiquidityETH{value:address(this).balance}(token, IERC20(token).balanceOf(address(this)), IERC20(token).balanceOf(address(this)), address(this).balance, address(this), block.timestamp + (300));\r\n                address storedLPAddr = UniswapFactory(UniswapRouter02(router).factory()).getPair(token, getWrapAddr());\r\n                ApproveLock(storedLPAddr,lpLockDeployer);\r\n                lockerAddress = lpLockDeployerInterface(lpLockDeployer).createLPLocker(storedLPAddr,17500000000,\"logo\",IERC20(storedLPAddr).balanceOf(address(this)), owner);\r\n                SimpleERC20(token).initiateDex();\r\n            }\r\n            */\r\n        }\r\n\r\n\r\n    }\r\n\r\n/*\r\n    function swapTokenForETH(uint256 tokenAmount) internal {\r\n        uint ethAmount = getAmountOut(tokenAmount, reserveTokens, reserveETH);\r\n        IERC20(token).transferFrom(msg.sender, address(this), tokenAmount);\r\n        payable(msg.sender).transfer(ethAmount);\r\n        reserveTokens += tokenAmount;\r\n        reserveETH -= ethAmount;\r\n\r\n        emit Swapped(msg.sender, tokenAmount, ethAmount, false);\r\n    }\r\n\r\n    // Swap ETH for token\r\n    function swapETHForToken() internal {\r\n        uint tokenAmount = getAmountOut(msg.value, reserveETH, reserveTokens);\r\n        IERC20(token).transfer(msg.sender, tokenAmount);\r\n        reserveETH += msg.value;\r\n        reserveTokens -= tokenAmount;\r\n\r\n        emit Swapped(msg.sender, msg.value, tokenAmount, true);\r\n    }\r\n*/\r\n    // Calculate amount of output tokens or ETH to give out\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) private pure returns (uint amountOut) {\r\n        require(amountIn > 0, \"Invalid input amount\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"Invalid reserves\");\r\n        uint numerator = amountIn * reserveOut;\r\n        uint denominator = (reserveIn) + amountIn;\r\n        amountOut = numerator / denominator;\r\n    }\r\n    function getAmountOutPublic(uint amountIn, uint reserveIn, uint reserveOut) public view returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"Invalid input amount\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"Invalid reserves\");\r\n        uint numerator = amountIn * reserveOut;\r\n        uint denominator = (reserveIn) + amountIn;\r\n        amountOut = numerator / denominator;\r\n        return amountOut;\r\n    }\r\n\r\n    function getCurrentCap() public view returns(uint256) {\r\n\r\n        return getAmountsMinToken(stableAddress,reserveETH) * IERC20(token).totalSupply() / reserveTokens;\r\n\r\n\r\n    }\r\n    function getToken() public view returns(address){\r\n\r\n        return address(token);\r\n\r\n    }\r\n    function getBaseToken() public view returns(address){\r\n\r\n        return address(baseToken);\r\n\r\n    }\r\n/*    \r\n    function changeNativePer(uint256 _newNativePer) public onlyOwner {\r\n\r\n        require(baseToken != getWrapAddr(),\"no custom base selected\");\r\n        require(_newNativePer >= 0 && _newNativePer <= 100,\"invalid per\");\r\n        nativePer = _newNativePer;\r\n\r\n\r\n\r\n    }\r\n*/\r\n\r\n}\r\n\r\n\r\ninterface funStorageInterface {\r\n\r\n    function addFunContract(address _funOwner,address _funAddress,address _tokenAddress,address _routerAddress, string memory _name, string memory _symbol, string memory _data, uint256 _totalSupply, uint256 _initialLiquidity) external;\r\n    function getFunContractOwner(address _funContract) external view returns (address);\r\n    function updateData(address _funOwner, uint256 _ownerFunNumber, string memory _data) external;\r\n}\r\n\r\ninterface FunEventTracker {\r\n\r\n    function buyEvent(address _caller, address _funContract, uint256 _buyAmount, uint256 _tokenRecieved) external;\r\n    function sellEvent(address _caller, address _funContract, uint256 _sellAmount, uint256 _nativeRecieved) external;\r\n    function createFunEvent(address creator, address funContract, address tokenAddress, string memory name, string memory symbol, string memory data, uint256 totalSupply,uint256 initialReserve, uint256 timestamp) external;\r\n    function listEvent(address user,address tokenAddress,address router,uint256 liquidityAmount,uint256 tokenAmount,uint256 _time,uint256 totalVolume) external;\r\n    function callerValidate(address _newFunContract) external;\r\n}\r\ninterface funTokenDeployerInterface{\r\n\r\n    //function createFunToken(string[2] memory _name_symbol, uint256 _totalSupply, address _deployer, address _midDeployer, uint256 _burnPer, address _creator) external returns(address);\r\n    function createFunToken(string[2] memory _name_symbol, uint256 _totalSupply, address _deployer, address _midDeployer) external  returns(address);\r\n\r\n\r\n}\r\ninterface funTokenInterface{\r\n\r\n    function setFunContract(address _funContract) external;\r\n    function initiateDex() external; \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_token_baseToken_deployer\",\"type\":\"address[3]\"},{\"internalType\":\"address[5]\",\"name\":\"eventTracker_txFee_lpLockDep_stableAddr_router\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[3]\",\"name\":\"_feePer_listThreshold_initResEth\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVolume\",\"type\":\"uint256\"}],\"name\":\"bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tradeType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVolume\",\"type\":\"uint256\"}],\"name\":\"funTradeCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVolume\",\"type\":\"uint256\"}],\"name\":\"listed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVolume\",\"type\":\"uint256\"}],\"name\":\"sold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eventTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOutPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethIN\",\"type\":\"uint256\"}],\"name\":\"getAmountsMinToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrapAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativePer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royalPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royalemitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"sellTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storedLPAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "fun", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000917d9856251ce2ec2bd3bac1a3c0ec6d404bc6ea000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000072e9f46b19116180d2422508803b2cb99907c530000000000000000000000000cee9498d1f9e46ab0fd0271d320cc470e9280bc0000000000000000000000001d6ebf29de04e80f3aace5a9422f9d45efb6d826000000000000000000000000a5edcf1b1288c87489a006c50aca62d2b324738c000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000002386f26fc10000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://714e1aa2d0f21cb20fc63812c6da6f53ebb5ec73c3d5b3ce8b4443541aabb295"}