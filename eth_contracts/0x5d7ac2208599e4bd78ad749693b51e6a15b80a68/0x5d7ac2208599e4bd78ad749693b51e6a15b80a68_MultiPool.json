{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/pkexec/MultiPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMPairFactory} from \\\"../LSSVMPairFactory.sol\\\";\\n\\ncontract MultiPool {\\n    LSSVMPairFactory immutable factory;\\n\\n    constructor(LSSVMPairFactory _factory) {\\n        factory = _factory;\\n    }\\n\\n    function createBulk1155Pools(\\n        LSSVMPairFactory.CreateERC1155ERC20PairParams[]\\n            calldata pairCreationArgs,\\n        uint256[] calldata _initialNFTBalances,\\n        // We expect token amounts to be 0 in the above params, and instead use the value submitted here for consistency\\n        uint256[] calldata tokenAmounts,\\n        bool isETH\\n    ) external payable returns (address[] memory) {\\n        address[] memory pairs = new address[](_initialNFTBalances.length);\\n\\n        if (!isETH) {\\n            // Create all pools\\n            for (uint256 i; i < pairCreationArgs.length; ) {\\n                LSSVMPairFactory.CreateERC1155ERC20PairParams\\n                    memory params = pairCreationArgs[i];\\n                LSSVMPair pair = factory.createPairERC1155ERC20(params);\\n\\n                // Deposit assets from caller into pools\\n                params.nft.safeTransferFrom(\\n                    msg.sender,\\n                    address(pair),\\n                    params.nftId,\\n                    _initialNFTBalances[i],\\n                    \\\"\\\"\\n                );\\n\\n                // Transfer ownership to caller\\n                pair.transferOwnership(msg.sender, \\\"\\\");\\n\\n                // Transfer tokens to pair\\n                if (tokenAmounts[i] > 0) {\\n                    params.token.transferFrom(\\n                        msg.sender,\\n                        address(pair),\\n                        tokenAmounts[i]\\n                    );\\n                }\\n\\n                pairs[i] = address(pair);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            for (uint256 i; i < pairCreationArgs.length; ) {\\n                LSSVMPairFactory.CreateERC1155ERC20PairParams\\n                    memory params = pairCreationArgs[i];\\n\\n                // Create pairs with eth\\n                LSSVMPair pair = factory.createPairERC1155ETH{value: tokenAmounts[i]}(\\n                    params.nft,\\n                    params.bondingCurve,\\n                    params.assetRecipient,\\n                    params.poolType,\\n                    params.delta,\\n                    params.fee,\\n                    params.spotPrice,\\n                    params.nftId,\\n                    params.initialNFTBalance\\n                );\\n\\n                // Deposit assets from caller into pools\\n                params.nft.safeTransferFrom(\\n                    msg.sender,\\n                    address(pair),\\n                    params.nftId,\\n                    _initialNFTBalances[i],\\n                    \\\"\\\"\\n                );\\n\\n                // Transfer ownership to caller\\n                pair.transferOwnership(msg.sender, \\\"\\\");\\n\\n                pairs[i] = address(pair);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport {ERC1155Holder} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"./bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\nimport {IOwnershipTransferReceiver} from \\\"./lib/IOwnershipTransferReceiver.sol\\\";\\nimport {OwnableWithTransferCallback} from \\\"./lib/OwnableWithTransferCallback.sol\\\";\\n\\n/**\\n * @title The base contract for an NFT/TOKEN AMM pair\\n * @author boredGenius, 0xmons, 0xCygaar\\n * @notice This implements the core swap logic from NFT to TOKEN\\n */\\nabstract contract LSSVMPair is OwnableWithTransferCallback, ERC721Holder, ERC1155Holder {\\n    /**\\n     * Library usage **\\n     */\\n\\n    using Address for address;\\n\\n    /**\\n     *  Enums **\\n     */\\n\\n    enum PoolType {\\n        TOKEN,\\n        NFT,\\n        TRADE\\n    }\\n\\n    /**\\n     * Constants **\\n     */\\n\\n    /**\\n     * @dev 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory)\\n     */\\n    uint256 internal constant MAX_TRADE_FEE = 0.5e18;\\n\\n    /**\\n     *  Immutable params **\\n     */\\n\\n    /**\\n     * @notice Sudoswap Royalty Engine\\n     */\\n    IRoyaltyEngineV1 public immutable ROYALTY_ENGINE;\\n\\n    /**\\n     *  Storage variables **\\n     */\\n\\n    /**\\n     * @dev This is generally used to mean the immediate sell price for the next marginal NFT.\\n     * However, this should NOT be assumed, as bonding curves may use spotPrice in different ways.\\n     * Use getBuyNFTQuote and getSellNFTQuote for accurate pricing info.\\n     */\\n    uint128 public spotPrice;\\n\\n    /**\\n     * @notice The parameter for the pair's bonding curve.\\n     * Units and meaning are bonding curve dependent.\\n     */\\n    uint128 public delta;\\n\\n    /**\\n     * @notice The spread between buy and sell prices, set to be a multiplier we apply to the buy price\\n     * Fee is only relevant for TRADE pools. Units are in base 1e18.\\n     */\\n    uint96 public fee;\\n\\n    /**\\n     * @notice The address that swapped assets are sent to.\\n     * For TRADE pools, assets are always sent to the pool, so this is used to track trade fee.\\n     * If set to address(0), will default to owner() for NFT and TOKEN pools.\\n     */\\n    address payable internal assetRecipient;\\n\\n    /**\\n     *  Events\\n     */\\n\\n    event SwapNFTInPair(uint256 amountOut, uint256[] ids);\\n    event SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\\n    event SwapNFTOutPair(uint256 amountIn, uint256[] ids);\\n    event SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\\n    event SpotPriceUpdate(uint128 newSpotPrice);\\n    event TokenDeposit(uint256 amount);\\n    event TokenWithdrawal(uint256 amount);\\n    event NFTWithdrawal(uint256[] ids);\\n    event NFTWithdrawal(uint256 numNFTs);\\n    event DeltaUpdate(uint128 newDelta);\\n    event FeeUpdate(uint96 newFee);\\n    event AssetRecipientChange(address indexed a);\\n\\n    /**\\n     *  Errors\\n     */\\n\\n    error LSSVMPair__NotRouter();\\n    error LSSVMPair__CallFailed();\\n    error LSSVMPair__InvalidDelta();\\n    error LSSVMPair__WrongPoolType();\\n    error LSSVMPair__OutputTooSmall();\\n    error LSSVMPair__ZeroSwapAmount();\\n    error LSSVMPair__RoyaltyTooLarge();\\n    error LSSVMPair__TradeFeeTooLarge();\\n    error LSSVMPair__InvalidSpotPrice();\\n    error LSSVMPair__TargetNotAllowed();\\n    error LSSVMPair__NftNotTransferred();\\n    error LSSVMPair__AlreadyInitialized();\\n    error LSSVMPair__FunctionNotAllowed();\\n    error LSSVMPair__DemandedInputTooLarge();\\n    error LSSVMPair__NonTradePoolWithTradeFee();\\n    error LSSVMPair__BondingCurveError(CurveErrorCodes.Error error);\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) {\\n        ROYALTY_ENGINE = royaltyEngine;\\n    }\\n\\n    /**\\n     * @notice Called during pair creation to set initial parameters\\n     * @dev Only called once by factory to initialize.\\n     * We verify this by making sure that the current owner is address(0).\\n     * The Ownable library we use disallows setting the owner to be address(0), so this condition\\n     * should only be valid before the first initialize call.\\n     * @param _owner The owner of the pair\\n     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.\\n     * @param _delta The initial delta of the bonding curve\\n     * @param _fee The initial % fee taken, if this is a trade pair\\n     * @param _spotPrice The initial price to sell an asset into the pair\\n     */\\n    function initialize(\\n        address _owner,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice\\n    ) external {\\n        if (owner() != address(0)) revert LSSVMPair__AlreadyInitialized();\\n        __Ownable_init(_owner);\\n\\n        ICurve _bondingCurve = bondingCurve();\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) {\\n            if (_fee != 0) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        } else {\\n            if (_fee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n            fee = _fee;\\n        }\\n\\n        assetRecipient = _assetRecipient;\\n\\n        if (!_bondingCurve.validateDelta(_delta)) revert LSSVMPair__InvalidDelta();\\n        if (!_bondingCurve.validateSpotPrice(_spotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        delta = _delta;\\n        spotPrice = _spotPrice;\\n    }\\n\\n    /**\\n     * External state-changing functions\\n     */\\n\\n    /**\\n     * @notice Sends token to the pair in exchange for a specific set of NFTs\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\\n     * This swap is meant for users who want specific IDs. Also higher chance of\\n     * reverting if some of the specified IDs leave the pool before the swap goes through.\\n     * @param nftIds The list of IDs of the NFTs to purchase\\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\\n     * amount is greater than this value, the transaction will be reverted.\\n     * @param nftRecipient The recipient of the NFTs\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     * @return - The amount of token used for purchase\\n     */\\n    function swapTokenForSpecificNFTs(\\n        uint256[] calldata nftIds,\\n        uint256 maxExpectedTokenInput,\\n        address nftRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external payable virtual returns (uint256);\\n\\n    /**\\n     * @notice Sends a set of NFTs to the pair in exchange for token\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @param nftIds The list of IDs of the NFTs to sell to the pair\\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\\n     * amount is less than this value, the transaction will be reverted.\\n     * @param tokenRecipient The recipient of the token output\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\\n     * ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\\n     * ETH pairs.\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external virtual returns (uint256 outputAmount);\\n\\n    /**\\n     * View functions\\n     */\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for buy pricing info\\n     * @param numNFTs The number of NFTs to buy from the pair\\n     */\\n    function getBuyNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        uint256 tradeFee;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            bondingCurve().getBuyInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Calculate the inputAmount minus tradeFee and protocolFee\\n            uint256 inputAmountMinusFees = inputAmount - tradeFee - protocolFee;\\n\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, inputAmountMinusFees);\\n\\n            inputAmount += royaltyAmount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for sell pricing info including royalties\\n     * @param numNFTs The number of NFTs to sell to the pair\\n     */\\n    function getSellNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        (error, newSpotPrice, newDelta, outputAmount, /* tradeFee */, protocolFee) =\\n            bondingCurve().getSellInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, outputAmount);\\n\\n            // Deduct royalties from outputAmount\\n            unchecked {\\n                // Safe because we already require outputAmount >= royaltyAmount in _calculateRoyalties()\\n                outputAmount -= royaltyAmount;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's variant (Pair uses ETH or ERC20)\\n     */\\n    function pairVariant() public pure virtual returns (ILSSVMPairFactoryLike.PairVariant);\\n\\n    function factory() public pure returns (ILSSVMPairFactoryLike _factory) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the type of bonding curve that parameterizes the pair\\n     */\\n    function bondingCurve() public pure returns (ICurve _bondingCurve) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address of NFT collection that parameterizes the pair\\n     */\\n    function nft() public pure returns (address _nft) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's type (TOKEN/NFT/TRADE)\\n     */\\n    function poolType() public pure returns (PoolType _poolType) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives assets when a swap is done with this pair\\n     * Can be set to another address by the owner, but has no effect on TRADE pools\\n     * If set to address(0), defaults to owner() for NFT/TOKEN pools\\n     */\\n    function getAssetRecipient() public view returns (address payable) {\\n        // TRADE pools will always receive the asset themselves\\n        if (poolType() == PoolType.TRADE) {\\n            return payable(address(this));\\n        }\\n\\n        address payable _assetRecipient = assetRecipient;\\n\\n        // Otherwise, we return the recipient if it's been set\\n        // Or, we replace it with owner() if it's address(0)\\n        if (_assetRecipient == address(0)) {\\n            return payable(owner());\\n        }\\n        return _assetRecipient;\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives trade fees when a swap is done with this pair\\n     * Only relevant for TRADE pools\\n     * If set to address(0), defaults to the pair itself\\n     */\\n    function getFeeRecipient() public view returns (address payable _feeRecipient) {\\n        _feeRecipient = assetRecipient;\\n        if (_feeRecipient == address(0)) {\\n            _feeRecipient = payable(address(this));\\n        }\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent into the pair for a buy and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to purchase from the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return tradeFee The amount of tokens to send as trade fee\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return inputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateBuyInfoAndUpdatePoolParams(uint256 numNFTs, ICurve _bondingCurve, ILSSVMPairFactoryLike _factory)\\n        internal\\n        returns (uint256 tradeFee, uint256 protocolFee, uint256 inputAmount)\\n    {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newDelta;\\n        uint128 newSpotPrice;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            _bondingCurve.getBuyInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent by the pair for a sell and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to send to the the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return outputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateSellInfoAndUpdatePoolParams(\\n        uint256 numNFTs,\\n        ICurve _bondingCurve,\\n        ILSSVMPairFactoryLike _factory\\n    ) internal returns (uint256 protocolFee, uint256 outputAmount) {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newSpotPrice;\\n        uint128 newDelta;\\n        (error, newSpotPrice, newDelta, outputAmount, /*tradeFee*/, protocolFee) =\\n            _bondingCurve.getSellInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pulls the token input of a trade from the trader (including all royalties and fees)\\n     * @param inputAmountExcludingRoyalty The amount of tokens to be sent, excluding the royalty (includes protocol fee)\\n     * @param royaltyAmounts The amounts of tokens to be sent as royalties\\n     * @param royaltyRecipients The recipients of the royalties\\n     * @param royaltyTotal The sum of all royaltyAmounts\\n     * @param tradeFeeAmount The amount of tokens to be sent as trade fee (if applicable)\\n     * @param isRouter Whether or not the caller is LSSVMRouter\\n     * @param routerCaller If called from LSSVMRouter, store the original caller\\n     * @param protocolFee The protocol fee to be paid\\n     */\\n    function _pullTokenInputs(\\n        uint256 inputAmountExcludingRoyalty,\\n        uint256[] memory royaltyAmounts,\\n        address payable[] memory royaltyRecipients,\\n        uint256 royaltyTotal,\\n        uint256 tradeFeeAmount,\\n        bool isRouter,\\n        address routerCaller,\\n        uint256 protocolFee\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Sends excess tokens back to the caller (if applicable)\\n     * @dev Swap callers interacting with an ETH pair must be able to receive ETH (e.g. if the caller sends too much ETH)\\n     */\\n    function _refundTokenToSender(uint256 inputAmount) internal virtual;\\n\\n    /**\\n     * @notice Sends tokens to a recipient\\n     * @param tokenRecipient The address receiving the tokens\\n     * @param outputAmount The amount of tokens to send\\n     */\\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal virtual;\\n\\n    /**\\n     * @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\\n     */\\n    function _immutableParamsLength() internal pure virtual returns (uint256);\\n\\n    /**\\n     * Royalty support functions\\n     */\\n\\n    function _calculateRoyalties(uint256 assetId, uint256 saleAmount)\\n        internal\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyalty(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Same as _calculateRoyalties, but uses getRoyaltyView to avoid state mutations and is public for external callers\\n     */\\n    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\\n        public\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyaltyView(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Common logic used by _calculateRoyalties() and calculateRoyaltiesView()\\n     */\\n    function _calculateRoyaltiesLogic(address payable[] memory recipients, uint256[] memory amounts, uint256 saleAmount)\\n        internal\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        // Cache to save gas\\n        uint256 numRecipients = recipients.length;\\n\\n        if (numRecipients != 0) {\\n            // If a pair has custom Settings, use the overridden royalty amount and only use the first receiver\\n            try factory().getSettingsForPair(address(this)) returns (bool settingsEnabled, uint96 bps) {\\n                if (settingsEnabled) {\\n                    royaltyRecipients = new address payable[](1);\\n                    royaltyRecipients[0] = recipients[0];\\n                    royaltyAmounts = new uint256[](1);\\n                    royaltyAmounts[0] = (saleAmount * bps) / 10000;\\n\\n                    // Update numRecipients to match new recipients list\\n                    numRecipients = 1;\\n                } else {\\n                    royaltyRecipients = recipients;\\n                    royaltyAmounts = amounts;\\n                }\\n            } catch {\\n                // Use the input values to calculate royalties if factory call fails\\n                royaltyRecipients = recipients;\\n                royaltyAmounts = amounts;\\n            }\\n        }\\n\\n        for (uint256 i; i < numRecipients;) {\\n            royaltyTotal += royaltyAmounts[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Ensure royalty total is at most 25% of the sale amount\\n        // This defends against a rogue Manifold registry that charges extremely high royalties\\n        if (royaltyTotal > saleAmount >> 2) {\\n            revert LSSVMPair__RoyaltyTooLarge();\\n        }\\n    }\\n\\n    /**\\n     * Owner functions\\n     */\\n\\n    /**\\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)\\n     * @param a The NFT to transfer\\n     * @param nftIds The list of IDs of the NFTs to send to the owner\\n     */\\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).\\n     * @param a The token to transfer\\n     * @param amount The amount of tokens to send to the owner\\n     */\\n    function withdrawERC20(ERC20 a, uint256 amount) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param ids The NFT ids to transfer\\n     * @param amounts The amounts of each id to transfer\\n     */\\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts) external virtual;\\n\\n    /**\\n     * @notice Updates the selling spot price. Only callable by the owner.\\n     * @param newSpotPrice The new selling spot price value, in Token\\n     */\\n    function changeSpotPrice(uint128 newSpotPrice) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateSpotPrice(newSpotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        if (spotPrice != newSpotPrice) {\\n            spotPrice = newSpotPrice;\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the delta parameter. Only callable by the owner.\\n     * @param newDelta The new delta parameter\\n     */\\n    function changeDelta(uint128 newDelta) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateDelta(newDelta)) revert LSSVMPair__InvalidDelta();\\n        if (delta != newDelta) {\\n            delta = newDelta;\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the fee taken by the LP. Only callable by the owner.\\n     * Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.\\n     * @param newFee The new LP fee percentage, 18 decimals\\n     */\\n    function changeFee(uint96 newFee) external onlyOwner {\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        if (newFee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n        if (fee != newFee) {\\n            fee = newFee;\\n            emit FeeUpdate(newFee);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the address that will receive assets received from\\n     * trades. Only callable by the owner.\\n     * @param newRecipient The new asset recipient\\n     */\\n    function changeAssetRecipient(address payable newRecipient) external onlyOwner {\\n        if (assetRecipient != newRecipient) {\\n            assetRecipient = newRecipient;\\n            emit AssetRecipientChange(newRecipient);\\n        }\\n    }\\n\\n    function _preCallCheck(address target) internal virtual;\\n\\n    /**\\n     * @notice Allows the pair to make arbitrary external calls to contracts\\n     * whitelisted by the protocol. Only callable by the owner.\\n     * @param target The contract to call\\n     * @param data The calldata to pass to the contract\\n     */\\n    function call(address payable target, bytes calldata data) external onlyOwner {\\n        ILSSVMPairFactoryLike _factory = factory();\\n        if (!_factory.callAllowed(target)) revert LSSVMPair__TargetNotAllowed();\\n\\n        // Ensure the call isn't calling a banned function\\n        bytes4 sig = bytes4(data[:4]);\\n        if (\\n            sig == IOwnershipTransferReceiver.onOwnershipTransferred.selector\\n                || sig == LSSVMRouter.pairTransferERC20From.selector || sig == LSSVMRouter.pairTransferNFTFrom.selector\\n                || sig == LSSVMRouter.pairTransferERC1155From.selector || sig == ILSSVMPairFactoryLike.openLock.selector\\n                || sig == ILSSVMPairFactoryLike.closeLock.selector\\n        ) {\\n            revert LSSVMPair__FunctionNotAllowed();\\n        }\\n\\n        // Prevent calling the pair's underlying nft\\n        // (We ban calling the underlying NFT/ERC20 to avoid maliciously transferring assets approved for the pair to spend)\\n        if (target == nft()) revert LSSVMPair__TargetNotAllowed();\\n\\n        _preCallCheck(target);\\n\\n        (bool success,) = target.call{value: 0}(data);\\n        if (!success) revert LSSVMPair__CallFailed();\\n    }\\n\\n    /**\\n     * @notice Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\\n     * @notice The revert handling is forked from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\\n     * @dev Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner\\n     * @param calls The calldata for each call to make\\n     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail. Calls to transferOwnership will revert regardless.\\n     */\\n    function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner {\\n        for (uint256 i; i < calls.length;) {\\n            bytes4 sig = bytes4(calls[i][:4]);\\n            // We ban calling transferOwnership when ownership\\n            if (sig == transferOwnership.selector) revert LSSVMPair__FunctionNotAllowed();\\n\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            if (!success && revertOnFail) {\\n                assembly {\\n                    revert(add(0x20, result), mload(result))\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMPairFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"./bonding-curves/ICurve.sol\\\";\\nimport {LSSVMPairCloner} from \\\"./lib/LSSVMPairCloner.sol\\\";\\nimport {LSSVMPairERC1155} from \\\"./erc1155/LSSVMPairERC1155.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {LSSVMPairERC20} from \\\"./LSSVMPairERC20.sol\\\";\\nimport {LSSVMPairERC721ETH} from \\\"./erc721/LSSVMPairERC721ETH.sol\\\";\\nimport {LSSVMPairERC1155ETH} from \\\"./erc1155/LSSVMPairERC1155ETH.sol\\\";\\nimport {LSSVMPairERC721ERC20} from \\\"./erc721/LSSVMPairERC721ERC20.sol\\\";\\nimport {LSSVMPairERC1155ERC20} from \\\"./erc1155/LSSVMPairERC1155ERC20.sol\\\";\\n\\nimport {ISettings} from \\\"./settings/ISettings.sol\\\";\\n\\n/**\\n * @notice Imports for authAllowedForToken (forked from manifold.xyz Royalty Registry)\\n */\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\\\";\\nimport \\\"./royalty-auth/INiftyGateway.sol\\\";\\nimport \\\"./royalty-auth/IFoundation.sol\\\";\\nimport \\\"./royalty-auth/IDigitalax.sol\\\";\\nimport \\\"./royalty-auth/IArtBlocks.sol\\\";\\n\\n/**\\n * @title The factory contract used to deploy new pairs\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\ncontract LSSVMPairFactory is Owned, ILSSVMPairFactoryLike {\\n    using LSSVMPairCloner for address;\\n    using AddressUpgradeable for address;\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    uint256 internal constant MAX_PROTOCOL_FEE = 0.1e18; // 10%, must <= 1 - MAX_FEE\\n\\n    LSSVMPairERC721ETH public immutable erc721ETHTemplate;\\n    LSSVMPairERC721ERC20 public immutable erc721ERC20Template;\\n    LSSVMPairERC1155ETH public immutable erc1155ETHTemplate;\\n    LSSVMPairERC1155ERC20 public immutable erc1155ERC20Template;\\n    address payable public override protocolFeeRecipient;\\n\\n    // Units are in base 1e18\\n    uint256 public override protocolFeeMultiplier;\\n\\n    mapping(ICurve => bool) public bondingCurveAllowed;\\n    mapping(address => bool) public override callAllowed;\\n\\n    // Data structures for settings logic\\n    mapping(address => mapping(address => bool)) public settingsForCollection;\\n    mapping(address => address) public settingsForPair;\\n\\n    struct RouterStatus {\\n        bool allowed;\\n        bool wasEverTouched;\\n    }\\n\\n    mapping(LSSVMRouter => RouterStatus) public override routerStatus;\\n\\n    address private constant _NOT_ENTERED = address(1);\\n    address private _caller;\\n\\n    event NewERC721Pair(address indexed poolAddress, uint256[] initialIds);\\n    event NewERC1155Pair(address indexed poolAddress, uint256 initialBalance);\\n    event ERC20Deposit(address indexed poolAddress, uint256 amount);\\n    event NFTDeposit(address indexed poolAddress, uint256[] ids);\\n    event ERC1155Deposit(address indexed poolAddress, uint256 indexed id, uint256 amount);\\n    event ProtocolFeeRecipientUpdate(address indexed recipientAddress);\\n    event ProtocolFeeMultiplierUpdate(uint256 newMultiplier);\\n    event BondingCurveStatusUpdate(ICurve indexed bondingCurve, bool isAllowed);\\n    event CallTargetStatusUpdate(address indexed target, bool isAllowed);\\n    event RouterStatusUpdate(LSSVMRouter indexed router, bool isAllowed);\\n\\n    error LSSVMPairFactory__FeeTooLarge();\\n    error LSSVMPairFactory__BondingCurveNotWhitelisted();\\n    error LSSVMPairFactory__ReentrantCall();\\n    error LSSVMPairFactory__ZeroAddress();\\n    error LSSVMPairFactory__CannotCallRouter();\\n    error LSSVMPairFactory__UnauthorizedCaller();\\n    error LSSVMPairFactory__InvalidPair();\\n    error LSSVMPairFactory__SettingsNotEnabledForCollection();\\n    error LSSVMPairFactory__SettingsNotEnabledForPair();\\n\\n    constructor(\\n        LSSVMPairERC721ETH _erc721ETHTemplate,\\n        LSSVMPairERC721ERC20 _erc721ERC20Template,\\n        LSSVMPairERC1155ETH _erc1155ETHTemplate,\\n        LSSVMPairERC1155ERC20 _erc1155ERC20Template,\\n        address payable _protocolFeeRecipient,\\n        uint256 _protocolFeeMultiplier,\\n        address _owner\\n    ) Owned(_owner) {\\n        erc721ETHTemplate = _erc721ETHTemplate;\\n        erc721ERC20Template = _erc721ERC20Template;\\n        erc1155ETHTemplate = _erc1155ETHTemplate;\\n        erc1155ERC20Template = _erc1155ERC20Template;\\n        protocolFeeRecipient = _protocolFeeRecipient;\\n        if (_protocolFeeMultiplier > MAX_PROTOCOL_FEE) revert LSSVMPairFactory__FeeTooLarge();\\n        protocolFeeMultiplier = _protocolFeeMultiplier;\\n        _caller = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * External functions\\n     */\\n\\n    /**\\n     * @notice Creates a pair contract using EIP-1167.\\n     * @param _nft The NFT contract of the collection the pair trades\\n     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted\\n     * @param _assetRecipient The address that will receive the assets traders give during trades.\\n     * If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.\\n     * @param _poolType TOKEN, NFT, or TRADE\\n     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.\\n     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.\\n     * @param _spotPrice The initial selling spot price\\n     * @param _propertyChecker The contract to use for verifying properties of IDs sent in\\n     * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair\\n     * @return pair The new pair\\n     */\\n    function createPairERC721ETH(\\n        IERC721 _nft,\\n        ICurve _bondingCurve,\\n        address payable _assetRecipient,\\n        LSSVMPair.PoolType _poolType,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        address _propertyChecker,\\n        uint256[] calldata _initialNFTIDs\\n    ) external payable returns (LSSVMPairERC721ETH pair) {\\n        if (!bondingCurveAllowed[_bondingCurve]) revert LSSVMPairFactory__BondingCurveNotWhitelisted();\\n\\n        pair = LSSVMPairERC721ETH(\\n            payable(\\n                address(erc721ETHTemplate).cloneERC721ETHPair(\\n                    this, _bondingCurve, _nft, uint8(_poolType), _propertyChecker\\n                )\\n            )\\n        );\\n\\n        _initializePairERC721ETH(pair, _nft, _assetRecipient, _delta, _fee, _spotPrice, _initialNFTIDs);\\n        emit NewERC721Pair(address(pair), _initialNFTIDs);\\n    }\\n\\n    struct CreateERC721ERC20PairParams {\\n        ERC20 token;\\n        IERC721 nft;\\n        ICurve bondingCurve;\\n        address payable assetRecipient;\\n        LSSVMPair.PoolType poolType;\\n        uint128 delta;\\n        uint96 fee;\\n        uint128 spotPrice;\\n        address propertyChecker;\\n        uint256[] initialNFTIDs;\\n        uint256 initialTokenBalance;\\n    }\\n\\n    /**\\n     * @notice Creates a pair contract using EIP-1167.\\n     * @param params The info used to create a new pair. This includes:\\n     * - token: The ERC20 token the pair trades\\n     * - nft: The NFT contract of the collection the pair trades\\n     * - bondingCurve: The bonding curve for the pair to price NFTs, must be whitelisted\\n     * - assetRecipient: The address that will receive the assets traders give during trades.\\n     *   If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.\\n     * - poolType: TOKEN, NFT, or TRADE\\n     * - delta: The delta value used by the bonding curve. The meaning of delta depends on the specific curve.\\n     * - fee: The fee taken by the LP in each trade. Can only be non-zero if poolType is Trade.\\n     * - spotPrice: Param 1 for the bonding curve, usually used for start price\\n     * - delta: Param 2 for the bonding curve, usually used for dynamic adjustment\\n     * - propertyChecker: The contract to use for verifying properties of IDs sent in\\n     * - initialNFTIDs: The list of IDs of NFTs to transfer from the sender to the pair\\n     * - initialTokenBalance: The initial token balance sent from the sender to the new pair\\n     * @return pair The new pair\\n     */\\n    function createPairERC721ERC20(CreateERC721ERC20PairParams calldata params)\\n        external\\n        returns (LSSVMPairERC721ERC20 pair)\\n    {\\n        if (!bondingCurveAllowed[params.bondingCurve]) revert LSSVMPairFactory__BondingCurveNotWhitelisted();\\n\\n        pair = LSSVMPairERC721ERC20(\\n            payable(\\n                address(erc721ERC20Template).cloneERC721ERC20Pair(\\n                    this, params.bondingCurve, params.nft, uint8(params.poolType), params.propertyChecker, params.token\\n                )\\n            )\\n        );\\n\\n        _initializePairERC721ERC20(\\n            pair,\\n            params.token,\\n            params.nft,\\n            params.assetRecipient,\\n            params.delta,\\n            params.fee,\\n            params.spotPrice,\\n            params.initialNFTIDs,\\n            params.initialTokenBalance\\n        );\\n        emit NewERC721Pair(address(pair), params.initialNFTIDs);\\n    }\\n    /**\\n     * @notice Creates a pair contract using EIP-1167.\\n     * @param _nft The NFT contract of the collection the pair trades\\n     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted\\n     * @param _assetRecipient The address that will receive the assets traders give during trades.\\n     * If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.\\n     * @param _poolType TOKEN, NFT, or TRADE\\n     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.\\n     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.\\n     * @param _spotPrice The initial selling spot price\\n     * @param _nftId The ID of the NFT to trade\\n     * @param _initialNFTBalance The amount of NFTs to transfer from the sender to the pair\\n     * @return pair The new pair\\n     */\\n\\n    function createPairERC1155ETH(\\n        IERC1155 _nft,\\n        ICurve _bondingCurve,\\n        address payable _assetRecipient,\\n        LSSVMPairERC1155ETH.PoolType _poolType,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        uint256 _nftId,\\n        uint256 _initialNFTBalance\\n    ) external payable returns (LSSVMPairERC1155ETH pair) {\\n        if (!bondingCurveAllowed[_bondingCurve]) revert LSSVMPairFactory__BondingCurveNotWhitelisted();\\n\\n        pair = LSSVMPairERC1155ETH(\\n            payable(\\n                address(erc1155ETHTemplate).cloneERC1155ETHPair(this, _bondingCurve, _nft, uint8(_poolType), _nftId)\\n            )\\n        );\\n\\n        _initializePairERC1155ETH(pair, _nft, _assetRecipient, _delta, _fee, _spotPrice, _nftId, _initialNFTBalance);\\n        emit NewERC1155Pair(address(pair), _initialNFTBalance);\\n    }\\n\\n    struct CreateERC1155ERC20PairParams {\\n        ERC20 token;\\n        IERC1155 nft;\\n        ICurve bondingCurve;\\n        address payable assetRecipient;\\n        LSSVMPairERC1155ERC20.PoolType poolType;\\n        uint128 delta;\\n        uint96 fee;\\n        uint128 spotPrice;\\n        uint256 nftId;\\n        uint256 initialNFTBalance;\\n        uint256 initialTokenBalance;\\n    }\\n\\n    /**\\n     * @notice Creates a pair contract using EIP-1167.\\n     * @param params The info used to create a new pair. This includes:\\n     * - token: The ERC20 token the pair trades\\n     * - nft: The NFT contract of the collection the pair trades\\n     * - bondingCurve: The bonding curve for the pair to price NFTs, must be whitelisted\\n     * - assetRecipient: The address that will receive the assets traders give during trades.\\n     *   If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.\\n     * - poolType: TOKEN, NFT, or TRADE\\n     * - delta: The delta value used by the bonding curve. The meaning of delta depends on the specific curve.\\n     * - fee: The fee taken by the LP in each trade. Can only be non-zero if poolType is Trade.\\n     * - spotPrice: Param 1 for the bonding curve, usually used for start price\\n     * - nftId: The ERC1155 nft id that this pair trades\\n     * - initialNFTBalance: The initial NFT balance sent from the sender to the new pair\\n     * - initialTokenBalance: The initial token balance sent from the sender to the new pair\\n     * @return pair The new pair\\n     */\\n    function createPairERC1155ERC20(CreateERC1155ERC20PairParams calldata params)\\n        external\\n        returns (LSSVMPairERC1155ERC20 pair)\\n    {\\n        if (!bondingCurveAllowed[params.bondingCurve]) revert LSSVMPairFactory__BondingCurveNotWhitelisted();\\n\\n        pair = LSSVMPairERC1155ERC20(\\n            payable(\\n                address(erc1155ERC20Template).cloneERC1155ERC20Pair(\\n                    this, params.bondingCurve, params.nft, uint8(params.poolType), params.nftId, params.token\\n                )\\n            )\\n        );\\n\\n        _initializePairERC1155ERC20(\\n            pair,\\n            params.token,\\n            params.nft,\\n            params.assetRecipient,\\n            params.delta,\\n            params.fee,\\n            params.spotPrice,\\n            params.nftId,\\n            params.initialNFTBalance,\\n            params.initialTokenBalance\\n        );\\n        emit NewERC1155Pair(address(pair), params.initialNFTBalance);\\n    }\\n\\n    function isValidPair(address pairAddress) public view returns (bool) {\\n        PairVariant variant = LSSVMPair(pairAddress).pairVariant();\\n        if (variant == PairVariant.ERC721_ETH) {\\n            return LSSVMPairCloner.isERC721ETHPairClone(address(this), address(erc721ETHTemplate), pairAddress);\\n        } else if (variant == PairVariant.ERC721_ERC20) {\\n            return LSSVMPairCloner.isERC721ERC20PairClone(address(this), address(erc721ERC20Template), pairAddress);\\n        } else if (variant == PairVariant.ERC1155_ETH) {\\n            return LSSVMPairCloner.isERC1155ETHPairClone(address(this), address(erc1155ETHTemplate), pairAddress);\\n        } else if (variant == PairVariant.ERC1155_ERC20) {\\n            return LSSVMPairCloner.isERC1155ERC20PairClone(address(this), address(erc1155ERC20Template), pairAddress);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function getPairNFTType(address pairAddress) public pure returns (PairNFTType) {\\n        PairVariant variant = LSSVMPair(pairAddress).pairVariant();\\n        return PairNFTType(uint8(variant) / 2);\\n    }\\n\\n    function getPairTokenType(address pairAddress) public pure returns (PairTokenType) {\\n        PairVariant variant = LSSVMPair(pairAddress).pairVariant();\\n        return PairTokenType(uint8(variant) % 2);\\n    }\\n\\n    function openLock() public {\\n        if (_caller == msg.sender) revert LSSVMPairFactory__ReentrantCall();\\n        _caller = msg.sender;\\n    }\\n\\n    function closeLock() public {\\n        if (_caller != msg.sender) revert LSSVMPairFactory__ReentrantCall();\\n        _caller = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @notice Checks if an address is an allowed auth for a token\\n     * @param tokenAddress The token address to check\\n     * @param proposedAuthAddress The auth address to check\\n     * @return True if the proposedAuthAddress is a valid auth for the tokenAddress, false otherwise.\\n     */\\n    function authAllowedForToken(address tokenAddress, address proposedAuthAddress) public view returns (bool) {\\n        // Check for admin interface\\n        if (\\n            ERC165Checker.supportsInterface(tokenAddress, type(IAdminControl).interfaceId)\\n                && IAdminControl(tokenAddress).isAdmin(proposedAuthAddress)\\n        ) {\\n            return true;\\n        }\\n        // Check for owner\\n        try OwnableUpgradeable(tokenAddress).owner() returns (address owner) {\\n            if (owner == proposedAuthAddress) return true;\\n\\n            if (owner.isContract()) {\\n                try OwnableUpgradeable(owner).owner() returns (address passThroughOwner) {\\n                    if (passThroughOwner == proposedAuthAddress) return true;\\n                } catch {}\\n            }\\n        } catch {}\\n        // Check for default OZ auth role\\n        try IAccessControlUpgradeable(tokenAddress).hasRole(0x00, proposedAuthAddress) returns (bool hasRole) {\\n            if (hasRole) return true;\\n        } catch {}\\n        // Nifty Gateway overrides\\n        try INiftyBuilderInstance(tokenAddress).niftyRegistryContract() returns (address niftyRegistry) {\\n            try INiftyRegistry(niftyRegistry).isValidNiftySender(proposedAuthAddress) returns (bool valid) {\\n                if (valid) return true;\\n            } catch {}\\n        } catch {}\\n        // Foundation overrides\\n        try IFoundationTreasuryNode(tokenAddress).getFoundationTreasury() returns (address payable foundationTreasury) {\\n            try IFoundationTreasury(foundationTreasury).isAdmin(proposedAuthAddress) returns (bool isAdmin) {\\n                if (isAdmin) return true;\\n            } catch {}\\n        } catch {}\\n        // DIGITALAX overrides\\n        try IDigitalax(tokenAddress).accessControls() returns (address externalAccessControls) {\\n            try IDigitalaxAccessControls(externalAccessControls).hasAdminRole(proposedAuthAddress) returns (\\n                bool hasRole\\n            ) {\\n                if (hasRole) return true;\\n            } catch {}\\n        } catch {}\\n        // Art Blocks overrides\\n        try IArtBlocks(tokenAddress).admin() returns (address admin) {\\n            if (admin == proposedAuthAddress) return true;\\n        } catch {}\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Allows receiving ETH in order to receive protocol fees\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * Admin functions\\n     */\\n\\n    /**\\n     * @notice Withdraws the ETH balance to the protocol fee recipient.\\n     * Only callable by the owner.\\n     */\\n    function withdrawETHProtocolFees() external onlyOwner {\\n        protocolFeeRecipient.safeTransferETH(address(this).balance);\\n    }\\n\\n    /**\\n     * @notice Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.\\n     * @param token The token to transfer\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function withdrawERC20ProtocolFees(ERC20 token, uint256 amount) external onlyOwner {\\n        token.safeTransfer(protocolFeeRecipient, amount);\\n    }\\n\\n    /**\\n     * @notice Changes the protocol fee recipient address. Only callable by the owner.\\n     * @param _protocolFeeRecipient The new fee recipient\\n     */\\n    function changeProtocolFeeRecipient(address payable _protocolFeeRecipient) external onlyOwner {\\n        if (_protocolFeeRecipient == address(0)) revert LSSVMPairFactory__ZeroAddress();\\n        protocolFeeRecipient = _protocolFeeRecipient;\\n        emit ProtocolFeeRecipientUpdate(_protocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @notice Changes the protocol fee multiplier. Only callable by the owner.\\n     * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals\\n     */\\n    function changeProtocolFeeMultiplier(uint256 _protocolFeeMultiplier) external onlyOwner {\\n        if (_protocolFeeMultiplier > MAX_PROTOCOL_FEE) revert LSSVMPairFactory__FeeTooLarge();\\n        protocolFeeMultiplier = _protocolFeeMultiplier;\\n        emit ProtocolFeeMultiplierUpdate(_protocolFeeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Sets the whitelist status of a bonding curve contract. Only callable by the owner.\\n     * @param bondingCurve The bonding curve contract\\n     * @param isAllowed True to whitelist, false to remove from whitelist\\n     */\\n    function setBondingCurveAllowed(ICurve bondingCurve, bool isAllowed) external onlyOwner {\\n        bondingCurveAllowed[bondingCurve] = isAllowed;\\n        emit BondingCurveStatusUpdate(bondingCurve, isAllowed);\\n    }\\n\\n    /**\\n     * @notice Sets the whitelist status of a contract to be called arbitrarily by a pair.\\n     * Only callable by the owner.\\n     * @param target The target contract\\n     * @param isAllowed True to whitelist, false to remove from whitelist\\n     */\\n    function setCallAllowed(address payable target, bool isAllowed) external onlyOwner {\\n        // Ensure target is not / was not ever a router\\n        if (isAllowed) {\\n            if (routerStatus[LSSVMRouter(target)].wasEverTouched) revert LSSVMPairFactory__CannotCallRouter();\\n        }\\n\\n        callAllowed[target] = isAllowed;\\n        emit CallTargetStatusUpdate(target, isAllowed);\\n    }\\n\\n    /**\\n     * @notice Updates the router whitelist. Only callable by the owner.\\n     * @param _router The router\\n     * @param isAllowed True to whitelist, false to remove from whitelist\\n     */\\n    function setRouterAllowed(LSSVMRouter _router, bool isAllowed) external onlyOwner {\\n        // Ensure target is not arbitrarily callable by pairs\\n        if (isAllowed) {\\n            if (callAllowed[address(_router)]) revert LSSVMPairFactory__CannotCallRouter();\\n        }\\n        routerStatus[_router] = RouterStatus({allowed: isAllowed, wasEverTouched: true});\\n\\n        emit RouterStatusUpdate(_router, isAllowed);\\n    }\\n\\n    /**\\n     * @notice Returns the Settings for a pair if it currently has Settings\\n     * @param pairAddress The address of the pair to look up\\n     * @return settingsEnabled Whether or not the pair has custom settings\\n     * @return bps The royalty basis points from the custom settings, 0 if there is no custom settings\\n     */\\n    function getSettingsForPair(address pairAddress) public view returns (bool settingsEnabled, uint96 bps) {\\n        address settingsAddress = settingsForPair[pairAddress];\\n        if (settingsAddress == address(0)) {\\n            return (false, 0);\\n        }\\n        return ISettings(settingsAddress).getRoyaltyInfo(pairAddress);\\n    }\\n\\n    /**\\n     * @notice Enables or disables an settings for a given NFT collection\\n     *  @param settings The address of the Settings contract\\n     *  @param collectionAddress The NFT project that the settings is toggled for\\n     *  @param enable Bool to determine whether to disable or enable the settings\\n     */\\n    function toggleSettingsForCollection(address settings, address collectionAddress, bool enable) public {\\n        if (!authAllowedForToken(collectionAddress, msg.sender)) revert LSSVMPairFactory__UnauthorizedCaller();\\n        if (enable) {\\n            settingsForCollection[collectionAddress][settings] = true;\\n        } else {\\n            delete settingsForCollection[collectionAddress][settings];\\n        }\\n    }\\n\\n    /**\\n     * @notice Enables an Settings for a given Pair\\n     * @notice Only the owner of the Pair can call this function\\n     * @notice The Settings must be enabled for the Pair's collection\\n     * @param settings The address of the Settings contract\\n     * @param pairAddress The address of the Pair contract\\n     */\\n    function enableSettingsForPair(address settings, address pairAddress) public {\\n        if (!isValidPair(pairAddress)) revert LSSVMPairFactory__InvalidPair();\\n        LSSVMPair pair = LSSVMPair(pairAddress);\\n        if (pair.owner() != msg.sender) revert LSSVMPairFactory__UnauthorizedCaller();\\n        if (!settingsForCollection[address(pair.nft())][settings]) {\\n            revert LSSVMPairFactory__SettingsNotEnabledForCollection();\\n        }\\n        settingsForPair[pairAddress] = settings;\\n    }\\n\\n    /**\\n     * @notice Disables an Settings for a given Pair\\n     * @notice Only the owner of the Pair can call this function\\n     * @notice The Settings must already be enabled for the Pair\\n     * @param settings The address of the Settings contract\\n     * @param pairAddress The address of the Pair contract\\n     */\\n    function disableSettingsForPair(address settings, address pairAddress) public {\\n        if (!isValidPair(pairAddress)) revert LSSVMPairFactory__InvalidPair();\\n        if (settingsForPair[pairAddress] != settings) revert LSSVMPairFactory__SettingsNotEnabledForPair();\\n        LSSVMPair pair = LSSVMPair(pairAddress);\\n        if (pair.owner() != msg.sender) revert LSSVMPairFactory__UnauthorizedCaller();\\n        delete settingsForPair[pairAddress];\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    function _initializePairERC721ETH(\\n        LSSVMPairERC721ETH _pair,\\n        IERC721 _nft,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        uint256[] calldata _initialNFTIDs\\n    ) internal {\\n        // Initialize pair\\n        _pair.initialize(msg.sender, _assetRecipient, _delta, _fee, _spotPrice);\\n\\n        // Transfer initial ETH to pair\\n        if (msg.value != 0) payable(address(_pair)).safeTransferETH(msg.value);\\n\\n        // Transfer initial NFTs from sender to pair\\n        uint256 numNFTs = _initialNFTIDs.length;\\n        for (uint256 i; i < numNFTs;) {\\n            _nft.transferFrom(msg.sender, address(_pair), _initialNFTIDs[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _initializePairERC721ERC20(\\n        LSSVMPairERC721ERC20 _pair,\\n        ERC20 _token,\\n        IERC721 _nft,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        uint256[] calldata _initialNFTIDs,\\n        uint256 _initialTokenBalance\\n    ) internal {\\n        // Initialize pair\\n        _pair.initialize(msg.sender, _assetRecipient, _delta, _fee, _spotPrice);\\n\\n        // Transfer initial tokens to pair (if != 0)\\n        if (_initialTokenBalance != 0) {\\n            _token.safeTransferFrom(msg.sender, address(_pair), _initialTokenBalance);\\n        }\\n\\n        // Transfer initial NFTs from sender to pair\\n        uint256 numNFTs = _initialNFTIDs.length;\\n        for (uint256 i; i < numNFTs;) {\\n            _nft.transferFrom(msg.sender, address(_pair), _initialNFTIDs[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _initializePairERC1155ETH(\\n        LSSVMPairERC1155ETH _pair,\\n        IERC1155 _nft,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        uint256 _nftId,\\n        uint256 _initialNFTBalance\\n    ) internal {\\n        // Initialize pair\\n        _pair.initialize(msg.sender, _assetRecipient, _delta, _fee, _spotPrice);\\n\\n        // Transfer initial ETH to pair\\n        if (msg.value != 0) payable(address(_pair)).safeTransferETH(msg.value);\\n\\n        // Transfer initial NFTs from sender to pair\\n        if (_initialNFTBalance != 0) {\\n            _nft.safeTransferFrom(msg.sender, address(_pair), _nftId, _initialNFTBalance, bytes(\\\"\\\"));\\n        }\\n    }\\n\\n    function _initializePairERC1155ERC20(\\n        LSSVMPairERC1155ERC20 _pair,\\n        ERC20 _token,\\n        IERC1155 _nft,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        uint256 _nftId,\\n        uint256 _initialNFTBalance,\\n        uint256 _initialTokenBalance\\n    ) internal {\\n        // Initialize pair\\n        _pair.initialize(msg.sender, _assetRecipient, _delta, _fee, _spotPrice);\\n\\n        // Transfer initial tokens to pair\\n        if (_initialTokenBalance != 0) {\\n            _token.safeTransferFrom(msg.sender, address(_pair), _initialTokenBalance);\\n        }\\n\\n        // Transfer initial NFTs from sender to pair\\n        if (_initialNFTBalance != 0) {\\n            _nft.safeTransferFrom(msg.sender, address(_pair), _nftId, _initialNFTBalance, bytes(\\\"\\\"));\\n        }\\n    }\\n\\n    /**\\n     * @dev Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)\\n     */\\n    function depositNFTs(IERC721 _nft, uint256[] calldata ids, address recipient) external {\\n        uint256 numNFTs = ids.length;\\n\\n        // Early return for trivial transfers\\n        if (numNFTs == 0) return;\\n\\n        // Transfer NFTs from caller to recipient\\n        for (uint256 i; i < numNFTs;) {\\n            _nft.transferFrom(msg.sender, recipient, ids[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (isValidPair(recipient) && (address(_nft) == LSSVMPair(recipient).nft())) {\\n            emit NFTDeposit(recipient, ids);\\n        }\\n    }\\n\\n    /**\\n     * @dev Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)\\n     */\\n    function depositERC20(ERC20 token, address recipient, uint256 amount) external {\\n        // Early return for trivial transfers\\n        if (amount == 0) return;\\n\\n        token.safeTransferFrom(msg.sender, recipient, amount);\\n        if (\\n            isValidPair(recipient) && getPairTokenType(recipient) == PairTokenType.ERC20\\n                && token == LSSVMPairERC20(recipient).token()\\n        ) {\\n            emit ERC20Deposit(recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Used to deposit ERC1155 NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)\\n     */\\n    function depositERC1155(IERC1155 nft, uint256 id, address recipient, uint256 amount) external {\\n        if (amount == 0) return;\\n\\n        nft.safeTransferFrom(msg.sender, recipient, id, amount, bytes(\\\"\\\"));\\n\\n        if (\\n            isValidPair(recipient) && getPairNFTType(recipient) == PairNFTType.ERC1155\\n                && address(nft) == LSSVMPair(recipient).nft() && id == LSSVMPairERC1155(recipient).nftId()\\n        ) {\\n            emit ERC1155Deposit(recipient, id, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Lookup engine interface\\n */\\ninterface IRoyaltyEngineV1 is IERC165 {\\n    /**\\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n\\n    /**\\n     * View only version of getRoyalty\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        view\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\n\\ncontract LSSVMRouter {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    struct PairSwapSpecific {\\n        LSSVMPair pair;\\n        uint256[] nftIds;\\n    }\\n\\n    struct RobustPairSwapSpecific {\\n        PairSwapSpecific swapInfo;\\n        uint256 maxCost;\\n    }\\n\\n    struct RobustPairSwapSpecificForToken {\\n        PairSwapSpecific swapInfo;\\n        uint256 minOutput;\\n    }\\n\\n    struct NFTsForSpecificNFTsTrade {\\n        PairSwapSpecific[] nftToTokenTrades;\\n        PairSwapSpecific[] tokenToNFTTrades;\\n    }\\n\\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\\n        RobustPairSwapSpecific[] tokenToNFTTrades;\\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\\n        uint256 inputAmount;\\n        address payable tokenRecipient;\\n        address nftRecipient;\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        _checkDeadline(deadline);\\n        _;\\n    }\\n\\n    ILSSVMPairFactoryLike public immutable factory;\\n\\n    constructor(ILSSVMPairFactoryLike _factory) {\\n        factory = _factory;\\n    }\\n\\n    /**\\n     * ETH swaps\\n     */\\n\\n    /**\\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent ETH amount\\n     */\\n    function swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * ETH as the intermediary.\\n     * @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\\n     * @param minOutput The minimum acceptable total excess ETH received\\n     * @param ethRecipient The address that will receive the ETH output\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH received\\n     */\\n    function swapNFTsForSpecificNFTsThroughETH(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 minOutput,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ETH\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += msg.value;\\n\\n        // Swap ETH for specific NFTs\\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\\n        outputAmount = _swapETHForSpecificNFTs(\\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\\n        ) + minOutput;\\n    }\\n\\n    /**\\n     * ERC20 swaps\\n     *\\n     * Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\\n     * Swapping using multiple tokens in the same transaction is possible, but the slippage checks\\n     * & the return values will be meaningless, and may lead to undefined behavior.\\n     *\\n     * Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\\n     * swaps to work smoothly.\\n     */\\n\\n    /**\\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function swapERC20ForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapERC20ForSpecificNFTs(swapList, inputAmount, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs into ETH/ERC20 using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param minOutput The minimum acceptable total tokens received\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total tokens received\\n     */\\n    function swapNFTsForToken(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 minOutput,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        return _swapNFTsForToken(swapList, minOutput, payable(tokenRecipient));\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * an ERC20 token as the intermediary.\\n     * @param trade The struct containing all NFT-to-ERC20 swaps and ERC20-to-NFT swaps.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param minOutput The minimum acceptable total excess tokens received\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ERC20 tokens received\\n     */\\n    function swapNFTsForSpecificNFTsThroughERC20(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ERC20\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        // output tokens are sent to msg.sender\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(msg.sender));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += inputAmount;\\n\\n        // Swap ERC20 for specific NFTs\\n        // cost <= maxCost = outputAmount - minOutput, so outputAmount' = outputAmount - cost >= minOutput\\n        // input tokens are taken directly from msg.sender\\n        outputAmount =\\n            _swapERC20ForSpecificNFTs(trade.tokenToNFTTrades, outputAmount - minOutput, nftRecipient) + minOutput;\\n    }\\n\\n    /**\\n     * Robust Swaps\\n     * These are \\\"robust\\\" versions of the NFT<>Token swap functions which will never revert due to slippage\\n     * Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\\n     */\\n\\n    /**\\n     * @dev Ensure msg.value >= sum of values in maxCostPerPair to make sure the transaction doesn't revert\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapETHForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public payable virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = msg.value;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                // We know how much ETH to send because we already did the math above\\n                // So we just send that much\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many ERC20 tokens for specific NFTs as possible, respecting the per-swap max cost.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapERC20ForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many NFTs for tokens as possible, respecting the per-swap min output\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH/ERC20 received\\n     */\\n    function robustSwapNFTsForToken(\\n        RobustPairSwapSpecificForToken[] calldata swapList,\\n        address payable tokenRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            uint256 pairOutput;\\n\\n            // Locally scoped to avoid stack too deep error\\n            {\\n                CurveErrorCodes.Error error;\\n                uint256[] memory nftIds = swapList[i].swapInfo.nftIds;\\n                if (nftIds.length == 0) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n                (error,,, pairOutput,,) = swapList[i].swapInfo.pair.getSellNFTQuote(nftIds[0], nftIds.length);\\n                if (error != CurveErrorCodes.Error.OK) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n            }\\n\\n            // If at least equal to our minOutput, proceed\\n            if (pairOutput >= swapList[i].minOutput) {\\n                // Do the swap and update outputAmount with how many tokens we got\\n                outputAmount += swapList[i].swapInfo.pair.swapNFTsForToken(\\n                    swapList[i].swapInfo.nftIds, 0, tokenRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ETH and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapETHForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        payable\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = msg.value;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    // We know how much ETH to send because we already did the math above\\n                    // So we just send that much\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Return remaining value to sender\\n            if (remainingValue > 0) {\\n                params.tokenRecipient.safeTransferETH(remainingValue);\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ERC20, and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapERC20ForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = params.inputAmount;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * Restricted functions\\n     */\\n\\n    /**\\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\\n     * @param token The ERC20 token to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n        // verify caller is an ERC20 pair\\n        require(factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20, \\\"Not ERC20 pair\\\");\\n\\n        // transfer tokens to pair\\n        token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\\n     * @param nft The ERC721 NFT to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param id The ID of the NFT to transfer\\n     */\\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        // transfer NFTs to pair\\n        nft.transferFrom(from, to, id);\\n    }\\n\\n    function pairTransferERC1155From(\\n        IERC1155 nft,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @param deadline The last valid time for a swap\\n     */\\n    function _checkDeadline(uint256 deadline) internal view {\\n        require(block.timestamp <= deadline, \\\"Deadline passed\\\");\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap ETH for a specific set of NFTs\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ETH to send\\n     * @param ethRecipient The address receiving excess ETH\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address payable ethRecipient,\\n        address nftRecipient\\n    ) internal virtual returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate the cost per swap first to send exact amount of ETH over, saves gas by avoiding the need to send back excess ETH\\n            (error,,, pairCost,,) = swapList[i].pair.getBuyNFTQuote(swapList[i].nftIds[0], swapList[i].nftIds.length);\\n\\n            // Require no errors\\n            require(error == CurveErrorCodes.Error.OK, \\\"Bonding curve error\\\");\\n\\n            // Total ETH taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap an ERC20 token for specific NFTs\\n     * @dev Note that we don't need to query the pair's bonding curve first for pricing data because\\n     * we just calculate and take the required amount from the caller during swap time.\\n     * However, we can't \\\"pull\\\" ETH, which is why for the ETH->NFT swaps, we need to calculate the pricing info\\n     * to figure out how much the router should send to the pool.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ERC20 tokens to send\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapERC20ForSpecificNFTs(PairSwapSpecific[] calldata swapList, uint256 inputAmount, address nftRecipient)\\n        internal\\n        virtual\\n        returns (uint256 remainingValue)\\n    {\\n        remainingValue = inputAmount;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Tokens are transferred in by the pair calling router.pairTransferERC20From\\n            // Total tokens taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs for tokens, designed to be used for 1 token at a time\\n     * @dev Calling with multiple tokens is permitted, BUT minOutput will be\\n     * far from enough of a safety check because different tokens almost certainly have different unit prices.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param minOutput The minimum number of tokens to be receieved from the swaps\\n     * @param tokenRecipient The address that receives the tokens\\n     * @return outputAmount The number of tokens to be received\\n     */\\n    function _swapNFTsForToken(PairSwapSpecific[] calldata swapList, uint256 minOutput, address payable tokenRecipient)\\n        internal\\n        virtual\\n        returns (uint256 outputAmount)\\n    {\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Do the swap for token and then update outputAmount\\n            // Note: minExpectedTokenOutput is set to 0 since we're doing an aggregate slippage check below\\n            outputAmount += swapList[i].pair.swapNFTsForToken(swapList[i].nftIds, 0, tokenRecipient, true, msg.sender);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Aggregate slippage check\\n        require(outputAmount >= minOutput, \\\"outputAmount too low\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bonding-curves/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {CurveErrorCodes} from \\\"./CurveErrorCodes.sol\\\";\\n\\ninterface ICurve {\\n    /**\\n     * @notice Validates if a delta value is valid for the curve. The criteria for\\n     * validity can be different for each type of curve, for instance ExponentialCurve\\n     * requires delta to be greater than 1.\\n     * @param delta The delta value to be validated\\n     * @return valid True if delta is valid, false otherwise\\n     */\\n    function validateDelta(uint128 delta) external pure returns (bool valid);\\n\\n    /**\\n     * @notice Validates if a new spot price is valid for the curve. Spot price is generally assumed to be the immediate sell price of 1 NFT to the pool, in units of the pool's paired token.\\n     * @param newSpotPrice The new spot price to be set\\n     * @return valid True if the new spot price is valid, false otherwise\\n     */\\n    function validateSpotPrice(uint128 newSpotPrice) external view returns (bool valid);\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should pay to purchase an NFT from the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is buying from the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return inputValue The amount that the user should pay, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getBuyInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 inputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should receive when selling NFTs to the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is selling to the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return outputValue The amount that the user should receive, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getSellInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 outputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n}\\n\"\r\n    },\r\n    \"src/ILSSVMPairFactoryLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\n\\ninterface ILSSVMPairFactoryLike {\\n    struct Settings {\\n        uint96 bps;\\n        address pairAddress;\\n    }\\n\\n    enum PairNFTType {\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    enum PairTokenType {\\n        ETH,\\n        ERC20\\n    }\\n\\n    enum PairVariant {\\n        ERC721_ETH,\\n        ERC721_ERC20,\\n        ERC1155_ETH,\\n        ERC1155_ERC20\\n    }\\n\\n    function protocolFeeMultiplier() external view returns (uint256);\\n\\n    function protocolFeeRecipient() external view returns (address payable);\\n\\n    function callAllowed(address target) external view returns (bool);\\n\\n    function authAllowedForToken(address tokenAddress, address proposedAuthAddress) external view returns (bool);\\n\\n    function getSettingsForPair(address pairAddress) external view returns (bool settingsEnabled, uint96 bps);\\n\\n    function enableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function disableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function routerStatus(LSSVMRouter router) external view returns (bool allowed, bool wasEverTouched);\\n\\n    function isValidPair(address pairAddress) external view returns (bool);\\n\\n    function getPairNFTType(address pairAddress) external pure returns (PairNFTType);\\n\\n    function getPairTokenType(address pairAddress) external pure returns (PairTokenType);\\n\\n    function openLock() external;\\n\\n    function closeLock() external;\\n}\\n\"\r\n    },\r\n    \"src/bonding-curves/CurveErrorCodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ncontract CurveErrorCodes {\\n    enum Error {\\n        OK, // No error\\n        INVALID_NUMITEMS, // The numItem value is 0\\n        SPOT_PRICE_OVERFLOW, // The updated spot price doesn't fit into 128 bits\\n        DELTA_OVERFLOW, // The updated delta doesn't fit into 128 bits\\n        SPOT_PRICE_UNDERFLOW // The updated spot price goes too low\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/IOwnershipTransferReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnershipTransferReceiver {\\n    function onOwnershipTransferred(address oldOwner, bytes memory data) external payable;\\n}\\n\"\r\n    },\r\n    \"src/lib/OwnableWithTransferCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {IOwnershipTransferReceiver} from \\\"./IOwnershipTransferReceiver.sol\\\";\\n\\nabstract contract OwnableWithTransferCallback {\\n    using ERC165Checker for address;\\n    using Address for address;\\n\\n    bytes4 constant TRANSFER_CALLBACK = type(IOwnershipTransferReceiver).interfaceId;\\n\\n    error Ownable_NotOwner();\\n    error Ownable_NewOwnerZeroAddress();\\n\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal {\\n        _owner = initialOwner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert Ownable_NotOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * @param newOwner The new address to become owner\\n     * @param data Any additional data to send to the ownership received callback.\\n     * Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization.\\n     * When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner, bytes calldata data) public payable virtual onlyOwner {\\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\\n        _transferOwnership(newOwner);\\n\\n        if (newOwner.isContract()) {\\n            try IOwnershipTransferReceiver(newOwner).onOwnershipTransferred{value: msg.value}(msg.sender, data) {}\\n            // If revert...\\n            catch (bytes memory reason) {\\n                // If we just transferred to a contract w/ no callback, this is fine\\n                if (reason.length == 0) {\\n                    // i.e., no need to revert\\n                }\\n                // Otherwise, the callback had an error, and we should revert\\n                else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        _owner = newOwner;\\n        emit OwnershipTransferred(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/LSSVMPairCloner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {ICurve} from \\\"../bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\nlibrary LSSVMPairCloner {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     *\\n     * During the delegate call, extra data is copied into the calldata which can then be\\n     * accessed by the implementation contract.\\n     *\\n     * @return instance The address of the new pair instance\\n     */\\n    function cloneERC721ETHPair(\\n        address implementation,\\n        ILSSVMPairFactoryLike factory,\\n        ICurve bondingCurve,\\n        IERC721 nft,\\n        uint8 poolType,\\n        address propertyChecker\\n    ) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // CREATION (9 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // creation size = 09\\n            // runtime size = 86\\n            // 60 runtime  | PUSH1 runtime (r)     | r                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 r                     | \u2013\\n            // 81          | DUP2                  | r 0 r                   | \u2013\\n            // 60 creation | PUSH1 creation (c)    | c r 0 r                 | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 c r 0 r               | \u2013\\n            // 39          | CODECOPY              | 0 r                     | [0-runSize): runtime code\\n            // f3          | RETURN                |                         | [0-runSize): runtime code\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // RUNTIME (53 bytes of code + 81 bytes of extra data = 134 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // extra data size = 51\\n            // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0                     | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0                   | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0 0                 | \u2013\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 cds 0 0 0 0         | \u2013\\n            // 37          | CALLDATACOPY          | 0 0 0 0                 | [0, cds) = calldata\\n            // 60 extra    | PUSH1 extra           | extra 0 0 0 0           | [0, cds) = calldata\\n            // 60 0x35     | PUSH1 0x35            | 0x35 extra 0 0 0 0      | [0, cds) = calldata // 0x35 (53) is runtime size - data\\n            // 36          | CALLDATASIZE          | cds 0x35 extra 0 0 0 0  | [0, cds) = calldata\\n            // 39          | CODECOPY              | 0 0 0 0                 | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 60 extra    | PUSH1 extra           | extra cds 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 01          | ADD                   | cds+extra 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0 0      | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            mstore(ptr, hex\\\"60863d8160093d39f33d3d3d3d363d3d37605160353639366051013d73000000\\\")\\n            mstore(add(ptr, 0x1d), shl(0x60, implementation))\\n\\n            // 5a          | GAS                   | gas addr 0 cds 0 0 0 0  | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // f4          | DELEGATECALL          | success 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds success 0 0         | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 93          | SWAP4                 | 0 rds success 0 rds     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 80          | DUP1                  | 0 0 rds success 0 rds   | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3e          | RETURNDATACOPY        | success 0 rds           | [0, rds) = return data (there might be some irrelevant leftovers in memory [rds, cds+0x35) when rds < cds+0x35)\\n            // 60 0x33     | PUSH1 0x33            | 0x33 success 0 rds      | [0, rds) = return data\\n            // 57          | JUMPI                 | 0 rds                   | [0, rds) = return data\\n            // fd          | REVERT                | \u2013                       | [0, rds) = return data\\n            // 5b          | JUMPDEST              | 0 rds                   | [0, rds) = return data\\n            // f3          | RETURN                | \u2013                       | [0, rds) = return data\\n            mstore(add(ptr, 0x31), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // EXTRA DATA (81 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            mstore(add(ptr, 0x3e), shl(0x60, factory))\\n            mstore(add(ptr, 0x52), shl(0x60, bondingCurve))\\n            mstore(add(ptr, 0x66), shl(0x60, nft))\\n            mstore8(add(ptr, 0x7a), poolType)\\n            mstore(add(ptr, 0x7b), shl(0x60, propertyChecker))\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // Total length is 143 (8f) bytes\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            instance := create(0, ptr, 0x8f)\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     *\\n     * During the delegate call, extra data is copied into the calldata which can then be\\n     * accessed by the implementation contract.\\n     *\\n     * @return instance The address of the new pair instance\\n     */\\n    function cloneERC721ERC20Pair(\\n        address implementation,\\n        ILSSVMPairFactoryLike factory,\\n        ICurve bondingCurve,\\n        IERC721 nft,\\n        uint8 poolType,\\n        address propertyChecker,\\n        ERC20 token\\n    ) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // CREATION (9 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // creation size = 09\\n            // runtime size = 9a\\n            // 60 runtime  | PUSH1 runtime (r)     | r                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 r                     | \u2013\\n            // 81          | DUP2                  | r 0 r                   | \u2013\\n            // 60 creation | PUSH1 creation (c)    | c r 0 r                 | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 c r 0 r               | \u2013\\n            // 39          | CODECOPY              | 0 r                     | [0-runSize): runtime code\\n            // f3          | RETURN                |                         | [0-runSize): runtime code\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // RUNTIME (53 bytes of code + 101 bytes of extra data = 154 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // extra data size = 65\\n            // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0                     | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0                   | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0 0                 | \u2013\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 cds 0 0 0 0         | \u2013\\n            // 37          | CALLDATACOPY          | 0 0 0 0                 | [0, cds) = calldata\\n            // 60 extra    | PUSH1 extra           | extra 0 0 0 0           | [0, cds) = calldata\\n            // 60 0x35     | PUSH1 0x35            | 0x35 extra 0 0 0 0      | [0, cds) = calldata // 0x35 (53) is runtime size - data\\n            // 36          | CALLDATASIZE          | cds 0x35 extra 0 0 0 0  | [0, cds) = calldata\\n            // 39          | CODECOPY              | 0 0 0 0                 | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 60 extra    | PUSH1 extra           | extra cds 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 01          | ADD                   | cds+extra 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0 0      | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            mstore(ptr, hex\\\"609a3d8160093d39f33d3d3d3d363d3d37606560353639366065013d73000000\\\")\\n            mstore(add(ptr, 0x1d), shl(0x60, implementation))\\n\\n            // 5a          | GAS                   | gas addr 0 cds 0 0 0 0  | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // f4          | DELEGATECALL          | success 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds success 0 0         | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 93          | SWAP4                 | 0 rds success 0 rds     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 80          | DUP1                  | 0 0 rds success 0 rds   | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3e          | RETURNDATACOPY        | success 0 rds           | [0, rds) = return data (there might be some irrelevant leftovers in memory [rds, cds+0x37) when rds < cds+0x37)\\n            // 60 0x33     | PUSH1 0x33            | 0x33 success 0 rds      | [0, rds) = return data\\n            // 57          | JUMPI                 | 0 rds                   | [0, rds) = return data\\n            // fd          | REVERT                | \u2013                       | [0, rds) = return data\\n            // 5b          | JUMPDEST              | 0 rds                   | [0, rds) = return data\\n            // f3          | RETURN                | \u2013                       | [0, rds) = return data\\n            mstore(add(ptr, 0x31), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // EXTRA DATA (101 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            mstore(add(ptr, 0x3e), shl(0x60, factory))\\n            mstore(add(ptr, 0x52), shl(0x60, bondingCurve))\\n            mstore(add(ptr, 0x66), shl(0x60, nft))\\n            mstore8(add(ptr, 0x7a), poolType)\\n            mstore(add(ptr, 0x7b), shl(0x60, propertyChecker))\\n            mstore(add(ptr, 0x8f), shl(0x60, token))\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // Total length is 163 (a3) bytes\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            instance := create(0, ptr, 0xa3)\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a contract is a clone of a LSSVMPairETH.\\n     * @dev Only checks the runtime bytecode, does not check the extra data.\\n     * @param factory the factory that deployed the clone\\n     * @param implementation the LSSVMPairETH implementation contract\\n     * @param query the contract to check\\n     * @return result True if the contract is a clone, false otherwise\\n     */\\n    function isERC721ETHPairClone(address factory, address implementation, address query)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"3d3d3d3d363d3d37605160353639366051013d73000000000000000000000000\\\")\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n            mstore(add(ptr, 0x35), shl(0x60, factory))\\n\\n            // compare expected bytecode with that of the queried contract\\n            let other := add(ptr, 0x49)\\n            extcodecopy(query, other, 0, 0x49)\\n            result :=\\n                and(\\n                    eq(mload(ptr), mload(other)),\\n                    and(\\n                        eq(mload(add(ptr, 0x20)), mload(add(other, 0x20))),\\n                        eq(mload(add(ptr, 0x29)), mload(add(other, 0x29)))\\n                    )\\n                )\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a contract is a clone of a LSSVMPairERC20.\\n     * @dev Only checks the runtime bytecode, does not check the extra data.\\n     * @param implementation the LSSVMPairERC20 implementation contract\\n     * @param query the contract to check\\n     * @return result True if the contract is a clone, false otherwise\\n     */\\n    function isERC721ERC20PairClone(address factory, address implementation, address query)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"3d3d3d3d363d3d37606560353639366065013d73000000000000000000000000\\\")\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n            mstore(add(ptr, 0x35), shl(0x60, factory))\\n\\n            // compare expected bytecode with that of the queried contract\\n            let other := add(ptr, 0x49)\\n            extcodecopy(query, other, 0, 0x49)\\n            result :=\\n                and(\\n                    eq(mload(ptr), mload(other)),\\n                    and(\\n                        eq(mload(add(ptr, 0x20)), mload(add(other, 0x20))),\\n                        eq(mload(add(ptr, 0x29)), mload(add(other, 0x29)))\\n                    )\\n                )\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     *\\n     * During the delegate call, extra data is copied into the calldata which can then be\\n     * accessed by the implementation contract.\\n     *\\n     * @return instance The address of the new pair instance\\n     */\\n    function cloneERC1155ETHPair(\\n        address implementation,\\n        ILSSVMPairFactoryLike factory,\\n        ICurve bondingCurve,\\n        IERC1155 nft,\\n        uint8 poolType,\\n        uint256 nftId\\n    ) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // CREATION (9 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // creation size = 09\\n            // runtime size = 92\\n            // 60 runtime  | PUSH1 runtime (r)     | r                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 r                     | \u2013\\n            // 81          | DUP2                  | r 0 r                   | \u2013\\n            // 60 creation | PUSH1 creation (c)    | c r 0 r                 | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 c r 0 r               | \u2013\\n            // 39          | CODECOPY              | 0 r                     | [0-runSize): runtime code\\n            // f3          | RETURN                |                         | [0-runSize): runtime code\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // RUNTIME (53 bytes of code + 93 bytes of extra data = 146 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // extra data size = 5d\\n            // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0                     | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0                   | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0 0                 | \u2013\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 cds 0 0 0 0         | \u2013\\n            // 37          | CALLDATACOPY          | 0 0 0 0                 | [0, cds) = calldata\\n            // 60 extra    | PUSH1 extra           | extra 0 0 0 0           | [0, cds) = calldata\\n            // 60 0x35     | PUSH1 0x35            | 0x35 extra 0 0 0 0      | [0, cds) = calldata // 0x35 (53) is runtime size - data\\n            // 36          | CALLDATASIZE          | cds 0x35 extra 0 0 0 0  | [0, cds) = calldata\\n            // 39          | CODECOPY              | 0 0 0 0                 | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 60 extra    | PUSH1 extra           | extra cds 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 01          | ADD                   | cds+extra 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0 0      | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            mstore(ptr, hex\\\"60923d8160093d39f33d3d3d3d363d3d37605d6035363936605d013d73000000\\\")\\n            mstore(add(ptr, 0x1d), shl(0x60, implementation))\\n\\n            // 5a          | GAS                   | gas addr 0 cds 0 0 0 0  | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // f4          | DELEGATECALL          | success 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds success 0 0         | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 93          | SWAP4                 | 0 rds success 0 rds     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 80          | DUP1                  | 0 0 rds success 0 rds   | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3e          | RETURNDATACOPY        | success 0 rds           | [0, rds) = return data (there might be some irrelevant leftovers in memory [rds, cds+0x37) when rds < cds+0x37)\\n            // 60 0x33     | PUSH1 0x33            | 0x33 success 0 rds      | [0, rds) = return data\\n            // 57          | JUMPI                 | 0 rds                   | [0, rds) = return data\\n            // fd          | REVERT                | \u2013                       | [0, rds) = return data\\n            // 5b          | JUMPDEST              | 0 rds                   | [0, rds) = return data\\n            // f3          | RETURN                | \u2013                       | [0, rds) = return data\\n            mstore(add(ptr, 0x31), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // EXTRA DATA (93 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            mstore(add(ptr, 0x3e), shl(0x60, factory))\\n            mstore(add(ptr, 0x52), shl(0x60, bondingCurve))\\n            mstore(add(ptr, 0x66), shl(0x60, nft))\\n            mstore8(add(ptr, 0x7a), poolType)\\n            mstore(add(ptr, 0x7b), nftId)\\n\\n            instance := create(0, ptr, 0x9b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     *\\n     * During the delegate call, extra data is copied into the calldata which can then be\\n     * accessed by the implementation contract.\\n     *\\n     * @return instance The address of the new pair instance\\n     */\\n    function cloneERC1155ERC20Pair(\\n        address implementation,\\n        ILSSVMPairFactoryLike factory,\\n        ICurve bondingCurve,\\n        IERC1155 nft,\\n        uint8 poolType,\\n        uint256 nftId,\\n        ERC20 token\\n    ) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // CREATION (9 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // creation size = 09\\n            // runtime size = a6\\n            // 60 runtime  | PUSH1 runtime (r)     | r                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 r                     | \u2013\\n            // 81          | DUP2                  | r 0 r                   | \u2013\\n            // 60 creation | PUSH1 creation (c)    | c r 0 r                 | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 c r 0 r               | \u2013\\n            // 39          | CODECOPY              | 0 r                     | [0-runSize): runtime code\\n            // f3          | RETURN                |                         | [0-runSize): runtime code\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // RUNTIME (53 bytes of code + 113 bytes of extra data = 166 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            // extra data size = 71\\n            // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0                     | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0                   | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 0 0                 | \u2013\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | \u2013\\n            // 3d          | RETURNDATASIZE        | 0 0 cds 0 0 0 0         | \u2013\\n            // 37          | CALLDATACOPY          | 0 0 0 0                 | [0, cds) = calldata\\n            // 60 extra    | PUSH1 extra           | extra 0 0 0 0           | [0, cds) = calldata\\n            // 60 0x35     | PUSH1 0x35            | 0x35 extra 0 0 0 0      | [0, cds) = calldata // 0x35 (53) is runtime size - data\\n            // 36          | CALLDATASIZE          | cds 0x35 extra 0 0 0 0  | [0, cds) = calldata\\n            // 39          | CODECOPY              | 0 0 0 0                 | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 36          | CALLDATASIZE          | cds 0 0 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 60 extra    | PUSH1 extra           | extra cds 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 01          | ADD                   | cds+extra 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0 0      | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            mstore(ptr, hex\\\"60a63d8160093d39f33d3d3d3d363d3d37607160353639366071013d73000000\\\")\\n            mstore(add(ptr, 0x1d), shl(0x60, implementation))\\n\\n            // 5a          | GAS                   | gas addr 0 cds 0 0 0 0  | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // f4          | DELEGATECALL          | success 0 0             | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds success 0 0         | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 93          | SWAP4                 | 0 rds success 0 rds     | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 80          | DUP1                  | 0 0 rds success 0 rds   | [0, cds) = calldata, [cds, cds+0x35) = extraData\\n            // 3e          | RETURNDATACOPY        | success 0 rds           | [0, rds) = return data (there might be some irrelevant leftovers in memory [rds, cds+0x37) when rds < cds+0x37)\\n            // 60 0x33     | PUSH1 0x33            | 0x33 success 0 rds      | [0, rds) = return data\\n            // 57          | JUMPI                 | 0 rds                   | [0, rds) = return data\\n            // fd          | REVERT                | \u2013                       | [0, rds) = return data\\n            // 5b          | JUMPDEST              | 0 rds                   | [0, rds) = return data\\n            // f3          | RETURN                | \u2013                       | [0, rds) = return data\\n            mstore(add(ptr, 0x31), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // EXTRA DATA (113 bytes)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            mstore(add(ptr, 0x3e), shl(0x60, factory))\\n            mstore(add(ptr, 0x52), shl(0x60, bondingCurve))\\n            mstore(add(ptr, 0x66), shl(0x60, nft))\\n            mstore8(add(ptr, 0x7a), poolType)\\n            mstore(add(ptr, 0x7b), nftId)\\n            mstore(add(ptr, 0x9b), shl(0x60, token))\\n\\n            instance := create(0, ptr, 0xaf)\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a contract is a clone of a LSSVMPairERC1155ETH.\\n     * @dev Only checks the runtime bytecode, does not check the extra data.\\n     * @param factory the factory that deployed the clone\\n     * @param implementation the LSSVMPairERC1155ETH implementation contract\\n     * @param query the contract to check\\n     * @return result True if the contract is a clone, false otherwise\\n     */\\n    function isERC1155ETHPairClone(address factory, address implementation, address query)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"3d3d3d3d363d3d37605d6035363936605d013d73000000000000000000000000\\\")\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n            mstore(add(ptr, 0x35), shl(0x60, factory))\\n\\n            // compare expected bytecode with that of the queried contract\\n            let other := add(ptr, 0x49)\\n            extcodecopy(query, other, 0, 0x49)\\n            result :=\\n                and(\\n                    eq(mload(ptr), mload(other)),\\n                    and(\\n                        eq(mload(add(ptr, 0x20)), mload(add(other, 0x20))),\\n                        eq(mload(add(ptr, 0x29)), mload(add(other, 0x29)))\\n                    )\\n                )\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a contract is a clone of a LSSVMPairERC1155ERC20.\\n     * @dev Only checks the runtime bytecode, does not check the extra data.\\n     * @param implementation the LSSVMPairERC1155ERC20 implementation contract\\n     * @param query the contract to check\\n     * @return result True if the contract is a clone, false otherwise\\n     */\\n    function isERC1155ERC20PairClone(address factory, address implementation, address query)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"3d3d3d3d363d3d37607160353639366071013d73000000000000000000000000\\\")\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), hex\\\"5af43d3d93803e603357fd5bf300000000000000000000000000000000000000\\\")\\n            mstore(add(ptr, 0x35), shl(0x60, factory))\\n\\n            // compare expected bytecode with that of the queried contract\\n            let other := add(ptr, 0x49)\\n            extcodecopy(query, other, 0, 0x49)\\n            result :=\\n                and(\\n                    eq(mload(ptr), mload(other)),\\n                    and(\\n                        eq(mload(add(ptr, 0x20)), mload(add(other, 0x20))),\\n                        eq(mload(add(ptr, 0x29)), mload(add(other, 0x29)))\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc1155/LSSVMPairERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMRouter} from \\\"../LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"../bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title LSSVMPairERC1155\\n * @author boredGenius, 0xmons, 0xCygaar\\n * @notice An NFT/Token pair for an ERC1155 NFT where NFTs with the same ID are considered fungible.\\n */\\nabstract contract LSSVMPairERC1155 is LSSVMPair {\\n    /**\\n     * External state-changing functions\\n     */\\n\\n    /**\\n     * @notice Sends token to the pair in exchange for any `numNFTs` NFTs\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo.\\n     * This swap function is meant for users who are ID agnostic\\n     * @param numNFTs The number of NFTs to purchase\\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\\n     * amount is greater than this value, the transaction will be reverted.\\n     * @param nftRecipient The recipient of the NFTs\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     * @return inputAmount The amount of token used for purchase\\n     */\\n    function swapTokenForSpecificNFTs(\\n        uint256[] calldata numNFTs,\\n        uint256 maxExpectedTokenInput,\\n        address nftRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external payable virtual override returns (uint256) {\\n        // Store locally to remove extra calls\\n        factory().openLock();\\n\\n        // Input validation\\n        {\\n            if (poolType() == PoolType.TOKEN) revert LSSVMPair__WrongPoolType();\\n            if (numNFTs.length != 1 || numNFTs[0] == 0) revert LSSVMPair__ZeroSwapAmount();\\n        }\\n\\n        // Call bonding curve for pricing information\\n        uint256 tradeFee;\\n        uint256 protocolFee;\\n        uint256 inputAmountExcludingRoyalty;\\n        (tradeFee, protocolFee, inputAmountExcludingRoyalty) =\\n            _calculateBuyInfoAndUpdatePoolParams(numNFTs[0], bondingCurve(), factory());\\n\\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\\n            _calculateRoyalties(nftId(), inputAmountExcludingRoyalty - protocolFee - tradeFee);\\n\\n        // Revert if the input amount is too large\\n        if (royaltyTotal + inputAmountExcludingRoyalty > maxExpectedTokenInput) {\\n            revert LSSVMPair__DemandedInputTooLarge();\\n        }\\n\\n        _pullTokenInputs({\\n            inputAmountExcludingRoyalty: inputAmountExcludingRoyalty,\\n            royaltyRecipients: royaltyRecipients,\\n            royaltyAmounts: royaltyAmounts,\\n            royaltyTotal: royaltyTotal,\\n            tradeFeeAmount: 2 * tradeFee,\\n            isRouter: isRouter,\\n            routerCaller: routerCaller,\\n            protocolFee: protocolFee\\n        });\\n\\n        _sendAnyNFTsToRecipient(IERC1155(nft()), nftRecipient, numNFTs[0]);\\n\\n        _refundTokenToSender(royaltyTotal + inputAmountExcludingRoyalty);\\n\\n        factory().closeLock();\\n\\n        emit SwapNFTOutPair(royaltyTotal + inputAmountExcludingRoyalty, numNFTs[0]);\\n\\n        return (royaltyTotal + inputAmountExcludingRoyalty);\\n    }\\n\\n    /**\\n     * @notice Sends a set of NFTs to the pair in exchange for token\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @param numNFTs The number of NFTs to swap\\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\\n     * amount is less than this value, the transaction will be reverted.\\n     * @param tokenRecipient The recipient of the token output\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata numNFTs, // @dev this is a bit hacky, to allow for better interop w/ other pair interfaces\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external virtual override returns (uint256 outputAmount) {\\n        // Store locally to remove extra calls\\n        ILSSVMPairFactoryLike _factory = factory();\\n\\n        _factory.openLock();\\n\\n        ICurve _bondingCurve = bondingCurve();\\n\\n        // Input validation\\n        {\\n            if (poolType() == PoolType.NFT) revert LSSVMPair__WrongPoolType();\\n            if (numNFTs.length != 1 || numNFTs[0] == 0) revert LSSVMPair__ZeroSwapAmount();\\n        }\\n\\n        // Call bonding curve for pricing information\\n        uint256 protocolFee;\\n        (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(numNFTs[0], _bondingCurve, _factory);\\n\\n        // Compute royalties\\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\\n            _calculateRoyalties(nftId(), outputAmount);\\n\\n        // Deduct royalties from outputAmount\\n        unchecked {\\n            // Safe because we already require outputAmount >= royaltyTotal in calculateRoyalties()\\n            outputAmount -= royaltyTotal;\\n        }\\n\\n        if (outputAmount < minExpectedTokenOutput) revert LSSVMPair__OutputTooSmall();\\n\\n        _takeNFTsFromSender(IERC1155(nft()), numNFTs[0], _factory, isRouter, routerCaller);\\n\\n        _sendTokenOutput(tokenRecipient, outputAmount);\\n\\n        for (uint256 i; i < royaltyRecipients.length;) {\\n            _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _sendTokenOutput(payable(address(_factory)), protocolFee);\\n\\n        _factory.closeLock();\\n\\n        emit SwapNFTInPair(outputAmount, numNFTs[0]);\\n    }\\n\\n    /**\\n     * View functions\\n     */\\n\\n    /**\\n     * @notice Returns the ERC-1155 NFT ID this pool uses\\n     */\\n    function nftId() public pure returns (uint256 id) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            id := calldataload(add(sub(calldatasize(), paramsLength), 61))\\n        }\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @notice Sends some number of NFTs to a recipient address\\n     * @dev Even though we specify the NFT address here, this internal function is only\\n     * used to send NFTs associated with this specific pool.\\n     * @param _nft The address of the NFT to send\\n     * @param nftRecipient The receiving address for the NFTs\\n     * @param numNFTs The number of NFTs to send\\n     */\\n    function _sendAnyNFTsToRecipient(IERC1155 _nft, address nftRecipient, uint256 numNFTs) internal virtual {\\n        _nft.safeTransferFrom(address(this), nftRecipient, nftId(), numNFTs, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @notice Takes NFTs from the caller and sends them into the pair's asset recipient\\n     * @dev This is used by the LSSVMPair's swapNFTForToken function.\\n     * @param _nft The NFT collection to take from\\n     * @param numNFTs The number of NFTs to take\\n     * @param isRouter Whether or not to use the router pull flow\\n     * @param routerCaller If the caller is a router, passes in which address to pull from (i.e. the router's caller)\\n     */\\n    function _takeNFTsFromSender(\\n        IERC1155 _nft,\\n        uint256 numNFTs,\\n        ILSSVMPairFactoryLike factory,\\n        bool isRouter,\\n        address routerCaller\\n    ) internal virtual {\\n        address _assetRecipient = getAssetRecipient();\\n\\n        if (isRouter) {\\n            // Verify if router is allowed\\n            LSSVMRouter router = LSSVMRouter(payable(msg.sender));\\n            (bool routerAllowed,) = factory.routerStatus(router);\\n            if (!routerAllowed) revert LSSVMPair__NotRouter();\\n\\n            uint256 _nftId = nftId();\\n            uint256 beforeBalance = _nft.balanceOf(_assetRecipient, _nftId);\\n            uint256[] memory ids = new uint256[](1);\\n            ids[0] = _nftId;\\n            uint256[] memory amounts = new uint256[](1);\\n            amounts[0] = numNFTs;\\n            router.pairTransferERC1155From(_nft, routerCaller, _assetRecipient, ids, amounts);\\n            if (_nft.balanceOf(_assetRecipient, _nftId) - beforeBalance != numNFTs) {\\n                revert LSSVMPair__NftNotTransferred();\\n            }\\n        } else {\\n            // Pull NFTs directly from sender\\n            _nft.safeTransferFrom(msg.sender, _assetRecipient, nftId(), numNFTs, bytes(\\\"\\\"));\\n        }\\n    }\\n\\n    /**\\n     * Owner functions\\n     */\\n\\n    /**\\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param nftIds The list of IDs of the NFTs to send to the owner\\n     */\\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual override onlyOwner {\\n        uint256 numNFTs = nftIds.length;\\n        for (uint256 i; i < numNFTs;) {\\n            a.safeTransferFrom(address(this), msg.sender, nftIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ERC1155 tokens from the pair to the owner. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param ids The NFT ids to transfer\\n     * @param amounts The amounts of each id to transfer\\n     */\\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts)\\n        external\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        if (a == IERC1155(nft())) {\\n            // Check if we need to emit an event for withdrawing the NFT this pool is trading\\n            uint256 _nftId = nftId();\\n            uint256 numNFTs = ids.length;\\n            uint256 numPairNFTsWithdrawn;\\n            for (uint256 i; i < numNFTs;) {\\n                if (ids[i] == _nftId) {\\n                    numPairNFTsWithdrawn += amounts[i];\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            if (numPairNFTsWithdrawn != 0) {\\n                // Only emit for the pair's NFT\\n                emit NFTWithdrawal(numPairNFTsWithdrawn);\\n            }\\n        }\\n\\n        a.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, bytes(\\\"\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMPairERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An NFT/Token pair where the token is an ERC20\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\nabstract contract LSSVMPairERC20 is LSSVMPair {\\n    using SafeTransferLib for ERC20;\\n\\n    error LSSVMPairERC20__RoyaltyNotPaid();\\n    error LSSVMPairERC20__MsgValueNotZero();\\n    error LSSVMPairERC20__AssetRecipientNotPaid();\\n\\n    /**\\n     * @notice Returns the ERC20 token associated with the pair\\n     * @dev See LSSVMPairCloner for an explanation on how this works\\n     * @dev The last 20 bytes of the immutable data contain the ERC20 token address\\n     */\\n    function token() public pure returns (ERC20 _token) {\\n        assembly {\\n            _token := shr(0x60, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _pullTokenInputs(\\n        uint256 inputAmountExcludingRoyalty,\\n        uint256[] memory royaltyAmounts,\\n        address payable[] memory royaltyRecipients,\\n        uint256, /* royaltyTotal */\\n        uint256 tradeFeeAmount,\\n        bool isRouter,\\n        address routerCaller,\\n        uint256 protocolFee\\n    ) internal override {\\n        address _assetRecipient = getAssetRecipient();\\n\\n        // Transfer tokens\\n        if (isRouter) {\\n            // Verify if router is allowed\\n            // Locally scoped to avoid stack too deep\\n            {\\n                (bool routerAllowed,) = factory().routerStatus(LSSVMRouter(payable(msg.sender)));\\n                if (!routerAllowed) revert LSSVMPair__NotRouter();\\n            }\\n\\n            // Cache state and then call router to transfer tokens from user\\n            uint256 beforeBalance = token().balanceOf(_assetRecipient);\\n            LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\\n                token(), routerCaller, _assetRecipient, inputAmountExcludingRoyalty - protocolFee\\n            );\\n\\n            // Verify token transfer (protect pair against malicious router)\\n            ERC20 token_ = token();\\n            if (token_.balanceOf(_assetRecipient) - beforeBalance != (inputAmountExcludingRoyalty - protocolFee)) {\\n                revert LSSVMPairERC20__AssetRecipientNotPaid();\\n            }\\n\\n            // Transfer royalties (if they exist)\\n            for (uint256 i; i < royaltyRecipients.length;) {\\n                beforeBalance = token_.balanceOf(royaltyRecipients[i]);\\n                LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\\n                    token_, routerCaller, royaltyRecipients[i], royaltyAmounts[i]\\n                );\\n                if (token_.balanceOf(royaltyRecipients[i]) - beforeBalance != royaltyAmounts[i]) {\\n                    revert LSSVMPairERC20__RoyaltyNotPaid();\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Take protocol fee (if it exists)\\n            if (protocolFee != 0) {\\n                LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\\n                    token_, routerCaller, address(factory()), protocolFee\\n                );\\n            }\\n        } else {\\n            // Transfer tokens directly (sans the protocol fee)\\n            ERC20 token_ = token();\\n            token_.safeTransferFrom(msg.sender, _assetRecipient, inputAmountExcludingRoyalty - protocolFee);\\n\\n            // Transfer royalties (if they exists)\\n            for (uint256 i; i < royaltyRecipients.length;) {\\n                token_.safeTransferFrom(msg.sender, royaltyRecipients[i], royaltyAmounts[i]);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Take protocol fee (if it exists)\\n            if (protocolFee != 0) {\\n                token_.safeTransferFrom(msg.sender, address(factory()), protocolFee);\\n            }\\n        }\\n        // Send trade fee if it exists, is TRADE pool, and fee recipient != pool address\\n        // @dev: (note that tokens are sent from the pool and not the caller)\\n        if (poolType() == PoolType.TRADE && tradeFeeAmount != 0) {\\n            address payable _feeRecipient = getFeeRecipient();\\n            if (_feeRecipient != _assetRecipient) {\\n                token().safeTransfer(_feeRecipient, tradeFeeAmount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _refundTokenToSender(uint256 inputAmount) internal override {\\n        // Do nothing since we transferred the exact input amount\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal override {\\n        // Send tokens to caller\\n        if (outputAmount != 0) {\\n            token().safeTransfer(tokenRecipient, outputAmount);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function withdrawERC20(ERC20 a, uint256 amount) external override onlyOwner {\\n        a.safeTransfer(msg.sender, amount);\\n\\n        if (a == token()) {\\n            // emit event since it is the pair token\\n            emit TokenWithdrawal(amount);\\n        }\\n    }\\n\\n    function _preCallCheck(address target) internal pure override {\\n        if (target == address(token())) revert LSSVMPair__TargetNotAllowed();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc721/LSSVMPairERC721ETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMPairETH} from \\\"../LSSVMPairETH.sol\\\";\\nimport {LSSVMPairERC721} from \\\"./LSSVMPairERC721.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An NFT/Token pair where the token is ETH\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\ncontract LSSVMPairERC721ETH is LSSVMPairERC721, LSSVMPairETH {\\n    uint256 internal constant IMMUTABLE_PARAMS_LENGTH = 81;\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) LSSVMPair(royaltyEngine) {}\\n\\n    /**\\n     * Public functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function pairVariant() public pure override returns (ILSSVMPairFactoryLike.PairVariant) {\\n        return ILSSVMPairFactoryLike.PairVariant.ERC721_ETH;\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     * @dev see LSSVMPairCloner for params length calculation\\n     */\\n    function _immutableParamsLength() internal pure override returns (uint256) {\\n        return IMMUTABLE_PARAMS_LENGTH;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc1155/LSSVMPairERC1155ETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMPairETH} from \\\"../LSSVMPairETH.sol\\\";\\nimport {LSSVMPairERC1155} from \\\"./LSSVMPairERC1155.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An ERC1155 pair where the token is an ETH\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\ncontract LSSVMPairERC1155ETH is LSSVMPairERC1155, LSSVMPairETH {\\n    uint256 internal constant IMMUTABLE_PARAMS_LENGTH = 93;\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) LSSVMPair(royaltyEngine) {}\\n\\n    /**\\n     * Public functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function pairVariant() public pure virtual override returns (ILSSVMPairFactoryLike.PairVariant) {\\n        return ILSSVMPairFactoryLike.PairVariant.ERC1155_ETH;\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     * @dev see LSSVMPairCloner for params length calculation\\n     */\\n    function _immutableParamsLength() internal pure override returns (uint256) {\\n        return IMMUTABLE_PARAMS_LENGTH;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc721/LSSVMPairERC721ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMPairERC20} from \\\"../LSSVMPairERC20.sol\\\";\\nimport {LSSVMPairERC721} from \\\"./LSSVMPairERC721.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An NFT/Token pair where the token is an ERC20\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\ncontract LSSVMPairERC721ERC20 is LSSVMPairERC721, LSSVMPairERC20 {\\n    uint256 internal constant IMMUTABLE_PARAMS_LENGTH = 101;\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) LSSVMPair(royaltyEngine) {}\\n\\n    /**\\n     * Public functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function pairVariant() public pure override returns (ILSSVMPairFactoryLike.PairVariant) {\\n        return ILSSVMPairFactoryLike.PairVariant.ERC721_ERC20;\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     * @dev see LSSVMPairCloner for params length calculation\\n     */\\n    function _immutableParamsLength() internal pure override returns (uint256) {\\n        return IMMUTABLE_PARAMS_LENGTH;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc1155/LSSVMPairERC1155ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMPairERC20} from \\\"../LSSVMPairERC20.sol\\\";\\nimport {LSSVMPairERC1155} from \\\"./LSSVMPairERC1155.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An ERC1155 pair where the token is an ERC20\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\ncontract LSSVMPairERC1155ERC20 is LSSVMPairERC1155, LSSVMPairERC20 {\\n    uint256 internal constant IMMUTABLE_PARAMS_LENGTH = 113;\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) LSSVMPair(royaltyEngine) {}\\n\\n    /**\\n     * Public functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function pairVariant() public pure virtual override returns (ILSSVMPairFactoryLike.PairVariant) {\\n        return ILSSVMPairFactoryLike.PairVariant.ERC1155_ERC20;\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     * @dev see LSSVMPairCloner for params length calculation\\n     */\\n    function _immutableParamsLength() internal pure override returns (uint256) {\\n        return IMMUTABLE_PARAMS_LENGTH;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/settings/ISettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface ISettings {\\n    struct PairInfo {\\n        address prevOwner;\\n        uint96 unlockTime;\\n        address prevFeeRecipient;\\n    }\\n\\n    function getFeeSplitBps() external pure returns (uint64);\\n\\n    function getRoyaltyInfo(address pairAddress) external view returns (bool, uint96);\\n\\n    function settingsFeeRecipient() external returns (address payable);\\n\\n    function getPrevFeeRecipientForPair(address pairAddress) external returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/libraries-solidity/contracts/access/IAdminControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for admin control\\n */\\ninterface IAdminControl is IERC165 {\\n\\n    event AdminApproved(address indexed account, address indexed sender);\\n    event AdminRevoked(address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev gets address of all admins\\n     */\\n    function getAdmins() external view returns (address[] memory);\\n\\n    /**\\n     * @dev add an admin.  Can only be called by contract owner.\\n     */\\n    function approveAdmin(address admin) external;\\n\\n    /**\\n     * @dev remove an admin.  Can only be called by contract owner.\\n     */\\n    function revokeAdmin(address admin) external;\\n\\n    /**\\n     * @dev checks whether or not given address is an admin\\n     * Returns True if they are\\n     */\\n    function isAdmin(address admin) external view returns (bool);\\n\\n}\"\r\n    },\r\n    \"src/royalty-auth/INiftyGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Nifty builder instance\\n */\\ninterface INiftyBuilderInstance {\\n    function niftyRegistryContract() external view returns (address);\\n}\\n\\n/**\\n * @dev Nifty registry\\n */\\ninterface INiftyRegistry {\\n    /**\\n     * @dev function to see if sending key is valid\\n     */\\n    function isValidNiftySender(address sending_key) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/royalty-auth/IFoundation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFoundation {\\n    /*\\n     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\\n     *\\n     *  => 0xd5a06d4c = 0xd5a06d4c\\n     */\\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\\ninterface IFoundationTreasuryNode {\\n    function getFoundationTreasury() external view returns (address payable);\\n}\\n\\ninterface IFoundationTreasury {\\n    function isAdmin(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/royalty-auth/IDigitalax.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Digitalax nfts\\n */\\ninterface IDigitalax {\\n    function accessControls() external view returns (address);\\n}\\n\\n/**\\n * @dev Digitalax Access Controls Simple\\n */\\ninterface IDigitalaxAccessControls {\\n    function hasAdminRole(address _account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/royalty-auth/IArtBlocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Art Blocks nfts\\n */\\ninterface IArtBlocks {\\n    // document getter function of public variable\\n    function admin() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMPairETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\n\\n/**\\n * @title An NFT/Token pair where the token is ETH\\n * @author boredGenius, 0xmons, 0xCygaar\\n */\\nabstract contract LSSVMPairETH is LSSVMPair {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    error LSSVMPairETH__InsufficientInput();\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _pullTokenInputs(\\n        uint256 inputAmountExcludingRoyalty,\\n        uint256[] memory royaltyAmounts,\\n        address payable[] memory royaltyRecipients,\\n        uint256 royaltyTotal,\\n        uint256 tradeFeeAmount,\\n        bool, /*isRouter*/\\n        address, /*routerCaller*/\\n        uint256 protocolFee\\n    ) internal override {\\n        // Require that the input amount is sufficient to pay for the sale amount, royalties, and fees\\n        if (msg.value < (royaltyTotal + inputAmountExcludingRoyalty)) revert LSSVMPairETH__InsufficientInput();\\n\\n        // Transfer inputAmountExcludingRoyalty ETH to assetRecipient if it has been set\\n        address payable _assetRecipient = getAssetRecipient();\\n\\n        // Attempt to transfer trade fees only if TRADE pool and they exist\\n        if (poolType() == PoolType.TRADE && tradeFeeAmount != 0) {\\n            address payable _feeRecipient = getFeeRecipient();\\n\\n            // Only send and deduct tradeFeeAmount if the fee recipient is not the asset recipient (i.e. the pool)\\n            if (_feeRecipient != _assetRecipient) {\\n                inputAmountExcludingRoyalty -= tradeFeeAmount;\\n                _feeRecipient.safeTransferETH(tradeFeeAmount);\\n            }\\n            // In the else case, we would want to ensure that inputAmountExcludingRoyalty >= tradeFeeAmount / 2\\n            // to avoid underpaying the trade fee, but it is always true because the max royalty\\n            // is 25%, the max protocol fee is 10%, and the max trade fee is 50%, meaning they can\\n            // never add up to more than 100%.\\n        }\\n\\n        if (_assetRecipient != address(this)) {\\n            _assetRecipient.safeTransferETH(inputAmountExcludingRoyalty - protocolFee);\\n        }\\n\\n        // Transfer royalties\\n        for (uint256 i; i < royaltyRecipients.length;) {\\n            royaltyRecipients[i].safeTransferETH(royaltyAmounts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Take protocol fee\\n        if (protocolFee != 0) {\\n            payable(address(factory())).safeTransferETH(protocolFee);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _refundTokenToSender(uint256 inputAmount) internal override {\\n        // Give excess ETH back to caller\\n        if (msg.value > inputAmount) {\\n            payable(msg.sender).safeTransferETH(msg.value - inputAmount);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal override {\\n        // Send ETH to caller\\n        if (outputAmount != 0) {\\n            tokenRecipient.safeTransferETH(outputAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraws all token owned by the pair to the owner address.\\n     * @dev Only callable by the owner.\\n     */\\n    function withdrawAllETH() external onlyOwner {\\n        withdrawETH(address(this).balance);\\n    }\\n\\n    /**\\n     * @notice Withdraws a specified amount of token owned by the pair to the owner address.\\n     * @dev Only callable by the owner.\\n     * @param amount The amount of token to send to the owner. If the pair's balance is less than\\n     * this value, the transaction will be reverted.\\n     */\\n    function withdrawETH(uint256 amount) public onlyOwner {\\n        payable(msg.sender).safeTransferETH(amount);\\n\\n        // emit event since ETH is the pair token\\n        emit TokenWithdrawal(amount);\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function withdrawERC20(ERC20 a, uint256 amount) external override onlyOwner {\\n        a.safeTransfer(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev All ETH transfers into the pair are accepted. This is the main method\\n     * for the owner to top up the pair's token reserves.\\n     */\\n    receive() external payable {\\n        emit TokenDeposit(msg.value);\\n    }\\n\\n    /**\\n     * @dev All ETH transfers into the pair are accepted. This is the main method\\n     * for the owner to top up the pair's token reserves.\\n     */\\n    fallback() external payable {\\n        // Only allow calls without function selector\\n        require(msg.data.length == _immutableParamsLength());\\n        emit TokenDeposit(msg.value);\\n    }\\n\\n    function _preCallCheck(address) internal pure override {}\\n}\\n\"\r\n    },\r\n    \"src/erc721/LSSVMPairERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {LSSVMRouter} from \\\"../LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"../bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\nimport {IPropertyChecker} from \\\"../property-checking/IPropertyChecker.sol\\\";\\n\\n/**\\n * @title LSSVMPairERC721\\n * @author boredGenius, 0xmons, 0xCygaar\\n * @notice An NFT/Token pair for an ERC721 NFT\\n */\\nabstract contract LSSVMPairERC721 is LSSVMPair {\\n    error LSSVMPairERC721__PropertyCheckFailed();\\n    error LSSVMPairERC721__NeedPropertyChecking();\\n\\n    /**\\n     * External state-changing functions\\n     */\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function swapTokenForSpecificNFTs(\\n        uint256[] calldata nftIds,\\n        uint256 maxExpectedTokenInput,\\n        address nftRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external payable virtual override returns (uint256) {\\n        // Store locally to remove extra calls\\n        factory().openLock();\\n\\n        // Input validation\\n        {\\n            PoolType _poolType = poolType();\\n            if (_poolType == PoolType.TOKEN) revert LSSVMPair__WrongPoolType();\\n            if (nftIds.length == 0) revert LSSVMPair__ZeroSwapAmount();\\n        }\\n\\n        // Call bonding curve for pricing information\\n        uint256 protocolFee;\\n        uint256 tradeFee;\\n        uint256 inputAmountExcludingRoyalty;\\n        (tradeFee, protocolFee, inputAmountExcludingRoyalty) =\\n            _calculateBuyInfoAndUpdatePoolParams(nftIds.length, bondingCurve(), factory());\\n\\n        // Calculate royalties\\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\\n            _calculateRoyalties(nftIds[0], inputAmountExcludingRoyalty - protocolFee - tradeFee);\\n\\n        // Revert if the input amount is too large\\n        if (royaltyTotal + inputAmountExcludingRoyalty > maxExpectedTokenInput) {\\n            revert LSSVMPair__DemandedInputTooLarge();\\n        }\\n\\n        _pullTokenInputs({\\n            inputAmountExcludingRoyalty: inputAmountExcludingRoyalty,\\n            royaltyAmounts: royaltyAmounts,\\n            royaltyRecipients: royaltyRecipients,\\n            royaltyTotal: royaltyTotal,\\n            tradeFeeAmount: 2 * tradeFee,\\n            isRouter: isRouter,\\n            routerCaller: routerCaller,\\n            protocolFee: protocolFee\\n        });\\n\\n        {\\n            _sendSpecificNFTsToRecipient(IERC721(nft()), nftRecipient, nftIds);\\n        }\\n\\n        _refundTokenToSender(royaltyTotal + inputAmountExcludingRoyalty);\\n\\n        factory().closeLock();\\n\\n        emit SwapNFTOutPair(royaltyTotal + inputAmountExcludingRoyalty, nftIds);\\n\\n        return (royaltyTotal + inputAmountExcludingRoyalty);\\n    }\\n\\n    /**\\n     * @inheritdoc LSSVMPair\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external virtual override returns (uint256 outputAmount) {\\n        if (propertyChecker() != address(0)) revert LSSVMPairERC721__NeedPropertyChecking();\\n\\n        return _swapNFTsForToken(nftIds, minExpectedTokenOutput, tokenRecipient, isRouter, routerCaller);\\n    }\\n\\n    /**\\n     * @notice Sends a set of NFTs to the pair in exchange for token\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @param nftIds The list of IDs of the NFTs to sell to the pair\\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\\n     * amount is less than this value, the transaction will be reverted.\\n     * @param tokenRecipient The recipient of the token output\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\\n     * ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\\n     * ETH pairs.\\n     * @param propertyCheckerParams Parameters to pass into the pair's underlying property checker\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller,\\n        bytes calldata propertyCheckerParams\\n    ) external virtual returns (uint256 outputAmount) {\\n        if (!IPropertyChecker(propertyChecker()).hasProperties(nftIds, propertyCheckerParams)) {\\n            revert LSSVMPairERC721__PropertyCheckFailed();\\n        }\\n\\n        return _swapNFTsForToken(nftIds, minExpectedTokenOutput, tokenRecipient, isRouter, routerCaller);\\n    }\\n\\n    /**\\n     * View functions\\n     */\\n\\n    /**\\n     * @notice Returns the property checker address\\n     */\\n    function propertyChecker() public pure returns (address _propertyChecker) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _propertyChecker := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 61)))\\n        }\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    function _swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) internal virtual returns (uint256 outputAmount) {\\n        // Store locally to remove extra calls\\n        ILSSVMPairFactoryLike _factory = factory();\\n\\n        _factory.openLock();\\n\\n        // Input validation\\n        {\\n            PoolType _poolType = poolType();\\n            if (_poolType == PoolType.NFT) revert LSSVMPair__WrongPoolType();\\n            if (nftIds.length == 0) revert LSSVMPair__ZeroSwapAmount();\\n        }\\n\\n        // Call bonding curve for pricing information\\n        uint256 protocolFee;\\n        (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(nftIds.length, bondingCurve(), _factory);\\n\\n        // Compute royalties\\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\\n            _calculateRoyalties(nftIds[0], outputAmount);\\n\\n        // Deduct royalties from outputAmount\\n        unchecked {\\n            // Safe because we already require outputAmount >= royaltyTotal in calculateRoyalties()\\n            outputAmount -= royaltyTotal;\\n        }\\n\\n        if (outputAmount < minExpectedTokenOutput) revert LSSVMPair__OutputTooSmall();\\n\\n        _takeNFTsFromSender(IERC721(nft()), nftIds, _factory, isRouter, routerCaller);\\n\\n        _sendTokenOutput(tokenRecipient, outputAmount);\\n        for (uint256 i; i < royaltyRecipients.length;) {\\n            _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _sendTokenOutput(payable(address(_factory)), protocolFee);\\n\\n        _factory.closeLock();\\n\\n        emit SwapNFTInPair(outputAmount, nftIds);\\n    }\\n\\n    /**\\n     * @notice Sends specific NFTs to a recipient address\\n     * @dev Even though we specify the NFT address here, this internal function is only\\n     * used to send NFTs associated with this specific pool.\\n     * @param _nft The address of the NFT to send\\n     * @param nftRecipient The receiving address for the NFTs\\n     * @param nftIds The specific IDs of NFTs to send\\n     */\\n    function _sendSpecificNFTsToRecipient(IERC721 _nft, address nftRecipient, uint256[] calldata nftIds)\\n        internal\\n        virtual\\n    {\\n        // Send NFTs to recipient\\n        uint256 numNFTs = nftIds.length;\\n        for (uint256 i; i < numNFTs;) {\\n            _nft.transferFrom(address(this), nftRecipient, nftIds[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Takes NFTs from the caller and sends them into the pair's asset recipient\\n     * @dev This is used by the LSSVMPair's swapNFTForToken function.\\n     * @param _nft The NFT collection to take from\\n     * @param nftIds The specific NFT IDs to take\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     */\\n    function _takeNFTsFromSender(\\n        IERC721 _nft,\\n        uint256[] calldata nftIds,\\n        ILSSVMPairFactoryLike _factory,\\n        bool isRouter,\\n        address routerCaller\\n    ) internal virtual {\\n        {\\n            address _assetRecipient = getAssetRecipient();\\n            uint256 numNFTs = nftIds.length;\\n\\n            if (isRouter) {\\n                // Verify if router is allowed\\n                LSSVMRouter router = LSSVMRouter(payable(msg.sender));\\n                (bool routerAllowed,) = _factory.routerStatus(router);\\n                if (!routerAllowed) revert LSSVMPair__NotRouter();\\n\\n                // Call router to pull NFTs\\n                // If more than 1 NFT is being transfered, and there is no property checker, we can do a balance check\\n                // instead of an ownership check, as pools are indifferent between NFTs from the same collection\\n                if ((numNFTs > 1) && (propertyChecker() == address(0))) {\\n                    uint256 beforeBalance = _nft.balanceOf(_assetRecipient);\\n                    for (uint256 i; i < numNFTs;) {\\n                        router.pairTransferNFTFrom(_nft, routerCaller, _assetRecipient, nftIds[i]);\\n\\n                        unchecked {\\n                            ++i;\\n                        }\\n                    }\\n                    if (_nft.balanceOf(_assetRecipient) - beforeBalance != numNFTs) {\\n                        revert LSSVMPair__NftNotTransferred();\\n                    }\\n                }\\n                // Otherwise we need to pull each asset 1 at a time and verify ownership\\n                else {\\n                    for (uint256 i; i < numNFTs;) {\\n                        router.pairTransferNFTFrom(_nft, routerCaller, _assetRecipient, nftIds[i]);\\n                        if (_nft.ownerOf(nftIds[i]) != _assetRecipient) revert LSSVMPair__NftNotTransferred();\\n                        unchecked {\\n                            ++i;\\n                        }\\n                    }\\n                }\\n            } else {\\n                // Pull NFTs directly from sender\\n                for (uint256 i; i < numNFTs;) {\\n                    _nft.transferFrom(msg.sender, _assetRecipient, nftIds[i]);\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Owner functions\\n     */\\n\\n    /**\\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwner modifier is in the implemented function)\\n     * @param a The NFT to transfer\\n     * @param nftIds The list of IDs of the NFTs to send to the owner\\n     */\\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual override onlyOwner {\\n        uint256 numNFTs = nftIds.length;\\n        for (uint256 i; i < numNFTs;) {\\n            a.safeTransferFrom(address(this), msg.sender, nftIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (a == IERC721(nft())) {\\n            emit NFTWithdrawal(nftIds);\\n        }\\n    }\\n\\n    /**\\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param ids The NFT ids to transfer\\n     * @param amounts The amounts of each id to transfer\\n     */\\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts)\\n        external\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        a.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/property-checking/IPropertyChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IPropertyChecker {\\n    function hasProperties(uint256[] calldata ids, bytes calldata params) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@manifoldxyz/=lib/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@prb/math/=lib/prb-math/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"create3-factory/=lib/create3-factory/src/\",\r\n      \"ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"foundry-huff/=lib/foundry-huff/src/\",\r\n      \"huffmate/=lib/huffmate/src/\",\r\n      \"lzero/=lib/solidity-examples/contracts/\",\r\n      \"manifoldxyz/=lib/royalty-registry-solidity/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"stringutils/=lib/foundry-huff/lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract LSSVMPairFactory\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IERC1155\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"contract ICurve\",\"name\":\"bondingCurve\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"assetRecipient\",\"type\":\"address\"},{\"internalType\":\"enum LSSVMPair.PoolType\",\"name\":\"poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"delta\",\"type\":\"uint128\"},{\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"},{\"internalType\":\"uint128\",\"name\":\"spotPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialNFTBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialTokenBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct LSSVMPairFactory.CreateERC1155ERC20PairParams[]\",\"name\":\"pairCreationArgs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_initialNFTBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"isETH\",\"type\":\"bool\"}],\"name\":\"createBulk1155Pools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "MultiPool", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a020d57ab0448ef74115c112d18a9c231cc86000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}