{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IVaultInterface {\r\n    function execute(\r\n        address,\r\n        bytes memory\r\n    ) external payable returns (bytes memory);\r\n}\r\n\r\ninterface ISparkPool {\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        //timestamp of last update\r\n        uint40 lastUpdateTimestamp;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint16 id;\r\n        //aToken address\r\n        address aTokenAddress;\r\n        //stableDebtToken address\r\n        address stableDebtTokenAddress;\r\n        //variableDebtToken address\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the current treasury balance, scaled\r\n        uint128 accruedToTreasury;\r\n        //the outstanding unbacked aTokens minted through the bridging feature\r\n        uint128 unbacked;\r\n        //the outstanding debt borrowed against this asset in isolation mode\r\n        uint128 isolationModeTotalDebt;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    function getUserAccountData(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralBase,\r\n            uint256 totalDebtBase,\r\n            uint256 availableBorrowsBase,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function getReserveData(\r\n        address asset\r\n    ) external view returns (ReserveData memory);\r\n}\r\n\r\ninterface IsparkSavingsInterface {\r\n    function pool() external view returns (address);\r\n\r\n    function wstETH() external view returns (address);\r\n\r\n    function savingsAsset() external view returns (address);\r\n\r\n    function borrowAsset() external view returns (address);\r\n}\r\n\r\ncontract SparkStakeRebalanceMonitor {\r\n    using SafeMath for uint256;\r\n    address public owner;\r\n    address public sparkPool;\r\n    address public daiStakePool;\r\n    address public lidoSparkSavingsStrategy;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        lidoSparkSavingsStrategy = 0x2B30A948Fe2bf1FF67506aaBB3dF3fE0603d128F; //0x71122Cd26c5f1E18826652708C3e00D1cf837DA4\r\n        sparkPool = IsparkSavingsInterface(lidoSparkSavingsStrategy).pool(); //spark 0xC13e21B648A5Ee794902342038FF3aDAB66BE987#\r\n        daiStakePool = IsparkSavingsInterface(lidoSparkSavingsStrategy)\r\n            .savingsAsset(); //0x83F20F44975D03b1b09e64809B757c47f942BEeA; // sdai\r\n    }\r\n\r\n    function setLidoSparkSavingsStrategy(\r\n        address _lidoSparkSavingsStrategy\r\n    ) external {\r\n        require(\r\n            msg.sender == owner,\r\n            \" only owner set Lido Aave Leverage Strategy\"\r\n        );\r\n        lidoSparkSavingsStrategy = _lidoSparkSavingsStrategy;\r\n    }\r\n\r\n    function getHealthFactor(address _vault) public view returns (uint256) {\r\n        (, , , , , uint256 hf) = ISparkPool(sparkPool).getUserAccountData(\r\n            _vault\r\n        );\r\n        return hf;\r\n    }\r\n\r\n    function hasSparkStaked(address _vault) public view returns (bool) {\r\n        uint256 _balance;\r\n\r\n        _balance = IERC20(daiStakePool).balanceOf(_vault);\r\n\r\n        if (_balance > 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function needReBalance(\r\n        address _vault,\r\n        uint256 _minReHealthFactor,\r\n        uint256 _maxReHealthFactor\r\n    ) public view returns (bool) {\r\n        uint256 vault_hf;\r\n        vault_hf = getHealthFactor(_vault);\r\n        if (vault_hf >= _maxReHealthFactor || vault_hf <= _minReHealthFactor) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function encodeRebalanceInput(\r\n        uint256 healthFactor\r\n    ) internal pure returns (bytes memory encodedInput) {\r\n        return abi.encodeWithSignature(\"rebalance(uint256)\", healthFactor);\r\n    }\r\n\r\n    function executeRebalance(\r\n        address _vault,\r\n        uint256 _rebalanceHealthFactory\r\n    ) internal view returns (bool canExec, bytes memory execPayload) {\r\n        bytes memory args = encodeRebalanceInput(_rebalanceHealthFactory);\r\n        execPayload = abi.encodeWithSelector(\r\n            IVaultInterface(_vault).execute.selector,\r\n            lidoSparkSavingsStrategy,\r\n            args\r\n        );\r\n        return (true, execPayload);\r\n    }\r\n\r\n    function checker(\r\n        address _vault,\r\n        uint256 _minReHealthFactorThreshold,\r\n        uint256 _rebalanceToHealthFactor,\r\n        uint256 _maxReHealthFactorThreshold\r\n    ) external view returns (bool canExec, bytes memory execPayload) {\r\n        if (hasSparkStaked(_vault)) {\r\n            if (\r\n                needReBalance(\r\n                    _vault,\r\n                    _minReHealthFactorThreshold,\r\n                    _maxReHealthFactorThreshold\r\n                )\r\n            ) {\r\n                return executeRebalance(_vault, _rebalanceToHealthFactor);\r\n            }\r\n        }\r\n        return (false, bytes(\"monitor is ok\"));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReHealthFactorThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebalanceToHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxReHealthFactorThreshold\",\"type\":\"uint256\"}],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiStakePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getHealthFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"hasSparkStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lidoSparkSavingsStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxReHealthFactor\",\"type\":\"uint256\"}],\"name\":\"needReBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lidoSparkSavingsStrategy\",\"type\":\"address\"}],\"name\":\"setLidoSparkSavingsStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sparkPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SparkStakeRebalanceMonitor", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000040ff7499951546dfa412e9dc05c816a453953616", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://529c5a35aa90279cf1a9b30b8e2f7a8273d56c9d774cb73f7396619d17ad9156"}