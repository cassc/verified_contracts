{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/owr/OptimisticWithdrawalRecipientFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {OptimisticWithdrawalRecipient} from \\\"./OptimisticWithdrawalRecipient.sol\\\";\\nimport {LibClone} from \\\"solady/utils/LibClone.sol\\\";\\nimport {IENSReverseRegistrar} from \\\"../interfaces/IENSReverseRegistrar.sol\\\";\\n\\n/// @title OptimisticWithdrawalRecipientFactory\\n/// @author Obol\\n/// @notice A factory contract for cheaply deploying\\n/// OptimisticWithdrawalRecipient.\\n/// @dev This contract uses token = address(0) to refer to ETH.\\ncontract OptimisticWithdrawalRecipientFactory {\\n  /// -----------------------------------------------------------------------\\n  /// errors\\n  /// -----------------------------------------------------------------------\\n\\n  /// Invalid number of recipients, must be 2\\n  error Invalid__Recipients();\\n\\n  /// Thresholds must be positive\\n  error Invalid__ZeroThreshold();\\n\\n  /// Invalid threshold at `index`; must be < 2^96\\n  /// @param threshold threshold of too-large threshold\\n  error Invalid__ThresholdTooLarge(uint256 threshold);\\n\\n  /// -----------------------------------------------------------------------\\n  /// libraries\\n  /// -----------------------------------------------------------------------\\n\\n  using LibClone for address;\\n\\n  /// -----------------------------------------------------------------------\\n  /// events\\n  /// -----------------------------------------------------------------------\\n\\n  /// Emitted after a new OptimisticWithdrawalRecipient module is deployed\\n  /// @param owr Address of newly created OptimisticWithdrawalRecipient clone\\n  /// @param recoveryAddress Address to recover non-OWR tokens to\\n  /// @param principalRecipient Address to distribute principal payment to\\n  /// @param rewardRecipient Address to distribute reward payment to\\n  /// @param threshold Absolute payment threshold for OWR first recipient\\n  /// (reward recipient has no threshold & receives all residual flows)\\n  event CreateOWRecipient(\\n    address indexed owr, address recoveryAddress, address principalRecipient, address rewardRecipient, uint256 threshold\\n  );\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage\\n  /// -----------------------------------------------------------------------\\n\\n  uint256 internal constant ADDRESS_BITS = 160;\\n\\n  /// OptimisticWithdrawalRecipient implementation address\\n  OptimisticWithdrawalRecipient public immutable owrImpl;\\n\\n  /// -----------------------------------------------------------------------\\n  /// constructor\\n  /// -----------------------------------------------------------------------\\n\\n  constructor(\\n    string memory _ensName,\\n    address _ensReverseRegistrar,\\n    address _ensOwner\\n  ) {\\n    owrImpl = new OptimisticWithdrawalRecipient();\\n    IENSReverseRegistrar(_ensReverseRegistrar).setName(_ensName);\\n    IENSReverseRegistrar(_ensReverseRegistrar).claim(_ensOwner);\\n  }\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions\\n  /// -----------------------------------------------------------------------\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions - public & external\\n  /// -----------------------------------------------------------------------\\n\\n  /// Create a new OptimisticWithdrawalRecipient clone\\n  /// @param recoveryAddress Address to recover tokens to\\n  /// If this address is 0x0, recovery of unrelated tokens can be completed by\\n  /// either the principal or reward recipients.  If this address is set, only\\n  /// this address can recover\\n  /// tokens (or ether) that isn't the token of the OWRecipient contract\\n  /// @param principalRecipient Address to distribute principal payments to\\n  /// @param rewardRecipient Address to distribute reward payments to\\n  /// @param amountOfPrincipalStake Absolute amount of stake to be paid to\\n  /// principal recipient (multiple of 32 ETH)\\n  /// (reward recipient has no threshold & receives all residual flows)\\n  /// it cannot be greater than uint96\\n  /// @return owr Address of new OptimisticWithdrawalRecipient clone\\n  function createOWRecipient(\\n    address recoveryAddress,\\n    address principalRecipient,\\n    address rewardRecipient,\\n    uint256 amountOfPrincipalStake\\n  ) external returns (OptimisticWithdrawalRecipient owr) {\\n    /// checks\\n\\n    // ensure doesn't have address(0)\\n    if (principalRecipient == address(0) || rewardRecipient == address(0)) revert Invalid__Recipients();\\n    // ensure threshold isn't zero\\n    if (amountOfPrincipalStake == 0) revert Invalid__ZeroThreshold();\\n    // ensure threshold isn't too large\\n    if (amountOfPrincipalStake > type(uint96).max) revert Invalid__ThresholdTooLarge(amountOfPrincipalStake);\\n\\n    /// effects\\n    uint256 principalData = (amountOfPrincipalStake << ADDRESS_BITS) | uint256(uint160(principalRecipient));\\n    uint256 rewardData = uint256(uint160(rewardRecipient));\\n\\n    // would not exceed contract size limits\\n    // important to not reorder\\n    bytes memory data = abi.encodePacked(recoveryAddress, principalData, rewardData);\\n    owr = OptimisticWithdrawalRecipient(address(owrImpl).clone(data));\\n\\n    emit CreateOWRecipient(address(owr), recoveryAddress, principalRecipient, rewardRecipient, amountOfPrincipalStake);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/owr/OptimisticWithdrawalRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {Clone} from \\\"solady/utils/Clone.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @title OptimisticWithdrawalRecipient\\n/// @author Obol\\n/// @notice A maximally-composable contract that distributes payments\\n/// based on threshold to it's recipients\\n/// @dev Only ETH can be distributed for a given deployment. There is a\\n/// recovery method for tokens sent by accident.\\ncontract OptimisticWithdrawalRecipient is Clone {\\n  /// -----------------------------------------------------------------------\\n  /// libraries\\n  /// -----------------------------------------------------------------------\\n\\n  using SafeTransferLib for address;\\n\\n  /// -----------------------------------------------------------------------\\n  /// errors\\n  /// -----------------------------------------------------------------------\\n\\n  /// Invalid token recovery recipient\\n  error InvalidTokenRecovery_InvalidRecipient();\\n\\n  /// Invalid distribution\\n  error InvalidDistribution_TooLarge();\\n\\n  /// -----------------------------------------------------------------------\\n  /// events\\n  /// -----------------------------------------------------------------------\\n\\n  /// Emitted after each successful ETH transfer to proxy\\n  /// @param amount Amount of ETH received\\n  /// @dev embedded in & emitted from clone bytecode\\n  event ReceiveETH(uint256 amount);\\n\\n  /// Emitted after funds are distributed to recipients\\n  /// @param principalPayout Amount of principal paid out\\n  /// @param rewardPayout Amount of reward paid out\\n  /// @param pullFlowFlag Flag for pushing funds to recipients or storing for\\n  /// pulling\\n  event DistributeFunds(uint256 principalPayout, uint256 rewardPayout, uint256 pullFlowFlag);\\n\\n  /// Emitted after tokens are recovered to a recipient\\n  /// @param recoveryAddressToken Recovered token (cannot be\\n  /// ETH)\\n  /// @param recipient Address receiving recovered token\\n  /// @param amount Amount of recovered token\\n  event RecoverNonOWRecipientFunds(address recoveryAddressToken, address recipient, uint256 amount);\\n\\n  /// Emitted after funds withdrawn using pull flow\\n  /// @param account Account withdrawing funds for\\n  /// @param amount Amount withdrawn\\n  event Withdrawal(address account, uint256 amount);\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage\\n  /// -----------------------------------------------------------------------\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage - constants\\n  /// -----------------------------------------------------------------------\\n\\n  uint256 internal constant PUSH = 0;\\n  uint256 internal constant PULL = 1;\\n\\n  uint256 internal constant ONE_WORD = 32;\\n  uint256 internal constant ADDRESS_BITS = 160;\\n\\n  /// @dev threshold for pushing balance update as reward or principal\\n  uint256 internal constant BALANCE_CLASSIFICATION_THRESHOLD = 16 ether;\\n  uint256 internal constant PRINCIPAL_RECIPIENT_INDEX = 0;\\n  uint256 internal constant REWARD_RECIPIENT_INDEX = 1;\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage - cwia offsets\\n  /// -----------------------------------------------------------------------\\n\\n  // recoveryAddress (address, 20 bytes),\\n  // tranches (uint256[], numTranches * 32 bytes)\\n\\n  // 0; first item\\n  uint256 internal constant RECOVERY_ADDRESS_OFFSET = 0;\\n  // 20 = recoveryAddress_offset (0) + recoveryAddress_size (address, 20\\n  // bytes)\\n  uint256 internal constant TRANCHES_OFFSET = 20;\\n\\n  /// Address to recover non-OWR tokens to\\n  /// @dev equivalent to address public immutable recoveryAddress;\\n  function recoveryAddress() public pure returns (address) {\\n    return _getArgAddress(RECOVERY_ADDRESS_OFFSET);\\n  }\\n\\n  /// Get OWR tranche `i`\\n  /// @dev emulates to uint256[] internal immutable tranche;\\n  function _getTranche(uint256 i) internal pure returns (uint256) {\\n    unchecked {\\n      // shouldn't overflow\\n      return _getArgUint256(TRANCHES_OFFSET + i * ONE_WORD);\\n    }\\n  }\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage - mutables\\n  /// -----------------------------------------------------------------------\\n\\n  /// Amount of active balance set aside for pulls\\n  /// @dev ERC20s with very large decimals may overflow & cause issues\\n  uint128 public fundsPendingWithdrawal;\\n\\n  /// Amount of distributed OWRecipient token for principal\\n  /// @dev Would be less than or equal to amount of stake\\n  /// @dev ERC20s with very large decimals may overflow & cause issues\\n  uint128 public claimedPrincipalFunds;\\n\\n  /// Mapping to account balances for pulling\\n  mapping(address => uint256) internal pullBalances;\\n\\n  /// -----------------------------------------------------------------------\\n  /// constructor\\n  /// -----------------------------------------------------------------------\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  /// clone implementation doesn't use constructor\\n  constructor() {}\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions\\n  /// -----------------------------------------------------------------------\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions - public & external\\n  /// -----------------------------------------------------------------------\\n\\n  /// emit event when receiving ETH\\n  /// @dev implemented w/i clone bytecode\\n  /* receive() external payable { */\\n  /*     emit ReceiveETH(msg.value); */\\n  /* } */\\n\\n  /// Distributes target token inside the contract to recipients\\n  /// @dev pushes funds to recipients\\n  function distributeFunds() external payable {\\n    _distributeFunds(PUSH);\\n  }\\n\\n  /// Distributes target token inside the contract to recipients\\n  /// @dev backup recovery if any recipient tries to brick the OWRecipient for\\n  /// remaining recipients\\n  function distributeFundsPull() external payable {\\n    _distributeFunds(PULL);\\n  }\\n\\n  /// Recover non-OWR tokens to a recipient\\n  /// @param nonOWRToken Token to recover (cannot be OWR token)\\n  /// @param recipient Address to receive recovered token\\n  function recoverFunds(address nonOWRToken, address recipient) external payable {\\n    /// checks\\n\\n    // if recoveryAddress is set, recipient must match it\\n    // else, recipient must be one of the OWR recipients\\n\\n    address _recoveryAddress = recoveryAddress();\\n    if (_recoveryAddress == address(0)) {\\n      // ensure txn recipient is a valid OWR recipient\\n      (address principalRecipient, address rewardRecipient,) = getTranches();\\n      if (recipient != principalRecipient && recipient != rewardRecipient) {\\n        revert InvalidTokenRecovery_InvalidRecipient();\\n      }\\n    } else if (recipient != _recoveryAddress) {\\n      revert InvalidTokenRecovery_InvalidRecipient();\\n    }\\n\\n    /// effects\\n\\n    /// interactions\\n\\n    // recover non-target token\\n    uint256 amount = ERC20(nonOWRToken).balanceOf(address(this));\\n    nonOWRToken.safeTransfer(recipient, amount);\\n\\n    emit RecoverNonOWRecipientFunds(nonOWRToken, recipient, amount);\\n  }\\n\\n  /// Withdraw token balance for account `account`\\n  /// @param account Address to withdraw on behalf of\\n  function withdraw(address account) external {\\n    uint256 tokenAmount = pullBalances[account];\\n    unchecked {\\n      // shouldn't underflow; fundsPendingWithdrawal = sum(pullBalances)\\n      fundsPendingWithdrawal -= uint128(tokenAmount);\\n    }\\n    pullBalances[account] = 0;\\n    account.safeTransferETH(tokenAmount);\\n\\n    emit Withdrawal(account, tokenAmount);\\n  }\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions - view & pure\\n  /// -----------------------------------------------------------------------\\n\\n  /// Return unpacked tranches\\n  /// @return principalRecipient Addres of principal recipient\\n  /// @return rewardRecipient Address of reward recipient\\n  /// @return amountOfPrincipalStake Absolute payment threshold for principal\\n  function getTranches()\\n    public\\n    pure\\n    returns (address principalRecipient, address rewardRecipient, uint256 amountOfPrincipalStake)\\n  {\\n    uint256 tranche = _getTranche(PRINCIPAL_RECIPIENT_INDEX);\\n    principalRecipient = address(uint160(tranche));\\n    amountOfPrincipalStake = tranche >> ADDRESS_BITS;\\n\\n    rewardRecipient = address(uint160(_getTranche(REWARD_RECIPIENT_INDEX)));\\n  }\\n\\n  /// Returns the balance for account `account`\\n  /// @param account Account to return balance for\\n  /// @return Account's balance OWR token\\n  function getPullBalance(address account) external view returns (uint256) {\\n    return pullBalances[account];\\n  }\\n\\n  /// -----------------------------------------------------------------------\\n  /// functions - private & internal\\n  /// -----------------------------------------------------------------------\\n\\n  /// Distributes target token inside the contract to next-in-line recipients\\n  /// @dev can PUSH or PULL funds to recipients\\n  function _distributeFunds(uint256 pullFlowFlag) internal {\\n    /// checks\\n\\n    /// effects\\n\\n    // load storage into memory\\n    uint256 currentbalance = address(this).balance;\\n    uint256 _claimedPrincipalFunds = uint256(claimedPrincipalFunds);\\n    uint256 _memoryFundsPendingWithdrawal = uint256(fundsPendingWithdrawal);\\n    uint256 _fundsToBeDistributed = currentbalance - _memoryFundsPendingWithdrawal;\\n\\n    (address principalRecipient, address rewardRecipient, uint256 amountOfPrincipalStake) = getTranches();\\n\\n    // determine which recipeint is getting paid based on funds to be\\n    // distributed\\n    uint256 _principalPayout = 0;\\n    uint256 _rewardPayout = 0;\\n\\n    unchecked {\\n      // _claimedPrincipalFunds should always be <= amountOfPrincipalStake\\n      uint256 principalStakeRemaining = amountOfPrincipalStake - _claimedPrincipalFunds;\\n\\n      if (_fundsToBeDistributed >= BALANCE_CLASSIFICATION_THRESHOLD && principalStakeRemaining > 0) {\\n        if (_fundsToBeDistributed > principalStakeRemaining) {\\n          // this means there is reward part of the funds to be\\n          // distributed\\n          _principalPayout = principalStakeRemaining;\\n          // shouldn't underflow\\n          _rewardPayout = _fundsToBeDistributed - principalStakeRemaining;\\n        } else {\\n          // this means there is no reward part of the funds to be\\n          // distributed\\n          _principalPayout = _fundsToBeDistributed;\\n        }\\n      } else {\\n        _rewardPayout = _fundsToBeDistributed;\\n      }\\n    }\\n\\n    {\\n      if (_fundsToBeDistributed > type(uint128).max) revert InvalidDistribution_TooLarge();\\n      // Write to storage\\n      // the principal value\\n      // it cannot overflow because _principalPayout < _fundsToBeDistributed\\n      if (_principalPayout > 0) claimedPrincipalFunds += uint128(_principalPayout);\\n    }\\n\\n    /// interactions\\n\\n    // pay outs\\n    // earlier tranche recipients may try to re-enter but will cause fn to\\n    // revert\\n    // when later external calls fail (bc balance is emptied early)\\n\\n    // pay out principal\\n    _payout(principalRecipient, _principalPayout, pullFlowFlag);\\n    // pay out reward\\n    _payout(rewardRecipient, _rewardPayout, pullFlowFlag);\\n\\n    if (pullFlowFlag == PULL) {\\n      if (_principalPayout > 0 || _rewardPayout > 0) {\\n        // Write to storage\\n        fundsPendingWithdrawal = uint128(_memoryFundsPendingWithdrawal + _principalPayout + _rewardPayout);\\n      }\\n    }\\n\\n    emit DistributeFunds(_principalPayout, _rewardPayout, pullFlowFlag);\\n  }\\n\\n  function _payout(address recipient, uint256 payoutAmount, uint256 pullFlowFlag) internal {\\n    if (payoutAmount > 0) {\\n      if (pullFlowFlag == PULL) {\\n        // Write to Storage\\n        pullBalances[recipient] += payoutAmount;\\n      } else {\\n        recipient.safeTransferETH(payoutAmount);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\nlibrary LibClone {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or the caller.\\n    error SaltDoesNotStartWithCaller();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(0, 0x0c, 0x35)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(0, 0x0c, 0x35, salt)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(0, 0x0e, 0x36)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(0, 0x0e, 0x36, salt)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a minimal proxy with `implementation`,\\n    /// using immutable arguments encoded in `data`.\\n    ///\\n    /// Note: This implementation of CWIA differs from the original implementation.\\n    /// If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`,\\n    /// using immutable arguments encoded in `data`, with `salt`.\\n    ///\\n    /// Note: This implementation of CWIA differs from the original implementation.\\n    /// If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Compute and store the bytecode hash.\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /// @dev Reverts if `salt` does not start with either the zero address or the caller.\\n    function checkStartsWithCaller(bytes32 salt) internal view {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or the caller.\\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\\n                // Store the function selector of `SaltDoesNotStartWithCaller()`.\\n                mstore(0x00, 0x2f634836)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IENSReverseRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IENSReverseRegistrar {\\n  function claim(address owner) external returns (bytes32);\\n  function defaultResolver() external view returns (address);\\n  function ens() external view returns (address);\\n  function node(address addr) external pure returns (bytes32);\\n  function setName(string memory name) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Class with helper read functions for clone with immutable args.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)\\n/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\nabstract contract Clone {\\n    /// @dev Reads all of the immutable args.\\n    function _getArgBytes() internal pure returns (bytes memory arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            let length := sub(calldatasize(), add(2, offset)) // 2 bytes are used for the length.\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), offset, length)\\n            let o := add(add(arg, 0x20), length)\\n            mstore(o, 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type bytes.\\n    function _getArgBytes(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (bytes memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\\n            let o := add(add(arg, 0x20), length)\\n            mstore(o, 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type address.\\n    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(96, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads a uint256 array stored in the immutable args.\\n    function _getArgUint256Array(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (uint256[] memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads a bytes32 array stored in the immutable args.\\n    function _getArgBytes32Array(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (bytes32[] memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type bytes32.\\n    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint256.\\n    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint248.\\n    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint240.\\n    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(16, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint232.\\n    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(24, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint224.\\n    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(0x20, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint216.\\n    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(40, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint208.\\n    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(48, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint200.\\n    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(56, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint192.\\n    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(64, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint184.\\n    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(72, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint176.\\n    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(80, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint168.\\n    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(88, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint160.\\n    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(96, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint152.\\n    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(104, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint144.\\n    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(112, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint136.\\n    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(120, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint128.\\n    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(128, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint120.\\n    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(136, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint112.\\n    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(144, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint104.\\n    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(152, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint96.\\n    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(160, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint88.\\n    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(168, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint80.\\n    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(176, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint72.\\n    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(184, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint64.\\n    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(192, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint56.\\n    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(200, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint48.\\n    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(208, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint40.\\n    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(216, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint32.\\n    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(224, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint24.\\n    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(232, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint16.\\n    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(240, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint8.\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(248, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata.\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"splits-tests/=lib/splits-utils/test/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"splits-utils/=lib/splits-utils/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ensName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_ensReverseRegistrar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ensOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Invalid__Recipients\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"Invalid__ThresholdTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid__ZeroThreshold\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"principalRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"CreateOWRecipient\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOfPrincipalStake\",\"type\":\"uint256\"}],\"name\":\"createOWRecipient\",\"outputs\":[{\"internalType\":\"contract OptimisticWithdrawalRecipient\",\"name\":\"owr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owrImpl\",\"outputs\":[{\"internalType\":\"contract OptimisticWithdrawalRecipient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OptimisticWithdrawalRecipientFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000a58e81fe9b61b5c3fe2afd33cf304c454abfc7cb00000000000000000000000043f641fa70e09f0326ac66b4ef0c416eaecbc6f500000000000000000000000000000000000000000000000000000000000000136f7772666163746f72792e6f626f6c2e65746800000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}