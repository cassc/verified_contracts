{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/BoringSolidity/contracts/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Simplified by BoringCrypto\\n\\ncontract BoringOwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\ncontract BoringOwnable is BoringOwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice `owner` defaults to msg.sender on construction.\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n    /// Can only be invoked by the current `owner`.\\n    /// @param newOwner Address of the new owner.\\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) public onlyOwner {\\n        if (direct) {\\n            // Checks\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\n\\n            // Effects\\n            emit OwnershipTransferred(owner, newOwner);\\n            owner = newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            // Effects\\n            pendingOwner = newOwner;\\n        }\\n    }\\n\\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\\n    function claimOwnership() public {\\n        address _pendingOwner = pendingOwner;\\n\\n        // Checks\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\n\\n        // Effects\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /// @notice Only allows the `owner` to execute the function.\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\\n    // By removing them you can't accidentally use them.\\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IStrictERC20 {\\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n// solhint-disable avoid-low-level-calls\\n\\nlibrary BoringERC20 {\\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\n\\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\\n        if (data.length >= 64) {\\n            return abi.decode(data, (string));\\n        } else if (data.length == 32) {\\n            uint8 i = 0;\\n            while (i < 32 && data[i] != 0) {\\n                i++;\\n            }\\n            bytes memory bytesArray = new bytes(i);\\n            for (i = 0; i < 32 && data[i] != 0; i++) {\\n                bytesArray[i] = data[i];\\n            }\\n            return string(bytesArray);\\n        } else {\\n            return \\\"???\\\";\\n        }\\n    }\\n\\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token symbol.\\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token name.\\n    function safeName(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (uint8) Token decimals.\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to The address of the user to check.\\n    /// @return amount The token amount.\\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\\n        require(success && data.length >= 32, \\\"BoringERC20: BalanceOf failed\\\");\\n        amount = abi.decode(data, (uint256));\\n    }\\n\\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\\n    /// @param token The address of the ERC-20 token.\\n    /// @return totalSupply The token totalSupply.\\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\\n        require(success && data.length >= 32, \\\"BoringERC20: totalSupply failed\\\");\\n        totalSupply = abi.decode(data, (uint256));\\n    }\\n\\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\n    }\\n\\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param from Transfer tokens from.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringRebase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Rebase {\\n    uint128 elastic;\\n    uint128 base;\\n}\\n\\n/// @notice A rebasing library using overflow-/underflow-safe math.\\nlibrary RebaseLibrary {\\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\\n    function toBase(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (uint256 base) {\\n        if (total.elastic == 0) {\\n            base = elastic;\\n        } else {\\n            base = (elastic * total.base) / total.elastic;\\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\\n                base++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\\n    function toElastic(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (uint256 elastic) {\\n        if (total.base == 0) {\\n            elastic = base;\\n        } else {\\n            elastic = (base * total.elastic) / total.base;\\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\\n                elastic++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\\n    /// @return (Rebase) The new total.\\n    /// @return base in relationship to `elastic`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 base) {\\n        base = toBase(total, elastic, roundUp);\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return (total, base);\\n    }\\n\\n    /// @notice Sub `base` from `total` and update `total.elastic`.\\n    /// @return (Rebase) The new total.\\n    /// @return elastic in relationship to `base`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 elastic) {\\n        elastic = toElastic(total, base, roundUp);\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return (total, elastic);\\n    }\\n\\n    /// @notice Add `elastic` and `base` to `total`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Subtract `elastic` and `base` to `total`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Add `elastic` to `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic += uint128(elastic);\\n    }\\n\\n    /// @notice Subtract `elastic` from `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic -= uint128(elastic);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBentoBoxV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\nimport \\\"interfaces/IStrategy.sol\\\";\\n\\ninterface IFlashBorrower {\\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param token The address of the token that is loaned.\\n    /// @param amount of the `token` that is loaned.\\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onFlashLoan(\\n        address sender,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBatchFlashBorrower {\\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onBatchFlashLoan(\\n        address sender,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBentoBoxV1 {\\n    function balanceOf(IERC20, address) external view returns (uint256);\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n\\n    function batchFlashLoan(\\n        IBatchFlashBorrower borrower,\\n        address[] calldata receivers,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function claimOwnership() external;\\n\\n    function flashLoan(\\n        IFlashBorrower borrower,\\n        address receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function deploy(\\n        address masterContract,\\n        bytes calldata data,\\n        bool useCreate2\\n    ) external payable returns (address);\\n\\n    function deposit(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function harvest(\\n        IERC20 token,\\n        bool balance,\\n        uint256 maxChangeAmount\\n    ) external;\\n\\n    function masterContractApproved(address, address) external view returns (bool);\\n\\n    function masterContractOf(address) external view returns (address);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function pendingStrategy(IERC20) external view returns (IStrategy);\\n\\n    function permitToken(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function registerProtocol() external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\\n\\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\\n\\n    function strategy(IERC20) external view returns (IStrategy);\\n\\n    function strategyData(IERC20)\\n        external\\n        view\\n        returns (\\n            uint64 strategyStartDate,\\n            uint64 targetPercentage,\\n            uint128 balance\\n        );\\n\\n    function toAmount(\\n        IERC20 token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    function toShare(\\n        IERC20 token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    function totals(IERC20) external view returns (Rebase memory totals_);\\n\\n    function transfer(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function transferMultiple(\\n        IERC20 token,\\n        address from,\\n        address[] calldata tos,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) external;\\n\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\n\\n    function whitelistedMasterContracts(address) external view returns (bool);\\n\\n    function withdraw(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICauldronV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\nimport \\\"interfaces/IOracle.sol\\\";\\n\\ninterface ICauldronV2 {\\n    function oracle() external view returns (IOracle);\\n\\n    function accrueInfo()\\n        external\\n        view\\n        returns (\\n            uint64,\\n            uint128,\\n            uint64\\n        );\\n\\n    function bentoBox() external view returns (address);\\n\\n    function feeTo() external view returns (address);\\n\\n    function masterContract() external view returns (ICauldronV2);\\n\\n    function collateral() external view returns (IERC20);\\n\\n    function setFeeTo(address newFeeTo) external;\\n\\n    function accrue() external;\\n\\n    function totalBorrow() external view returns (Rebase memory);\\n\\n    function userBorrowPart(address account) external view returns (uint256);\\n\\n    function userCollateralShare(address account) external view returns (uint256);\\n\\n    function withdrawFees() external;\\n\\n    function cook(\\n        uint8[] calldata actions,\\n        uint256[] calldata values,\\n        bytes[] calldata datas\\n    ) external payable returns (uint256 value1, uint256 value2);\\n\\n    function addCollateral(\\n        address to,\\n        bool skim,\\n        uint256 share\\n    ) external;\\n\\n    function removeCollateral(address to, uint256 share) external;\\n\\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\\n\\n    function repay(\\n        address to,\\n        bool skim,\\n        uint256 part\\n    ) external returns (uint256 amount);\\n\\n    function reduceSupply(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICauldronV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"interfaces/ICauldronV2.sol\\\";\\n\\ninterface ICauldronV3 is ICauldronV2 {\\n    function changeInterestRate(ICauldronV3 cauldron, uint64 newInterestRate) external;\\n\\n    function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICauldronV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"interfaces/ICauldronV3.sol\\\";\\n\\ninterface ICauldronV4 is ICauldronV3 {\\n    function setBlacklistedCallee(address callee, bool blacklisted) external;\\n\\n    function repayForAll(uint128 amount, bool skim) external returns (uint128);\\n\\n    function setAllowedSupplyReducer(address account, bool allowed) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IOracle {\\n    /// @notice Get the latest exchange rate.\\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\\n    /// For example:\\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n    /// @return success if no valid (recent) rate is available, return false else true.\\n    /// @return rate The rate of the requested asset / pair / pool.\\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\\n\\n    /// @notice Check the last exchange rate without any state changes.\\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\\n    /// For example:\\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n    /// @return success if no valid (recent) rate is available, return false else true.\\n    /// @return rate The rate of the requested asset / pair / pool.\\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\\n\\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\\n    /// For example:\\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n    /// @return rate The rate of the requested asset / pair / pool.\\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\\n\\n    /// @notice Returns a human readable (short) name about this oracle.\\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\\n    /// For example:\\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n    /// @return (string) A human readable symbol name about this oracle.\\n    function symbol(bytes calldata data) external view returns (string memory);\\n\\n    /// @notice Returns a human readable name about this oracle.\\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\\n    /// For example:\\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n    /// @return (string) A human readable name about this oracle.\\n    function name(bytes calldata data) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IStrategy {\\n    /// @notice Send the assets to the Strategy and call skim to invest them.\\n    /// @param amount The amount of tokens to invest.\\n    function skim(uint256 amount) external;\\n\\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\n\\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\\n    /// @dev The `actualAmount` should be very close to the amount.\\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\\n    /// @param amount The requested amount the caller wants to withdraw.\\n    /// @return actualAmount The real amount that is withdrawn.\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\n}\\n\"\r\n    },\r\n    \"src/periphery/CauldronOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringERC20.sol\\\";\\nimport \\\"BoringSolidity/BoringOwnable.sol\\\";\\nimport \\\"OpenZeppelin/utils/Address.sol\\\";\\nimport \\\"interfaces/ICauldronV4.sol\\\";\\nimport \\\"interfaces/IBentoBoxV1.sol\\\";\\n\\ncontract CauldronOwner is BoringOwnable {\\n    using BoringERC20 for IERC20;\\n\\n    error ErrNotOperator(address operator);\\n    error ErrCauldronNotAuthorized(address cauldron);\\n    error ErrBentoBoxNotAuthorized(address bentoBox);\\n    error ErrNotDeprecated(address cauldron);\\n\\n    event LogOperatorChanged(address indexed operator, bool previous, bool current);\\n    event LogTreasuryChanged(address indexed previous, address indexed current);\\n    event LogDeprecated(address indexed cauldron, bool previous, bool current);\\n\\n    IERC20 public immutable mim;\\n\\n    mapping(address => bool) public operators;\\n    mapping(address => bool) public deprecated;\\n\\n    address public treasury;\\n\\n    modifier onlyOperators() {\\n        if (!operators[msg.sender]) {\\n            revert ErrNotOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    constructor(address _treasury, IERC20 _mim) {\\n        treasury = _treasury;\\n        mim = _mim;\\n\\n        emit LogTreasuryChanged(address(0), _treasury);\\n    }\\n\\n    function reduceSupply(ICauldronV2 cauldron, uint256 amount) external onlyOperators {\\n        cauldron.reduceSupply(amount);\\n    }\\n\\n    function changeInterestRate(ICauldronV3 cauldron, uint64 newInterestRate) external onlyOperators {\\n        cauldron.changeInterestRate(cauldron, newInterestRate);\\n    }\\n\\n    function reduceCompletely(ICauldronV2 cauldron) external onlyOperators {\\n        if (!deprecated[address(cauldron)]) {\\n            revert ErrNotDeprecated(address(cauldron));\\n        }\\n\\n        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());\\n        uint256 amount = bentoBox.toAmount(mim, bentoBox.balanceOf(mim, address(cauldron)), false);\\n        cauldron.reduceSupply(amount);\\n    }\\n\\n    function changeBorrowLimit(\\n        ICauldronV3 cauldron,\\n        uint128 newBorrowLimit,\\n        uint128 perAddressPart\\n    ) external onlyOperators {\\n        cauldron.changeBorrowLimit(newBorrowLimit, perAddressPart);\\n    }\\n\\n    function withdrawMIMToTreasury(IBentoBoxV1 bentoBox, uint256 share) external onlyOperators {\\n        uint256 maxShare = bentoBox.balanceOf(mim, address(this));\\n        if (share > maxShare) {\\n            share = maxShare;\\n        }\\n\\n        bentoBox.withdraw(mim, address(this), treasury, 0, share);\\n    }\\n\\n    function setFeeTo(ICauldronV2 cauldron, address newFeeTo) external onlyOperators {\\n        cauldron.setFeeTo(newFeeTo);\\n    }\\n\\n    function setDeprecated(address cauldron, bool _deprecated) external onlyOperators {\\n        emit LogDeprecated(cauldron, deprecated[cauldron], _deprecated);\\n\\n        deprecated[cauldron] = _deprecated;\\n    }\\n\\n    function setBlacklistedCallee(\\n        ICauldronV4 cauldron,\\n        address callee,\\n        bool blacklisted\\n    ) external onlyOperators {\\n        cauldron.setBlacklistedCallee(callee, blacklisted);\\n    }\\n\\n    function setAllowedSupplyReducer(\\n        ICauldronV4 cauldron,\\n        address account,\\n        bool allowed\\n    ) external onlyOperators {\\n        cauldron.setAllowedSupplyReducer(account, allowed);\\n    }\\n\\n    function setOperator(address operator, bool enabled) external onlyOwner {\\n        emit LogOperatorChanged(operator, operators[operator], enabled);\\n        operators[operator] = true;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        emit LogTreasuryChanged(treasury, _treasury);\\n        treasury = _treasury;\\n    }\\n\\n    function transferMasterContractOwnership(BoringOwnable masterContract, address newOwner) external onlyOwner {\\n        masterContract.transferOwnership(newOwner, true, false);\\n    }\\n\\n    /// low level execution for any other future added functions\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external onlyOwner returns (bool success, bytes memory result) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, result) = to.call{value: value}(data);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"OpenZeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"harvesters/=src/harvesters/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"mocks/=src/mocks/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"utils/=utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_mim\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bentoBox\",\"type\":\"address\"}],\"name\":\"ErrBentoBoxNotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"}],\"name\":\"ErrCauldronNotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"}],\"name\":\"ErrNotDeprecated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ErrNotOperator\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"previous\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"LogDeprecated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"previous\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"LogOperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"LogTreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV3\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"newBorrowLimit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"perAddressPart\",\"type\":\"uint128\"}],\"name\":\"changeBorrowLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV3\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"newInterestRate\",\"type\":\"uint64\"}],\"name\":\"changeInterestRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mim\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV2\",\"name\":\"cauldron\",\"type\":\"address\"}],\"name\":\"reduceCompletely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV2\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reduceSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV4\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowedSupplyReducer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV4\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"setBlacklistedCallee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_deprecated\",\"type\":\"bool\"}],\"name\":\"setDeprecated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICauldronV2\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BoringOwnable\",\"name\":\"masterContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferMasterContractOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"bentoBox\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"withdrawMIMToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CauldronOwner", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000df2c270f610dc35d8ffda5b453e74db5471e126b00000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}