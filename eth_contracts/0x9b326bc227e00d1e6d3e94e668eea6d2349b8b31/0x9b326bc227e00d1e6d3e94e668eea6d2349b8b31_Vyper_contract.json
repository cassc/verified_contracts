{"SourceCode": "# @version 0.3.7\r\n\r\n\"\"\"\r\n@title \ud83c\udfd5\ufe0f NPC Orthodoxy Camp\r\n@notice \ud83e\udd69 Steak your NPC-er for re-education and earn worthless $THING CBDCs\r\n@author npcers.eth\r\n\r\n         :=+******++=-:                 \r\n      -+*+======------=+++=:            \r\n     %+========------------=++=.        \r\n    %+=======------------------++:      \r\n   *+=======--------------------:++     \r\n  =*=======------------------------*.   \r\n .%========-------------------------*.  \r\n %+=======-------------------------:-%  \r\n+*========--------------------------:%  \r\n%=========--------------------------:%. \r\n%=========--------------------+**=--:++ \r\n%+========-----=*%%%=--------%%%%%+-::*:\r\n:%========-----+%%%%%=-------=%%%%%-::+=\r\n -%======-------+%%%%=----=*=--+**=-::%:\r\n  :%+====---------==----===%%=------::% \r\n    %+===-------------======%%=------:=+\r\n    .%===------------=======+%%------::%\r\n     %+==-----------=========+%%-------+\r\n     %===------------*%%%%%%%%%%%-----%.\r\n     %====-----------============----%: \r\n     *+==%+----------+%%%%%%%%%%%--=*.  \r\n     -%==+%=---------=+=========--*=    \r\n      +===+%+--------------------*-     \r\n       =====*%=------------------%      \r\n       .======*%*=------------=*+.      \r\n         -======+*%*+--------*+         \r\n          .-========+***+++=-.          \r\n             .-=======:           \r\n\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC721\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udd0c INTERFACES                                                                       #\r\n#######################################################################################\r\n\r\ninterface ESG_NPC:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def wrap(ids: DynArray[uint256, 100]): nonpayable\r\n\r\ninterface CurrentThing:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def new_current_thing(current_thing: String[256]): nonpayable\r\n    def current_epoch() -> uint256: view\r\n    def mint(recipient: address, amount: uint256): nonpayable\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udcbe STATE VARIABLES                                                                  #\r\n#######################################################################################\r\n\r\n# \ud83d\udcec Addresses\r\nnpc_nft: public(ERC721)\r\nnpc_esg: public(ESG_NPC)\r\nthing: public(CurrentThing)\r\nowner: public(address)\r\n\r\n# \ud83e\udd69 Steakers\r\nsteaked_nfts: public(HashMap[address, DynArray[uint256, 6000]])\r\nsteaked_coin: public(HashMap[address, uint256])\r\nsteaked_users: public(DynArray[address, 6000])\r\n\r\n# \ud83c\udfcb\ufe0f Weights\r\nperiod_user_start: public( HashMap[address, uint256] )  # User -> Block Height \r\nfinalized_rewards: public( HashMap[address, uint256] )  # Settled prior periods\r\n\r\n# \ud83d\udda8 Brrr.... \r\ninflation_rate: public(uint256)                         # Rewards per block\r\n\r\n# \ud83d\udd2a Kill Conditions\r\nkill_time: public(uint256)                              # Admin function delay\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udc23 INITIALIZATION                                                                   #\r\n#######################################################################################\r\n\r\n@external\r\ndef __init__(npc_nft: address, npc_esg: address, thing: address):\r\n    \"\"\"\r\n    @param npc_nft Address of NPC NFT\r\n    @param npc_esg Address of Wrapped NPC token\r\n    @param thing Address of $THING token\r\n    \"\"\"\r\n    self.npc_nft = ERC721(npc_nft)\r\n    self.npc_esg = ESG_NPC(npc_esg)\r\n    self.npc_nft.setApprovalForAll(npc_esg, True)\r\n\r\n    self.thing = CurrentThing(thing)\r\n    self.inflation_rate = 1000  * 10 ** 18 / 7200 \r\n\r\n    self.owner = msg.sender\r\n    self.kill_time = 0\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udc40 VIEW FUNCTIONS                                                                   #\r\n#######################################################################################\r\n\r\n# INFORMATION\r\n\r\n@external\r\n@view\r\ndef current_epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Retrieve the current epoch number\r\n    @return Epoch number\r\n    \"\"\"\r\n    return self._current_epoch()\r\n\r\n\r\n# USER BALANCES\r\n\r\n@external\r\n@view\r\ndef balance_nft(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Check balance of NPC NFTs user has steaked\r\n    @param user Address of user\r\n    @return User balance\r\n    \"\"\"\r\n    return(self._nft_balance_of(user) )\r\n\r\n\r\n@external\r\n@view\r\ndef balance_esg(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Check balance of esgNPCs user has steaked\r\n    @param user Address of user\r\n    @return User balance\r\n    \"\"\"\r\n    return(self.steaked_coin[user] )\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOf(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Retrieve total balance (NPC + esgNPC) user has steaked\r\n    @param user Address of user\r\n    @return Total balance\r\n    \"\"\"\r\n    return(self._nft_balance_of(user) * 10 ** 18 + self.steaked_coin[user]) \r\n\r\n\r\n@external\r\n@view\r\ndef reward_balance(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Total rewards available to claim \r\n    @param user Address to check\r\n    @return Amount of $THING available to claim\r\n    \"\"\"\r\n    return self._reward_balance(user) \r\n\r\n\r\n@external\r\n@view\r\ndef reward_uncached(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Rewards earned this epoch, exclusive of previously cached rewards \r\n    @dev Mostly included for tests, may want to remove before launch\r\n    @param user Address of user\r\n    @return Rewards accumulated just this epoch\r\n    \"\"\"\r\n    return self._recent_rewards(user)\r\n\r\n\r\n# MULTIPLIERS\r\n\r\n@external\r\n@view\r\ndef calc_multiplier(id: uint256, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the multiplier for a particular NPC in a given epoch\r\n    @dev Rename to calc_nft_multplier\r\n    @param id NFT identifier\r\n    @param epoch Epoch number\r\n    @return Multiplier for staking single NFT, 18 digits\r\n    \"\"\"\r\n    return self._calc_multiplier(id, epoch)\r\n\r\n\r\n@external\r\n@view\r\ndef calc_avg_multiplier_nft(user: address, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Average multiplier for a steaked user's entire NFT collection\r\n    @dev Reverts if no balance of steaked NFTs\r\n    @param user Staked user\r\n    @param epoch Epoch number\r\n    @return Multiplier, 18 digits\r\n    \"\"\"\r\n    return self._calc_avg_multiplier(user, epoch)\r\n\r\n\r\n@external\r\n@view\r\ndef calc_avg_multiplier_esg(bal: uint256, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Multiplier for depositing wrapped esgNPC\r\n    @dev Calculated as the average multiplier for the first 10 NPC NFTs, exact units\r\n    @param bal Balance affects the bulk bonus\r\n    @param epoch Weight at epoch\r\n    @return Multiplier, 18 digits\r\n    \"\"\"\r\n    return self._calc_avg_coin_multiplier(bal, epoch)\r\n\r\n\r\n# RATE CALCULATION\r\n\r\n@external\r\n@view\r\ndef bulk_bonus(quantity: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate bonus multiplier applied for staking several NPCs\r\n    @param quantity Balance of NFTs to steak\r\n    @return Multiplier, 18 digits\r\n    \"\"\"\r\n    return self._bulk_bonus(quantity)\r\n\r\n\r\n@external\r\n@view\r\ndef current_rate_for_user(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Earnings per block for user\r\n    @param addr Address to check\r\n    @return Earnings per block\r\n    \"\"\"\r\n    return self._curr_weight_for_user(addr) * self.inflation_rate / 10 ** 18\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udcdd STATE MODIFYING FUNCTION                                                         #\r\n#######################################################################################\r\n\r\n@external\r\ndef steak_npc(nft_ids: DynArray[uint256, 100]):\r\n    \"\"\"\r\n    @notice Stake NPC NFT to earn rewards\r\n    @param nft_ids List of NPC ids to steak\r\n    \"\"\"\r\n    assert self.npc_nft.isApprovedForAll(msg.sender, self)\r\n    assert self.kill_time == 0\r\n    \r\n    for id in nft_ids:\r\n        self.npc_nft.transferFrom(msg.sender, self, id)\r\n        self.steaked_nfts[msg.sender].append(id)\r\n    \r\n    self._add_to_steaked_users(msg.sender)\r\n    self._store_recent_rewards(msg.sender)\r\n\r\n\r\n@external\r\ndef steak_esg_npc(quantity: uint256):\r\n    \"\"\"\r\n    @notice Stake esgNPC to earn rewards\r\n    @param quantity Amount of NPC to steak\r\n    \"\"\"\r\n    assert self.npc_esg.balanceOf(msg.sender) >= quantity \r\n    assert self.kill_time == 0\r\n\r\n    # Staking minimum\r\n    assert quantity >= 10 ** 18 \r\n\r\n    self.npc_esg.transferFrom(msg.sender, self, quantity)\r\n    self.steaked_coin[msg.sender] += quantity\r\n\r\n    self._add_to_steaked_users(msg.sender)\r\n    self._store_recent_rewards(msg.sender)\r\n\r\n\r\n@external\r\ndef withdraw():\r\n    \"\"\"\r\n    @notice Withdraw accrued $THING and NPCs\r\n    \"\"\"\r\n    self._withdraw(msg.sender, msg.sender)\r\n\r\n\r\n@external\r\ndef wrap():\r\n    \"\"\"\r\n    @notice Wrap all steaked NPCs into esgNPCs\r\n    \"\"\"\r\n    self._wrap_for_user(msg.sender)\r\n    self._store_recent_rewards(msg.sender)\r\n\r\n\r\n@external\r\ndef withdraw_wrapped():\r\n    \"\"\"\r\n    @notice Wrap NPC to esgNPC, then withdraw all\r\n    \"\"\"\r\n    self._wrap_for_user(msg.sender)\r\n    self._withdraw(msg.sender, msg.sender)\r\n\r\n\r\n@external\r\ndef withdraw_rewards():\r\n    \"\"\"\r\n    @notice Withdraw accrued $THING rewards, but stay steaked\r\n    \"\"\"\r\n    self._withdraw_rewards(msg.sender)\r\n\r\n\r\n\r\n#######################################################################################\r\n# \ud83d\udd12 ADMIN FUNCTIONS                                                                  #\r\n#######################################################################################\r\n\r\n@external\r\ndef admin_trigger_epoch(current_thing: String[256]):\r\n    \"\"\"\r\n    @notice Admin function to set epoch\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    self._close_epoch_rewards()\r\n    self.thing.new_current_thing(current_thing)\r\n\r\n\r\n@external\r\ndef admin_shutdown():\r\n    \"\"\"\r\n    @notice Admin function to stop streaming\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    self.kill_time = block.number + 6 * 60 * 24 * 7  # Kill time kicked to future\r\n    self.inflation_rate = 0\r\n    self._close_epoch_rewards()\r\n\r\n\r\n@external\r\ndef admin_set_inflation(new_rate: uint256):\r\n    \"\"\"\r\n    @notice Admin function to stop streaming\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    self._close_epoch_rewards()\r\n    self.inflation_rate = new_rate\r\n\r\n\r\n@external\r\ndef admin_force_withdraw(from_user: address, to_user: address):\r\n    \"\"\"\r\n    @notice Allow admin to force claim for user after kill\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time \r\n\r\n    self._withdraw(from_user, to_user)\r\n\r\n\r\n@external\r\ndef admin_force_transfer_nft(npc_id: uint256):\r\n    \"\"\"\r\n    @notice Admin function to claim an NFT\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time\r\n    self.npc_nft.transferFrom(self, self.owner, npc_id)\r\n\r\n\r\n@external\r\ndef admin_force_transfer_coin(bal: uint256):\r\n    \"\"\"\r\n    @notice Admin function to claim an NFT\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time\r\n    self.npc_esg.transfer(self.owner, bal)\r\n\r\n\r\n@external\r\ndef admin_reclaim_erc20(addr: address, bal: uint256):\r\n    \"\"\"\r\n    @notice Admin function to claim ERC20 tokens accidentally sent to contract\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time\r\n    ERC20(addr).transfer(self.owner, bal)\r\n\r\n\r\n@external\r\ndef admin_reclaim_erc721(addr: address, id: uint256):\r\n    \"\"\"\r\n    @notice Admin function to claim an NFT accidentally sent to contract\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time\r\n    ERC721(addr).transferFrom(self, self.owner, id)\r\n\r\n\r\n@external\r\ndef admin_transfer_owner(new_owner: address):\r\n    \"\"\"\r\n    @notice Allow admin to force claim of ERC20 tokens after contract kill cooldown\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    self.owner = new_owner \r\n\r\n\r\n@external\r\ndef admin_approve_operator(operator: address):\r\n    assert msg.sender == self.owner\r\n    assert block.number > self.kill_time\r\n    \r\n    self.npc_nft.setApprovalForAll(operator, True)\r\n\r\n\r\n########################################################################################\r\n# \ud83d\udd27 INTERNAL FUNCTIONS                                                                #\r\n########################################################################################\r\n\r\n# \ud83d\udc40 VIEWS\r\n\r\n@internal\r\n@view\r\ndef _nft_balance_of(user: address) -> uint256:\r\n    \"\"\"\r\n    @dev Number of unwrapped NFTs steaked by a user\r\n    \"\"\"\r\n    return(len(self.steaked_nfts[user]))\r\n\r\n\r\n@internal\r\n@view\r\ndef _current_epoch() -> uint256:\r\n    \"\"\"\r\n    @dev Each new \"Current Thing\" advances the epoch incrementer by 1\r\n    \"\"\"\r\n    return self.thing.current_epoch()\r\n\r\n\r\n# \ud83e\udd69 STEAKING LOGIC\r\n\r\n@internal\r\n@view\r\ndef _calc_avg_multiplier(user: address, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev For user in a given epoch, calculate the average multiplier for all steaked, unwrapped NPCs, no units\r\n    \"\"\"\r\n\r\n    # Sum up all multipliers for all NPCs\r\n    adder: uint256 = 0\r\n    for i in range(6000):\r\n        if i >= len(self.steaked_nfts[user]):\r\n            break\r\n        adder += self._calc_multiplier(self.steaked_nfts[user][i] , epoch)\r\n   \r\n    # Divide by bonus for staking a higher quantity\r\n    retval: uint256 = 0\r\n    if self._nft_balance_of(user) > 0:\r\n        retval = self._bulk_bonus(self._nft_balance_of(user)) * adder / self._nft_balance_of(user) \r\n    return retval\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_avg_coin_multiplier(bal: uint256, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Return the multiplier for a quantity of steaked, wrapped ESG-NPCs\r\n    \"\"\"\r\n    adder: uint256 = 0\r\n    for i in range(10):\r\n        adder += self._calc_multiplier(i, epoch) \r\n\r\n    # Returns sqrt 10 ** 18 == 10 ** 9, times 10 iterations\r\n    return adder * self._bulk_bonus(bal) / 10 ** 10\r\n\r\n\r\n@internal\r\n@view\r\ndef _bulk_bonus(quantity: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Bonus for staking a larger number of NPCs\r\n    \"\"\"\r\n    return isqrt(quantity * 10 ** 18 * 10 ** 18)\r\n\r\n\r\n@internal\r\n@view\r\ndef _curr_weight_for_user(user: address) -> uint256:\r\n    \"\"\"\r\n    @dev Total weight for user's wrapped and unwrapped NPCs\r\n    \"\"\"\r\n\r\n    _nft_weight: uint256 = 0\r\n\r\n    # Unwrapped NPCs \r\n    if self._nft_balance_of(user) > 0:\r\n        _nft_weight += self._nft_balance_of(user) * self._calc_avg_multiplier(user, self._current_epoch())\r\n\r\n    # Wrapped NPCs\r\n    _coin_weight: uint256 = self.steaked_coin[user] * self._calc_avg_coin_multiplier(self.steaked_coin[user], self._current_epoch()) / 10 ** 18\r\n\r\n    return _nft_weight + _coin_weight    \r\n\r\n\r\n# \ud83d\udcb0 REWARDS\r\n\r\n@internal\r\n@view\r\ndef _recent_rewards(user: address) -> uint256:\r\n    \"\"\"\r\n    @dev Rewards accrued since user last hit a checkpoint\r\n    \"\"\"\r\n    blocks: uint256 = block.number - self.period_user_start[user]\r\n    return blocks * self._curr_weight_for_user(user) * self.inflation_rate  / 10 ** 18\r\n\r\n\r\n@internal\r\n@view\r\ndef _reward_balance(addr: address) -> uint256:\r\n    \"\"\"\r\n    @dev Current user balance is rewards cachd at checkpoint plus uncached rewards\r\n    \"\"\"\r\n    return self.finalized_rewards[addr] + self._recent_rewards(addr)\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_multiplier(id: uint256, epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Function to calculate a pseudorandom, deterministic multiplier for an NPC in any epoch, Poisson distribution\r\n    \"\"\"\r\n    hash: bytes32 = keccak256( concat(convert(id, bytes32), convert(epoch, bytes32) ))\r\n\r\n    ret_val: uint256 = 1\r\n    for i in range(10):\r\n        if convert(slice(hash,i,1), uint256) < 20:\r\n            ret_val += 1\r\n\r\n    return ret_val \r\n\r\n\r\n# \ud83d\udcbe STATE MODIFYING\r\n\r\n@internal\r\ndef _withdraw(user: address, to_user: address):\r\n    \"\"\"\r\n    @dev Withdraw all NPCs\r\n    \"\"\"\r\n    # Withdraw NPCs\r\n    if len(self.steaked_nfts[user]) > 0:\r\n        nfts: DynArray[uint256, 6000] = self.steaked_nfts[user]\r\n        for i in nfts:\r\n            self.npc_nft.transferFrom(self, to_user, i)\r\n\r\n    # Withdraw Wrapped NPCs\r\n    if self.steaked_coin[user] > 0:\r\n        self.npc_esg.transfer(to_user, self.steaked_coin[user])\r\n\r\n    # Withdraw $THING\r\n    self._withdraw_rewards(user)\r\n    self._clear_staking(user)\r\n\r\n\r\n@internal\r\ndef _wrap_for_user(user: address):\r\n    \"\"\"\r\n    @dev Wrap user's NPC into wrapped ESG-NPCs\r\n    \"\"\"\r\n    _bal: uint256 = 0\r\n    for i in range(6000):\r\n        if i >= len(self.steaked_nfts[user]):\r\n            break\r\n        self.npc_esg.wrap([self.steaked_nfts[user][i]])\r\n        _bal += 10 ** 18\r\n    self.steaked_nfts[user] = []\r\n    self.steaked_coin[user] += _bal\r\n\r\n\r\n@internal\r\ndef _withdraw_rewards(user: address):\r\n    \"\"\"\r\n    @dev Close out user position\r\n    \"\"\"\r\n    qty: uint256 = self.steaked_coin[user] + self._reward_balance(user)\r\n    contract_balance : uint256 = self.thing.balanceOf(self)\r\n    if qty < contract_balance:\r\n        self.thing.transfer(user, qty)\r\n    else:\r\n        self.thing.mint(user, qty - contract_balance)\r\n        self.thing.transfer(user, contract_balance)\r\n\r\n    self.period_user_start[user] = block.number\r\n    self.finalized_rewards[user] = 0\r\n\r\n\r\n@internal\r\ndef _add_to_steaked_users(user: address):\r\n    \"\"\"\r\n    @dev Add a user to the index of steaked users\r\n    \"\"\"\r\n    if user not in self.steaked_users:\r\n        self.steaked_users.append(user)\r\n\r\n\r\n@internal\r\ndef _remove_from_steaked_users(user: address):\r\n    \"\"\"\r\n    @dev Remove a user from index of steaked users\r\n    \"\"\"\r\n    assert user != empty(address)\r\n    assert user in self.steaked_users\r\n\r\n    temp_array: DynArray[address, 6000] = []\r\n\r\n    for cur_user in self.steaked_users:\r\n        if cur_user != user:\r\n            temp_array.append(cur_user)\r\n\r\n    self.steaked_users = temp_array\r\n\r\n\r\n@internal\r\ndef _store_recent_rewards(user: address):\r\n    \"\"\"\r\n    @dev Set user checkpoint for rewards period\r\n    \"\"\"\r\n    if self.period_user_start[user] > 0:\r\n        self.finalized_rewards[user] += self._recent_rewards(user) \r\n\r\n    # Update weights\r\n    self.period_user_start[user] = block.number\r\n\r\n\r\n@internal\r\ndef _close_epoch_rewards():\r\n    \"\"\"\r\n    @dev When writing a new current thing, set new checkpoints for all users (expensivo)\r\n    \"\"\"\r\n    for i in self.steaked_users: \r\n        self._store_recent_rewards(i)\r\n\r\n\r\n@internal\r\ndef _clear_staking(addr: address):\r\n    \"\"\"\r\n    @dev Close out a user's position\r\n    \"\"\"\r\n    self.steaked_coin[addr] = 0\r\n    self.steaked_nfts[addr] = []\r\n    self._remove_from_steaked_users(addr)", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"npc_nft\",\"type\":\"address\"},{\"name\":\"npc_esg\",\"type\":\"address\"},{\"name\":\"thing\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"current_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balance_nft\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balance_esg\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_balance\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_uncached\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_multiplier\",\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_avg_multiplier_nft\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_avg_multiplier_esg\",\"inputs\":[{\"name\":\"bal\",\"type\":\"uint256\"},{\"name\":\"epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bulk_bonus\",\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"current_rate_for_user\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"steak_npc\",\"inputs\":[{\"name\":\"nft_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"steak_esg_npc\",\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"wrap\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_wrapped\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_rewards\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_trigger_epoch\",\"inputs\":[{\"name\":\"current_thing\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_shutdown\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_set_inflation\",\"inputs\":[{\"name\":\"new_rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_force_withdraw\",\"inputs\":[{\"name\":\"from_user\",\"type\":\"address\"},{\"name\":\"to_user\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_force_transfer_nft\",\"inputs\":[{\"name\":\"npc_id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_force_transfer_coin\",\"inputs\":[{\"name\":\"bal\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_reclaim_erc20\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"bal\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_reclaim_erc721\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_transfer_owner\",\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"admin_approve_operator\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"npc_nft\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"npc_esg\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"thing\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"steaked_nfts\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"steaked_coin\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"steaked_users\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_user_start\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"finalized_rewards\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"kill_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000a5ea010a46eae77bd20eee754f6d15320358dfd800000000000000000000000066e9b35be6c529a68622531bbc169733f73b8eca0000000000000000000000002c9084e65d046146d6cfc26bf45f5b80042b90eb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}