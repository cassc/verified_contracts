{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title AggMonetaryPolicy - monetary policy based on aggregated prices for crvUSD\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n\"\"\"\r\n\r\ninterface PegKeeper:\r\n    def debt() -> uint256: view\r\n\r\ninterface PriceOracle:\r\n    def price() -> uint256: view\r\n    def price_w() -> uint256: nonpayable\r\n\r\ninterface ControllerFactory:\r\n    def total_debt() -> uint256: view\r\n    def debt_ceiling(_for: address) -> uint256: view\r\n\r\ninterface Controller:\r\n    def total_debt() -> uint256: view\r\n\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\nevent AddPegKeeper:\r\n    peg_keeper: indexed(address)\r\n\r\nevent RemovePegKeeper:\r\n    peg_keeper: indexed(address)\r\n\r\nevent SetRate:\r\n    rate: uint256\r\n\r\nevent SetSigma:\r\n    sigma: uint256\r\n\r\nevent SetTargetDebtFraction:\r\n    target_debt_fraction: uint256\r\n\r\n\r\nadmin: public(address)\r\n\r\nrate0: public(uint256)\r\nsigma: public(int256)  # 2 * 10**16 for example\r\ntarget_debt_fraction: public(uint256)\r\n\r\npeg_keepers: public(PegKeeper[1001])\r\nPRICE_ORACLE: public(immutable(PriceOracle))\r\nCONTROLLER_FACTORY: public(immutable(ControllerFactory))\r\n\r\nMAX_TARGET_DEBT_FRACTION: constant(uint256) = 10**18\r\nMAX_SIGMA: constant(uint256) = 10**18\r\nMIN_SIGMA: constant(uint256) = 10**14\r\nMAX_EXP: constant(uint256) = 1000 * 10**18\r\nMAX_RATE: constant(uint256) = 43959106799  # 300% APY\r\nTARGET_REMAINDER: constant(uint256) = 10**17  # rate is x2 when 10% left before ceiling\r\n\r\n\r\n@external\r\ndef __init__(admin: address,\r\n             price_oracle: PriceOracle,\r\n             controller_factory: ControllerFactory,\r\n             peg_keepers: PegKeeper[5],\r\n             rate: uint256,\r\n             sigma: uint256,\r\n             target_debt_fraction: uint256):\r\n    self.admin = admin\r\n    PRICE_ORACLE = price_oracle\r\n    CONTROLLER_FACTORY = controller_factory\r\n    for i in range(5):\r\n        if peg_keepers[i].address == empty(address):\r\n            break\r\n        self.peg_keepers[i] = peg_keepers[i]\r\n\r\n    assert sigma >= MIN_SIGMA\r\n    assert sigma <= MAX_SIGMA\r\n    assert target_debt_fraction <= MAX_TARGET_DEBT_FRACTION\r\n    assert rate <= MAX_RATE\r\n    self.rate0 = rate\r\n    self.sigma = convert(sigma, int256)\r\n    self.target_debt_fraction = target_debt_fraction\r\n\r\n\r\n@external\r\ndef set_admin(admin: address):\r\n    assert msg.sender == self.admin\r\n    self.admin = admin\r\n    log SetAdmin(admin)\r\n\r\n\r\n@external\r\ndef add_peg_keeper(pk: PegKeeper):\r\n    assert msg.sender == self.admin\r\n    assert pk.address != empty(address)\r\n    for i in range(1000):\r\n        _pk: PegKeeper = self.peg_keepers[i]\r\n        assert _pk != pk, \"Already added\"\r\n        if _pk.address == empty(address):\r\n            self.peg_keepers[i] = pk\r\n            log AddPegKeeper(pk.address)\r\n            break\r\n\r\n\r\n@external\r\ndef remove_peg_keeper(pk: PegKeeper):\r\n    assert msg.sender == self.admin\r\n    replaced_peg_keeper: uint256 = 10000\r\n    for i in range(1001):  # 1001th element is always 0x0\r\n        _pk: PegKeeper = self.peg_keepers[i]\r\n        if _pk == pk:\r\n            replaced_peg_keeper = i\r\n            log RemovePegKeeper(pk.address)\r\n        if _pk.address == empty(address):\r\n            if replaced_peg_keeper < i:\r\n                if replaced_peg_keeper < i - 1:\r\n                    self.peg_keepers[replaced_peg_keeper] = self.peg_keepers[i - 1]\r\n                self.peg_keepers[i - 1] = PegKeeper(empty(address))\r\n            break\r\n\r\n\r\n@internal\r\n@pure\r\ndef exp(power: int256) -> uint256:\r\n    if power <= -42139678854452767551:\r\n        return 0\r\n\r\n    if power >= 135305999368893231589:\r\n        # Return MAX_EXP when we are in overflow mode\r\n        return MAX_EXP\r\n\r\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\r\n\r\n    k: int256 = unsafe_div(\r\n        unsafe_add(\r\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\r\n            2**95),\r\n        2**96)\r\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\r\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\r\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\r\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\r\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\r\n\r\n    q: int256 = x - 2855989394907223263936484059900\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\r\n\r\n    return shift(\r\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\r\n        unsafe_sub(k, 195))\r\n\r\n\r\n@internal\r\n@view\r\ndef calculate_rate(_for: address, _price: uint256) -> uint256:\r\n    sigma: int256 = self.sigma\r\n    target_debt_fraction: uint256 = self.target_debt_fraction\r\n\r\n    p: int256 = convert(_price, int256)\r\n    pk_debt: uint256 = 0\r\n    for pk in self.peg_keepers:\r\n        if pk.address == empty(address):\r\n            break\r\n        pk_debt += pk.debt()\r\n\r\n    power: int256 = (10**18 - p) * 10**18 / sigma  # high price -> negative pow -> low rate\r\n    if pk_debt > 0:\r\n        total_debt: uint256 = CONTROLLER_FACTORY.total_debt()\r\n        if total_debt == 0:\r\n            return 0\r\n        else:\r\n            power -= convert(pk_debt * 10**18 / total_debt * 10**18 / target_debt_fraction, int256)\r\n\r\n    # Rate accounting for crvUSD price and PegKeeper debt\r\n    rate: uint256 = self.rate0 * min(self.exp(power), MAX_EXP) / 10**18\r\n\r\n    # Account for individual debt ceiling to dynamically tune rate depending on filling the market\r\n    ceiling: uint256 = CONTROLLER_FACTORY.debt_ceiling(_for)\r\n    if ceiling > 0:\r\n        f: uint256 = min(Controller(_for).total_debt() * 10**18 / ceiling, 10**18 - TARGET_REMAINDER / 1000)\r\n        rate = min(rate * ((10**18 - TARGET_REMAINDER) + TARGET_REMAINDER * 10**18 / (10**18 - f)) / 10**18, MAX_RATE)\r\n\r\n    return rate\r\n\r\n\r\n@view\r\n@external\r\ndef rate(_for: address = msg.sender) -> uint256:\r\n    return self.calculate_rate(_for, PRICE_ORACLE.price())\r\n\r\n\r\n@external\r\ndef rate_write(_for: address = msg.sender) -> uint256:\r\n    # Not needed here but useful for more automated policies\r\n    # which change rate0 - for example rate0 targeting some fraction pl_debt/total_debt\r\n    return self.calculate_rate(_for, PRICE_ORACLE.price_w())\r\n\r\n\r\n@external\r\ndef set_rate(rate: uint256):\r\n    assert msg.sender == self.admin\r\n    assert rate <= MAX_RATE\r\n    self.rate0 = rate\r\n    log SetRate(rate)\r\n\r\n\r\n@external\r\ndef set_sigma(sigma: uint256):\r\n    assert msg.sender == self.admin\r\n    assert sigma >= MIN_SIGMA\r\n    assert sigma <= MAX_SIGMA\r\n\r\n    self.sigma = convert(sigma, int256)\r\n    log SetSigma(sigma)\r\n\r\n\r\n@external\r\ndef set_target_debt_fraction(target_debt_fraction: uint256):\r\n    assert msg.sender == self.admin\r\n    assert target_debt_fraction <= MAX_TARGET_DEBT_FRACTION\r\n\r\n    self.target_debt_fraction = target_debt_fraction\r\n    log SetTargetDebtFraction(target_debt_fraction)", "ABI": "[{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddPegKeeper\",\"inputs\":[{\"name\":\"peg_keeper\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemovePegKeeper\",\"inputs\":[{\"name\":\"peg_keeper\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetSigma\",\"inputs\":[{\"name\":\"sigma\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTargetDebtFraction\",\"inputs\":[{\"name\":\"target_debt_fraction\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"price_oracle\",\"type\":\"address\"},{\"name\":\"controller_factory\",\"type\":\"address\"},{\"name\":\"peg_keepers\",\"type\":\"address[5]\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"sigma\",\"type\":\"uint256\"},{\"name\":\"target_debt_fraction\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_peg_keeper\",\"inputs\":[{\"name\":\"pk\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_peg_keeper\",\"inputs\":[{\"name\":\"pk\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_sigma\",\"inputs\":[{\"name\":\"sigma\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_target_debt_fraction\",\"inputs\":[{\"name\":\"target_debt_fraction\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate0\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"sigma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"target_debt_fraction\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"peg_keepers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"PRICE_ORACLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"CONTROLLER_FACTORY\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "AggMonetaryPolicy - monetary policy based on aggregated prices for crvUSD", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000040907540d8a6c65c637785e8f8b742ae6b0b9968000000000000000000000000e5afcf332a5457e8fafcd668bce3df953762dfe7000000000000000000000000c9332fdcb1c491dcc683bae86fe3cb70360738bc000000000000000000000000aa346781ddd7009caa644a4980f044c50cd2ae22000000000000000000000000e7cd2b4eb1d98cd6a4a48b6071d46401ac7dc5c80000000000000000000000006b765d07cf966c745b340adca67749fe75b5c3450000000000000000000000001ef89ed0edd93d1ec09e4c07373f69c49f4dccae0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006e21962500000000000000000000000000000000000000000000000000470de4df820000000000000000000000000000000000000000000000000000016345785d8a0000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}