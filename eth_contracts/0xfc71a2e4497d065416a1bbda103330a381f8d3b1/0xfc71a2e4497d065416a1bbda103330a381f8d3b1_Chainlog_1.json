{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Chainlog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\n\\nimport {IChainlog} from \\\"src/IChainlog.sol\\\";\\n\\n/**\\n * @title Chainlog\\n *\\n * @notice Chainlog provides a public readable contract registry\\n *\\n * @dev The contract uses the `chronicle-std/Auth` module for access control.\\n *      While the registry is public readable, state mutating functions are only\\n *      callable by auth'ed addresses.\\n */\\ncontract Chainlog is IChainlog, Auth {\\n    struct Location {\\n        uint pos;\\n        address addr;\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    string public version;\\n\\n    /// @inheritdoc IChainlog\\n    string public sha256sum;\\n\\n    /// @inheritdoc IChainlog\\n    string public ipfs;\\n\\n    /// @dev Mapping storing a key's position and address.\\n    /// @custom:invariant Location's `pos` is not mutated after being set.\\n    ///                     \u2200x \u220a bytes32: pos = preTx(_locations[x].pos) \u22c0 pos != 0\\n    ///                         \u2192 postTx(_locations[x].pos == pos)\\n    mapping(bytes32 => Location) private _locations;\\n\\n    /// @dev List of known keys.\\n    /// @custom:invariant Does not contain duplicates.\\n    ///                     \u2200x \u220a bytes32: _keys.count(x) <= 1\\n    /// @custom:invariant Each non-empty key links to an address in _locations.\\n    ///                     \u2200x \u220a bytes32: _keys.count(x) > 0 \u22c0 x != \\\"\\\"\\n    ///                         \u2192 _locations[x].addr != address(0)\\n    /// @custom:invariant Elements may only be added, never deleted or mutated.\\n    ///                     \u2200x \u220a [0, _keys.length-1]:\\n    ///                         preTx(_keys[x]) == postTx(_keys[x])\\n    /// @custom:invariant Zero index links to empty key.\\n    ///                     _keys[0] = \\\"\\\"\\n    bytes32[] private _keys;\\n\\n    constructor(address initialAuthed) Auth(initialAuthed) {\\n        // Let _keys[0] = \\\"\\\";\\n        _keys.push(\\\"\\\");\\n\\n        _setVersion(\\\"0.0.0\\\");\\n        _setAddress(\\\"CHANGELOG\\\", address(this));\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function setVersion(string memory version_) external auth {\\n        _setVersion(version_);\\n    }\\n\\n    function _setVersion(string memory version_) internal {\\n        if (!equal(version, version_)) {\\n            emit VersionUpdated(msg.sender, version, version_);\\n            version = version_;\\n        }\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function setSha256sum(string memory sha256sum_) external auth {\\n        if (!equal(sha256sum, sha256sum_)) {\\n            emit Sha256sumUpdated(msg.sender, sha256sum, sha256sum_);\\n            sha256sum = sha256sum_;\\n        }\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function setIPFS(string memory ipfs_) external auth {\\n        if (!equal(ipfs, ipfs_)) {\\n            emit IPFSUpdated(msg.sender, ipfs, ipfs_);\\n            ipfs = ipfs_;\\n        }\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function setAddress(bytes32 key, address addr) external auth {\\n        _setAddress(key, addr);\\n    }\\n\\n    function _setAddress(bytes32 key, address addr) internal {\\n        if (key == \\\"\\\") {\\n            revert EmptyKey();\\n        }\\n\\n        // Get reference to key's location instance.\\n        Location storage keyLoc = _locations[key];\\n\\n        // Assign position to key, if key unknown.\\n        if (keyLoc.pos == 0) {\\n            _keys.push(key);\\n            keyLoc.pos = _keys.length - 1;\\n        }\\n\\n        // Update key's address, if necessary.\\n        if (keyLoc.addr != addr) {\\n            emit AddressUpdated(msg.sender, key, keyLoc.addr, addr);\\n            keyLoc.addr = addr;\\n        }\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function get(bytes32 key) external view returns (address) {\\n        if (!exists(key)) {\\n            revert UnknownKey(key);\\n        }\\n\\n        return _locations[key].addr;\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function tryGet(bytes32 key) external view returns (bool, address) {\\n        if (exists(key)) {\\n            return (true, _locations[key].addr);\\n        } else {\\n            return (false, address(0));\\n        }\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    /// @custom:invariant Contains every key for which a non-zero address is set.\\n    ///                     \u2200x \u220a _keys: _locations[x].addr != address(0)\\n    ///                         \u2192 x \u220a list()\\n    function list() public view returns (bytes32[] memory) {\\n        // Initiate array with upper limit length.\\n        bytes32[] memory keys = new bytes32[](_keys.length);\\n\\n        // Iterate through all known keys.\\n        uint ctr;\\n        for (uint i; i < keys.length; i++) {\\n            // Add key only if key still exists.\\n            if (exists(_keys[i])) {\\n                keys[ctr++] = _keys[i];\\n            }\\n        }\\n\\n        // Set length of array to number of keys actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(keys, ctr)\\n        }\\n\\n        return keys;\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    /// @custom:invariant Equals list() if start is zero and size big enough to\\n    ///                   hold all keys.\\n    ///                     start = 0 \u22c0 size >= _keys.length\\n    ///                         \u2192 list(start, size) == list()\\n    function list(uint start, uint size)\\n        external\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        // Initiate array with upper limit length.\\n        bytes32[] memory keys = new bytes32[](size);\\n\\n        // Iterate over up to size known keys, starting at start.\\n        uint ctr;\\n        uint i = start;\\n        while (i <= start + size && i < _keys.length) {\\n            // Add key only if key still exists.\\n            if (exists(_keys[i])) {\\n                keys[ctr++] = _keys[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        // Set length of array to number of keys actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(keys, ctr)\\n        }\\n\\n        return keys;\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    /// @custom:invariant Equals the number of keys returned via list().\\n    ///                     count() == list().length\\n    function count() external view returns (uint) {\\n        // Iterate through all known keys.\\n        uint ctr;\\n        for (uint i; i < _keys.length; i++) {\\n            // Increase counter if key exists.\\n            if (exists(_keys[i])) {\\n                ctr++;\\n            }\\n        }\\n\\n        return ctr;\\n    }\\n\\n    /// @inheritdoc IChainlog\\n    function exists(bytes32 key) public view returns (bool) {\\n        return _locations[key].addr != address(0);\\n    }\\n\\n    // -- Helpers --\\n\\n    function equal(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (bytes(a).length != bytes(b).length) {\\n            return false;\\n        } else {\\n            return keccak256(bytes(a)) == keccak256(bytes(b));\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract Chainlog_1 is Chainlog {\\n    constructor(address initialAuthed) Chainlog(initialAuthed) {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IChainlog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IChainlog {\\n    /// @notice Thrown if given key unknown.\\n    /// @param key The unknown key given.\\n    error UnknownKey(bytes32 key);\\n\\n    /// @notice Thrown if empty key given.\\n    error EmptyKey();\\n\\n    /// @notice Emitted when an address updated.\\n    /// @param caller The caller's address.\\n    /// @param key The key of the address updated.\\n    /// @param oldAddr The old address.\\n    /// @param newAddr The new address.\\n    event AddressUpdated(\\n        address indexed caller,\\n        bytes32 indexed key,\\n        address oldAddr,\\n        address newAddr\\n    );\\n\\n    /// @notice Emitted when version identifier updated.\\n    /// @param caller The caller's address.\\n    /// @param oldVersion The old version identifier.\\n    /// @param newVersion The new version identifier.\\n    event VersionUpdated(\\n        address indexed caller, string oldVersion, string newVersion\\n    );\\n\\n    /// @notice Emitted when sha256sum identifier updated.\\n    /// @param caller The caller's address.\\n    /// @param oldSha256sum The old sha256sum identifier.\\n    /// @param newSha256sum The new sha256sum identifier.\\n    event Sha256sumUpdated(\\n        address indexed caller, string oldSha256sum, string newSha256sum\\n    );\\n\\n    /// @notice Emitted when IPFS identifier updated.\\n    /// @param caller The caller's address.\\n    /// @param oldIPFS The old ipfs identifier.\\n    /// @param newIPFS The new ipfs identifier.\\n    event IPFSUpdated(address indexed caller, string oldIPFS, string newIPFS);\\n\\n    /// @notice Updates `key'`s address to `addr`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param key The key to update.\\n    /// @param addr The address to set for `key`.\\n    function setAddress(bytes32 key, address addr) external;\\n\\n    /// @notice Updates version identifier to `version`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param version The value to update version to.\\n    function setVersion(string memory version) external;\\n\\n    /// @notice Updates sha256sum identifier to `sha256sum`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param sha256sum The value to update sha256sum to.\\n    function setSha256sum(string memory sha256sum) external;\\n\\n    /// @notice Updates IPFS identifier to `ipfs`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param ipfs The value to update ipfs to.\\n    function setIPFS(string memory ipfs) external;\\n\\n    /// @notice Returns the address set for key `key`.\\n    /// @dev Reverts if key unknown.\\n    /// @param key The key to return its address.\\n    function get(bytes32 key) external view returns (address);\\n\\n    /// @notice Returns the address set for key `key`.\\n    /// @param key The key to return its address.\\n    /// @return True if key `key` exists, false otherwise.\\n    /// @return The address of key `key` if `key` exists, zero address\\n    ///         otherwise.\\n    function tryGet(bytes32 key) external view returns (bool, address);\\n\\n    /// @notice Returns the list of keys for which a non-zero address is set.\\n    /// @dev May reverts if number of keys is too large.\\n    ///      If so, use list(uint,uint)(bytes32) to read keys in pages.\\n    /// @return The list existing keys.\\n    function list() external view returns (bytes32[] memory);\\n\\n    /// @notice Returns the paginated list of keys starting with index `start`\\n    ///         and maximum size `size`.\\n    /// @dev Use this function to read keys paginated.\\n    /// @return The list of existing keys, paginated via `start` and `size`.\\n    function list(uint start, uint size)\\n        external\\n        view\\n        returns (bytes32[] memory);\\n\\n    /// @notice Returns the number of keys existing.\\n    /// @return The number of keys existing.\\n    function count() external view returns (uint);\\n\\n    /// @notice Returns whether key `key` exists.\\n    /// @return True if key `key` exists, false otherwise.\\n    function exists(bytes32 key) external view returns (bool);\\n\\n    /// @notice Returns the chainlog's version identifier.\\n    /// @return The chainlog's version identifier.\\n    function version() external view returns (string memory);\\n\\n    /// @notice Returns the chainlog's sha256sum identifier.\\n    /// @return The chainlog's sha256sum identifier.\\n    function sha256sum() external view returns (string memory);\\n\\n    /// @notice Returns the chainlog's IPFS identifier.\\n    /// @return The chainlog's IPFS identifier.\\n    function ipfs() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmptyKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"UnknownKey\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"AddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldIPFS\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newIPFS\",\"type\":\"string\"}],\"name\":\"IPFSUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldSha256sum\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newSha256sum\",\"type\":\"string\"}],\"name\":\"Sha256sumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldVersion\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newVersion\",\"type\":\"string\"}],\"name\":\"VersionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ipfs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ipfs_\",\"type\":\"string\"}],\"name\":\"setIPFS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"sha256sum_\",\"type\":\"string\"}],\"name\":\"setSha256sum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version_\",\"type\":\"string\"}],\"name\":\"setVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sha256sum\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"tryGet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Chainlog_1", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}