{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WETHGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport { Ownable } from \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"./base/ErrorMessages.sol\\\";\\nimport \\\"./interfaces/IZeroLiquid.sol\\\";\\nimport \\\"./interfaces/external/IWETH9.sol\\\";\\nimport \\\"./interfaces/IWETHGateway.sol\\\";\\n\\n/// @title  WETHGateway\\n/// @author ZeroLiquid\\ncontract WETHGateway is IWETHGateway, Ownable {\\n    /// @notice The version.\\n    string public constant version = \\\"1.0.0\\\";\\n\\n    /// @notice The wrapped ethereum contract.\\n    IWETH9 public immutable WETH;\\n\\n    constructor(address weth) {\\n        WETH = IWETH9(weth);\\n    }\\n\\n    /// @dev Allows for payments from the WETH contract.\\n    receive() external payable {\\n        if (IWETH9(msg.sender) != WETH) {\\n            revert Unauthorized(\\\"msg.sender is not WETH contract\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc IWETHGateway\\n    function refreshAllowance(address zeroliquid) external onlyOwner {\\n        WETH.approve(zeroliquid, type(uint256).max);\\n    }\\n\\n    /// @inheritdoc IWETHGateway\\n    function depositUnderlying(\\n        address zeroliquid,\\n        address yieldToken,\\n        uint256 amount,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        payable\\n    {\\n        if (amount != msg.value) {\\n            revert IllegalArgument(\\\"Invalid deposit amount\\\");\\n        }\\n        WETH.deposit{ value: msg.value }();\\n        IZeroLiquid(zeroliquid).depositUnderlying(yieldToken, amount, recipient, minimumAmountOut);\\n    }\\n\\n    /// @inheritdoc IWETHGateway\\n    function withdrawUnderlying(\\n        address zeroliquid,\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n    {\\n        // Ensure that the underlying of the target yield token is in fact WETH\\n        IZeroLiquid.YieldTokenParams memory params = IZeroLiquid(zeroliquid).getYieldTokenParameters(yieldToken);\\n        if (params.underlyingToken != address(WETH)) {\\n            revert IllegalArgument(\\\"Token is not WETH contract\\\");\\n        }\\n\\n        IZeroLiquid(zeroliquid).withdrawUnderlyingFrom(msg.sender, yieldToken, shares, address(this), minimumAmountOut);\\n\\n        uint256 amount = WETH.balanceOf(address(this));\\n        WETH.withdraw(amount);\\n\\n        (bool success,) = recipient.call{ value: amount }(new bytes(0));\\n        if (!success) {\\n            revert IllegalState(\\\"Unsuccessful withdrawal\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/base/ErrorMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\n/// @notice An error used to indicate that an argument passed to a function is illegal or\\n///         inappropriate.\\n///\\n/// @param message The error message.\\nerror IllegalArgument(string message);\\n\\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\\n///\\n/// @param message The error message.\\nerror IllegalState(string message);\\n\\n/// @notice An error used to indicate that an operation is unsupported.\\n///\\n/// @param message The error message.\\nerror UnsupportedOperation(string message);\\n\\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\\n///\\n/// @param message The error message.\\nerror Unauthorized(string message);\\n\"\r\n    },\r\n    \"src/interfaces/IZeroLiquid.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"./zeroliquid/IZeroLiquidActions.sol\\\";\\nimport \\\"./zeroliquid/IZeroLiquidAdminActions.sol\\\";\\nimport \\\"./zeroliquid/IZeroLiquidErrors.sol\\\";\\nimport \\\"./zeroliquid/IZeroLiquidImmutables.sol\\\";\\nimport \\\"./zeroliquid/IZeroLiquidEvents.sol\\\";\\nimport \\\"./zeroliquid/IZeroLiquidState.sol\\\";\\n\\n/// @title  IZeroLiquid\\n/// @author ZeroLiquid\\ninterface IZeroLiquid is\\n    IZeroLiquidActions,\\n    IZeroLiquidAdminActions,\\n    IZeroLiquidErrors,\\n    IZeroLiquidImmutables,\\n    IZeroLiquidEvents,\\n    IZeroLiquidState\\n{ }\\n\"\r\n    },\r\n    \"src/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../IERC20Metadata.sol\\\";\\n\\n/// @title IWETH9\\ninterface IWETH9 is IERC20, IERC20Metadata {\\n    /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\\n    function deposit() external payable;\\n\\n    /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\\n    ///\\n    /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\\n    ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\\n    ///\\n    /// @param amount The amount of tokens to burn.\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETHGateway.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IWETHGateway\\n/// @author ZeroLiquid\\ninterface IWETHGateway {\\n    /// @notice Refreshes the wrapped ethereum ERC20 approval for an zeroliquid contract.\\n    ///\\n    /// @param zeroliquid The address of the zeroliquid to refresh the allowance for.\\n    function refreshAllowance(address zeroliquid) external;\\n\\n    /// @notice Takes ethereum, converts it to wrapped ethereum, and then deposits it into an zeroliquid.\\n    ///\\n    /// See [IZeroLiquidActions.depositUnderlying](./zeroliquid/IZeroLiquidActions.md#depositunderlying) for more\\n    /// details.\\n    ///\\n    /// @param zeroliquid        The address of the zeroliquid to deposit wrapped ethereum into.\\n    /// @param yieldToken       The yield token to deposit the wrapped ethereum as.\\n    /// @param amount           The amount of ethereum to deposit.\\n    /// @param recipient        The address which will receive the deposited yield tokens.\\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be deposited to `recipient`.\\n    function depositUnderlying(\\n        address zeroliquid,\\n        address yieldToken,\\n        uint256 amount,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        payable;\\n\\n    /// @notice Withdraws a wrapped ethereum based yield token from an zeroliquid, converts it to ethereum, and then\\n    ///         transfers it to the recipient.\\n    ///\\n    /// A withdraw approval on the zeroliquid is required for this call to succeed.\\n    ///\\n    /// See [IZeroLiquidActions.withdrawUnderlying](./zeroliquid/IZeroLiquidActions.md#withdrawunderlying) for more\\n    /// details.\\n    ///\\n    /// @param zeroliquid        The address of the zeroliquid to withdraw wrapped ethereum from.\\n    /// @param yieldToken       The address of the yield token to withdraw.\\n    /// @param shares           The amount of shares to withdraw.\\n    /// @param recipient        The address which will receive the ethereum.\\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be withdrawn to\\n    /// `recipient`.\\n    function withdrawUnderlying(\\n        address zeroliquid,\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidActions.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidActions\\n/// @author ZeroLiquid\\n///\\n/// @notice Specifies user actions.\\ninterface IZeroLiquidActions {\\n    /// @notice Approve `spender` to mint `amount` debt tokens.\\n    ///\\n    ///\\n    /// @param spender The address that will be approved to mint.\\n    /// @param amount  The amount of tokens that `spender` will be allowed to mint.\\n    function approveMint(address spender, uint256 amount) external;\\n\\n    /// @notice Approve `spender` to withdraw `amount` shares of `yieldToken`.\\n    ///\\n    ///\\n    /// @param spender    The address that will be approved to withdraw.\\n    /// @param yieldToken The address of the yield token that `spender` will be allowed to withdraw.\\n    /// @param shares     The amount of shares that `spender` will be allowed to withdraw.\\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external;\\n\\n    /// @notice Synchronizes the state of the account owned by `owner`.\\n    ///\\n    /// @param owner The owner of the account to synchronize.\\n    function poke(address owner) external;\\n\\n    /// @notice Deposit a yield token into a user's account.\\n    ///\\n    /// @notice An approval must be set for `yieldToken` which is greater than `amount`.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `yieldToken` must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `yieldToken` underlying token must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or the call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Deposit} event.\\n    ///\\n    ///\\n    /// @notice **_NOTE:_** When depositing, the `ZeroLiquid` contract must have **allowance()** to spend funds on\\n    /// behalf of **msg.sender** for at least **amount** of the **yieldToken** being deposited.  This can be done via\\n    /// the standard `ERC20.approve()` method.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 amount = 50000;\\n    /// @notice IERC20(wstETH).approve(ZeroLiquidAddress, amount);\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).deposit(wstETH, amount, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken The yield-token to deposit.\\n    /// @param amount     The amount of yield tokens to deposit.\\n    /// @param recipient  The owner of the account that will receive the resulting shares.\\n    ///\\n    /// @return sharesIssued The number of shares issued to `recipient`.\\n    function deposit(address yieldToken, uint256 amount, address recipient) external returns (uint256 sharesIssued);\\n\\n    /// @notice Deposit an underlying token into the account of `recipient` as `yieldToken`.\\n    ///\\n    /// @notice An approval must be set for the underlying token of `yieldToken` which is greater than `amount`.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or the call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Deposit} event.\\n    ///\\n    /// @notice **_NOTE:_** When depositing, the `ZeroLiquid` contract must have **allowance()** to spend funds on\\n    /// behalf of **msg.sender** for at least **amount** of the **underlyingToken** being deposited.  This can be done\\n    /// via the standard `ERC20.approve()` method.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 amount = 50000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).depositUnderlying(wstETH, amount, msg.sender, 1);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\\n    /// @param amount           The amount of the underlying token to deposit.\\n    /// @param recipient        The address of the recipient.\\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be deposited to `recipient`.\\n    ///\\n    /// @return sharesIssued The number of shares issued to `recipient`.\\n    function depositUnderlying(\\n        address yieldToken,\\n        uint256 amount,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        returns (uint256 sharesIssued);\\n\\n    /// @notice Withdraw yield tokens to `recipient` by burning `share` shares. The number of yield tokens withdrawn to\\n    /// `recipient` will depend on the value of shares for that yield token at the time of the call.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Withdraw} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 pps = ZeroLiquid(ZeroLiquidAddress).getYieldTokensPerShare(wstETH);\\n    /// @notice uint256 amtYieldTokens = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).withdraw(wstETH, amtYieldTokens / pps, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken The address of the yield token to withdraw.\\n    /// @param shares     The number of shares to burn.\\n    /// @param recipient  The address of the recipient.\\n    ///\\n    /// @return amountWithdrawn The number of yield tokens that were withdrawn to `recipient`.\\n    function withdraw(\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient\\n    )\\n        external\\n        returns (uint256 amountWithdrawn);\\n\\n    /// @notice Withdraw yield tokens to `recipient` by burning `share` shares from the account of `owner`\\n    ///\\n    /// @notice `owner` must have an withdrawal allowance which is greater than `amount` for this call to succeed.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Withdraw} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 pps = ZeroLiquid(ZeroLiquidAddress).getYieldTokensPerShare(wstETH);\\n    /// @notice uint256 amtYieldTokens = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).withdrawFrom(msg.sender, wstETH, amtYieldTokens / pps, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param owner      The address of the account owner to withdraw from.\\n    /// @param yieldToken The address of the yield token to withdraw.\\n    /// @param shares     The number of shares to burn.\\n    /// @param recipient  The address of the recipient.\\n    ///\\n    /// @return amountWithdrawn The number of yield tokens that were withdrawn to `recipient`.\\n    function withdrawFrom(\\n        address owner,\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient\\n    )\\n        external\\n        returns (uint256 amountWithdrawn);\\n\\n    /// @notice Withdraw underlying tokens to `recipient` by burning `share` shares and unwrapping the yield tokens that\\n    /// the shares were redeemed for.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice The loss in expected value of `yieldToken` must be less than the maximum permitted by the system or this\\n    /// call will revert with a {LossExceeded} error.\\n    ///\\n    /// @notice Emits a {Withdraw} event.\\n    ///\\n    /// @notice **_NOTE:_** The caller of `withdrawFrom()` must have **withdrawAllowance()** to withdraw funds on behalf\\n    /// of **owner** for at least the amount of `yieldTokens` that **shares** will be converted to.  This can be done\\n    /// via the `approveWithdraw()` or `permitWithdraw()` methods.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 pps = ZeroLiquid(ZeroLiquidAddress).getUnderlyingTokensPerShare(wstETH);\\n    /// @notice uint256 amountUnderlyingTokens = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).withdrawUnderlying(wstETH, amountUnderlyingTokens / pps, msg.sender, 1);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken       The address of the yield token to withdraw.\\n    /// @param shares           The number of shares to burn.\\n    /// @param recipient        The address of the recipient.\\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be withdrawn to\\n    /// `recipient`.\\n    ///\\n    /// @return amountWithdrawn The number of underlying tokens that were withdrawn to `recipient`.\\n    function withdrawUnderlying(\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        returns (uint256 amountWithdrawn);\\n\\n    /// @notice Withdraw underlying tokens to `recipient` by burning `share` shares from the account of `owner` and\\n    /// unwrapping the yield tokens that the shares were redeemed for.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice The loss in expected value of `yieldToken` must be less than the maximum permitted by the system or this\\n    /// call will revert with a {LossExceeded} error.\\n    ///\\n    /// @notice Emits a {Withdraw} event.\\n    ///\\n    /// @notice **_NOTE:_** The caller of `withdrawFrom()` must have **withdrawAllowance()** to withdraw funds on behalf\\n    /// of **owner** for at least the amount of `yieldTokens` that **shares** will be converted to.  This can be done\\n    /// via the `approveWithdraw()` or `permitWithdraw()` methods.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 pps = ZeroLiquid(ZeroLiquidAddress).getUnderlyingTokensPerShare(wstETH);\\n    /// @notice uint256 amtUnderlyingTokens = 5000 * 10**wstETH.decimals();\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).withdrawUnderlying(msg.sender, wstETH, amtUnderlyingTokens / pps,\\n    /// msg.sender, 1);\\n    /// @notice ```\\n    ///\\n    /// @param owner            The address of the account owner to withdraw from.\\n    /// @param yieldToken       The address of the yield token to withdraw.\\n    /// @param shares           The number of shares to burn.\\n    /// @param recipient        The address of the recipient.\\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be withdrawn to\\n    /// `recipient`.\\n    ///\\n    /// @return amountWithdrawn The number of underlying tokens that were withdrawn to `recipient`.\\n    function withdrawUnderlyingFrom(\\n        address owner,\\n        address yieldToken,\\n        uint256 shares,\\n        address recipient,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        returns (uint256 amountWithdrawn);\\n\\n    /// @notice Mint `amount` debt tokens.\\n    ///\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Mint} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice uint256 amtDebt = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).mint(amtDebt, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param amount     The amount of tokens to mint.\\n    /// @param recipient  The address of the recipient.\\n    function mint(uint256 amount, address recipient) external;\\n\\n    /// @notice Mint `amount` debt tokens from the account owned by `owner` to `recipient`.\\n    ///\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Mint} event.\\n    ///\\n    /// @notice **_NOTE:_** The caller of `mintFrom()` must have **mintAllowance()** to mint debt from the `Account`\\n    /// controlled by **owner** for at least the amount of **yieldTokens** that **shares** will be converted to.  This\\n    /// can be done via the `approveMint()` or `permitMint()` methods.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice uint256 amtDebt = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).mintFrom(msg.sender, amtDebt, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param owner      The address of the owner of the account to mint from.\\n    /// @param amount     The amount of tokens to mint.\\n    /// @param recipient  The address of the recipient.\\n    function mintFrom(address owner, uint256 amount, address recipient) external;\\n\\n    /// @notice Burn `amount` debt tokens to credit the account owned by `recipient`.\\n    ///\\n    /// @notice `amount` will be limited up to the amount of debt that `recipient` currently holds.\\n    ///\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    /// @notice `recipient` must have non-zero debt or this call will revert with an {IllegalState} error.\\n    ///\\n    /// @notice Emits a {Burn} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice uint256 amtBurn = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).burn(amtBurn, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param amount     The amount of tokens to burn.\\n    /// @param recipient  The address of the recipient.\\n    ///\\n    /// @return amountBurned The amount of tokens that were burned.\\n    function burn(uint256 amount, address recipient) external returns (uint256 amountBurned);\\n\\n    /// @notice Repay `amount` debt using `underlyingToken` to credit the account owned by `recipient`.\\n    ///\\n    /// @notice `amount` will be limited up to the amount of debt that `recipient` currently holds.\\n    ///\\n    /// @notice `amount` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `underlyingToken` must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `amount` must be less than or equal to the current available repay limit or this call will revert with a\\n    /// {ReplayLimitExceeded} error.\\n    ///\\n    /// @notice Emits a {Repay} event.\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    /// @notice uint256 amtRepay = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).repay(weth, amtRepay, msg.sender);\\n    /// @notice ```\\n    ///\\n    /// @param underlyingToken The address of the underlying token to repay.\\n    /// @param amount          The amount of the underlying token to repay.\\n    /// @param recipient       The address of the recipient which will receive credit.\\n    ///\\n    /// @return amountRepaid The amount of tokens that were repaid.\\n    function repay(\\n        address underlyingToken,\\n        uint256 amount,\\n        address recipient\\n    )\\n        external\\n        returns (uint256 amountRepaid);\\n\\n    /// @notice\\n    ///\\n    /// @notice `shares` will be limited up to an equal amount of debt that `recipient` currently holds.\\n    ///\\n    /// @notice `shares` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `yieldToken` must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `yieldToken` underlying token must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice The loss in expected value of `yieldToken` must be less than the maximum permitted by the system or this\\n    /// call will revert with a {LossExceeded} error.\\n    /// @notice `amount` must be less than or equal to the current available liquidation limit or this call will revert\\n    /// with a {LiquidationLimitExceeded} error.\\n    ///\\n    /// @notice Emits a {Liquidate} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 amtSharesLiquidate = 5000 * 10**wstETH.decimals();\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).liquidate(wstETH, amtSharesLiquidate, 1);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken       The address of the yield token to liquidate.\\n    /// @param shares           The number of shares to burn for credit.\\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be liquidated.\\n    ///\\n    /// @return sharesLiquidated The amount of shares that were liquidated.\\n    function liquidate(\\n        address yieldToken,\\n        uint256 shares,\\n        uint256 minimumAmountOut\\n    )\\n        external\\n        returns (uint256 sharesLiquidated);\\n\\n    /// @notice Burns `amount` debt tokens to credit accounts which have deposited `yieldToken`.\\n    ///\\n    /// @notice `amount` must be greater than zero or this call will revert with a {IllegalArgument} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @notice Emits a {Donate} event.\\n    ///\\n    ///\\n    /// @notice **Example:**\\n    /// @notice ```\\n    /// @notice address wstETH = 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;\\n    /// @notice uint256 amtSharesLiquidate = 5000;\\n    /// @notice ZeroLiquid(ZeroLiquidAddress).liquidate(wstETH, amtSharesLiquidate, 1);\\n    /// @notice ```\\n    ///\\n    /// @param yieldToken The address of the yield token to credit accounts for.\\n    /// @param amount     The amount of debt tokens to burn.\\n    function donate(address yieldToken, uint256 amount) external;\\n\\n    /// @notice Harvests outstanding yield that a yield token has accumulated and distributes it as credit to holders.\\n    ///\\n    /// @notice `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice The amount being harvested must be greater than zero or else this call will revert with an\\n    /// {IllegalState} error.\\n    ///\\n    /// @notice Emits a {Harvest} event.\\n    ///\\n    /// @param yieldToken       The address of the yield token to harvest.\\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be withdrawn to\\n    /// `recipient`.\\n    function harvest(address yieldToken, uint256 minimumAmountOut) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidAdminActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidAdminActions\\n/// @author ZeroLiquid\\n///\\n/// @notice Specifies admin and or sentinel actions.\\ninterface IZeroLiquidAdminActions {\\n    /// @notice Contract initialization parameters.\\n    struct InitializationParams {\\n        // The initial admin account.\\n        address admin;\\n        // The ERC20 token used to represent debt.\\n        address debtToken;\\n        // The initial steamer or steamer buffer.\\n        address steamer;\\n        // The minimum collateralization ratio that an account must maintain.\\n        uint256 minimumCollateralization;\\n        // The percentage fee taken from each harvest measured in units of basis points.\\n        uint256 protocolFee;\\n        // The address that receives protocol fees.\\n        address protocolFeeReceiver;\\n        // A limit used to prevent administrators from making minting functionality inoperable.\\n        uint256 mintingLimitMinimum;\\n        // The maximum number of tokens that can be minted per period of time.\\n        uint256 mintingLimitMaximum;\\n        // The number of blocks that it takes for the minting limit to be refreshed.\\n        uint256 mintingLimitBlocks;\\n    }\\n\\n    /// @notice Configuration parameters for an underlying token.\\n    struct UnderlyingTokenConfig {\\n        // A limit used to prevent administrators from making repayment functionality inoperable.\\n        uint256 repayLimitMinimum;\\n        // The maximum number of underlying tokens that can be repaid per period of time.\\n        uint256 repayLimitMaximum;\\n        // The number of blocks that it takes for the repayment limit to be refreshed.\\n        uint256 repayLimitBlocks;\\n        // A limit used to prevent administrators from making liquidation functionality inoperable.\\n        uint256 liquidationLimitMinimum;\\n        // The maximum number of underlying tokens that can be liquidated per period of time.\\n        uint256 liquidationLimitMaximum;\\n        // The number of blocks that it takes for the liquidation limit to be refreshed.\\n        uint256 liquidationLimitBlocks;\\n    }\\n\\n    /// @notice Configuration parameters of a yield token.\\n    struct YieldTokenConfig {\\n        // The adapter used by the system to interop with the token.\\n        address adapter;\\n        // The maximum percent loss in expected value that can occur before certain actions are disabled measured in\\n        // units of basis points.\\n        uint256 maximumLoss;\\n        // The maximum value that can be held by the system before certain actions are disabled measured in the\\n        // underlying token.\\n        uint256 maximumExpectedValue;\\n        // The number of blocks that credit will be distributed over to depositors.\\n        uint256 creditUnlockBlocks;\\n    }\\n\\n    /// @notice Initialize the contract.\\n    ///\\n    /// @notice `params.protocolFee` must be in range or this call will with an {IllegalArgument} error.\\n    /// @notice The minting growth limiter parameters must be valid or this will revert with an {IllegalArgument} error.\\n    /// For more information, see the {Limiters} library.\\n    ///\\n    /// @notice Emits an {AdminUpdated} event.\\n    /// @notice Emits a {SteamerUpdated} event.\\n    /// @notice Emits a {MinimumCollateralizationUpdated} event.\\n    /// @notice Emits a {ProtocolFeeUpdated} event.\\n    /// @notice Emits a {ProtocolFeeReceiverUpdated} event.\\n    /// @notice Emits a {MintingLimitUpdated} event.\\n    ///\\n    /// @param params The contract initialization parameters.\\n    function initialize(InitializationParams memory params) external;\\n\\n    /// @notice Sets the pending administrator.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will will revert with an {Unauthorized} error.\\n    ///\\n    /// @notice Emits a {PendingAdminUpdated} event.\\n    ///\\n    /// @dev This is the first step in the two-step process of setting a new administrator. After this function is\\n    /// called, the pending administrator will then need to call {acceptAdmin} to complete the process.\\n    ///\\n    /// @param value the address to set the pending admin to.\\n    function setPendingAdmin(address value) external;\\n\\n    /// @notice Allows for `msg.sender` to accepts the role of administrator.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice The current pending administrator must be non-zero or this call will revert with an {IllegalState}\\n    /// error.\\n    ///\\n    /// @dev This is the second step in the two-step process of setting a new administrator. After this function is\\n    /// successfully called, this pending administrator will be reset and the new administrator will be set.\\n    ///\\n    /// @notice Emits a {AdminUpdated} event.\\n    /// @notice Emits a {PendingAdminUpdated} event.\\n    function acceptAdmin() external;\\n\\n    /// @notice Sets an address as a sentinel.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @param sentinel The address to set or unset as a sentinel.\\n    /// @param flag     A flag indicating of the address should be set or unset as a sentinel.\\n    function setSentinel(address sentinel, bool flag) external;\\n\\n    /// @notice Sets an address as a keeper.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @param keeper The address to set or unset as a keeper.\\n    /// @param flag   A flag indicating of the address should be set or unset as a keeper.\\n    function setKeeper(address keeper, bool flag) external;\\n\\n    /// @notice Adds an underlying token to the system.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @param underlyingToken The address of the underlying token to add.\\n    /// @param config          The initial underlying token configuration.\\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external;\\n\\n    /// @notice Adds a yield token to the system.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @notice Emits a {AddYieldToken} event.\\n    /// @notice Emits a {TokenAdapterUpdated} event.\\n    /// @notice Emits a {MaximumLossUpdated} event.\\n    ///\\n    /// @param yieldToken The address of the yield token to add.\\n    /// @param config     The initial yield token configuration.\\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external;\\n\\n    /// @notice Sets an underlying token as either enabled or disabled.\\n    ///\\n    /// @notice `msg.sender` must be either the admin or a sentinel or this call will revert with an {Unauthorized}\\n    /// error.\\n    /// @notice `underlyingToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @notice Emits an {UnderlyingTokenEnabled} event.\\n    ///\\n    /// @param underlyingToken The address of the underlying token to enable or disable.\\n    /// @param enabled         If the underlying token should be enabled or disabled.\\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external;\\n\\n    /// @notice Sets a yield token as either enabled or disabled.\\n    ///\\n    /// @notice `msg.sender` must be either the admin or a sentinel or this call will revert with an {Unauthorized}\\n    /// error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @notice Emits a {YieldTokenEnabled} event.\\n    ///\\n    /// @param yieldToken The address of the yield token to enable or disable.\\n    /// @param enabled    If the underlying token should be enabled or disabled.\\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external;\\n\\n    /// @notice Configures the the repay limit of `underlyingToken`.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `underlyingToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @notice Emits a {ReplayLimitUpdated} event.\\n    ///\\n    /// @param underlyingToken The address of the underlying token to configure the repay limit of.\\n    /// @param maximum         The maximum repay limit.\\n    /// @param blocks          The number of blocks it will take for the maximum repayment limit to be replenished when\\n    /// it is completely exhausted.\\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external;\\n\\n    /// @notice Configure the liquidation limiter of `underlyingToken`.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `underlyingToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @notice Emits a {LiquidationLimitUpdated} event.\\n    ///\\n    /// @param underlyingToken The address of the underlying token to configure the liquidation limit of.\\n    /// @param maximum         The maximum liquidation limit.\\n    /// @param blocks          The number of blocks it will take for the maximum liquidation limit to be replenished\\n    /// when it is completely exhausted.\\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external;\\n\\n    /// @notice Set the address of the steamer.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `value` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {SteamerUpdated} event.\\n    ///\\n    /// @param value The address of the steamer.\\n    function setSteamer(address value) external;\\n\\n    /// @notice Set the minimum collateralization ratio.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @notice Emits a {MinimumCollateralizationUpdated} event.\\n    ///\\n    /// @param value The new minimum collateralization ratio.\\n    function setMinimumCollateralization(uint256 value) external;\\n\\n    /// @notice Sets the fee that the protocol will take from harvests.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `value` must be in range or this call will with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {ProtocolFeeUpdated} event.\\n    ///\\n    /// @param value The value to set the protocol fee to measured in basis points.\\n    function setProtocolFee(uint256 value) external;\\n\\n    /// @notice Sets the address which will receive protocol fees.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `value` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {ProtocolFeeReceiverUpdated} event.\\n    ///\\n    /// @param value The address to set the protocol fee receiver to.\\n    function setProtocolFeeReceiver(address value) external;\\n\\n    /// @notice Configures the minting limiter.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    ///\\n    /// @notice Emits a {MintingLimitUpdated} event.\\n    ///\\n    /// @param maximum The maximum minting limit.\\n    /// @param blocks  The number of blocks it will take for the maximum minting limit to be replenished when it is\\n    /// completely exhausted.\\n    function configureMintingLimit(uint256 maximum, uint256 blocks) external;\\n\\n    /// @notice Sets the rate at which credit will be completely available to depositors after it is harvested.\\n    ///\\n    /// @notice Emits a {CreditUnlockRateUpdated} event.\\n    ///\\n    /// @param yieldToken The address of the yield token to set the credit unlock rate for.\\n    /// @param blocks     The number of blocks that it will take before the credit will be unlocked.\\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external;\\n\\n    /// @notice Sets the token adapter of a yield token.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice The token that `adapter` supports must be `yieldToken` or this call will revert with a {IllegalState}\\n    /// error.\\n    ///\\n    /// @notice Emits a {TokenAdapterUpdated} event.\\n    ///\\n    /// @param yieldToken The address of the yield token to set the adapter for.\\n    /// @param adapter    The address to set the token adapter to.\\n    function setTokenAdapter(address yieldToken, address adapter) external;\\n\\n    /// @notice Sets the maximum expected value of a yield token that the system can hold.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @param yieldToken The address of the yield token to set the maximum expected value for.\\n    /// @param value      The maximum expected value of the yield token denoted measured in its underlying token.\\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external;\\n\\n    /// @notice Sets the maximum loss that a yield bearing token will permit before restricting certain actions.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @dev There are two types of loss of value for yield bearing assets: temporary or permanent. The system will\\n    /// automatically restrict actions which are sensitive to both forms of loss when detected. For example, deposits\\n    /// must be restricted when an excessive loss is encountered to prevent users from having their collateral harvested\\n    /// from them. While the user would receive credit, which then could be exchanged for value equal to the collateral\\n    /// that was harvested from them, it is seen as a negative user experience because the value of their collateral\\n    /// should have been higher than what was originally recorded when they made their deposit.\\n    ///\\n    /// @param yieldToken The address of the yield bearing token to set the maximum loss for.\\n    /// @param value      The value to set the maximum loss to. This is in units of basis points.\\n    function setMaximumLoss(address yieldToken, uint256 value) external;\\n\\n    /// @notice Snap the expected value `yieldToken` to the current value.\\n    ///\\n    /// @notice `msg.sender` must be the admin or this call will revert with an {Unauthorized} error.\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    ///\\n    /// @dev This function should only be used in the event of a loss in the target yield-token. For example, say a\\n    /// third-party protocol experiences a fifty percent loss. The expected value (amount of underlying tokens) of the\\n    /// yield tokens being held by the system would be two times the real value that those yield tokens could be\\n    /// redeemed for. This function gives governance a way to realize those losses so that users can continue using the\\n    /// token as normal.\\n    ///\\n    /// @param yieldToken The address of the yield token to snap.\\n    function snap(address yieldToken) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidErrors\\n/// @author ZeroLiquid\\n///\\n/// @notice Specifies errors.\\ninterface IZeroLiquidErrors {\\n    /// @notice An error which is used to indicate that an operation failed because it tried to operate on a token that\\n    /// the system did not recognize.\\n    ///\\n    /// @param token The address of the token.\\n    error UnsupportedToken(address token);\\n\\n    /// @notice An error which is used to indicate that an operation failed because it tried to operate on a token that\\n    /// has been disabled.\\n    ///\\n    /// @param token The address of the token.\\n    error TokenDisabled(address token);\\n\\n    /// @notice An error which is used to indicate that an operation failed because an account became\\n    /// undercollateralized.\\n    error Undercollateralized();\\n\\n    /// @notice An error which is used to indicate that an operation failed because the expected value of a yield token\\n    /// in the system exceeds the maximum value permitted.\\n    ///\\n    /// @param yieldToken           The address of the yield token.\\n    /// @param expectedValue        The expected value measured in units of the underlying token.\\n    /// @param maximumExpectedValue The maximum expected value permitted measured in units of the underlying token.\\n    error ExpectedValueExceeded(address yieldToken, uint256 expectedValue, uint256 maximumExpectedValue);\\n\\n    /// @notice An error which is used to indicate that an operation failed because the loss that a yield token in the\\n    /// system exceeds the maximum value permitted.\\n    ///\\n    /// @param yieldToken  The address of the yield token.\\n    /// @param loss        The amount of loss measured in basis points.\\n    /// @param maximumLoss The maximum amount of loss permitted measured in basis points.\\n    error LossExceeded(address yieldToken, uint256 loss, uint256 maximumLoss);\\n\\n    /// @notice An error which is used to indicate that a minting operation failed because the minting limit has been\\n    /// exceeded.\\n    ///\\n    /// @param amount    The amount of debt tokens that were requested to be minted.\\n    /// @param available The amount of debt tokens which are available to mint.\\n    error MintingLimitExceeded(uint256 amount, uint256 available);\\n\\n    /// @notice An error which is used to indicate that an repay operation failed because the repay limit for an\\n    /// underlying token has been exceeded.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    /// @param amount          The amount of underlying tokens that were requested to be repaid.\\n    /// @param available       The amount of underlying tokens that are available to be repaid.\\n    error RepayLimitExceeded(address underlyingToken, uint256 amount, uint256 available);\\n\\n    /// @notice An error which is used to indicate that an repay operation failed because the liquidation limit for an\\n    /// underlying token has been exceeded.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    /// @param amount          The amount of underlying tokens that were requested to be liquidated.\\n    /// @param available       The amount of underlying tokens that are available to be liquidated.\\n    error LiquidationLimitExceeded(address underlyingToken, uint256 amount, uint256 available);\\n\\n    /// @notice An error which is used to indicate that the slippage of a wrap or unwrap operation was exceeded.\\n    ///\\n    /// @param amount           The amount of underlying or yield tokens returned by the operation.\\n    /// @param minimumAmountOut The minimum amount of the underlying or yield token that was expected when performing\\n    ///                         the operation.\\n    error SlippageExceeded(uint256 amount, uint256 minimumAmountOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidImmutables\\n/// @author ZeroLiquid\\ninterface IZeroLiquidImmutables {\\n    /// @notice Returns the version of the zeroliquid.\\n    ///\\n    /// @return The version.\\n    function version() external view returns (string memory);\\n\\n    /// @notice Returns the address of the debt token used by the system.\\n    ///\\n    /// @return The address of the debt token.\\n    function debtToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidEvents.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidEvents\\n/// @author ZeroLiquid\\ninterface IZeroLiquidEvents {\\n    /// @notice Emitted when the pending admin is updated.\\n    ///\\n    /// @param pendingAdmin The address of the pending admin.\\n    event PendingAdminUpdated(address pendingAdmin);\\n\\n    /// @notice Emitted when the administrator is updated.\\n    ///\\n    /// @param admin The address of the administrator.\\n    event AdminUpdated(address admin);\\n\\n    /// @notice Emitted when an address is set or unset as a sentinel.\\n    ///\\n    /// @param sentinel The address of the sentinel.\\n    /// @param flag     A flag indicating if `sentinel` was set or unset as a sentinel.\\n    event SentinelSet(address sentinel, bool flag);\\n\\n    /// @notice Emitted when an address is set or unset as a keeper.\\n    ///\\n    /// @param sentinel The address of the keeper.\\n    /// @param flag     A flag indicating if `keeper` was set or unset as a sentinel.\\n    event KeeperSet(address sentinel, bool flag);\\n\\n    /// @notice Emitted when an underlying token is added.\\n    ///\\n    /// @param underlyingToken The address of the underlying token that was added.\\n    event AddUnderlyingToken(address indexed underlyingToken);\\n\\n    /// @notice Emitted when a yield token is added.\\n    ///\\n    /// @param yieldToken The address of the yield token that was added.\\n    event AddYieldToken(address indexed yieldToken);\\n\\n    /// @notice Emitted when an underlying token is enabled or disabled.\\n    ///\\n    /// @param underlyingToken The address of the underlying token that was enabled or disabled.\\n    /// @param enabled         A flag indicating if the underlying token was enabled or disabled.\\n    event UnderlyingTokenEnabled(address indexed underlyingToken, bool enabled);\\n\\n    /// @notice Emitted when an yield token is enabled or disabled.\\n    ///\\n    /// @param yieldToken The address of the yield token that was enabled or disabled.\\n    /// @param enabled    A flag indicating if the yield token was enabled or disabled.\\n    event YieldTokenEnabled(address indexed yieldToken, bool enabled);\\n\\n    /// @notice Emitted when the repay limit of an underlying token is updated.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    /// @param maximum         The updated maximum repay limit.\\n    /// @param blocks          The updated number of blocks it will take for the maximum repayment limit to be\\n    /// replenished when it is completely exhausted.\\n    event RepayLimitUpdated(address indexed underlyingToken, uint256 maximum, uint256 blocks);\\n\\n    /// @notice Emitted when the liquidation limit of an underlying token is updated.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    /// @param maximum         The updated maximum liquidation limit.\\n    /// @param blocks          The updated number of blocks it will take for the maximum liquidation limit to be\\n    /// replenished when it is completely exhausted.\\n    event LiquidationLimitUpdated(address indexed underlyingToken, uint256 maximum, uint256 blocks);\\n\\n    /// @notice Emitted when the steamer is updated.\\n    ///\\n    /// @param steamer The updated address of the steamer.\\n    event SteamerUpdated(address steamer);\\n\\n    /// @notice Emitted when the minimum collateralization is updated.\\n    ///\\n    /// @param minimumCollateralization The updated minimum collateralization.\\n    event MinimumCollateralizationUpdated(uint256 minimumCollateralization);\\n\\n    /// @notice Emitted when the protocol fee is updated.\\n    ///\\n    /// @param protocolFee The updated protocol fee.\\n    event ProtocolFeeUpdated(uint256 protocolFee);\\n\\n    /// @notice Emitted when the protocol fee receiver is updated.\\n    ///\\n    /// @param protocolFeeReceiver The updated address of the protocol fee receiver.\\n    event ProtocolFeeReceiverUpdated(address protocolFeeReceiver);\\n\\n    /// @notice Emitted when the minting limit is updated.\\n    ///\\n    /// @param maximum The updated maximum minting limit.\\n    /// @param blocks  The updated number of blocks it will take for the maximum minting limit to be replenished when it\\n    /// is completely exhausted.\\n    event MintingLimitUpdated(uint256 maximum, uint256 blocks);\\n\\n    /// @notice Emitted when the credit unlock rate is updated.\\n    ///\\n    /// @param yieldToken The address of the yield token.\\n    /// @param blocks     The number of blocks that distributed credit will unlock over.\\n    event CreditUnlockRateUpdated(address yieldToken, uint256 blocks);\\n\\n    /// @notice Emitted when the adapter of a yield token is updated.\\n    ///\\n    /// @param yieldToken   The address of the yield token.\\n    /// @param tokenAdapter The updated address of the token adapter.\\n    event TokenAdapterUpdated(address yieldToken, address tokenAdapter);\\n\\n    /// @notice Emitted when the maximum expected value of a yield token is updated.\\n    ///\\n    /// @param yieldToken           The address of the yield token.\\n    /// @param maximumExpectedValue The updated maximum expected value.\\n    event MaximumExpectedValueUpdated(address indexed yieldToken, uint256 maximumExpectedValue);\\n\\n    /// @notice Emitted when the maximum loss of a yield token is updated.\\n    ///\\n    /// @param yieldToken  The address of the yield token.\\n    /// @param maximumLoss The updated maximum loss.\\n    event MaximumLossUpdated(address indexed yieldToken, uint256 maximumLoss);\\n\\n    /// @notice Emitted when the expected value of a yield token is snapped to its current value.\\n    ///\\n    /// @param yieldToken    The address of the yield token.\\n    /// @param expectedValue The updated expected value measured in the yield token's underlying token.\\n    event Snap(address indexed yieldToken, uint256 expectedValue);\\n\\n    /// @notice Emitted when `owner` grants `spender` the ability to mint debt tokens on its behalf.\\n    ///\\n    /// @param owner   The address of the account owner.\\n    /// @param spender The address which is being permitted to mint tokens on the behalf of `owner`.\\n    /// @param amount  The amount of debt tokens that `spender` is allowed to mint.\\n    event ApproveMint(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @notice Emitted when `owner` grants `spender` the ability to withdraw `yieldToken` from its account.\\n    ///\\n    /// @param owner      The address of the account owner.\\n    /// @param spender    The address which is being permitted to mint tokens on the behalf of `owner`.\\n    /// @param yieldToken The address of the yield token that `spender` is allowed to withdraw.\\n    /// @param amount     The amount of shares of `yieldToken` that `spender` is allowed to withdraw.\\n    event ApproveWithdraw(address indexed owner, address indexed spender, address indexed yieldToken, uint256 amount);\\n\\n    /// @notice Emitted when a user deposits `amount of `yieldToken` to `recipient`.\\n    ///\\n    /// @notice This event does not imply that `sender` directly deposited yield tokens. It is possible that the\\n    ///         underlying tokens were wrapped.\\n    ///\\n    /// @param sender       The address of the user which deposited funds.\\n    /// @param yieldToken   The address of the yield token that was deposited.\\n    /// @param amount       The amount of yield tokens that were deposited.\\n    /// @param recipient    The address that received the deposited funds.\\n    event Deposit(address indexed sender, address indexed yieldToken, uint256 amount, address recipient);\\n\\n    /// @notice Emitted when `shares` shares of `yieldToken` are burned to withdraw `yieldToken` from the account owned\\n    ///         by `owner` to `recipient`.\\n    ///\\n    /// @notice This event does not imply that `recipient` received yield tokens. It is possible that the yield tokens\\n    ///         were unwrapped.\\n    ///\\n    /// @param owner      The address of the account owner.\\n    /// @param yieldToken The address of the yield token that was withdrawn.\\n    /// @param shares     The amount of shares that were burned.\\n    /// @param recipient  The address that received the withdrawn funds.\\n    event Withdraw(address indexed owner, address indexed yieldToken, uint256 shares, address recipient);\\n\\n    /// @notice Emitted when `amount` debt tokens are minted to `recipient` using the account owned by `owner`.\\n    ///\\n    /// @param owner     The address of the account owner.\\n    /// @param amount    The amount of tokens that were minted.\\n    /// @param recipient The recipient of the minted tokens.\\n    event Mint(address indexed owner, uint256 amount, address recipient);\\n\\n    /// @notice Emitted when `sender` burns `amount` debt tokens to grant credit to `recipient`.\\n    ///\\n    /// @param sender    The address which is burning tokens.\\n    /// @param amount    The amount of tokens that were burned.\\n    /// @param recipient The address that received credit for the burned tokens.\\n    event Burn(address indexed sender, uint256 amount, address recipient);\\n\\n    /// @notice Emitted when `amount` of `underlyingToken` are repaid to grant credit to `recipient`.\\n    ///\\n    /// @param sender          The address which is repaying tokens.\\n    /// @param underlyingToken The address of the underlying token that was used to repay debt.\\n    /// @param amount          The amount of the underlying token that was used to repay debt.\\n    /// @param recipient       The address that received credit for the repaid tokens.\\n    /// @param credit          The amount of debt that was paid-off to the account owned by owner.\\n    event Repay(\\n        address indexed sender, address indexed underlyingToken, uint256 amount, address recipient, uint256 credit\\n    );\\n\\n    /// @notice Emitted when `sender` liquidates `share` shares of `yieldToken`.\\n    ///\\n    /// @param owner           The address of the account owner liquidating shares.\\n    /// @param yieldToken      The address of the yield token.\\n    /// @param underlyingToken The address of the underlying token.\\n    /// @param shares          The amount of the shares of `yieldToken` that were liquidated.\\n    /// @param credit          The amount of debt that was paid-off to the account owned by owner.\\n    event Liquidate(\\n        address indexed owner,\\n        address indexed yieldToken,\\n        address indexed underlyingToken,\\n        uint256 shares,\\n        uint256 credit\\n    );\\n\\n    /// @notice Emitted when `sender` burns `amount` debt tokens to grant credit to users who have deposited\\n    /// `yieldToken`.\\n    ///\\n    /// @param sender     The address which burned debt tokens.\\n    /// @param yieldToken The address of the yield token.\\n    /// @param amount     The amount of debt tokens which were burned.\\n    event Donate(address indexed sender, address indexed yieldToken, uint256 amount);\\n\\n    /// @notice Emitted when `yieldToken` is harvested.\\n    ///\\n    /// @param yieldToken       The address of the yield token that was harvested.\\n    /// @param minimumAmountOut The maximum amount of loss that is acceptable when unwrapping the underlying tokens into\\n    /// yield tokens, measured in basis points.\\n    /// @param totalHarvested   The total amount of underlying tokens harvested.\\n    /// @param credit           The total amount of debt repaid to depositors of `yieldToken`.\\n    event Harvest(address indexed yieldToken, uint256 minimumAmountOut, uint256 totalHarvested, uint256 credit);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/zeroliquid/IZeroLiquidState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\n/// @title  IZeroLiquidState\\n/// @author ZeroLiquid\\ninterface IZeroLiquidState {\\n    /// @notice Defines underlying token parameters.\\n    struct UnderlyingTokenParams {\\n        // The number of decimals the token has. This value is cached once upon registering the token so it is important\\n        // that the decimals of the token are immutable or the system will begin to have computation errors.\\n        uint8 decimals;\\n        // A coefficient used to normalize the token to a value comparable to the debt token. For example, if the\\n        // underlying token is 8 decimals and the debt token is 18 decimals then the conversion factor will be\\n        // 10^10. One unit of the underlying token will be comparably equal to one unit of the debt token.\\n        uint256 conversionFactor;\\n        // A flag to indicate if the token is enabled.\\n        bool enabled;\\n    }\\n\\n    /// @notice Defines yield token parameters.\\n    struct YieldTokenParams {\\n        // The number of decimals the token has. This value is cached once upon registering the token so it is important\\n        // that the decimals of the token are immutable or the system will begin to have computation errors.\\n        uint8 decimals;\\n        // The associated underlying token that can be redeemed for the yield-token.\\n        address underlyingToken;\\n        // The adapter used by the system to wrap, unwrap, and lookup the conversion rate of this token into its\\n        // underlying token.\\n        address adapter;\\n        // The maximum percentage loss that is acceptable before disabling certain actions.\\n        uint256 maximumLoss;\\n        // The maximum value of yield tokens that the system can hold, measured in units of the underlying token.\\n        uint256 maximumExpectedValue;\\n        // The percent of credit that will be unlocked per block. The representation of this value is a 18  decimal\\n        // fixed point integer.\\n        uint256 creditUnlockRate;\\n        // The current balance of yield tokens which are held by users.\\n        uint256 activeBalance;\\n        // The current balance of yield tokens which are earmarked to be harvested by the system at a later time.\\n        uint256 harvestableBalance;\\n        // The total number of shares that have been minted for this token.\\n        uint256 totalShares;\\n        // The expected value of the tokens measured in underlying tokens. This value controls how much of the token\\n        // can be harvested. When users deposit yield tokens, it increases the expected value by how much the tokens\\n        // are exchangeable for in the underlying token. When users withdraw yield tokens, it decreases the expected\\n        // value by how much the tokens are exchangeable for in the underlying token.\\n        uint256 expectedValue;\\n        // The current amount of credit which is will be distributed over time to depositors.\\n        uint256 pendingCredit;\\n        // The amount of the pending credit that has been distributed.\\n        uint256 distributedCredit;\\n        // The block number which the last credit distribution occurred.\\n        uint256 lastDistributionBlock;\\n        // The total accrued weight. This is used to calculate how much credit a user has been granted over time. The\\n        // representation of this value is a 18 decimal fixed point integer.\\n        uint256 accruedWeight;\\n        // A flag to indicate if the token is enabled.\\n        bool enabled;\\n    }\\n\\n    /// @notice Gets the address of the admin.\\n    ///\\n    /// @return admin The admin address.\\n    function admin() external view returns (address admin);\\n\\n    /// @notice Gets the address of the pending administrator.\\n    ///\\n    /// @return pendingAdmin The pending administrator address.\\n    function pendingAdmin() external view returns (address pendingAdmin);\\n\\n    /// @notice Gets if an address is a sentinel.\\n    ///\\n    /// @param sentinel The address to check.\\n    ///\\n    /// @return isSentinel If the address is a sentinel.\\n    function sentinels(address sentinel) external view returns (bool isSentinel);\\n\\n    /// @notice Gets if an address is a keeper.\\n    ///\\n    /// @param keeper The address to check.\\n    ///\\n    /// @return isKeeper If the address is a keeper\\n    function keepers(address keeper) external view returns (bool isKeeper);\\n\\n    /// @notice Gets the address of the steamer.\\n    ///\\n    /// @return steamer The steamer address.\\n    function steamer() external view returns (address steamer);\\n\\n    /// @notice Gets the minimum collateralization.\\n    ///\\n    /// @notice Collateralization is determined by taking the total value of collateral that a user has deposited into\\n    /// their account and dividing it their debt.\\n    ///\\n    /// @dev The value returned is a 18 decimal fixed point integer.\\n    ///\\n    /// @return minimumCollateralization The minimum collateralization.\\n    function minimumCollateralization() external view returns (uint256 minimumCollateralization);\\n\\n    /// @notice Gets the protocol fee.\\n    ///\\n    /// @return protocolFee The protocol fee.\\n    function protocolFee() external view returns (uint256 protocolFee);\\n\\n    /// @notice Gets the protocol fee receiver.\\n    ///\\n    /// @return protocolFeeReceiver The protocol fee receiver.\\n    function protocolFeeReceiver() external view returns (address protocolFeeReceiver);\\n\\n    /// @notice Gets the conversion rate of underlying tokens per share.\\n    ///\\n    /// @param yieldToken The address of the yield token to get the conversion rate for.\\n    ///\\n    /// @return rate The rate of underlying tokens per share.\\n    function getUnderlyingTokensPerShare(address yieldToken) external view returns (uint256 rate);\\n\\n    /// @notice Gets the conversion rate of yield tokens per share.\\n    ///\\n    /// @param yieldToken The address of the yield token to get the conversion rate for.\\n    ///\\n    /// @return rate The rate of yield tokens per share.\\n    function getYieldTokensPerShare(address yieldToken) external view returns (uint256 rate);\\n\\n    /// @notice Gets the supported underlying tokens.\\n    ///\\n    /// @dev The order of the entries returned by this function is not guaranteed to be consistent between calls.\\n    ///\\n    /// @return tokens The supported underlying tokens.\\n    function getSupportedUnderlyingTokens() external view returns (address[] memory tokens);\\n\\n    /// @notice Gets the supported yield tokens.\\n    ///\\n    /// @dev The order of the entries returned by this function is not guaranteed to be consistent between calls.\\n    ///\\n    /// @return tokens The supported yield tokens.\\n    function getSupportedYieldTokens() external view returns (address[] memory tokens);\\n\\n    /// @notice Gets if an underlying token is supported.\\n    ///\\n    /// @param underlyingToken The address of the underlying token to check.\\n    ///\\n    /// @return isSupported If the underlying token is supported.\\n    function isSupportedUnderlyingToken(address underlyingToken) external view returns (bool isSupported);\\n\\n    /// @notice Gets if a yield token is supported.\\n    ///\\n    /// @param yieldToken The address of the yield token to check.\\n    ///\\n    /// @return isSupported If the yield token is supported.\\n    function isSupportedYieldToken(address yieldToken) external view returns (bool isSupported);\\n\\n    /// @notice Gets information about the account owned by `owner`.\\n    ///\\n    /// @param owner The address that owns the account.\\n    ///\\n    /// @return debt            The unrealized amount of debt that the account had incurred.\\n    /// @return depositedTokens The yield tokens that the owner has deposited.\\n    function accounts(address owner) external view returns (int256 debt, address[] memory depositedTokens);\\n\\n    /// @notice Gets information about a yield token position for the account owned by `owner`.\\n    ///\\n    /// @param owner      The address that owns the account.\\n    /// @param yieldToken The address of the yield token to get the position of.\\n    ///\\n    /// @return shares            The amount of shares of that `owner` owns of the yield token.\\n    /// @return lastAccruedWeight The last recorded accrued weight of the yield token.\\n    function positions(\\n        address owner,\\n        address yieldToken\\n    )\\n        external\\n        view\\n        returns (uint256 shares, uint256 lastAccruedWeight);\\n\\n    /// @notice Gets the amount of debt tokens `spender` is allowed to mint on behalf of `owner`.\\n    ///\\n    /// @param owner   The owner of the account.\\n    /// @param spender The address which is allowed to mint on behalf of `owner`.\\n    ///\\n    /// @return allowance The amount of debt tokens that `spender` can mint on behalf of `owner`.\\n    function mintAllowance(address owner, address spender) external view returns (uint256 allowance);\\n\\n    /// @notice Gets the amount of shares of `yieldToken` that `spender` is allowed to withdraw on behalf of `owner`.\\n    ///\\n    /// @param owner      The owner of the account.\\n    /// @param spender    The address which is allowed to withdraw on behalf of `owner`.\\n    /// @param yieldToken The address of the yield token.\\n    ///\\n    /// @return allowance The amount of shares that `spender` can withdraw on behalf of `owner`.\\n    function withdrawAllowance(\\n        address owner,\\n        address spender,\\n        address yieldToken\\n    )\\n        external\\n        view\\n        returns (uint256 allowance);\\n\\n    /// @notice Gets the parameters of an underlying token.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    ///\\n    /// @return params The underlying token parameters.\\n    function getUnderlyingTokenParameters(address underlyingToken)\\n        external\\n        view\\n        returns (UnderlyingTokenParams memory params);\\n\\n    /// @notice Get the parameters and state of a yield-token.\\n    ///\\n    /// @param yieldToken The address of the yield token.\\n    ///\\n    /// @return params The yield token parameters.\\n    function getYieldTokenParameters(address yieldToken) external view returns (YieldTokenParams memory params);\\n\\n    /// @notice Gets current limit, maximum, and rate of the minting limiter.\\n    ///\\n    /// @return currentLimit The current amount of debt tokens that can be minted.\\n    /// @return rate         The maximum possible amount of tokens that can be liquidated at a time.\\n    /// @return maximum      The highest possible maximum amount of debt tokens that can be minted at a time.\\n    function getMintLimitInfo() external view returns (uint256 currentLimit, uint256 rate, uint256 maximum);\\n\\n    /// @notice Gets current limit, maximum, and rate of a repay limiter for `underlyingToken`.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    ///\\n    /// @return currentLimit The current amount of underlying tokens that can be repaid.\\n    /// @return rate         The rate at which the the current limit increases back to its maximum in tokens per block.\\n    /// @return maximum      The maximum possible amount of tokens that can be repaid at a time.\\n    function getRepayLimitInfo(address underlyingToken)\\n        external\\n        view\\n        returns (uint256 currentLimit, uint256 rate, uint256 maximum);\\n\\n    /// @notice Gets current limit, maximum, and rate of the liquidation limiter for `underlyingToken`.\\n    ///\\n    /// @param underlyingToken The address of the underlying token.\\n    ///\\n    /// @return currentLimit The current amount of underlying tokens that can be liquidated.\\n    /// @return rate         The rate at which the function increases back to its maximum limit (tokens / block).\\n    /// @return maximum      The highest possible maximum amount of debt tokens that can be liquidated at a time.\\n    function getLiquidationLimitInfo(address underlyingToken)\\n        external\\n        view\\n        returns (uint256 currentLimit, uint256 rate, uint256 maximum);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IERC20Metadata\\n/// @author ZeroLiquid\\ninterface IERC20Metadata {\\n    /// @notice Gets the name of the token.\\n    ///\\n    /// @return The name.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Gets the symbol of the token.\\n    ///\\n    /// @return The symbol.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Gets the number of decimals that the token has.\\n    ///\\n    /// @return The number of decimals.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zeroliquid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumAmountOut\",\"type\":\"uint256\"}],\"name\":\"depositUnderlying\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zeroliquid\",\"type\":\"address\"}],\"name\":\"refreshAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zeroliquid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumAmountOut\",\"type\":\"uint256\"}],\"name\":\"withdrawUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WETHGateway", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}