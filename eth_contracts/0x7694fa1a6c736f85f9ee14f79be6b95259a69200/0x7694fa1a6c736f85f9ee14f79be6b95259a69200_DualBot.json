{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DualBot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IERC4626} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\\\";\\nimport \\\"../lib/openzeppelin-contracts/contracts/access/AccessControl.sol\\\";\\nimport {IOracle} from \\\"../lib/morpho-blue/src/interfaces/IOracle.sol\\\";\\nimport {IMorpho, Market, Position, MarketParams, Id} from \\\"../lib/morpho-blue/src/interfaces/IMorpho.sol\\\";\\nimport {IMorphoFlashLoanCallback, IMorphoSupplyCollateralCallback} from \\\"../lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol\\\";\\nimport {MathLib} from \\\"../lib/morpho-blue/src/libraries/MathLib.sol\\\";\\nimport {MorphoBalancesLib} from \\\"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\\\";\\n\\nimport {IChainlinkOracle} from \\\"../src/interfaces/IChainlinkOracle.sol\\\";\\nimport {ISwapper} from \\\"../src/interfaces/ISwapper.sol\\\";\\nimport {IMorphoReader, MarketDataExt, PositionExt} from \\\"../src/interfaces/IMorphoReader.sol\\\";\\nimport {IWsteth} from \\\"../src/interfaces/IWsteth.sol\\\";\\n\\n/**\\n * @title Bot that leverage borrows cash (of type currency) against assets (of type collateral)\\n */\\ncontract DualBot is\\n    AccessControl,\\n    IMorphoFlashLoanCallback,\\n    IMorphoSupplyCollateralCallback\\n{\\n    event Wind(uint256 equity, uint256 exposure, uint256 toBorrow);\\n    event Unwind(\\n        uint256 borrowShares,\\n        uint256 borrowAmount,\\n        uint256 collateral\\n    );\\n\\n    // Create a new role identifier for the minter role\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    bytes32 public constant CALLBACK_ROLE = keccak256(\\\"CALLBACK_ROLE\\\");\\n\\n    IERC20 public immutable currency;\\n    IERC20 public immutable collateral;\\n    IOracle public immutable oracle;\\n    IMorpho public immutable morpho =\\n        IMorpho(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb);\\n    IMorphoReader public immutable morphoReader;\\n    ISwapper public immutable swapper;\\n\\n    Id[] public markets;\\n    mapping(Id => bool) internal marketsMap;\\n\\n    uint256 internal immutable WEI_FACTOR = 10 ** 18;\\n    /// @notice Max allowed slippage in bps\\n    uint256 public maxSlippage = 5; // in bps\\n    uint256 internal constant SLIPPAGE_FACTOR = 10000; // in bps so 100%\\n    uint256 internal minExpected = 0 ether; // MEV protection where sender can say how much min after swaps\\n    uint256 internal constant DUST = 10 ** 12;\\n    bytes internal constant NULL_DATA = \\\"\\\";\\n    uint256 internal immutable ORACLE_FACTOR = 10 ** 36;\\n\\n    bool internal constant WIND = true;\\n    bool internal constant UNWIND = false;\\n\\n    MarketParams public marketParams;\\n\\n    constructor(\\n        address owner,\\n        IERC20 currency_,\\n        IERC20 collateral_,\\n        IOracle oracle_,\\n        ISwapper swapper_,\\n        IMorphoReader reader_\\n    ) {\\n        currency = currency_;\\n        collateral = collateral_;\\n        oracle = oracle_;\\n        swapper = swapper_;\\n        morphoReader = reader_;\\n\\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\\n        _grantRole(OPERATOR_ROLE, msg.sender);\\n\\n        // Only Morpho and DssFlashLoan can call the callback\\n        _grantRole(CALLBACK_ROLE, address(morpho));\\n\\n        // Grant admin to change permissions\\n        _setRoleAdmin(OPERATOR_ROLE, DEFAULT_ADMIN_ROLE);\\n        _setRoleAdmin(CALLBACK_ROLE, DEFAULT_ADMIN_ROLE);\\n    }\\n\\n    /// @notice Borrow cash currency, swap in collateral in market id and use it as collateral\\n    /// @param marketId Market Id to use\\n    /// @param cash currency amount to be borrowed\\n    function wind(Id marketId, uint256 cash) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        morpho.flashLoan(address(currency), cash, abi.encode(marketId, WIND));\\n    }\\n\\n    /// @notice remove collateral on market id, swap to currency, repay the loan\\n    /// @param marketId Market Id to use\\n    /// @param assets Amount of collateral to sell to repay the loan\\n    function unwind(\\n        Id marketId,\\n        uint256 assets\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        morpho.flashLoan(\\n            address(collateral),\\n            assets,\\n            abi.encode(marketId, UNWIND)\\n        );\\n    }\\n\\n    /// @notice Borrow cash currency, swap in collateral in market id and use it as collateral\\n    /// @param marketId Market Id to use\\n    /// @param cash currency amount to be borrowed\\n    /// @param minAssets_ Revert if we don't get at least minAssets_ collateral from the sale\\n    function wind(\\n        Id marketId,\\n        uint256 cash,\\n        uint256 minAssets_\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        minExpected = minAssets_; // Revert if we don't get at least minCollateral_\\n        morpho.flashLoan(address(currency), cash, abi.encode(marketId, WIND));\\n        minExpected = 0;\\n    }\\n\\n    /// @notice remove collateral on market id, swap to currency, repay the loan\\n    /// @param marketId Market Id to use\\n    /// @param minCash_ Revert if we don't get at least minCash_ currency from the sale\\n    function unwind(\\n        Id marketId,\\n        uint256 assets,\\n        uint256 minCash_\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        minExpected = minCash_; // Revert if we don't get at least minAssets_\\n        morpho.flashLoan(\\n            address(collateral),\\n            assets,\\n            abi.encode(marketId, UNWIND)\\n        );\\n        minExpected = 0;\\n    }\\n\\n    /// @notice Moves collateral from marketFrom to marketTo\\n    /// @param marketFrom From which market\\n    /// @param marketTo To which market\\n    /// @param assets Amount of collateral to move\\n    function shiftCollateral(\\n        Id marketFrom,\\n        Id marketTo,\\n        uint256 assets\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketFrom);\\n        _checkMarket(marketTo);\\n\\n        _withdrawCollateral(marketFrom, assets);\\n        _supplyCollateral(marketTo, assets);\\n    }\\n\\n    /// @notice Borrow cash on marketFrom to repay a loan on marketTo\\n    /// @param marketFrom From which market\\n    /// @param marketTo To which market\\n    /// @param cash Amount of currency to move (will be borrowed)\\n    function shiftCurrency(\\n        Id marketFrom,\\n        Id marketTo,\\n        uint256 cash\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketFrom);\\n        _checkMarket(marketTo);\\n\\n        _borrow(marketFrom, cash);\\n        _repay(marketTo, cash);\\n    }\\n\\n    /// @notice Moves collateral from marketFrom to marketTo, borrow cash from marketTo to repay marketFrom\\n    function shiftPosition(\\n        Id marketFrom,\\n        Id marketTo,\\n        uint256 assets,\\n        uint256 cash\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketFrom);\\n        _checkMarket(marketTo);\\n\\n        morpho.supplyCollateral(\\n            morpho.idToMarketParams(marketTo),\\n            assets,\\n            address(this),\\n            abi.encode(marketFrom, marketTo, cash)\\n        );\\n    }\\n\\n    function onMorphoFlashLoan(\\n        uint256 amount,\\n        bytes calldata data\\n    ) external onlyRole(CALLBACK_ROLE) {\\n        (Id marketId, bool wind) = abi.decode(data, (Id, bool));\\n        if (wind) {\\n            // Floashloaned currency\\n            uint256 collateral = _swapToCollateral(amount);\\n            _supplyCollateral(marketId, collateral);\\n            _borrow(marketId, amount);\\n            currency.approve(address(morpho), amount);\\n        } else {\\n            // Unwind, we flashloaded collateral\\n            uint256 cash = _swapToCurrency(amount);\\n            _repayCurrencyFallbackShares(marketId, cash);\\n            _withdrawCollateral(marketId, amount);\\n            collateral.approve(address(morpho), amount);\\n        }\\n    }\\n\\n    /// @notice Callback called when we shift a position\\n    function onMorphoSupplyCollateral(\\n        uint256 assets,\\n        bytes calldata data\\n    ) external onlyRole(CALLBACK_ROLE) {\\n        (Id marketFrom, Id marketTo, uint256 cash) = abi.decode(\\n            data,\\n            (Id, Id, uint256)\\n        );\\n        _borrow(marketTo, cash);\\n        _repay(marketFrom, cash);\\n        _withdrawCollateral(marketFrom, assets);\\n        collateral.approve(address(morpho), assets);\\n    }\\n\\n    /// @notice change the max slippage allowed with 1 ether = 100% sippage\\n    function setMaxSlippage(\\n        uint256 maxSlippage_\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        require(maxSlippage_ <= 5, \\\"Max slippage should be at max 0.05%\\\");\\n        maxSlippage = maxSlippage_;\\n    }\\n\\n    /// @notice change the max slippage allowed with 1 ether = 100% sippage\\n    function setMaxSlippageForce(\\n        uint256 maxSlippage_\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(maxSlippage_ <= 10000, \\\"Max slippage should be at max 100%\\\");\\n        maxSlippage = maxSlippage_;\\n    }\\n\\n    function addMarket(Id marketId) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(marketsMap[marketId] == false, \\\"Market already added\\\");\\n        markets.push(marketId);\\n        marketsMap[marketId] = true;\\n    }\\n\\n    function deleteMarket(Id marketId) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(marketsMap[marketId] == true, \\\"Market isn't added yet\\\");\\n        uint i = 0;\\n        for (; Id.unwrap(markets[i]) != Id.unwrap(marketId); i++) {}\\n        markets[i] = markets[markets.length - 1];\\n        markets.pop();\\n        delete marketsMap[marketId];\\n    }\\n\\n    ////////////////////////////////\\n    // VIEW FUNCTIONS\\n    ////////////////////////////////\\n\\n    /// @notice Returns the equity (collateral - debt) for a market\\n    function equity() public view returns (uint256) {\\n        uint256 _equity = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            _equity += equity(markets[i]);\\n        }\\n        return _equity;\\n    }\\n\\n    /// @notice Returns the equity (collateral - debt) for a market\\n    function equityAsCollateral() public view returns (uint256) {\\n        uint256 _equity = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            _equity += equity(markets[i]);\\n        }\\n        return (_equity * ORACLE_FACTOR) / oracle.price();\\n    }\\n\\n    /// @notice Returns the equity (collateral - debt) for a market\\n    function equity(Id marketId) public view returns (uint256) {\\n        PositionExt memory p = morphoReader.getPosition(\\n            marketId,\\n            address(this)\\n        );\\n        return p.collateralValue - p.borrowedAssets;\\n    }\\n\\n    /// @notice Returns the equity expressed in collateral units\\n    function equityAsCollateral(Id marketId) public view returns (uint256) {\\n        return (equity(marketId) * ORACLE_FACTOR) / oracle.price();\\n    }\\n\\n    /// @notice Returns the amount of collateral to be sale to repay a loan\\n    ///        include the worth case allowed slippage\\n    function collateralNeeded(uint256 cash) public view returns (uint256) {\\n        return\\n            (cash * ORACLE_FACTOR * SLIPPAGE_FACTOR) /\\n            (oracle.price() * (SLIPPAGE_FACTOR - maxSlippage));\\n    }\\n\\n    /// @notice returen the price of cash collateral in the currency\\n    function priceCollateralInCurrency(\\n        uint256 assets\\n    ) public view returns (uint256 cash) {\\n        return (assets * oracle.price()) / ORACLE_FACTOR;\\n    }\\n\\n    /// @notice Returns the minimal collateral expected from the swap of cash currency\\n    function minCollateral(uint256 cash) public view returns (uint256) {\\n        return\\n            (minExpected > 0)\\n                ? minExpected\\n                : (cash * ORACLE_FACTOR * (SLIPPAGE_FACTOR - maxSlippage)) /\\n                    (oracle.price() * SLIPPAGE_FACTOR);\\n    }\\n\\n    /// @notice Returns the minimal cash expected from the swap of collateral\\n    function minCurrency(uint256 assets) public view returns (uint256) {\\n        return\\n            (minExpected > 0)\\n                ? minExpected\\n                : (assets * oracle.price() * (SLIPPAGE_FACTOR - maxSlippage)) /\\n                    (ORACLE_FACTOR * SLIPPAGE_FACTOR);\\n    }\\n\\n    function isUnwinded(Id marketId) public view returns (bool) {\\n        Position memory position = morpho.position(marketId, address(this));\\n        return position.borrowShares == 0;\\n    }\\n\\n    function sharesBorrowed(Id marketId) public view returns (uint256) {\\n        Position memory position = morpho.position(marketId, address(this));\\n        return position.borrowShares;\\n    }\\n\\n    /// @notice Returns the available market liquidity\\n    function availableLiqudidity(Id marketId) public view returns (uint256) {\\n        MarketDataExt memory m = morphoReader.getMarketData(marketId);\\n        return m.totalSupplyAssets - m.totalBorrowAssets;\\n    }\\n\\n    /// @notice Returns how much would be winded\\n    function availableToBorrow(Id marketId) public view returns (uint256) {\\n        uint256 _liquidity = availableLiqudidity(marketId);\\n        PositionExt memory p = morphoReader.getPosition(\\n            marketId,\\n            address(this)\\n        );\\n\\n        // We assume we can borrow up to 95% LTV\\n        MarketParams memory params = morpho.idToMarketParams(marketId);\\n        uint256 _equity = p.collateralValue - p.borrowedAssets;\\n        uint256 maxExposure = _equity +\\n            ((_equity * (1 ether)) / (1 ether - params.lltv));\\n\\n        if (maxExposure < p.borrowedAssets) return 0;\\n\\n        return _min(_liquidity, maxExposure - p.borrowedAssets);\\n    }\\n\\n    ///////////////////////////////////////////\\n    // EXPOSE LOW LEVEL FUNCTIONS\\n    ///////////////////////////////////////////\\n\\n    function borrow(\\n        Id marketId,\\n        uint256 cash\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        _borrow(marketId, cash);\\n    }\\n\\n    function repay(Id marketId, uint256 cash) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        _repay(marketId, cash);\\n    }\\n\\n    function repayShares(\\n        Id marketId,\\n        uint256 shares\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        _repayShares(marketId, shares);\\n    }\\n\\n    function supplyCollateral(\\n        Id marketId,\\n        uint256 assets\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        if (assets == 0) assets = collateral.balanceOf(address(this));\\n        _supplyCollateral(marketId, assets);\\n    }\\n\\n    function withdrawCollateral(\\n        Id marketId,\\n        uint256 assets\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        _withdrawCollateral(marketId, assets);\\n    }\\n\\n    function withdrawAllCollateral(\\n        Id marketId\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        // Check that the market is already added\\n        _checkMarket(marketId);\\n\\n        Position memory pos = morpho.position(marketId, address(this));\\n        _withdrawCollateral(marketId, pos.collateral);\\n    }\\n\\n    /// @notice Allows a slippage-checked swap from wstETH to WETH\\n    /// @param assets Collateral to swap, if 0 use balance of wstETH in the contract\\n    function swapToCurrency(uint256 assets) external onlyRole(OPERATOR_ROLE) {\\n        if (assets == 0) assets = collateral.balanceOf(address(this));\\n        _swapToCurrency(assets);\\n    }\\n\\n    /// @notice Allows a slippage-checked from currency to collateral\\n    /// @param cash Amount of currency to swap, if 0 use balance of currency in the contract\\n    function swapToCollateral(uint256 cash) external onlyRole(OPERATOR_ROLE) {\\n        if (cash == 0) cash = currency.balanceOf(address(this));\\n        _swapToCollateral(cash);\\n    }\\n\\n    ///////////////////////////////////////////\\n    // LOW LEVEL FUNCTIONS\\n    ///////////////////////////////////////////\\n    function _checkMarket(Id marketId) internal {\\n        require(marketsMap[marketId] == true, \\\"Market is not allowed\\\");\\n    }\\n\\n    /// @param cash Amount of currency to borrow\\n    function _borrow(Id marketId, uint256 cash) internal {\\n        morpho.borrow(\\n            morpho.idToMarketParams(marketId),\\n            cash,\\n            0,\\n            address(this),\\n            address(this)\\n        );\\n    }\\n\\n    /// @param cash Amount of currency to repay\\n    function _repay(Id marketId, uint256 cash) internal {\\n        currency.approve(address(morpho), cash);\\n        morpho.repay(\\n            morpho.idToMarketParams(marketId),\\n            cash,\\n            0,\\n            address(this),\\n            NULL_DATA\\n        );\\n    }\\n\\n    /// @param shares 18 decimals\\n    function _repayShares(Id marketId, uint256 shares) internal {\\n        currency.approve(address(morpho), type(uint256).max);\\n        morpho.repay(\\n            morpho.idToMarketParams(marketId),\\n            0,\\n            shares,\\n            address(this),\\n            NULL_DATA\\n        );\\n        currency.approve(address(morpho), 0);\\n    }\\n\\n    /// @notice will repay amount as asset of it doesn't work will repay all the borrow shares\\n    /// @param cash 18 decimals\\n    function _repayCurrencyFallbackShares(Id marketId, uint256 cash) internal {\\n        MarketParams memory marketParams = morpho.idToMarketParams(marketId);\\n        currency.approve(address(morpho), cash);\\n        try\\n            morpho.repay(marketParams, cash, 0, address(this), NULL_DATA)\\n        returns (uint256, uint256) {} catch {\\n            Position memory p = morpho.position(marketId, address(this));\\n            if (p.borrowShares > 0)\\n                morpho.repay(\\n                    marketParams,\\n                    0,\\n                    p.borrowShares,\\n                    address(this),\\n                    NULL_DATA\\n                );\\n            // If there is some remain we put it back as collateral\\n            uint256 dust = currency.balanceOf(address(this));\\n            minExpected = 0; // Disable expectation and fallback on maxSlippage\\n            uint256 dustCollateral = _swapToCollateral(dust);\\n            _supplyCollateral(marketId, dustCollateral);\\n        }\\n    }\\n\\n    /// @param marketId market to use\\n    /// @param assets in collateral term\\n    function _supplyCollateral(Id marketId, uint256 assets) internal {\\n        collateral.approve(address(morpho), assets);\\n        morpho.supplyCollateral(\\n            morpho.idToMarketParams(marketId),\\n            assets,\\n            address(this),\\n            NULL_DATA\\n        );\\n    }\\n\\n    /// @param marketId market to use\\n    /// @param assets in collateral term\\n    function _withdrawCollateral(Id marketId, uint256 assets) internal {\\n        morpho.withdrawCollateral(\\n            morpho.idToMarketParams(marketId),\\n            assets,\\n            address(this),\\n            address(this)\\n        );\\n    }\\n\\n    /// @notice Swap assets collateral in the contract for currency. Check for slippage.\\n    /// @param assets Quantity of collateral to sell\\n    /// @return cash Quantity of currency obtained\\n    function _swapToCurrency(uint256 assets) internal returns (uint256 cash) {\\n        collateral.approve(address(swapper), assets);\\n        cash = swapper.sell(collateral, currency, assets);\\n        require(\\n            cash > minCurrency(assets),\\n            \\\"Less assets generated than expected\\\"\\n        );\\n        return cash;\\n    }\\n\\n    /// @notice Swap the WETH in the contract to wstETH. Check for slippage.\\n    function _swapToCollateral(uint256 cash) internal returns (uint256 assets) {\\n        currency.approve(address(swapper), cash);\\n        assets = swapper.sell(currency, collateral, cash);\\n        require(\\n            assets > minCollateral(cash),\\n            \\\"Less collateral generated than expected\\\"\\n        );\\n        return assets;\\n    }\\n\\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    ///////////////////////////////////////////\\n    // RECOVER AND UNSTUCK FUNCTION\\n    ///////////////////////////////////////////\\n    function recoverLost(\\n        IERC20 token,\\n        address where,\\n        uint256 amount\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        token.transfer(where, amount);\\n    }\\n\\n    function recover(\\n        IERC20 token,\\n        address where\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        token.transfer(where, token.balanceOf(address(this)));\\n    }\\n\\n    function recoverETH() external payable onlyRole(DEFAULT_ADMIN_ROLE) {\\n        (bool os, ) = payable(msg.sender).call{value: address(this).balance}(\\n            \\\"\\\"\\n        );\\n        require(os);\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address where,\\n        uint256 amount\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        token.approve(where, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title IOracle\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Interface that oracles used by Morpho must implement.\\n/// @dev It is the user's responsibility to select markets with safe oracles.\\ninterface IOracle {\\n    /// @notice Returns the price of 1 asset of collateral token quoted in 1 asset of loan token, scaled by 1e36.\\n    /// @dev It corresponds to the price of 10**(collateral token decimals) assets of collateral token quoted in\\n    /// 10**(loan token decimals) assets of loan token with `36 + loan token decimals - collateral token decimals`\\n    /// decimals of precision.\\n    function price() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IMorpho.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\ntype Id is bytes32;\\n\\nstruct MarketParams {\\n    address loanToken;\\n    address collateralToken;\\n    address oracle;\\n    address irm;\\n    uint256 lltv;\\n}\\n\\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n/// accrual.\\nstruct Position {\\n    uint256 supplyShares;\\n    uint128 borrowShares;\\n    uint128 collateral;\\n}\\n\\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\\n/// interest accrual.\\nstruct Market {\\n    uint128 totalSupplyAssets;\\n    uint128 totalSupplyShares;\\n    uint128 totalBorrowAssets;\\n    uint128 totalBorrowShares;\\n    uint128 lastUpdate;\\n    uint128 fee;\\n}\\n\\nstruct Authorization {\\n    address authorizer;\\n    address authorized;\\n    bool isAuthorized;\\n    uint256 nonce;\\n    uint256 deadline;\\n}\\n\\nstruct Signature {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoBase {\\n    /// @notice The EIP-712 domain separator.\\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\\n    /// the same chain id because the domain separator would be the same.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice The owner of the contract.\\n    /// @dev It has the power to change the owner.\\n    /// @dev It has the power to set fees on markets and set the fee recipient.\\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\\n    function owner() external view returns (address);\\n\\n    /// @notice The fee recipient of all markets.\\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\\n    function feeRecipient() external view returns (address);\\n\\n    /// @notice Whether the `irm` is enabled.\\n    function isIrmEnabled(address irm) external view returns (bool);\\n\\n    /// @notice Whether the `lltv` is enabled.\\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\\n\\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s position on all markets.\\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\\n\\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\\n    function nonce(address authorizer) external view returns (uint256);\\n\\n    /// @notice Sets `newOwner` as `owner` of the contract.\\n    /// @dev Warning: No two-step transfer ownership.\\n    /// @dev Warning: The owner can be set to the zero address.\\n    function setOwner(address newOwner) external;\\n\\n    /// @notice Enables `irm` as a possible IRM for market creation.\\n    /// @dev Warning: It is not possible to disable an IRM.\\n    function enableIrm(address irm) external;\\n\\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\\n    /// @dev Warning: It is not possible to disable a LLTV.\\n    function enableLltv(uint256 lltv) external;\\n\\n    /// @notice Sets the `newFee` for the given market `marketParams`.\\n    /// @param newFee The new fee, scaled by WAD.\\n    /// @dev Warning: The recipient can be the zero address.\\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\\n\\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\\n    function setFeeRecipient(address newFeeRecipient) external;\\n\\n    /// @notice Creates the market `marketParams`.\\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\\n    /// Morpho behaves as expected:\\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\\n    /// burn functions are not supported.\\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\\n    /// - The IRM should not re-enter Morpho.\\n    /// - The oracle should return a price with the correct scaling.\\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\\n    /// (funds could get stuck):\\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\\n    /// `toSharesDown` overflow.\\n    /// - The IRM can revert on `borrowRate`.\\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\\n    /// overflow.\\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\\n    /// `liquidate` from being used under certain market conditions.\\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\\n    function createMarket(MarketParams memory marketParams) external;\\n\\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoSupply` function with the given `data`.\\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\n    /// caller is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific\\n    /// amount of shares is given for full compatibility and precision.\\n    /// @dev Supplying a large amount can revert for overflow.\\n    /// @dev Supplying an amount of shares may lead to supply more or fewer assets than expected due to slippage.\\n    /// Consider using the `assets` parameter to avoid this.\\n    /// @param marketParams The market to supply assets to.\\n    /// @param assets The amount of assets to supply.\\n    /// @param shares The amount of shares to mint.\\n    /// @param onBehalf The address that will own the increased supply position.\\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\\n    /// @return assetsSupplied The amount of assets supplied.\\n    /// @return sharesSupplied The amount of shares minted.\\n    function supply(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        bytes memory data\\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\\n\\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\\n    /// conversion roundings between shares and assets.\\n    /// @param marketParams The market to withdraw assets from.\\n    /// @param assets The amount of assets to withdraw.\\n    /// @param shares The amount of shares to burn.\\n    /// @param onBehalf The address of the owner of the supply position.\\n    /// @param receiver The address that will receive the withdrawn assets.\\n    /// @return assetsWithdrawn The amount of assets withdrawn.\\n    /// @return sharesWithdrawn The amount of shares burned.\\n    function withdraw(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        address receiver\\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\\n\\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\n    /// caller is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is\\n    /// given for full compatibility and precision.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Borrowing a large amount can revert for overflow.\\n    /// @dev Borrowing an amount of shares may lead to borrow fewer assets than expected due to slippage.\\n    /// Consider using the `assets` parameter to avoid this.\\n    /// @param marketParams The market to borrow assets from.\\n    /// @param assets The amount of assets to borrow.\\n    /// @param shares The amount of shares to mint.\\n    /// @param onBehalf The address that will own the increased borrow position.\\n    /// @param receiver The address that will receive the borrowed assets.\\n    /// @return assetsBorrowed The amount of assets borrowed.\\n    /// @return sharesBorrowed The amount of shares minted.\\n    function borrow(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        address receiver\\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\\n\\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoReplay` function with the given `data`.\\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\\n    /// roundings between shares and assets.\\n    /// @dev An attacker can front-run a repay with a small repay making the transaction revert for underflow.\\n    /// @param marketParams The market to repay assets to.\\n    /// @param assets The amount of assets to repay.\\n    /// @param shares The amount of shares to burn.\\n    /// @param onBehalf The address of the owner of the debt position.\\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\\n    /// @return assetsRepaid The amount of assets repaid.\\n    /// @return sharesRepaid The amount of shares burned.\\n    function repay(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        bytes memory data\\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\\n\\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoSupplyCollateral` function with the given `data`.\\n    /// @dev Interest are not accrued since it's not required and it saves gas.\\n    /// @dev Supplying a large amount can revert for overflow.\\n    /// @param marketParams The market to supply collateral to.\\n    /// @param assets The amount of collateral to supply.\\n    /// @param onBehalf The address that will own the increased collateral position.\\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\\n        external;\\n\\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` and sends the assets to `receiver`.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\\n    /// @param marketParams The market to withdraw collateral from.\\n    /// @param assets The amount of collateral to withdraw.\\n    /// @param onBehalf The address of the owner of the collateral position.\\n    /// @param receiver The address that will receive the collateral assets.\\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\\n        external;\\n\\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\\n    /// `onMorphoLiquidate` function with the given `data`.\\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\\n    /// @dev An attacker can front-run a liquidation with a small repay making the transaction revert for underflow.\\n    /// @param marketParams The market of the position.\\n    /// @param borrower The owner of the position.\\n    /// @param seizedAssets The amount of collateral to seize.\\n    /// @param repaidShares The amount of shares to repay.\\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\\n    /// @return The amount of assets seized.\\n    /// @return The amount of assets repaid.\\n    function liquidate(\\n        MarketParams memory marketParams,\\n        address borrower,\\n        uint256 seizedAssets,\\n        uint256 repaidShares,\\n        bytes memory data\\n    ) external returns (uint256, uint256);\\n\\n    /// @notice Executes a flash loan.\\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\\n    /// markets combined, plus donations).\\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\\n    /// - `flashFee` is zero.\\n    /// - `maxFlashLoan` is the token's balance of this contract.\\n    /// - The receiver of `assets` is the caller.\\n    /// @param token The token to flash loan.\\n    /// @param assets The amount of assets to flash loan.\\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\\n\\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\\n    /// @param authorized The authorized address.\\n    /// @param newIsAuthorized The new authorization status.\\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\\n\\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\\n    /// @dev Warning: Reverts if the signature has already been submitted.\\n    /// @dev The signature is malleable, but it has no impact on the security here.\\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\\n    /// @param authorization The `Authorization` struct.\\n    /// @param signature The signature.\\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\\n\\n    /// @notice Accrues interest for the given market `marketParams`.\\n    function accrueInterest(MarketParams memory marketParams) external;\\n\\n    /// @notice Returns the data stored on the different `slots`.\\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\\n}\\n\\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoStaticTyping is IMorphoBase {\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n    /// accrual.\\n    function position(Id id, address user)\\n        external\\n        view\\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\\n\\n    /// @notice The state of the market corresponding to `id`.\\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\\n    /// accrual.\\n    function market(Id id)\\n        external\\n        view\\n        returns (\\n            uint128 totalSupplyAssets,\\n            uint128 totalSupplyShares,\\n            uint128 totalBorrowAssets,\\n            uint128 totalBorrowShares,\\n            uint128 lastUpdate,\\n            uint128 fee\\n        );\\n\\n    /// @notice The market params corresponding to `id`.\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n    function idToMarketParams(Id id)\\n        external\\n        view\\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\\n}\\n\\n/// @title IMorpho\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\\ninterface IMorpho is IMorphoBase {\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\\n    /// accrual.\\n    function position(Id id, address user) external view returns (Position memory p);\\n\\n    /// @notice The state of the market corresponding to `id`.\\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\\n    /// interest accrual.\\n    function market(Id id) external view returns (Market memory m);\\n\\n    /// @notice The market params corresponding to `id`.\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title IMorphoLiquidateCallback\\n/// @notice Interface that liquidators willing to use `liquidate`'s callback must implement.\\ninterface IMorphoLiquidateCallback {\\n    /// @notice Callback called when a liquidation occurs.\\n    /// @dev The callback is called only if data is not empty.\\n    /// @param repaidAssets The amount of repaid assets.\\n    /// @param data Arbitrary data passed to the `liquidate` function.\\n    function onMorphoLiquidate(uint256 repaidAssets, bytes calldata data) external;\\n}\\n\\n/// @title IMorphoRepayCallback\\n/// @notice Interface that users willing to use `repay`'s callback must implement.\\ninterface IMorphoRepayCallback {\\n    /// @notice Callback called when a repayment occurs.\\n    /// @dev The callback is called only if data is not empty.\\n    /// @param assets The amount of repaid assets.\\n    /// @param data Arbitrary data passed to the `repay` function.\\n    function onMorphoRepay(uint256 assets, bytes calldata data) external;\\n}\\n\\n/// @title IMorphoSupplyCallback\\n/// @notice Interface that users willing to use `supply`'s callback must implement.\\ninterface IMorphoSupplyCallback {\\n    /// @notice Callback called when a supply occurs.\\n    /// @dev The callback is called only if data is not empty.\\n    /// @param assets The amount of supplied assets.\\n    /// @param data Arbitrary data passed to the `supply` function.\\n    function onMorphoSupply(uint256 assets, bytes calldata data) external;\\n}\\n\\n/// @title IMorphoSupplyCollateralCallback\\n/// @notice Interface that users willing to use `supplyCollateral`'s callback must implement.\\ninterface IMorphoSupplyCollateralCallback {\\n    /// @notice Callback called when a supply of collateral occurs.\\n    /// @dev The callback is called only if data is not empty.\\n    /// @param assets The amount of supplied collateral.\\n    /// @param data Arbitrary data passed to the `supplyCollateral` function.\\n    function onMorphoSupplyCollateral(uint256 assets, bytes calldata data) external;\\n}\\n\\n/// @title IMorphoFlashLoanCallback\\n/// @notice Interface that users willing to use `flashLoan`'s callback must implement.\\ninterface IMorphoFlashLoanCallback {\\n    /// @notice Callback called when a flash loan occurs.\\n    /// @dev The callback is called only if data is not empty.\\n    /// @param assets The amount of assets that was flash loaned.\\n    /// @param data Arbitrary data passed to the `flashLoan` function.\\n    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/MathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nuint256 constant WAD = 1e18;\\n\\n/// @title MathLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library to manage fixed-point arithmetic.\\nlibrary MathLib {\\n    /// @dev Returns (`x` * `y`) / `WAD` rounded down.\\n    function wMulDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n    }\\n\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded down.\\n    function wDivDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n    }\\n\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded up.\\n    function wDivUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n    }\\n\\n    /// @dev Returns (`x` * `y`) / `d` rounded down.\\n    function mulDivDown(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\n        return (x * y) / d;\\n    }\\n\\n    /// @dev Returns (`x` * `y`) / `d` rounded up.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\n        return (x * y + (d - 1)) / d;\\n    }\\n\\n    /// @dev Returns the sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1, to approximate a\\n    /// continuous compound interest rate.\\n    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 firstTerm = x * n;\\n        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD);\\n        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);\\n\\n        return firstTerm + secondTerm + thirdTerm;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {Id, MarketParams, Market, IMorpho} from \\\"../../interfaces/IMorpho.sol\\\";\\nimport {IIrm} from \\\"../../interfaces/IIrm.sol\\\";\\n\\nimport {MathLib} from \\\"../MathLib.sol\\\";\\nimport {UtilsLib} from \\\"../UtilsLib.sol\\\";\\nimport {MorphoLib} from \\\"./MorphoLib.sol\\\";\\nimport {SharesMathLib} from \\\"../SharesMathLib.sol\\\";\\nimport {MarketParamsLib} from \\\"../MarketParamsLib.sol\\\";\\n\\n/// @title MorphoBalancesLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library exposing getters with the expected value after interest accrual.\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\n/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply\\n/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.\\nlibrary MorphoBalancesLib {\\n    using MathLib for uint256;\\n    using MathLib for uint128;\\n    using UtilsLib for uint256;\\n    using MorphoLib for IMorpho;\\n    using SharesMathLib for uint256;\\n    using MarketParamsLib for MarketParams;\\n\\n    /// @notice Returns the expected market balances of a market after having accrued interest.\\n    /// @return The expected total supply assets.\\n    /// @return The expected total supply shares.\\n    /// @return The expected total borrow assets.\\n    /// @return The expected total borrow shares.\\n    function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256, uint256, uint256, uint256)\\n    {\\n        Id id = marketParams.id();\\n        Market memory market = morpho.market(id);\\n\\n        uint256 elapsed = block.timestamp - market.lastUpdate;\\n\\n        // Skipped if elapsed == 0 or totalBorrowAssets == 0 because interest would be null, or if irm == address(0).\\n        if (elapsed != 0 && market.totalBorrowAssets != 0 && marketParams.irm != address(0)) {\\n            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\\n            uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\\n            market.totalBorrowAssets += interest.toUint128();\\n            market.totalSupplyAssets += interest.toUint128();\\n\\n            if (market.fee != 0) {\\n                uint256 feeAmount = interest.wMulDown(market.fee);\\n                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact\\n                // that total supply is already updated.\\n                uint256 feeShares =\\n                    feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);\\n                market.totalSupplyShares += feeShares.toUint128();\\n            }\\n        }\\n\\n        return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);\\n    }\\n\\n    /// @notice Returns the expected total supply assets of a market after having accrued interest.\\n    function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalSupplyAssets)\\n    {\\n        (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected total borrow assets of a market after having accrued interest.\\n    function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalBorrowAssets)\\n    {\\n        (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected total supply shares of a market after having accrued interest.\\n    function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalSupplyShares)\\n    {\\n        (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.\\n    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.\\n    /// @dev Warning: Withdrawing using the expected supply assets can lead to a revert due to conversion roundings from\\n    /// assets to shares.\\n    function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Id id = marketParams.id();\\n        uint256 supplyShares = morpho.supplyShares(id, user);\\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\n\\n        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\\n    }\\n\\n    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.\\n    /// @dev Warning: The expected balance is rounded up, so it may be greater than the market's expected total borrow\\n    /// assets.\\n    function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Id id = marketParams.id();\\n        uint256 borrowShares = morpho.borrowShares(id, user);\\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);\\n\\n        return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IChainlinkOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport {IERC4626} from \\\"../../lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\\\";\\nimport {AggregatorV3Interface} from \\\"./AggregatorV3Interface.sol\\\";\\nimport {IOracle} from \\\"../../lib/morpho-blue/src/interfaces/IOracle.sol\\\";\\n\\n/// @title IChainlinkOracle\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Interface of ChainlinkOracle.\\ninterface IChainlinkOracle is IOracle {\\n    /// @notice Returns the address of the ERC4626 vault.\\n    function VAULT() external view returns (IERC4626);\\n\\n    /// @notice Returns the vault conversion sample.\\n    function VAULT_CONVERSION_SAMPLE() external view returns (uint256);\\n\\n    /// @notice Returns the address of the first Chainlink base feed.\\n    function BASE_FEED_1() external view returns (AggregatorV3Interface);\\n\\n    /// @notice Returns the address of the second Chainlink base feed.\\n    function BASE_FEED_2() external view returns (AggregatorV3Interface);\\n\\n    /// @notice Returns the address of the first Chainlink quote feed.\\n    function QUOTE_FEED_1() external view returns (AggregatorV3Interface);\\n\\n    /// @notice Returns the address of the second Chainlink quote feed.\\n    function QUOTE_FEED_2() external view returns (AggregatorV3Interface);\\n\\n    /// @notice Returns the price scale factor, calculated at contract creation.\\n    function SCALE_FACTOR() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface ISwapper {\\n    /**\\n     * @notice Sell from tokenFrom to tokenTo, need to approuve first\\n     * @param amountIn number of token to sell (tokenFrom), 0 means sell all\\n     */\\n    function sell(\\n        IERC20 tokenFrom,\\n        IERC20 tokenTo,\\n        uint256 amountIn\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Preview from tokenFrom to tokenTo and return the amount you would get\\n     * @param amountIn number of token to sell (tokenFrom), 0 means sell all\\n     */\\n    function previewSell(\\n        IERC20 tokenFrom,\\n        IERC20 tokenTo,\\n        uint256 amountIn\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMorphoReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {Id} from \\\"../../lib/morpho-blue/src/interfaces/IMorpho.sol\\\";\\n\\nstruct MarketDataExt {\\n    uint256 totalSupplyAssets;\\n    uint256 totalSupplyShares;\\n    uint256 totalBorrowAssets;\\n    uint256 totalBorrowShares;\\n    uint256 fee;\\n    uint256 utilization;\\n    uint256 supplyRate;\\n    uint256 borrowRate;\\n}\\n\\nstruct PositionExt {\\n    uint256 suppliedShares;\\n    uint256 suppliedAssets;\\n    uint256 borrowedShares;\\n    uint256 borrowedAssets;\\n    uint256 collateral;\\n    uint256 collateralValue;\\n    uint256 ltv;\\n    uint256 healthFactor;\\n}\\n\\ninterface IMorphoReader {\\n    function getMarketData(Id id) external view returns (MarketDataExt memory);\\n\\n    function getPosition(\\n        Id id,\\n        address user\\n    ) external view returns (PositionExt memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWsteth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from \\\"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface IWsteth is IERC20 {\\n    function getWstETHByStETH(\\n        uint256 _stETHAmount\\n    ) external view returns (uint256);\\n\\n    function getStETHByWstETH(\\n        uint256 _wstETHAmount\\n    ) external view returns (uint256);\\n\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IIrm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport {MarketParams, Market} from \\\"./IMorpho.sol\\\";\\n\\n/// @title IIrm\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Interface that Interest Rate Models (IRMs) used by Morpho must implement.\\ninterface IIrm {\\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams`.\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256);\\n\\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams` without modifying any\\n    /// storage.\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/UtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {ErrorsLib} from \\\"../libraries/ErrorsLib.sol\\\";\\n\\n/// @title UtilsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library exposing helpers.\\n/// @dev Inspired by https://github.com/morpho-org/morpho-utils.\\nlibrary UtilsLib {\\n    /// @dev Returns true if there is exactly one zero among `x` and `y`.\\n    function exactlyOneZero(uint256 x, uint256 y) internal pure returns (bool z) {\\n        assembly {\\n            z := xor(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @dev Returns the min of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` safely cast to uint128.\\n    function toUint128(uint256 x) internal pure returns (uint128) {\\n        require(x <= type(uint128).max, ErrorsLib.MAX_UINT128_EXCEEDED);\\n        return uint128(x);\\n    }\\n\\n    /// @dev Returns max(0, x - y).\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IMorpho, Id} from \\\"../../interfaces/IMorpho.sol\\\";\\nimport {MorphoStorageLib} from \\\"./MorphoStorageLib.sol\\\";\\n\\n/// @title MorphoLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library to access Morpho storage variables.\\n/// @dev Warning: Supply and borrow getters may return outdated values that do not include accrued interest.\\nlibrary MorphoLib {\\n    function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));\\n        return uint256(morpho.extSloads(slot)[0]);\\n    }\\n\\n    function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function fee(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function _array(bytes32 x) private pure returns (bytes32[] memory) {\\n        bytes32[] memory res = new bytes32[](1);\\n        res[0] = x;\\n        return res;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/SharesMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {MathLib} from \\\"./MathLib.sol\\\";\\n\\n/// @title SharesMathLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Shares management library.\\n/// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\\n/// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\\nlibrary SharesMathLib {\\n    using MathLib for uint256;\\n\\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\\n    /// high precision computations.\\n    /// @dev Virtual shares can never be redeemed for the assets they are entitled to, but it is assumed the share price\\n    /// stays low enough not to inflate these assets to a significant value.\\n    /// @dev Warning: The assets to which virtual borrow shares are entitled behave like unrealizable bad debt.\\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\\n\\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\\n    /// empty.\\n    uint256 internal constant VIRTUAL_ASSETS = 1;\\n\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding down.\\n    function toSharesDown(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return assets.mulDivDown(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\n    }\\n\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding down.\\n    function toAssetsDown(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\n    }\\n\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding up.\\n    function toSharesUp(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return assets.mulDivUp(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\n    }\\n\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding up.\\n    function toAssetsUp(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return shares.mulDivUp(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/MarketParamsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {Id, MarketParams} from \\\"../interfaces/IMorpho.sol\\\";\\n\\n/// @title MarketParamsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library to convert a market to its id.\\nlibrary MarketParamsLib {\\n    /// @notice The length of the data used to compute the id of a market.\\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\\n\\n    /// @notice Returns the id of the market `marketParams`.\\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\\n        assembly (\\\"memory-safe\\\") {\\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n/// @dev From\\n/// https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/ErrorsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title ErrorsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library exposing error messages.\\nlibrary ErrorsLib {\\n    /// @notice Thrown when the caller is not the owner.\\n    string internal constant NOT_OWNER = \\\"not owner\\\";\\n\\n    /// @notice Thrown when the LLTV to enable exceeds the maximum LLTV.\\n    string internal constant MAX_LLTV_EXCEEDED = \\\"max LLTV exceeded\\\";\\n\\n    /// @notice Thrown when the fee to set exceeds the maximum fee.\\n    string internal constant MAX_FEE_EXCEEDED = \\\"max fee exceeded\\\";\\n\\n    /// @notice Thrown when the value is already set.\\n    string internal constant ALREADY_SET = \\\"already set\\\";\\n\\n    /// @notice Thrown when the IRM is not enabled at market creation.\\n    string internal constant IRM_NOT_ENABLED = \\\"IRM not enabled\\\";\\n\\n    /// @notice Thrown when the LLTV is not enabled at market creation.\\n    string internal constant LLTV_NOT_ENABLED = \\\"LLTV not enabled\\\";\\n\\n    /// @notice Thrown when the market is already created.\\n    string internal constant MARKET_ALREADY_CREATED = \\\"market already created\\\";\\n\\n    /// @notice Thrown when a token to transfer doesn't have code.\\n    string internal constant NO_CODE = \\\"no code\\\";\\n\\n    /// @notice Thrown when the market is not created.\\n    string internal constant MARKET_NOT_CREATED = \\\"market not created\\\";\\n\\n    /// @notice Thrown when not exactly one of the input amount is zero.\\n    string internal constant INCONSISTENT_INPUT = \\\"inconsistent input\\\";\\n\\n    /// @notice Thrown when zero assets is passed as input.\\n    string internal constant ZERO_ASSETS = \\\"zero assets\\\";\\n\\n    /// @notice Thrown when a zero address is passed as input.\\n    string internal constant ZERO_ADDRESS = \\\"zero address\\\";\\n\\n    /// @notice Thrown when the caller is not authorized to conduct an action.\\n    string internal constant UNAUTHORIZED = \\\"unauthorized\\\";\\n\\n    /// @notice Thrown when the collateral is insufficient to `borrow` or `withdrawCollateral`.\\n    string internal constant INSUFFICIENT_COLLATERAL = \\\"insufficient collateral\\\";\\n\\n    /// @notice Thrown when the liquidity is insufficient to `withdraw` or `borrow`.\\n    string internal constant INSUFFICIENT_LIQUIDITY = \\\"insufficient liquidity\\\";\\n\\n    /// @notice Thrown when the position to liquidate is healthy.\\n    string internal constant HEALTHY_POSITION = \\\"position is healthy\\\";\\n\\n    /// @notice Thrown when the authorization signature is invalid.\\n    string internal constant INVALID_SIGNATURE = \\\"invalid signature\\\";\\n\\n    /// @notice Thrown when the authorization signature is expired.\\n    string internal constant SIGNATURE_EXPIRED = \\\"signature expired\\\";\\n\\n    /// @notice Thrown when the nonce is invalid.\\n    string internal constant INVALID_NONCE = \\\"invalid nonce\\\";\\n\\n    /// @notice Thrown when a token transfer reverted.\\n    string internal constant TRANSFER_REVERTED = \\\"transfer reverted\\\";\\n\\n    /// @notice Thrown when a token transfer returned false.\\n    string internal constant TRANSFER_RETURNED_FALSE = \\\"transfer returned false\\\";\\n\\n    /// @notice Thrown when a token transferFrom reverted.\\n    string internal constant TRANSFER_FROM_REVERTED = \\\"transferFrom reverted\\\";\\n\\n    /// @notice Thrown when a token transferFrom returned false\\n    string internal constant TRANSFER_FROM_RETURNED_FALSE = \\\"transferFrom returned false\\\";\\n\\n    /// @notice Thrown when the maximum uint128 is exceeded.\\n    string internal constant MAX_UINT128_EXCEEDED = \\\"max uint128 exceeded\\\";\\n}\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoStorageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {Id} from \\\"../../interfaces/IMorpho.sol\\\";\\n\\n/// @title MorphoStorageLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library exposing getters to access Morpho storage variables' slot.\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\nlibrary MorphoStorageLib {\\n    /* SLOTS */\\n\\n    uint256 internal constant OWNER_SLOT = 0;\\n    uint256 internal constant FEE_RECIPIENT_SLOT = 1;\\n    uint256 internal constant POSITION_SLOT = 2;\\n    uint256 internal constant MARKET_SLOT = 3;\\n    uint256 internal constant IS_IRM_ENABLED_SLOT = 4;\\n    uint256 internal constant IS_LLTV_ENABLED_SLOT = 5;\\n    uint256 internal constant IS_AUTHORIZED_SLOT = 6;\\n    uint256 internal constant NONCE_SLOT = 7;\\n    uint256 internal constant ID_TO_MARKET_PARAMS_SLOT = 8;\\n\\n    /* SLOT OFFSETS */\\n\\n    uint256 internal constant LOAN_TOKEN_OFFSET = 0;\\n    uint256 internal constant COLLATERAL_TOKEN_OFFSET = 1;\\n    uint256 internal constant ORACLE_OFFSET = 2;\\n    uint256 internal constant IRM_OFFSET = 3;\\n    uint256 internal constant LLTV_OFFSET = 4;\\n\\n    uint256 internal constant SUPPLY_SHARES_OFFSET = 0;\\n    uint256 internal constant BORROW_SHARES_AND_COLLATERAL_OFFSET = 1;\\n\\n    uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;\\n    uint256 internal constant TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1;\\n    uint256 internal constant LAST_UPDATE_AND_FEE_OFFSET = 2;\\n\\n    /* GETTERS */\\n\\n    function ownerSlot() internal pure returns (bytes32) {\\n        return bytes32(OWNER_SLOT);\\n    }\\n\\n    function feeRecipientSlot() internal pure returns (bytes32) {\\n        return bytes32(FEE_RECIPIENT_SLOT);\\n    }\\n\\n    function positionSupplySharesSlot(Id id, address user) internal pure returns (bytes32) {\\n        return bytes32(\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET\\n        );\\n    }\\n\\n    function positionBorrowSharesAndCollateralSlot(Id id, address user) internal pure returns (bytes32) {\\n        return bytes32(\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT)))))\\n                + BORROW_SHARES_AND_COLLATERAL_OFFSET\\n        );\\n    }\\n\\n    function marketTotalSupplyAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET);\\n    }\\n\\n    function marketTotalBorrowAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET);\\n    }\\n\\n    function marketLastUpdateAndFeeSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET);\\n    }\\n\\n    function isIrmEnabledSlot(address irm) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(irm, IS_IRM_ENABLED_SLOT));\\n    }\\n\\n    function isLltvEnabledSlot(uint256 lltv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(lltv, IS_LLTV_ENABLED_SLOT));\\n    }\\n\\n    function isAuthorizedSlot(address authorizer, address authorizee) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(authorizee, keccak256(abi.encode(authorizer, IS_AUTHORIZED_SLOT))));\\n    }\\n\\n    function nonceSlot(address authorizer) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(authorizer, NONCE_SLOT));\\n    }\\n\\n    function idToLoanTokenSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET);\\n    }\\n\\n    function idToCollateralTokenSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET);\\n    }\\n\\n    function idToOracleSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET);\\n    }\\n\\n    function idToIrmSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET);\\n    }\\n\\n    function idToLltvSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-auth/=lib/dss-psm/lib/dss/lib/ds-token/lib/ds-auth/src/\",\r\n      \"ds-math/=lib/dss-psm/lib/dss/lib/ds-token/lib/ds-math/src/\",\r\n      \"ds-note/=lib/dss-psm/lib/dss/lib/ds-value/lib/ds-thing/lib/ds-note/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"ds-thing/=lib/dss-psm/lib/dss/lib/ds-value/lib/ds-thing/src/\",\r\n      \"ds-token/=lib/dss-psm/lib/dss/lib/ds-token/src/\",\r\n      \"ds-value/=lib/dss-psm/lib/dss/lib/ds-value/src/\",\r\n      \"dss-interfaces/=lib/dss-psm/lib/dss-interfaces/src/\",\r\n      \"dss-psm/=lib/dss-psm/src/\",\r\n      \"dss/=lib/dss-psm/lib/dss/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"morpho-blue-oracles/=lib/morpho-blue-oracles/src/\",\r\n      \"@morpho-blue-oracles/=lib/morpho-blue-oracles/\",\r\n      \"morpho-blue/=lib/morpho-blue/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"v3-core/=lib/v3-core/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateral_\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle_\",\"type\":\"address\"},{\"internalType\":\"contract ISwapper\",\"name\":\"swapper_\",\"type\":\"address\"},{\"internalType\":\"contract IMorphoReader\",\"name\":\"reader_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"Unwind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exposure\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toBorrow\",\"type\":\"uint256\"}],\"name\":\"Wind\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALLBACK_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"addMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"where\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"availableLiqudidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"availableToBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"collateralNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"deleteMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"equity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"equity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"equityAsCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"equityAsCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"isUnwinded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lltv\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"Id\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"minCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"minCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"morpho\",\"outputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"morphoReader\",\"outputs\":[{\"internalType\":\"contract IMorphoReader\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onMorphoFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onMorphoSupplyCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"priceCollateralInCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"where\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"where\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"repayShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSlippage_\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSlippage_\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippageForce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"sharesBorrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketFrom\",\"type\":\"bytes32\"},{\"internalType\":\"Id\",\"name\":\"marketTo\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"shiftCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketFrom\",\"type\":\"bytes32\"},{\"internalType\":\"Id\",\"name\":\"marketTo\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"shiftCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketFrom\",\"type\":\"bytes32\"},{\"internalType\":\"Id\",\"name\":\"marketTo\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"shiftPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"supplyCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"swapToCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"swapToCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"contract ISwapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"unwind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCash_\",\"type\":\"uint256\"}],\"name\":\"unwind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"}],\"name\":\"wind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAssets_\",\"type\":\"uint256\"}],\"name\":\"wind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"}],\"name\":\"withdrawAllCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DualBot", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000029d4cdfee8f533af8529a9e1517b580e022874f7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000057f5e098cad7a3d1eed53991d4d66c45c9af781200000000000000000000000038ed40ab78d2d00467cedd5b1631c040768cdfca000000000000000000000000cef0ccd2e9ea13356324f53a5f26308e6c3298c7000000000000000000000000b6ea86eb114b780a72de73ed9609ed550df24133", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}