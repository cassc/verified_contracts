/*
 * SPDX-License-Identifier: UNLICENSED
 * Copyright © 2022 Blocksquare d.o.o.
 */
pragma solidity 0.8.14;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

/// @notice A collection of helper functions
interface LPStakingHelpers {
    function mint(address to, uint256 amount) external;

    function owner() external view returns (address);

    function addVestingInfo(address user, uint256 amount)
        external
        returns (bool);
}

/// @title Oceanpoint Liquidity Pool token staking
/// @author David Šenica
/// @notice Allows staking of single Liquidity Pool token generated by Uniswap
contract LPStaking is
    OwnableUpgradeable,
    ERC20Upgradeable,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;

    uint256 private constant _MINIMUM_LOCK_DAYS = 2;
    uint256 private _minDays; // Minimum number of days to lock you asset to get minimum boost
    uint256 private _maxDays; // Maximum number of days to lock you asset to get maximum boost
    uint256 private _minBoost;
    uint256 private _maxBoost;

    uint256 private _tempLPBalanceThis; // Internal amount of temporary LP
    address private _LPToken;

    IERC20 private _rewardToken;

    mapping(address => uint256) private _lockedUntil;
    mapping(address => uint256) private _LPStaked; // Internal LP staked tracker
    mapping(address => uint256) private _tempLP; // Internal temporary LP tracker (calculated from LP amount and boost)

    /// @notice Event triggers every time a deposit is made
    /// @param owner Address of user wallet
    /// @param inAmount Amount of LP staked
    /// @param outAmount Amount of staked LP returned (your share in the pool)
    /// @param lockedUntil Timestamp when withdrawal can be made
    event Deposit(
        address indexed owner,
        uint256 inAmount,
        uint256 outAmount,
        uint256 lockedUntil
    );
    /// @notice Event triggers every time a withdrawal is made
    /// @param owner Address of user wallet
    /// @param inAmount Amount of staked LP
    /// @param outAmount Amount of LP returned
    /// @param reward Amount of BST user got as reward
    event Withdraw(
        address indexed owner,
        uint256 inAmount,
        uint256 outAmount,
        uint256 reward
    );
    /// @notice Event triggers every time a reward is added
    /// @param from Address of user who added reward
    /// @param amount Amount of BST added as reward
    event Reward(address indexed from, uint256 amount);

    event LPStakingInit(
        address indexed lpToken,
        uint256 minDays,
        uint256 maxDays,
        uint256 minBoost,
        uint256 maxBoost
    );

    constructor() {
        // Only interact with this contract through proxy
        _disableInitializers();
    }

    /// @notice Initialize contract. Can only be called once
    /// @param rewardToken Address of reward token (BST token)
    /// @param ownerWallet Address of owner of this contract
    /// @param lpToken Address of LP smart contract
    /// @param minDays Minimum number of days to lock tokens for boost to take effect
    /// @param maxDays Maximum number of days to lock tokens
    /// @param minBoost Minimum boost given when locking for minimum days (supports 2 decimals)
    /// @param maxBoost Maximum boost given when locking for maximum days (supports 2 decimals)
    /// @param tokenName Name of staked LP token
    /// @param tokenSymbol Symbol of staked LP token
    function initialize(
        address rewardToken,
        address ownerWallet,
        address lpToken,
        uint256 minDays,
        uint256 maxDays,
        uint256 minBoost,
        uint256 maxBoost,
        string memory tokenName,
        string memory tokenSymbol
    ) external initializer {
        require(
            rewardToken != address(0) &&
                ownerWallet != address(0) &&
                lpToken != address(0),
            "LPStaking: Address iz zero"
        );
        require(
            maxBoost >= minBoost && maxDays >= minDays,
            "LPStaking: Max must be bigger than min!"
        );
        require(
            minBoost >= 100,
            "LPStaking: Min boost must be bigger or equal to 100"
        );
        _rewardToken = IERC20(rewardToken);
        _transferOwnership(ownerWallet);
        __ERC20_init(tokenName, tokenSymbol);
        _LPToken = lpToken;
        _minDays = minDays;
        _maxDays = maxDays;
        _minBoost = minBoost;
        _maxBoost = maxBoost;
        emit LPStakingInit(lpToken, minDays, maxDays, minBoost, maxBoost);
    }

    /// @notice It withdraws all LP tokens and makes deposit equal to previous staked plus `amount`
    /// @dev Wraps withdraw and deposit for cases when you wish to increase your stake
    function redeposit(uint256 amount, uint256 numberOfDays) external {
        uint256 alreadyIn = _LPStaked[_msgSender()];
        withdraw();
        deposit(alreadyIn + amount, numberOfDays);
    }

    /// @notice Adds `amount` reward
    /// @param amount Amount of reward
    function addReward(uint256 amount) external nonReentrant {
        _rewardToken.safeTransferFrom(_msgSender(), address(this), amount);
        _tempLPBalanceThis += amount;
        emit Reward(_msgSender(), amount);
    }

    /// @notice Get amount of LP staked for `user`
    /// @param user Address of user wallet
    /// @return Amount of LP staked
    function getLPStaked(address user) external view returns (uint256) {
        return _LPStaked[user];
    }

    /// @notice Return current unclaimed reward for given wallet
    /// @param wallet Address to check reward for
    /// @return Reward amount
    function getUnclaimedReward(address wallet)
        external
        view
        returns (uint256)
    {
        if (totalSupply() == 0) {
            return 0;
        }
        uint256 tempLPToReturn = ((balanceOf(wallet) * _tempLPBalanceThis) /
            totalSupply());
        if (tempLPToReturn >= _tempLP[wallet]) {
            return tempLPToReturn - _tempLP[wallet];
        }
        return 0;
    }

    /// @notice Return current configuration for staking
    /// @return LP token address, min days to stake, max days to stake, min boost and max boost
    function getConfiguration()
        external
        view
        returns (
            address,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        return (_LPToken, _minDays, _maxDays, _minBoost, _maxBoost);
    }

    /// @notice Get timestamp until wallet is locked for withdrawal or redeposit
    /// @param wallet Address of wallet
    /// @return Returns timestamp until wallet is locked
    function getLockedUntil(address wallet) external view returns (uint256) {
        return _lockedUntil[wallet];
    }

    /// @notice Deposit LP tokens for staking
    /// @param amount Amount of LP tokens to stake
    /// @param numberOfDays Number of days you want to stake
    function deposit(uint256 amount, uint256 numberOfDays) public nonReentrant {
        require(
            _LPStaked[_msgSender()] == 0,
            "LPStaking: You need to withdraw already staked LP"
        );
        require(
            _MINIMUM_LOCK_DAYS <= numberOfDays && numberOfDays <= _maxDays,
            "LPStaking: Number of days needs to be between 2 and max_days"
        );
        IERC20(_LPToken).safeTransferFrom(_msgSender(), address(this), amount);
        uint256 amountToMint = _updateBeforeStakeStart(
            _msgSender(),
            amount,
            numberOfDays
        );
        _mint(_msgSender(), amountToMint);
    }

    /// @notice It withdraws all LP tokens
    function withdraw() public nonReentrant {
        require(
            _lockedUntil[_msgSender()] < block.timestamp,
            "LPStaking: You need to wait for time lock to expire."
        );
        require(
            balanceOf(_msgSender()) > 0,
            "LPStaking: You need to stake LP first."
        );
        uint256 stakedLP = _updateAtStakeEnd(_msgSender());
        IERC20(_LPToken).safeTransfer(_msgSender(), stakedLP);
    }

    /// @notice Calculate boost given depending on number of days
    /// @param numberOfDays Number of days for boost
    /// @return Boost
    function getBoost(uint256 numberOfDays) public view returns (uint256) {
        if (numberOfDays < _minDays) {
            return 100;
            //100 means 1x so no boost effectively
        }
        if (numberOfDays > _maxDays) {
            return _maxBoost;
        }
        return
            ((numberOfDays - _minDays) * (_maxBoost - _minBoost)) /
            (_maxDays - _minDays) +
            _minBoost;
    }

    /// @notice Calculates sLP based on different LP already in contract and reward
    /// @param user Address of user, making deposit
    /// @param amount Amount of LP tokens being deposited
    /// @param numberOfDays Number of days you want to stake
    /// @return amountsLPToMint Amount of sLP depositor should receive
    function _updateBeforeStakeStart(
        address user,
        uint256 amount,
        uint256 numberOfDays
    ) private returns (uint256 amountsLPToMint) {
        _lockedUntil[user] = block.timestamp + (numberOfDays * 1 days);
        uint256 tempLPAmount = (amount * getBoost(numberOfDays));
        uint256 tempLPBalance = _tempLPBalanceThis;
        uint256 sLPSupply = totalSupply();
        amountsLPToMint = (sLPSupply == 0 || tempLPBalance == 0)
            ? tempLPAmount
            : (tempLPAmount * sLPSupply) / tempLPBalance;
        _LPStaked[user] += amount;
        _tempLPBalanceThis += tempLPAmount;
        _tempLP[user] += tempLPAmount;
        emit Deposit(user, amount, amountsLPToMint, _lockedUntil[user]);
    }

    /// @notice Calculates reward and LP tokens user should get
    /// @param user Address of user
    /// @return stakedLP Amount of LP user staked
    function _updateAtStakeEnd(address user)
        private
        returns (uint256 stakedLP)
    {
        uint256 tempLPBalance = _tempLPBalanceThis;
        uint256 sLPSupply = totalSupply();
        uint256 share = balanceOf(user);
        uint256 tempLPToReturn = ((share * tempLPBalance) / (sLPSupply));
        _burn(user, share);
        uint256 reward = 0;
        if (tempLPToReturn >= _tempLP[user]) {
            reward = tempLPToReturn - _tempLP[user];
        }
        _tempLP[user] = 0;
        if (_tempLPBalanceThis < tempLPToReturn) {
            _tempLPBalanceThis = 0;
        } else {
            _tempLPBalanceThis -= tempLPToReturn;
        }
        _rewardToken.safeTransfer(user, reward);
        stakedLP = _LPStaked[user];
        _LPStaked[_msgSender()] = 0;
        emit Withdraw(user, share, stakedLP, reward);
    }

    /// @dev Don't allow the transfer of sLP (sLP token is only used for tracking share)
    function _transfer(
        address,
        address,
        uint256
    ) internal pure override {
        revert("sLP is non transferable");
    }
}