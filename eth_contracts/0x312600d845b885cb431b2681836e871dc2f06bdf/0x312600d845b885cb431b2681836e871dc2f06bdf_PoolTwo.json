{"SourceCode": "// SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n \r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\ncontract PoolTwo {\r\n    uint256 private constant MINIMUM_NFT_BALANCE = 10;\r\n    uint256 private constant MAX_STAKE_AMOUNT = 500;\r\n    uint256 private constant MAX_STAKE_AMOUNT_PER_USER = 20;\r\n    \r\n    address private constant NFTToken = 0x0FCBD68251819928C8f6D182fC04bE733fA94170; // LO-FI PEPE Collection\r\n    address private constant REWARDToken = 0x6982508145454Ce325dDbE47a25d4ec3d2311933; // PEPE token\r\n\r\n    // State variables\r\n    // 20 + 4 + 4 + 1 = 29 byte\r\n    address public admin;\r\n    uint32 private totalStaked;\r\n    uint32 private stakingId;\r\n    bool private started;\r\n\r\n    uint256 private constant rate = 10_000e18; // per staking for 90 days\r\n    uint256 private constant stakingPeriod = 24 hours;\r\n    \r\n    uint private immutable startTimestamp; // September 10th 2023, 00:00 PST\r\n    uint private immutable endTimestamp; // December 9th 2023, 00:00 PST (default of 90 days staking period)\r\n\r\n    // Structs\r\n    struct Staking {\r\n        // 20 + 5 + 1 + 4 = 30 byte\r\n        address staker;\r\n        uint40 releaseTime;\r\n        bool isCanceled;\r\n        uint32 stakingId;\r\n\r\n        // 4 + 16  + 5 = 25 byte\r\n        uint32 tokenId;     \r\n        uint128 claimedAmount;\r\n        uint40 stakeTime;\r\n    }\r\n\r\n    // Mapping\r\n    mapping(address => uint256) private stakedCount;\r\n    mapping(uint32 => Staking) private _stakedItem;\r\n\r\n    // Errors\r\n    error Paused();\r\n    error InvalidNFTContract();\r\n    error InvalidLength();\r\n    error NotAvailableToStake();\r\n    error MaxStakeAmountPerUserReached();\r\n    error MaxStakeAmountReached();\r\n    error NotEnoughNFTs();\r\n    error StakingPeriodIsNotOver();\r\n    error NotStaker();\r\n    error NotActiveStatus();\r\n    error NotAdmin();\r\n\r\n   // Events\r\n    event TokenStaked(\r\n        address indexed staker,\r\n        uint256 tokenId,\r\n        bool isStaked,\r\n        uint256 stakingId\r\n    );\r\n    event TokenClaimStatus(\r\n        uint256 indexed tokenId,\r\n        bool isActive,\r\n        uint256 stakingId\r\n    );\r\n    event TokenClaimComplete(\r\n        uint256 indexed tokenId,\r\n        bool isActive,\r\n        uint256 stakingId\r\n    );\r\n    event TokenCancelComplete(\r\n        uint256 indexed tokenId,\r\n        bool isCancelled,\r\n        uint256 stakingId\r\n    );\r\n\r\n    // Constructor\r\n    constructor() {\r\n        startTimestamp = block.timestamp;\r\n        endTimestamp = block.timestamp + stakingPeriod;\r\n\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if (admin != msg.sender) revert NotAdmin();\r\n        _;\r\n    }\r\n\r\n    //function to call another function\r\n    function callStakeToken(address _token, uint256[] memory _tokenIDs) public {\r\n        if (started) revert Paused();\r\n        if (_token != NFTToken) revert InvalidNFTContract();\r\n        if (_tokenIDs.length == 0) revert InvalidLength();\r\n\r\n        // Check if staking period not started or is over.\r\n        if (block.timestamp > endTimestamp || block.timestamp < startTimestamp)\r\n            revert NotAvailableToStake();\r\n\r\n        uint256 userStakedCount = stakedCount[msg.sender];\r\n\r\n        // Check if MAX_STAKE_AMOUNT_PER_USER is exceeded.\r\n        if (userStakedCount + _tokenIDs.length > MAX_STAKE_AMOUNT_PER_USER)\r\n            revert MaxStakeAmountPerUserReached();\r\n\r\n        // TODO: uncomment that\r\n        // uint256 balance = IERC721(NFTToken).balanceOf(msg.sender);\r\n        // if (balance + userStakedCount < MINIMUM_NFT_BALANCE) revert NotEnoughNFTs();\r\n\r\n        stakeToken(_tokenIDs);\r\n    }\r\n\r\n    //function to transfer NFT from user to contract\r\n    function stakeToken(uint256[] memory _tokenIds) private {\r\n        uint256 tokenIdLength = _tokenIds.length;\r\n        uint32 currentTotalStaked = totalStaked;\r\n\r\n        // Check if maximum stake amount is reached.\r\n        if (currentTotalStaked + tokenIdLength > MAX_STAKE_AMOUNT)\r\n            revert MaxStakeAmountReached();\r\n\r\n        uint32 currentStakingId = stakingId;\r\n        \r\n        for (uint256 i; i < tokenIdLength;) {\r\n\r\n            IERC721(NFTToken).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _tokenIds[i]\r\n            );\r\n\r\n            Staking memory staking = Staking(\r\n                msg.sender, // staker\r\n                uint40(block.timestamp), // releaseTime\r\n                false, // isCancelled\r\n                currentStakingId, // stakingId\r\n                uint32(_tokenIds[i]), // tokenId\r\n                0, // claimedAmount\r\n                uint40(block.timestamp) // stakeTime\r\n            );\r\n\r\n            _stakedItem[currentStakingId] = staking;\r\n\r\n            emit TokenStaked(\r\n                msg.sender,\r\n                _tokenIds[i],\r\n                true,\r\n                currentStakingId\r\n            );\r\n\r\n            unchecked {\r\n                currentStakingId++;\r\n                currentTotalStaked++;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        stakingId = currentStakingId;\r\n        totalStaked = currentTotalStaked;\r\n        stakedCount[msg.sender] += tokenIdLength;\r\n    }\r\n\r\n     // Function to view staked NFT\r\n    function viewStake(\r\n        uint32 _stakingId\r\n    ) external view returns (Staking memory) {\r\n        return _stakedItem[_stakingId];\r\n    }\r\n\r\n    // Function to get list of staked tokens\r\n    function viewMyStakedNfts(\r\n        address user\r\n    ) external view returns (Staking[] memory) {\r\n        Staking[] memory list = new Staking[](stakedCount[user]);\r\n\r\n        uint256 cnt;\r\n        for (uint32 index; index < stakingId; index++) {\r\n            if (\r\n                _stakedItem[index].staker == user &&\r\n                _stakedItem[index].isCanceled == false\r\n            ) {\r\n                list[cnt++] = _stakedItem[index];\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    // Function to check NFT stake duration status\r\n    function checkStake(\r\n        uint32 _stakingId,\r\n        address _staker\r\n    ) external returns (Staking memory) {\r\n        Staking memory staking = _stakedItem[_stakingId];\r\n\r\n        if (staking.staker != _staker) revert NotStaker();\r\n        if (staking.isCanceled) revert NotActiveStatus();\r\n\r\n        emit TokenClaimStatus(\r\n            staking.tokenId,\r\n            true,\r\n            _stakingId\r\n        );\r\n\r\n        return staking;\r\n    }\r\n\r\n    // Function to claim reward token if NFT stake duration is completed\r\n    function claimReward(uint32 _stakingId) public {\r\n        Staking storage staking = _stakedItem[_stakingId];\r\n\r\n        if (staking.isCanceled) revert NotActiveStatus();\r\n\r\n        uint256 maxTimestamp = endTimestamp;\r\n        uint256 curTimestamp = block.timestamp;\r\n\r\n        uint256 releaseTime = curTimestamp < maxTimestamp\r\n            ? curTimestamp\r\n            : maxTimestamp;\r\n\r\n        if (releaseTime <= staking.releaseTime) return;\r\n\r\n        uint256 amount = (rate / stakingPeriod) *\r\n            (releaseTime - staking.releaseTime);\r\n\r\n        uint256 balance = IERC20(REWARDToken).balanceOf(address(this));\r\n        if (balance < amount) {\r\n            amount = balance;\r\n        }\r\n\r\n        staking.releaseTime = uint40(releaseTime);\r\n        staking.claimedAmount += uint128(amount);\r\n\r\n        emit TokenClaimComplete(\r\n            staking.tokenId,\r\n            true,\r\n            _stakingId\r\n        );\r\n\r\n        if (amount != 0) {\r\n            IERC20(REWARDToken).transfer(staking.staker, amount);\r\n        }\r\n    }\r\n\r\n    function unStakeAll(uint32[] memory _stakingIds) external onlyAdmin {\r\n        if (block.timestamp < endTimestamp) revert StakingPeriodIsNotOver();\r\n\r\n        uint256 length = _stakingIds.length;\r\n        for (uint256 i; i < length;) {\r\n            Staking storage staking = _stakedItem[_stakingIds[i]];\r\n\r\n            claimReward(_stakingIds[i]);\r\n\r\n            staking.isCanceled = true;\r\n            address recipient = staking.staker;\r\n\r\n            // Lo-Fi NFT contract does not have transfer function.\r\n            IERC721(NFTToken).transferFrom(\r\n                address(this),\r\n                recipient,\r\n                staking.tokenId\r\n            );\r\n\r\n            unchecked {\r\n                stakedCount[recipient]--;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        totalStaked -= uint32(length);\r\n    }\r\n\r\n   // Function to cancel NFT stake\r\n    function unStake(uint32[] memory _stakingIds) external {\r\n        uint256 length = _stakingIds.length;\r\n        if (length == 0) revert InvalidLength();\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Staking storage staking = _stakedItem[_stakingIds[i]];\r\n\r\n            if (staking.staker != msg.sender) revert NotStaker();\r\n\r\n            // Claim the reward.\r\n            claimReward(_stakingIds[i]);\r\n\r\n            staking.isCanceled = true;\r\n            uint256 tokenId = staking.tokenId;\r\n\r\n            // Transfer tokenId to msg.sender. Here msg.sender == staking.staker\r\n            IERC721(NFTToken).transferFrom(address(this), msg.sender, tokenId);\r\n\r\n            emit TokenCancelComplete(\r\n                tokenId,\r\n                true,\r\n                _stakingIds[i]\r\n            );\r\n        }\r\n\r\n        totalStaked -= uint32(length);\r\n        stakedCount[msg.sender] -= length;\r\n    }\r\n\r\n    function withdraw(uint256 amount) public onlyAdmin {\r\n        IERC20(REWARDToken).transfer(msg.sender, amount);\r\n    }\r\n\r\n    function toggleStake(bool newStat) public onlyAdmin {\r\n        started = newStat;\r\n    }\r\n\r\n\r\n    function getRewardRate() external pure returns (uint256) {\r\n        return rate;\r\n    }\r\n\r\n    function getNFTAddress() external pure returns (address) {\r\n        return NFTToken;\r\n    }\r\n\r\n    function getRewardToken() external pure returns (address) {\r\n        return REWARDToken;\r\n    }\r\n\r\n    function getStakingIndex() external view returns (uint256) {\r\n        return stakingId;\r\n    }\r\n\r\n    function getTotalStaked() external view returns (uint256) {\r\n        return totalStaked;\r\n    }\r\n\r\n    function setNewAdmin(address newAdd) external onlyAdmin {\r\n        admin = newAdd;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNFTContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxStakeAmountPerUserReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxStakeAmountReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotActiveStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAvailableToStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughNFTs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingPeriodIsNotOver\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"TokenCancelComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"TokenClaimComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"TokenClaimStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"callStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_stakingId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"checkStake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"releaseTime\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isCanceled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"stakingId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"claimedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"stakeTime\",\"type\":\"uint40\"}],\"internalType\":\"struct PoolTwo.Staking\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_stakingId\",\"type\":\"uint32\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdd\",\"type\":\"address\"}],\"name\":\"setNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStat\",\"type\":\"bool\"}],\"name\":\"toggleStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_stakingIds\",\"type\":\"uint32[]\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_stakingIds\",\"type\":\"uint32[]\"}],\"name\":\"unStakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewMyStakedNfts\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"releaseTime\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isCanceled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"stakingId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"claimedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"stakeTime\",\"type\":\"uint40\"}],\"internalType\":\"struct PoolTwo.Staking[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_stakingId\",\"type\":\"uint32\"}],\"name\":\"viewStake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"releaseTime\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isCanceled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"stakingId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"claimedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"stakeTime\",\"type\":\"uint40\"}],\"internalType\":\"struct PoolTwo.Staking\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolTwo", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dd70a6446fef37125cadb349c2859fae89251c8d1dafe8743d938ce5ef1a8b74"}