{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CellMates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./Metadata.sol\\\";\\n\\n/*\\n\\nCellMates (CELL)\\nAn experimental hybrid of ERC-20 & ERC-721.\\n\\n- 256 total supply\\n- 1 ETH + 128 CELL initial liquidity\\n- 0.1 ETH mint from contract price\\n- sellable on both Uniswap and Opensea\\n- fully on-chain artwork based on cellular automata\\n\\nhttps://cellmates.io\\n\\n*/\\n\\ninterface Receiver {\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\\n}\\n\\ninterface Router {\\n\\tfunction WETH() external pure returns (address);\\n\\tfunction factory() external pure returns (address);\\n\\tfunction addLiquidityETH(address, uint256, uint256, uint256, address, uint256) external payable returns (uint256, uint256, uint256);\\n}\\n\\ninterface Factory {\\n\\tfunction createPair(address, address) external returns (address);\\n}\\n\\n\\ncontract CellMates {\\n\\n\\tuint256 constant private UINT_MAX = type(uint256).max;\\n\\tuint256 constant private TOTAL_SUPPLY = 256;\\n\\tuint256 constant private LIQUIDITY_TOKENS = 128;\\n\\tRouter constant private ROUTER = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n\\tuint256 constant private M1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\\n\\tuint256 constant private M2 = 0x3333333333333333333333333333333333333333333333333333333333333333;\\n\\tuint256 constant private M4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n\\tuint256 constant private H01 = 0x0101010101010101010101010101010101010101010101010101010101010101;\\n\\tbytes32 constant private TRANSFER_TOPIC = keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"));\\n\\tbytes32 constant private APPROVAL_TOPIC = keccak256(bytes(\\\"Approval(address,address,uint256)\\\"));\\n\\n\\tuint256 constant public MINT_COST = 0.1 ether;\\n\\n\\tuint8 constant public decimals = 0;\\n\\n\\tstruct User {\\n\\t\\tbytes32 mask;\\n\\t\\tmapping(address => uint256) allowance;\\n\\t\\tmapping(address => bool) approved;\\n\\t}\\n\\n\\tstruct Info {\\n\\t\\tbytes32 salt;\\n\\t\\taddress pair;\\n\\t\\taddress owner;\\n\\t\\tMetadata metadata;\\n\\t\\tmapping(address => User) users;\\n\\t\\tmapping(uint256 => address) approved;\\n\\t\\taddress[] holders;\\n\\t}\\n\\tInfo private info;\\n\\n\\tmapping(bytes4 => bool) public supportsInterface;\\n\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\tevent ERC20Transfer(bytes32 indexed topic0, address indexed from, address indexed to, uint256 tokens) anonymous;\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n\\tevent ERC20Approval(bytes32 indexed topic0, address indexed owner, address indexed spender, uint256 tokens) anonymous;\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\n\\tmodifier _onlyOwner() {\\n\\t\\trequire(msg.sender == owner());\\n\\t\\t_;\\n\\t}\\n\\n\\n\\tconstructor() payable {\\n\\t\\trequire(msg.value > 0);\\n\\t\\tinfo.owner = 0xFaDED72464D6e76e37300B467673b36ECc4d2ccF;\\n\\t\\tinfo.metadata = new Metadata();\\n\\t\\tsupportsInterface[0x01ffc9a7] = true; // ERC-165\\n\\t\\tsupportsInterface[0x80ac58cd] = true; // ERC-721\\n\\t\\tsupportsInterface[0x5b5e139f] = true; // Metadata\\n\\t\\tinfo.salt = keccak256(abi.encodePacked(\\\"Salt:\\\", blockhash(block.number - 1)));\\n\\t}\\n\\n\\tfunction setOwner(address _owner) external _onlyOwner {\\n\\t\\tinfo.owner = _owner;\\n\\t}\\n\\n\\tfunction setMetadata(Metadata _metadata) external _onlyOwner {\\n\\t\\tinfo.metadata = _metadata;\\n\\t}\\n\\n\\n\\tfunction initialize() external {\\n\\t\\trequire(pair() == address(0x0));\\n\\t\\taddress _this = address(this);\\n\\t\\taddress _weth = ROUTER.WETH();\\n\\t\\tinfo.users[_this].mask = bytes32(UINT_MAX);\\n\\t\\tinfo.holders.push(_this);\\n\\t\\temit ERC20Transfer(TRANSFER_TOPIC, address(0x0), _this, TOTAL_SUPPLY);\\n\\t\\tfor (uint256 i = 0; i < TOTAL_SUPPLY; i++) {\\n\\t\\t\\temit Transfer(address(0x0), _this, TOTAL_SUPPLY + i + 1);\\n\\t\\t}\\n\\t\\t_approveERC20(_this, address(ROUTER), LIQUIDITY_TOKENS);\\n\\t\\tinfo.pair = Factory(ROUTER.factory()).createPair(_weth, _this);\\n\\t\\tROUTER.addLiquidityETH{value:_this.balance}(_this, LIQUIDITY_TOKENS, 0, 0, owner(), block.timestamp);\\n\\t\\t_transferERC20(_this, 0xEC513e5959dBB02F314fc2F30041FCA2685119F3, 10); // marketing + giveaways\\n\\t\\t_transferERC20(_this, owner(), 10); // developer tokens\\n\\t}\\n\\n\\tfunction mint(uint256 _tokens) external payable {\\n\\t\\taddress _this = address(this);\\n\\t\\tuint256 _available = balanceOf(_this);\\n\\t\\trequire(_tokens <= _available);\\n\\t\\tuint256 _cost = _tokens * MINT_COST;\\n\\t\\trequire(msg.value >= _cost);\\n\\t\\t_transferERC20(_this, msg.sender, _tokens);\\n\\t\\tpayable(owner()).transfer(_cost);\\n\\t\\tif (msg.value > _cost) {\\n\\t\\t\\tpayable(msg.sender).transfer(msg.value - _cost);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\\n\\t\\tif (_tokens > TOTAL_SUPPLY && _tokens <= 2 * TOTAL_SUPPLY) {\\n\\t\\t\\t_approveNFT(_spender, _tokens);\\n\\t\\t} else {\\n\\t\\t\\t_approveERC20(msg.sender, _spender, _tokens);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external {\\n\\t\\tinfo.users[msg.sender].approved[_operator] = _approved;\\n\\t\\temit ApprovalForAll(msg.sender, _operator, _approved);\\n\\t}\\n\\n\\tfunction transfer(address _to, uint256 _tokens) external returns (bool) {\\n\\t\\t_transferERC20(msg.sender, _to, _tokens);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {\\n\\t\\tif (_tokens > TOTAL_SUPPLY && _tokens <= 2 * TOTAL_SUPPLY) {\\n\\t\\t\\t_transferNFT(_from, _to, _tokens);\\n\\t\\t} else {\\n\\t\\t\\tuint256 _allowance = allowance(_from, msg.sender);\\n\\t\\t\\trequire(_allowance >= _tokens);\\n\\t\\t\\tif (_allowance != UINT_MAX) {\\n\\t\\t\\t\\tinfo.users[_from].allowance[msg.sender] -= _tokens;\\n\\t\\t\\t}\\n\\t\\t\\t_transferERC20(_from, _to, _tokens);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\n\\t\\tsafeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\\n\\t\\t_transferNFT(_from, _to, _tokenId);\\n\\t\\tuint32 _size;\\n\\t\\tassembly {\\n\\t\\t\\t_size := extcodesize(_to)\\n\\t\\t}\\n\\t\\tif (_size > 0) {\\n\\t\\t\\trequire(Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == 0x150b7a02);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction bulkTransfer(address _to, uint256[] memory _tokenIds) external {\\n\\t\\t_transferNFTs(_to, _tokenIds);\\n\\t}\\n\\t\\n\\n\\tfunction owner() public view returns (address) {\\n\\t\\treturn info.owner;\\n\\t}\\n\\n\\tfunction pair() public view returns (address) {\\n\\t\\treturn info.pair;\\n\\t}\\n\\n\\tfunction holders() public view returns (address[] memory) {\\n\\t\\treturn info.holders;\\n\\t}\\n\\n\\tfunction salt() external view returns (bytes32) {\\n\\t\\treturn info.salt;\\n\\t}\\n\\n\\tfunction metadata() external view returns (address) {\\n\\t\\treturn address(info.metadata);\\n\\t}\\n\\n\\tfunction name() external view returns (string memory) {\\n\\t\\treturn info.metadata.name();\\n\\t}\\n\\n\\tfunction symbol() external view returns (string memory) {\\n\\t\\treturn info.metadata.symbol();\\n\\t}\\n\\n\\tfunction tokenURI(uint256 _tokenId) public view returns (string memory) {\\n\\t\\treturn info.metadata.tokenURI(_tokenId);\\n\\t}\\n\\n\\tfunction totalSupply() public pure returns (uint256) {\\n\\t\\treturn TOTAL_SUPPLY;\\n\\t}\\n\\n\\tfunction maskOf(address _user) public view returns (bytes32) {\\n\\t\\treturn info.users[_user].mask;\\n\\t}\\n\\n\\tfunction balanceOf(address _user) public view returns (uint256) {\\n\\t\\treturn _popcount(maskOf(_user));\\n\\t}\\n\\n\\tfunction allowance(address _user, address _spender) public view returns (uint256) {\\n\\t\\treturn info.users[_user].allowance[_spender];\\n\\t}\\n\\n\\tfunction ownerOf(uint256 _tokenId) public view returns (address) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenId > TOTAL_SUPPLY && _tokenId <= 2 * TOTAL_SUPPLY);\\n\\t\\t\\tbytes32 _mask = bytes32(1 << (_tokenId - TOTAL_SUPPLY - 1));\\n\\t\\t\\taddress[] memory _holders = holders();\\n\\t\\t\\tfor (uint256 i = 0; i < _holders.length; i++) {\\n\\t\\t\\t\\tif (maskOf(_holders[i]) & _mask == _mask) {\\n\\t\\t\\t\\t\\treturn _holders[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn address(0x0);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getApproved(uint256 _tokenId) public view returns (address) {\\n\\t\\trequire(_tokenId > TOTAL_SUPPLY && _tokenId <= 2 * TOTAL_SUPPLY);\\n\\t\\treturn info.approved[_tokenId];\\n\\t}\\n\\n\\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\n\\t\\treturn info.users[_owner].approved[_operator];\\n\\t}\\n\\n\\tfunction getToken(uint256 _tokenId) public view returns (address tokenOwner, address approved, string memory uri) {\\n\\t\\treturn (ownerOf(_tokenId), getApproved(_tokenId), tokenURI(_tokenId));\\n\\t}\\n\\n\\tfunction getTokens(uint256[] memory _tokenIds) external view returns (address[] memory owners, address[] memory approveds, string[] memory uris) {\\n\\t\\tuint256 _length = _tokenIds.length;\\n\\t\\towners = new address[](_length);\\n\\t\\tapproveds = new address[](_length);\\n\\t\\turis = new string[](_length);\\n\\t\\tfor (uint256 i = 0; i < _length; i++) {\\n\\t\\t\\t(owners[i], approveds[i], uris[i]) = getToken(_tokenIds[i]);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction _approveERC20(address _owner, address _spender, uint256 _tokens) internal {\\n\\t\\tinfo.users[_owner].allowance[_spender] = _tokens;\\n\\t\\temit ERC20Approval(APPROVAL_TOPIC, _owner, _spender, _tokens);\\n\\t}\\n\\n\\tfunction _approveNFT(address _spender, uint256 _tokenId) internal {\\n\\t\\tbytes32 _mask = bytes32(1 << (_tokenId - TOTAL_SUPPLY - 1));\\n\\t\\trequire(maskOf(msg.sender) & _mask == _mask);\\n\\t\\tinfo.approved[_tokenId] = _spender;\\n\\t\\temit Approval(msg.sender, _spender, _tokenId);\\n\\t}\\n\\t\\n\\tfunction _transferERC20(address _from, address _to, uint256 _tokens) internal {\\n\\t\\tunchecked {\\n\\t\\t\\tbytes32 _mask;\\n\\t\\t\\tuint256 _pos = 0;\\n\\t\\t\\tuint256 _count = 0;\\n\\t\\t\\tuint256 _n = uint256(maskOf(_from));\\n\\t\\t\\tuint256[] memory _tokenIds = new uint256[](_tokens);\\n\\t\\t\\twhile (_n > 0 && _count < _tokens) {\\n\\t\\t\\t\\tif (_n & 1 == 1) {\\n\\t\\t\\t\\t\\t_mask |= bytes32(1 << _pos);\\n\\t\\t\\t\\t\\t_tokenIds[_count++] = TOTAL_SUPPLY + _pos + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_pos++;\\n\\t\\t\\t\\t_n >>= 1;\\n\\t\\t\\t}\\n\\t\\t\\trequire(_count == _tokens);\\n\\t\\t\\trequire(maskOf(_from) & _mask == _mask);\\n\\t\\t\\t_transfer(_from, _to, _mask, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _transferNFT(address _from, address _to, uint256 _tokenId) internal {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenId > TOTAL_SUPPLY && _tokenId <= 2 * TOTAL_SUPPLY);\\n\\t\\t\\tbytes32 _mask = bytes32(1 << (_tokenId - TOTAL_SUPPLY - 1));\\n\\t\\t\\trequire(maskOf(_from) & _mask == _mask);\\n\\t\\t\\trequire(msg.sender == _from || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender));\\n\\t\\t\\tuint256[] memory _tokenIds = new uint256[](1);\\n\\t\\t\\t_tokenIds[0] = _tokenId;\\n\\t\\t\\t_transfer(_from, _to, _mask, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _transferNFTs(address _to, uint256[] memory _tokenIds) internal {\\n\\t\\tunchecked {\\n\\t\\t\\tbytes32 _mask;\\n\\t\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\t\\t_mask |= bytes32(1 << (_tokenIds[i] - TOTAL_SUPPLY - 1));\\n\\t\\t\\t}\\n\\t\\t\\trequire(_popcount(_mask) == _tokenIds.length);\\n\\t\\t\\trequire(maskOf(msg.sender) & _mask == _mask);\\n\\t\\t\\t_transfer(msg.sender, _to, _mask, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _transfer(address _from, address _to, bytes32 _mask, uint256[] memory _tokenIds) internal {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenIds.length > 0);\\n\\t\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\t\\tif (getApproved(_tokenIds[i]) != address(0x0)) {\\n\\t\\t\\t\\t\\tinfo.approved[_tokenIds[i]] = address(0x0);\\n\\t\\t\\t\\t\\temit Approval(address(0x0), address(0x0), _tokenIds[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\temit Transfer(_from, _to, _tokenIds[i]);\\n\\t\\t\\t}\\n\\t\\t\\tinfo.users[_from].mask ^= _mask;\\n\\t\\t\\tbool _from0 = maskOf(_from) == 0x0;\\n\\t\\t\\tbool _to0 = maskOf(_to) == 0x0;\\n\\t\\t\\tinfo.users[_to].mask |= _mask;\\n\\t\\t\\tif (_from0) {\\n\\t\\t\\t\\tuint256 _index;\\n\\t\\t\\t\\taddress[] memory _holders = holders();\\n\\t\\t\\t\\tfor (uint256 i = 0; i < _holders.length; i++) {\\n\\t\\t\\t\\t\\tif (_holders[i] == _from) {\\n\\t\\t\\t\\t\\t\\t_index = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (_to0) {\\n\\t\\t\\t\\t\\tinfo.holders[_index] = _to;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinfo.holders[_index] = _holders[_holders.length - 1];\\n\\t\\t\\t\\t\\tinfo.holders.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (_to0) {\\n\\t\\t\\t\\tinfo.holders.push(_to);\\n\\t\\t\\t}\\n\\t\\t\\trequire(maskOf(_from) & maskOf(_to) == 0x0);\\n\\t\\t\\temit ERC20Transfer(TRANSFER_TOPIC, _from, _to, _tokenIds.length);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction _popcount(bytes32 _b) internal pure returns (uint256) {\\n\\t\\tuint256 _n = uint256(_b);\\n\\t\\tif (_n == UINT_MAX) {\\n\\t\\t\\treturn 256;\\n\\t\\t}\\n\\t\\tunchecked {\\n\\t\\t\\t_n -= (_n >> 1) & M1;\\n\\t\\t\\t_n = (_n & M2) + ((_n >> 2) & M2);\\n\\t\\t\\t_n = (_n + (_n >> 4)) & M4;\\n\\t\\t\\t_n = (_n * H01) >> 248;\\n\\t\\t}\\n\\t\\treturn _n;\\n\\t}\\n}\\n\\n\\ncontract Deploy {\\n\\tCellMates immutable public cellmates;\\n\\tconstructor() payable {\\n\\t\\tcellmates = new CellMates{value:msg.value}();\\n\\t\\tcellmates.initialize();\\n\\t}\\n}\"\r\n    },\r\n    \"Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface CM {\\n\\tfunction salt() external view returns (bytes32);\\n}\\n\\ncontract Metadata {\\n\\t\\n\\tstring public name = \\\"CellMates\\\";\\n\\tstring public symbol = \\\"CELL\\\";\\n\\n\\tstring constant private TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\tbytes3 constant private BG_COLOR = 0xd1d3dc;\\n\\tuint256 constant private PADDING = 2;\\n\\n\\tstruct Size {\\n\\t\\tuint248 size;\\n\\t\\tuint8 chance;\\n\\t}\\n\\tSize[] private sizes;\\n\\n\\tstruct Color {\\n\\t\\tbytes3 primaryColor;\\n\\t\\tbytes3 outlineColor;\\n\\t\\tuint8 chance;\\n\\t\\tstring name;\\n\\t}\\n\\tColor[] private colors;\\n\\n\\tCM immutable public cellmates;\\n\\n\\n\\tconstructor() {\\n\\t\\tcellmates = CM(msg.sender);\\n\\n\\t\\t// sizes\\n\\t\\tsizes.push(Size(14, 120));\\n\\t\\tsizes.push(Size(16, 80));\\n\\t\\tsizes.push(Size(18, 50));\\n\\t\\tsizes.push(Size(20, 20));\\n\\t\\tsizes.push(Size(22, 10));\\n\\t\\tsizes.push(Size(24, 5));\\n\\t\\t\\n\\t\\t// colors\\n\\t\\tcolors.push(Color(0x179629, 0x15491f, 100, \\\"Slimy Green\\\"));\\n\\t\\tcolors.push(Color(0xc9a91c, 0x5f5120, 75, \\\"Pacific Blue\\\"));\\n\\t\\tcolors.push(Color(0x009fff, 0x144d79, 55, \\\"Orange Peel\\\"));\\n\\t\\tcolors.push(Color(0x3bb5cf, 0x235763, 35, \\\"Old Gold\\\"));\\n\\t\\tcolors.push(Color(0x908070, 0x463f38, 25, \\\"Slate Gray\\\"));\\n\\t\\tcolors.push(Color(0xac8fe6, 0x53466d, 15, \\\"Charm Pink\\\"));\\n\\t\\tcolors.push(Color(0x2b2ca6, 0x191d52, 10, \\\"Metallic Red\\\"));\\n\\t\\tcolors.push(Color(0xa95178, 0x522b3d, 5, \\\"Royal Purple\\\"));\\n\\t}\\n\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\t( , uint256 _size, uint256 _colorIndex) = _getTokenInfo(_tokenId);\\n\\t\\t\\tstring memory _json = string(abi.encodePacked('{\\\"name\\\":\\\"CELL #', _uint2str(_tokenId), '\\\",\\\"description\\\":\\\"An experimental hybrid of ERC-20 & ERC-721.\\\",\\\"external_url\\\":\\\"https://cellmates.io/#/token/', _uint2str(_tokenId), '\\\",'));\\n\\t\\t\\t_json = string(abi.encodePacked(_json, '\\\"image\\\":\\\"', svgURI(_tokenId), '\\\",\\\"attributes\\\":['));\\n\\t\\t\\t_json = string(abi.encodePacked(_json, '{\\\"trait_type\\\":\\\"Size\\\",\\\"value\\\":', _uint2str(_size - 2 * PADDING), '},'));\\n\\t\\t\\t_json = string(abi.encodePacked(_json, '{\\\"trait_type\\\":\\\"Color\\\",\\\"value\\\":\\\"', colors[_colorIndex].name, '\\\"}'));\\n\\t\\t\\t_json = string(abi.encodePacked(_json, ']}'));\\n\\t\\t\\treturn string(abi.encodePacked('data:application/json;base64,', _encode(bytes(_json))));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction svgURI(uint256 _tokenId) public view returns (string memory) {\\n\\t\\treturn string(abi.encodePacked('data:image/svg+xml;base64,', _encode(bytes(getSVG(_tokenId)))));\\n\\t}\\n\\t\\n\\tfunction bmpURI(uint256 _tokenId) public view returns (string memory) {\\n\\t\\treturn string(abi.encodePacked('data:image/bmp;base64,', _encode(getBMP(_tokenId))));\\n\\t}\\n\\n\\tfunction getSVG(uint256 _tokenId) public view returns (string memory) {\\n\\t\\treturn string(abi.encodePacked('<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" preserveAspectRatio=\\\"xMidYMid meet\\\" viewBox=\\\"0 0 512 512\\\" width=\\\"100%\\\" height=\\\"100%\\\"><defs><style type=\\\"text/css\\\">svg{image-rendering:optimizeSpeed;image-rendering:-moz-crisp-edges;image-rendering:-o-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:pixelated;image-rendering:optimize-contrast;-ms-interpolation-mode:nearest-neighbor;background-color:', _col2str(BG_COLOR), ';background-image:url(', bmpURI(_tokenId), ');background-repeat:no-repeat;background-size:contain;background-position:50% 50%;}</style></defs></svg>'));\\n\\t}\\n\\t\\n\\tfunction getBMP(uint256 _tokenId) public view returns (bytes memory) {\\n\\t\\t(bytes32 _seed, uint256 _size, uint256 _colorIndex) = _getTokenInfo(_tokenId);\\n\\t\\treturn _getBMP(_makePalette(colors[_colorIndex].primaryColor, colors[_colorIndex].outlineColor), _convertToColors(_addOutline(_expandAndReflect(_step(_step(_getInitialState(_seed, _size)))))), _size);\\n\\t}\\n\\t\\n\\t\\n\\tfunction _getTokenInfo(uint256 _tokenId) internal view returns (bytes32 seed, uint256 size, uint256 colorIndex) {\\n\\t\\tunchecked {\\n\\t\\t\\tseed = keccak256(abi.encodePacked(\\\"Seed:\\\", _tokenId, cellmates.salt()));\\n\\t\\t\\tsize = _sampleSize(seed);\\n\\t\\t\\tcolorIndex = _sampleColor(seed);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _sampleSize(bytes32 _seed) internal view returns (uint256 size) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _total = 0;\\n\\t\\t\\tfor (uint256 i = 0; i < sizes.length; i++) {\\n\\t\\t\\t\\t_total += sizes[i].chance;\\n\\t\\t\\t}\\n\\t\\t\\tuint256 _target = uint256(keccak256(abi.encodePacked(\\\"Size:\\\", _seed))) % _total;\\n\\t\\t\\t_total = 0;\\n\\t\\t\\tfor (uint256 i = 0; i < sizes.length; i++) {\\n\\t\\t\\t\\t_total += sizes[i].chance;\\n\\t\\t\\t\\tif (_target < _total) {\\n\\t\\t\\t\\t\\treturn sizes[i].size;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _sampleColor(bytes32 _seed) internal view returns (uint256 colorIndex) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _total = 0;\\n\\t\\t\\tfor (uint256 i = 0; i < colors.length; i++) {\\n\\t\\t\\t\\t_total += colors[i].chance;\\n\\t\\t\\t}\\n\\t\\t\\tuint256 _target = uint256(keccak256(abi.encodePacked(\\\"Color:\\\", _seed))) % _total;\\n\\t\\t\\t_total = 0;\\n\\t\\t\\tfor (uint256 i = 0; i < colors.length; i++) {\\n\\t\\t\\t\\t_total += colors[i].chance;\\n\\t\\t\\t\\tif (_target < _total) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getInitialState(bytes32 _seed, uint256 _size) internal pure returns (uint8[][] memory state) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _rollingSeed = uint256(keccak256(abi.encodePacked(\\\"State:\\\", _seed)));\\n\\t\\t\\tstate = new uint8[][](_size - 2 * PADDING - 2);\\n\\t\\t\\tfor (uint256 y = 0; y < state.length; y++) {\\n\\t\\t\\t\\tstate[y] = new uint8[](_size / 2 - PADDING - 1);\\n\\t\\t\\t\\tfor (uint256 x = 0; x < state[y].length; x++) {\\n\\t\\t\\t\\t\\tstate[y][x] = uint8(_rollingSeed % 2);\\n\\t\\t\\t\\t\\tif (_rollingSeed < type(uint16).max) {\\n\\t\\t\\t\\t\\t\\t_rollingSeed = uint256(keccak256(abi.encodePacked(\\\"Roll:\\\", _seed, _rollingSeed)));\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t_rollingSeed /= 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getNeighborhood(uint8[][] memory _state) internal pure returns (uint8[][] memory neighborhood) {\\n\\t\\tunchecked {\\n\\t\\t\\tneighborhood = new uint8[][](_state.length);\\n\\t\\t\\tfor (uint256 y = 0; y < _state.length; y++) {\\n\\t\\t\\t\\tneighborhood[y] = new uint8[](_state[y].length);\\n\\t\\t\\t\\tfor (uint256 x = 0; x < _state[y].length; x++) {\\n\\t\\t\\t\\t\\tuint8 _count = 0;\\n\\t\\t\\t\\t\\tif (y > 0) {\\n\\t\\t\\t\\t\\t\\t_count += _state[y - 1][x];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (y < _state.length - 1) {\\n\\t\\t\\t\\t\\t\\t_count += _state[y + 1][x];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (x > 0) {\\n\\t\\t\\t\\t\\t\\t_count += _state[y][x - 1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (x < _state[y].length - 1) {\\n\\t\\t\\t\\t\\t\\t_count += _state[y][x + 1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tneighborhood[y][x] = _count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _step(uint8[][] memory _state) internal pure returns (uint8[][] memory newState) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint8[][] memory _neighborhood = _getNeighborhood(_state);\\n\\t\\t\\tnewState = new uint8[][](_state.length);\\n\\t\\t\\tfor (uint256 y = 0; y < _state.length; y++) {\\n\\t\\t\\t\\tnewState[y] = new uint8[](_state[y].length);\\n\\t\\t\\t\\tfor (uint256 x = 0; x < _state[y].length; x++) {\\n\\t\\t\\t\\t\\tnewState[y][x] = ((_state[y][x] == 0 && _neighborhood[y][x] <= 1) || (_state[y][x] == 1 && (_neighborhood[y][x] == 2 || _neighborhood[y][x] == 3))) ? 1 : 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _expandAndReflect(uint8[][] memory _state) internal pure returns (uint8[][] memory newState) {\\n\\t\\tunchecked {\\n\\t\\t\\tnewState = new uint8[][](_state.length + 2 * PADDING + 2);\\n\\t\\t\\tfor (uint256 y = 0; y < newState.length; y++) {\\n\\t\\t\\t\\tnewState[y] = new uint8[](_state.length + 2 * PADDING + 2);\\n\\t\\t\\t\\tfor (uint256 x = 0; x < newState[y].length; x++) {\\n\\t\\t\\t\\t\\tif (y > PADDING && y <= _state.length + PADDING && x > PADDING && x <= _state.length + PADDING) {\\n\\t\\t\\t\\t\\t\\tnewState[y][x] = _state[y - PADDING - 1][x > _state[y - PADDING - 1].length + PADDING ? _state.length + PADDING - x : x - PADDING - 1];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnewState[y][x] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _addOutline(uint8[][] memory _state) internal pure returns (uint8[][] memory newState) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint8[][] memory _neighborhood = _getNeighborhood(_state);\\n\\t\\t\\tnewState = new uint8[][](_state.length);\\n\\t\\t\\tfor (uint256 y = 0; y < _state.length; y++) {\\n\\t\\t\\t\\tnewState[y] = new uint8[](_state[y].length);\\n\\t\\t\\t\\tfor (uint256 x = 0; x < _state[y].length; x++) {\\n\\t\\t\\t\\t\\tnewState[y][x] = _state[y][x] == 0 && _neighborhood[y][x] > 0 ? 2 : _state[y][x];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _convertToColors(uint8[][] memory _state) internal pure returns (bytes memory cols) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _scanline = _state[0].length;\\n\\t\\t\\tif (_scanline % 4 != 0) {\\n\\t\\t\\t\\t_scanline += 4 - (_scanline % 4);\\n\\t\\t\\t}\\n\\t\\t\\tcols = new bytes(_state.length * _scanline);\\n\\t\\t\\tfor (uint256 y = 0; y < _state.length; y++) {\\n\\t\\t\\t\\tfor (uint256 x = 0; x < _state[y].length; x++) {\\n\\t\\t\\t\\t\\tcols[(_state.length - y - 1) * _scanline + x] = bytes1(_state[y][x]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _makePalette(bytes3 _primaryColor, bytes3 _outlineColor) internal pure returns (bytes memory) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn abi.encodePacked(BG_COLOR, bytes1(0), _primaryColor, bytes1(0), _outlineColor, bytes1(0));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getBMP(bytes memory _palette, bytes memory _colors, uint256 _size) internal pure returns (bytes memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint32 _bufSize = 14 + 40 + uint32(_palette.length);\\n\\t\\t\\tbytes memory _buf = new bytes(_bufSize - _palette.length);\\n\\t\\t\\t_buf[0] = 0x42;\\n\\t\\t\\t_buf[1] = 0x4d;\\n\\t\\t\\tuint32 _tmp = _bufSize + uint32(_colors.length);\\n\\t\\t\\tuint32 b;\\n\\t\\t\\tfor (uint i = 2; i < 6; i++) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tb := and(_tmp, 0xff)\\n\\t\\t\\t\\t\\t_tmp := shr(8, _tmp)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_buf[i] = bytes1(uint8(b));\\n\\t\\t\\t}\\n\\t\\t\\t_tmp = _bufSize;\\n\\t\\t\\tfor (uint i = 10; i < 14; i++) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tb := and(_tmp, 0xff)\\n\\t\\t\\t\\t\\t_tmp := shr(8, _tmp)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_buf[i] = bytes1(uint8(b));\\n\\t\\t\\t}\\n\\t\\t\\t_buf[14] = 0x28;\\n\\t\\t\\t_tmp = uint32(_size);\\n\\t\\t\\tfor (uint i = 18; i < 22; i++) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tb := and(_tmp, 0xff)\\n\\t\\t\\t\\t\\t_tmp := shr(8, _tmp)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_buf[i] = bytes1(uint8(b));\\n\\t\\t\\t\\t_buf[i + 4] = bytes1(uint8(b));\\n\\t\\t\\t}\\n\\t\\t\\t_buf[26] = 0x01;\\n\\t\\t\\t_buf[28] = 0x08;\\n\\t\\t\\t_tmp = uint32(_colors.length);\\n\\t\\t\\tfor (uint i = 34; i < 38; i++) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tb := and(_tmp, 0xff)\\n\\t\\t\\t\\t\\t_tmp := shr(8, _tmp)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_buf[i] = bytes1(uint8(b));\\n\\t\\t\\t}\\n\\t\\t\\t_tmp = uint32(_palette.length / 4);\\n\\t\\t\\tfor (uint i = 46; i < 50; i++) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tb := and(_tmp, 0xff)\\n\\t\\t\\t\\t\\t_tmp := shr(8, _tmp)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_buf[i] = bytes1(uint8(b));\\n\\t\\t\\t\\t_buf[i + 4] = bytes1(uint8(b));\\n\\t\\t\\t}\\n\\t\\t\\treturn abi.encodePacked(_buf, _palette, _colors);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _uint2str(uint256 _value) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _digits = 1;\\n\\t\\t\\tuint256 _n = _value;\\n\\t\\t\\twhile (_n > 9) {\\n\\t\\t\\t\\t_n /= 10;\\n\\t\\t\\t\\t_digits++;\\n\\t\\t\\t}\\n\\t\\t\\tbytes memory _out = new bytes(_digits);\\n\\t\\t\\tfor (uint256 i = 0; i < _out.length; i++) {\\n\\t\\t\\t\\tuint256 _dec = (_value / (10**(_out.length - i - 1))) % 10;\\n\\t\\t\\t\\t_out[i] = bytes1(uint8(_dec) + 48);\\n\\t\\t\\t}\\n\\t\\t\\treturn string(_out);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _col2str(bytes3 _col) internal pure returns (string memory str) {\\n\\t\\tunchecked {\\n\\t\\t\\tstr = \\\"#\\\";\\n\\t\\t\\tfor (uint256 i = 0; i < 6; i++) {\\n\\t\\t\\t\\tuint256 _hex = (uint24(_col) >> (4 * (i + 1 - 2 * (i % 2)))) % 16;\\n\\t\\t\\t\\tbytes memory _char = new bytes(1);\\n\\t\\t\\t\\t_char[0] = bytes1(uint8(_hex) + (_hex > 9 ? 87 : 48));\\n\\t\\t\\t\\tstr = string(abi.encodePacked(str, string(_char)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _encode(bytes memory _data) internal pure returns (string memory result) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (_data.length == 0) return '';\\n\\t\\t\\tstring memory _table = TABLE;\\n\\t\\t\\tuint256 _encodedLen = 4 * ((_data.length + 2) / 3);\\n\\t\\t\\tresult = new string(_encodedLen + 32);\\n\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(result, _encodedLen)\\n\\t\\t\\t\\tlet tablePtr := add(_table, 1)\\n\\t\\t\\t\\tlet dataPtr := _data\\n\\t\\t\\t\\tlet endPtr := add(dataPtr, mload(_data))\\n\\t\\t\\t\\tlet resultPtr := add(result, 32)\\n\\n\\t\\t\\t\\tfor {} lt(dataPtr, endPtr) {}\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdataPtr := add(dataPtr, 3)\\n\\t\\t\\t\\t\\tlet input := mload(dataPtr)\\n\\t\\t\\t\\t\\tmstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n\\t\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\t\\tmstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n\\t\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\t\\tmstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n\\t\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\t\\tmstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n\\t\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tswitch mod(mload(_data), 3)\\n\\t\\t\\t\\tcase 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n\\t\\t\\t\\tcase 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"topic0\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ERC20Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"topic0\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINT_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"bulkTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"approveds\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"uris\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"maskOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Metadata\",\"name\":\"_metadata\",\"type\":\"address\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CellMates", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}