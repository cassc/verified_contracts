{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Multicaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Multicaller\\n * @author vectorized.eth\\n * @notice Contract that allows for efficient aggregation\\n *         of multiple calls in a single transaction.\\n */\\ncontract Multicaller {\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @dev The lengths of the input arrays are not the same.\\n     */\\n    error ArrayLengthsMismatch();\\n\\n    // =============================================================\\n    //                    AGGREGATION OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Aggregates multiple calls in a single transaction.\\n     * @param targets  An array of addresses to call.\\n     * @param data     An array of calldata to forward to the targets.\\n     * @param values   How much ETH to forward to each target.\\n     * @param refundTo The address to transfer any remaining ETH in the contract after the calls.\\n     *                 If `address(0)`, remaining ETH will NOT be refunded.\\n     *                 If `address(1)`, remaining ETH will be refunded to `msg.sender`.\\n     *                 If anything else, remaining ETH will be refunded to `refundTo`.\\n     * @return An array of the returndata from each call.\\n     */\\n    function aggregate(\\n        address[] calldata targets,\\n        bytes[] calldata data,\\n        uint256[] calldata values,\\n        address refundTo\\n    ) external payable returns (bytes[] memory) {\\n        assembly {\\n            if iszero(and(eq(targets.length, data.length), eq(data.length, values.length))) {\\n                // Store the function selector of `ArrayLengthsMismatch()`.\\n                mstore(returndatasize(), 0x3b800a46)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            let resultsSize := 0x40\\n\\n            if data.length {\\n                let results := 0x40\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                data.length := shl(5, data.length)\\n                // Copy the offsets from calldata into memory.\\n                calldatacopy(results, data.offset, data.length)\\n                // Offset into `results`.\\n                let resultsOffset := data.length\\n                // Pointer to the end of `results`.\\n                let end := add(results, data.length)\\n                // For deriving the calldata offsets from the `results` pointer.\\n                let valuesOffsetDiff := sub(values.offset, results)\\n                let targetsOffsetDiff := sub(targets.offset, results)\\n\\n                for {} 1 {} {\\n                    // The offset of the current bytes in the calldata.\\n                    let o := add(data.offset, mload(results))\\n                    let memPtr := add(resultsOffset, 0x40)\\n                    // Copy the current bytes from calldata to the memory.\\n                    calldatacopy(\\n                        memPtr,\\n                        add(o, 0x20), // The offset of the current bytes' bytes.\\n                        calldataload(o) // The length of the current bytes.\\n                    )\\n                    if iszero(\\n                        call(\\n                            gas(), // Remaining gas.\\n                            calldataload(add(targetsOffsetDiff, results)), // Address to call.\\n                            calldataload(add(valuesOffsetDiff, results)), // ETH to send.\\n                            memPtr, // Start of input calldata in memory.\\n                            calldataload(o), // Size of input calldata.\\n                            0x00, // We will use returndatacopy instead.\\n                            0x00 // We will use returndatacopy instead.\\n                        )\\n                    ) {\\n                        // Bubble up the revert if the call reverts.\\n                        returndatacopy(0x00, 0x00, returndatasize())\\n                        revert(0x00, returndatasize())\\n                    }\\n                    // Append the current `resultsOffset` into `results`.\\n                    mstore(results, resultsOffset)\\n                    // Append the returndatasize, and the returndata.\\n                    mstore(memPtr, returndatasize())\\n                    returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                    // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                    // rounded up to the next multiple of 0x20.\\n                    resultsOffset := and(add(add(resultsOffset, returndatasize()), 0x3f), not(0x1f))\\n                    // Advance the `results` pointer.\\n                    results := add(results, 0x20)\\n                    if eq(results, end) { break }\\n                }\\n                resultsSize := add(resultsOffset, 0x40)\\n            }\\n\\n            if refundTo {\\n                // Force transfers all the remaining ETH in the contract to `refundTo`,\\n                // with a gas stipend of 100000, which should be enough for most use cases.\\n                // If sending via a regular call fails, force sends the ETH by\\n                // creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n                if selfbalance() {\\n                    // If `refundTo` is `address(1)`, replace it with the `msg.sender`.\\n                    refundTo := xor(refundTo, mul(eq(refundTo, 1), xor(refundTo, caller())))\\n                    // Transfer the ETH and check if it succeeded or not.\\n                    if iszero(\\n                        call(100000, refundTo, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n                    ) {\\n                        mstore(0x00, refundTo) // Store the address in scratch space.\\n                        mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                        mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                        // We can directly use `SELFDESTRUCT` in the contract creation.\\n                        // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                        if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                            // Coerce gas estimation to provide enough gas for the `create` above.\\n                            revert(codesize(), codesize())\\n                        }\\n                    }\\n                }\\n            }\\n\\n            mstore(0x00, 0x20) // Store the memory offset of the `results`.\\n            mstore(0x20, targets.length) // Store `targets.length` into `results`.\\n            // Direct return.\\n            return(0x00, resultsSize)\\n        }\\n    }\\n\\n    /**\\n     * @dev For receiving ETH.\\n     *      Does nothing and returns nothing.\\n     *      Called instead of `fallback()` if the calldatasize is zero.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Decompresses the calldata and performs a delegatecall\\n     *      with the decompressed calldata to itself.\\n     *\\n     *      Accompanying JavaScript library to compress the calldata:\\n     *      https://github.com/vectorized/solady/blob/main/js/solady.js\\n     *      (See: `LibZip.cdCompress`)\\n     */\\n    fallback() external payable {\\n        assembly {\\n            // If the calldata starts with the bitwise negation of\\n            // `bytes4(keccak256(\\\"aggregate(address[],bytes[],uint256[],address)\\\"))`.\\n            let s := calldataload(returndatasize())\\n            if eq(shr(224, s), 0x66e0daa0) {\\n                mstore(returndatasize(), not(s))\\n                let o := 4\\n                for { let i := o } lt(i, calldatasize()) {} {\\n                    let c := byte(returndatasize(), calldataload(i))\\n                    i := add(i, 1)\\n                    if iszero(c) {\\n                        let d := byte(returndatasize(), calldataload(i))\\n                        i := add(i, 1)\\n                        // Fill with either 0xff or 0x00.\\n                        mstore(o, not(returndatasize()))\\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                        o := add(o, add(and(d, 0x7f), 1))\\n                        continue\\n                    }\\n                    mstore8(o, c)\\n                    o := add(o, 1)\\n                }\\n                let success := delegatecall(gas(), address(), 0x00, o, 0x00, 0x00)\\n                returndatacopy(0x00, 0x00, returndatasize())\\n                if iszero(success) { revert(0x00, returndatasize()) }\\n                return(0x00, returndatasize())\\n            }\\n            revert(returndatasize(), returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ArrayLengthsMismatch\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"refundTo\",\"type\":\"address\"}],\"name\":\"aggregate\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Multicaller", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0dfa3a85cbd068a99fd4d5051615c4bde5995f9e1dd4a095bb55fc5af681c440"}