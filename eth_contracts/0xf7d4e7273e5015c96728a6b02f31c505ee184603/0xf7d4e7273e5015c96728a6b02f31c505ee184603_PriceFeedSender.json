{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/priceFeed/PriceFeedSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.22;\\n\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {IWormholeRelayer} from \\\"@wormhole-solidity-sdk/interfaces/IWormholeRelayer.sol\\\";\\nimport {IChainlinkV3Aggregator} from \\\"@stakewise-core/interfaces/IChainlinkV3Aggregator.sol\\\";\\nimport {IPriceFeedSender} from \\\"./interfaces/IPriceFeedSender.sol\\\";\\n\\n/**\\n * @title PriceFeedSender\\n * @author StakeWise\\n * @notice Sends the new rate to the Wormhole Relayer\\n */\\ncontract PriceFeedSender is IPriceFeedSender {\\n    error InsufficientFunds();\\n\\n    IChainlinkV3Aggregator private immutable _priceFeed;\\n    IWormholeRelayer private immutable _wormholeRelayer;\\n    uint256 private immutable _gasLimit;\\n    uint16 private immutable _chainId;\\n\\n    /**\\n     * @dev Constructor\\n     * @param priceFeed The address of the PriceFeed contract\\n     * @param wormholeRelayer The address of the Wormhole Relayer contract\\n     * @param gasLimit The gas limit for the Wormhole Relayer call\\n     * @param chainId The Wormhole chain ID\\n     */\\n    constructor(address priceFeed, address wormholeRelayer, uint256 gasLimit, uint16 chainId) {\\n        _priceFeed = IChainlinkV3Aggregator(priceFeed);\\n        _wormholeRelayer = IWormholeRelayer(wormholeRelayer);\\n        _gasLimit = gasLimit;\\n        _chainId = chainId;\\n    }\\n\\n    /// @inheritdoc IPriceFeedSender\\n    function quoteRateSync(uint16 targetChain) public view override returns (uint256 cost) {\\n        (cost,) = _wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            0, // pass zero as receiver value is not used\\n            _gasLimit\\n        );\\n    }\\n\\n    /// @inheritdoc IPriceFeedSender\\n    function syncRate(uint16 targetChain, address targetAddress) external payable override {\\n        // check sufficient funds\\n        uint256 cost = quoteRateSync(targetChain);\\n        if (msg.value != cost) {\\n            revert InsufficientFunds();\\n        }\\n\\n        // fetch latest rate\\n        (, int256 answer,, uint256 updatedAt,) = _priceFeed.latestRoundData();\\n        uint128 timestamp = SafeCast.toUint128(updatedAt);\\n        uint128 newRate = SafeCast.toUint128(SafeCast.toUint256(answer));\\n\\n        // send the rate to the Wormhole Relayer\\n        _wormholeRelayer.sendPayloadToEvm{value: cost}(\\n            targetChain,\\n            targetAddress,\\n            abi.encode(timestamp, newRate), // encode payload\\n            0, // pass zero as receiver value is not used\\n            _gasLimit,\\n            _chainId, // use the current chain ID as the refund chain\\n            msg.sender // use the sender as the refund address\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WormholeRelayer\\n * @author\\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\\n * write and run their own relaying infrastructure\\n *\\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages)\\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n    uint16 chainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n}\\n\\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\nuint8 constant VAA_KEY_TYPE = 1;\\n\\nstruct MessageKey {\\n    uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\n    bytes encodedKey;\\n}\\n\\ninterface IWormholeRelayerBase {\\n    event SendEvent(\\n        uint64 indexed sequence,\\n        uint256 deliveryQuote,\\n        uint256 paymentForExtraReceiverValue\\n    );\\n\\n    function getRegisteredWormholeRelayerContract(\\n        uint16 chainId\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if a delivery has been attempted for the given deliveryHash\\n     * Note: invalid deliveries where the tx reverts are not considered attempted\\n     */\\n    function deliveryAttempted(\\n        bytes32 deliveryHash\\n    ) external view returns (bool attempted);\\n\\n    /**\\n     * @notice block number at which a delivery was successfully executed\\n     */\\n    function deliverySuccessBlock(\\n        bytes32 deliveryHash\\n    ) external view returns (uint256 blockNumber);\\n\\n    /**\\n     * @notice block number of the latest attempt to execute a delivery that failed\\n     */\\n    function deliveryFailureBlock(\\n        bytes32 deliveryHash\\n    ) external view returns (uint256 blockNumber);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     * (e.g. with a different delivery provider)\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     * @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     */\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        uint256 newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     *\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified.\\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 nativePriceQuote,\\n            uint256 targetChainRefundPerGasUnused\\n        );\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified\\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address deliveryProviderAddress\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 nativePriceQuote,\\n            uint256 targetChainRefundPerGasUnused\\n        );\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\\n     *              if a refundAddress is specified)\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    )\\n        external\\n        view\\n        returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n     *         receiverValue + targetChainAmount\\n     */\\n    function quoteNativeForChain(\\n        uint16 targetChain,\\n        uint256 currentChainAmount,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 targetChainAmount);\\n\\n    /**\\n     * @notice Returns the address of the current default delivery provider\\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n     *   chain. This must be a contract that implements IDeliveryProvider.\\n     */\\n    function getDefaultDeliveryProvider()\\n        external\\n        view\\n        returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n    enum DeliveryStatus {\\n        SUCCESS,\\n        RECEIVER_FAILURE\\n    }\\n\\n    enum RefundStatus {\\n        REFUND_SENT,\\n        REFUND_FAIL,\\n        CROSS_CHAIN_REFUND_SENT,\\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\\n        NO_REFUND_REQUESTED\\n    }\\n\\n    /**\\n     * @custom:member recipientContract - The target contract address\\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n     *     ChainID format)\\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n     *     corresponding to this delivery request\\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n     *     request\\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract\\n     * @custom:member status:\\n     *   - RECEIVER_FAILURE, if the target contract reverts\\n     *   - SUCCESS, if the target contract doesn't revert\\n     * @custom:member additionalStatusInfo:\\n     *   - If status is SUCCESS, then this is empty.\\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n     *       return data (i.e. potentially truncated revert reason information).\\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n     *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\\n     * @custom:member overridesInfo:\\n     *   - If not an override: empty bytes array\\n     *   - Otherwise: An encoded `DeliveryOverride`\\n     */\\n    event Delivery(\\n        address indexed recipientContract,\\n        uint16 indexed sourceChain,\\n        uint64 indexed sequence,\\n        bytes32 deliveryVaaHash,\\n        DeliveryStatus status,\\n        uint256 gasUsed,\\n        RefundStatus refundStatus,\\n        bytes additionalStatusInfo,\\n        bytes overridesInfo\\n    );\\n\\n    /**\\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n     *\\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n     *\\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n     * - the delivery VAA has a valid signature\\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\\n     * - the instruction's target chain is this chain\\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n     *\\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n     *     transaction)\\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n     *     contract with payload being the encoded delivery instruction container\\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n     *     should be sent\\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n     *     an encoded DeliveryOverride struct\\n     */\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(\\n    address relayer,\\n    uint16 chainId\\n);\\nerror DeliveryProviderCannotReceivePayment();\\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\\n\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\nerror TooManyMessageKeys(uint256 numMessageKeys);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\\n\"\r\n    },\r\n    \"lib/v3-core/contracts/interfaces/IChainlinkV3Aggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.22;\\n\\n/**\\n * @title IChainlinkAggregator\\n * @author Chainlink\\n * @dev Copied from https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\n * @notice Interface for Chainlink V3 aggregator contract\\n */\\ninterface IChainlinkV3Aggregator {\\n  /**\\n   * @notice The number of decimals the price is formatted with\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @notice The description of the aggregator\\n   */\\n  function description() external view returns (string memory);\\n\\n  /**\\n   * @notice The version number of the aggregator\\n   */\\n  function version() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the data from the latest round\\n   * @return roundId The round ID\\n   * @return answer The current price\\n   * @return startedAt The timestamp of when the round started\\n   * @return updatedAt The timestamp of when the round was updated\\n   * @return answeredInRound (Deprecated) Previously used when answers could take multiple rounds to be computed\\n   */\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/priceFeed/interfaces/IPriceFeedSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.22;\\n\\n/**\\n * @title IPriceFeedSender\\n * @author StakeWise\\n * @notice Interface for the PriceFeedSender contract\\n */\\ninterface IPriceFeedSender {\\n    /**\\n     * @notice Function for calculating the cost of the rate sync\\n     * @param targetChain The Wormhole chain ID of the target chain\\n     * @return cost The cost of the rate sync\\n     */\\n    function quoteRateSync(uint16 targetChain) external view returns (uint256 cost);\\n\\n    /**\\n     * @notice Function for syncing the rate to the target chain. Must be called with the exact cost of the rate sync.\\n     * @param targetChain The Wormhole chain ID of the target chain\\n     * @param targetAddress The address of the rate receiver on the target chain\\n     */\\n    function syncRate(uint16 targetChain, address targetAddress) external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/\",\r\n      \"@stakewise-core/=lib/v3-core/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/wormhole-solidity-sdk/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-gas-snapshot/=lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wormholeRelayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntToUint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"}],\"name\":\"quoteRateSync\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"syncRate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "PriceFeedSender", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008023518b2192fb5384dadc596765b3dd1cdfe47100000000000000000000000027428dd2d3dd32a4d7f7c497eaaa23130d89491100000000000000000000000000000000000000000000000000000000000249f00000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}