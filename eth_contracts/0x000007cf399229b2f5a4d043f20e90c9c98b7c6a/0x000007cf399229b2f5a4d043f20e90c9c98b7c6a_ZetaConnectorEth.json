{"SourceCode": "// Sources flattened with hardhat v2.13.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.8.3\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity 0.8.7;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.8.3\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.3\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File contracts/evm/interfaces/ConnectorErrors.sol\r\n\r\n/**\r\n * @dev Interface with connector custom errors\r\n */\r\ninterface ConnectorErrors {\r\n    // @dev Thrown when caller is not the address defined as paused address\r\n    error CallerIsNotPauser(address caller);\r\n\r\n    // @dev Thrown when caller is not the address defined as TSS address\r\n    error CallerIsNotTss(address caller);\r\n\r\n    // @dev Thrown when caller is not the address defined as TSS Updater address\r\n    error CallerIsNotTssUpdater(address caller);\r\n\r\n    // @dev Thrown when caller is not the address defined as TSS or TSS Updater address\r\n    error CallerIsNotTssOrUpdater(address caller);\r\n\r\n    // @dev Thrown when Zeta can't be transferred for some reason\r\n    error ZetaTransferError();\r\n\r\n    // @dev Thrown when maxSupply will be exceed if minting will proceed\r\n    error ExceedsMaxSupply(uint256 maxSupply);\r\n}\r\n\r\n// File contracts/evm/interfaces/ZetaInterfaces.sol\r\n\r\ninterface ZetaInterfaces {\r\n    /**\r\n     * @dev Use SendInput to interact with the Connector: connector.send(SendInput)\r\n     */\r\n    struct SendInput {\r\n        /// @dev Chain id of the destination chain. More about chain ids https://docs.zetachain.com/learn/glossary#chain-id\r\n        uint256 destinationChainId;\r\n        /// @dev Address receiving the message on the destination chain (expressed in bytes since it can be non-EVM)\r\n        bytes destinationAddress;\r\n        /// @dev Gas limit for the destination chain's transaction\r\n        uint256 destinationGasLimit;\r\n        /// @dev An encoded, arbitrary message to be parsed by the destination contract\r\n        bytes message;\r\n        /// @dev ZETA to be sent cross-chain + ZetaChain gas fees + destination chain gas fees (expressed in ZETA)\r\n        uint256 zetaValueAndGas;\r\n        /// @dev Optional parameters for the ZetaChain protocol\r\n        bytes zetaParams;\r\n    }\r\n\r\n    /**\r\n     * @dev Our Connector calls onZetaMessage with this struct as argument\r\n     */\r\n    struct ZetaMessage {\r\n        bytes zetaTxSenderAddress;\r\n        uint256 sourceChainId;\r\n        address destinationAddress;\r\n        /// @dev Remaining ZETA from zetaValueAndGas after subtracting ZetaChain gas fees and destination gas fees\r\n        uint256 zetaValue;\r\n        bytes message;\r\n    }\r\n\r\n    /**\r\n     * @dev Our Connector calls onZetaRevert with this struct as argument\r\n     */\r\n    struct ZetaRevert {\r\n        address zetaTxSenderAddress;\r\n        uint256 sourceChainId;\r\n        bytes destinationAddress;\r\n        uint256 destinationChainId;\r\n        /// @dev Equals to: zetaValueAndGas - ZetaChain gas fees - destination chain gas fees - source chain revert tx gas fees\r\n        uint256 remainingZetaValue;\r\n        bytes message;\r\n    }\r\n}\r\n\r\ninterface ZetaConnector {\r\n    /**\r\n     * @dev Sending value and data cross-chain is as easy as calling connector.send(SendInput)\r\n     */\r\n    function send(ZetaInterfaces.SendInput calldata input) external;\r\n}\r\n\r\ninterface ZetaReceiver {\r\n    /**\r\n     * @dev onZetaMessage is called when a cross-chain message reaches a contract\r\n     */\r\n    function onZetaMessage(ZetaInterfaces.ZetaMessage calldata zetaMessage) external;\r\n\r\n    /**\r\n     * @dev onZetaRevert is called when a cross-chain message reverts.\r\n     * It's useful to rollback to the original state\r\n     */\r\n    function onZetaRevert(ZetaInterfaces.ZetaRevert calldata zetaRevert) external;\r\n}\r\n\r\n/**\r\n * @dev ZetaTokenConsumer makes it easier to handle the following situations:\r\n *   - Getting Zeta using native coin (to pay for destination gas while using `connector.send`)\r\n *   - Getting Zeta using a token (to pay for destination gas while using `connector.send`)\r\n *   - Getting native coin using Zeta (to return unused destination gas when `onZetaRevert` is executed)\r\n *   - Getting a token using Zeta (to return unused destination gas when `onZetaRevert` is executed)\r\n * @dev The interface can be implemented using different strategies, like UniswapV2, UniswapV3, etc\r\n */\r\ninterface ZetaTokenConsumer {\r\n    event EthExchangedForZeta(uint256 amountIn, uint256 amountOut);\r\n    event TokenExchangedForZeta(address token, uint256 amountIn, uint256 amountOut);\r\n    event ZetaExchangedForEth(uint256 amountIn, uint256 amountOut);\r\n    event ZetaExchangedForToken(address token, uint256 amountIn, uint256 amountOut);\r\n\r\n    function getZetaFromEth(address destinationAddress, uint256 minAmountOut) external payable returns (uint256);\r\n\r\n    function getZetaFromToken(\r\n        address destinationAddress,\r\n        uint256 minAmountOut,\r\n        address inputToken,\r\n        uint256 inputTokenAmount\r\n    ) external returns (uint256);\r\n\r\n    function getEthFromZeta(\r\n        address destinationAddress,\r\n        uint256 minAmountOut,\r\n        uint256 zetaTokenAmount\r\n    ) external returns (uint256);\r\n\r\n    function getTokenFromZeta(\r\n        address destinationAddress,\r\n        uint256 minAmountOut,\r\n        address outputToken,\r\n        uint256 zetaTokenAmount\r\n    ) external returns (uint256);\r\n\r\n    function hasZetaLiquidity() external view returns (bool);\r\n}\r\n\r\ninterface ZetaCommonErrors {\r\n    error InvalidAddress();\r\n}\r\n\r\n// File contracts/evm/ZetaConnector.base.sol\r\n\r\n/**\r\n * @dev Main abstraction of ZetaConnector.\r\n * This contract manages interactions between TSS and different chains.\r\n * There's an instance of this contract on each chain supported by ZetaChain.\r\n */\r\ncontract ZetaConnectorBase is ConnectorErrors, Pausable {\r\n    address public immutable zetaToken;\r\n\r\n    /**\r\n     * @dev Multisig contract to pause incoming transactions.\r\n     * The responsibility of pausing outgoing transactions is left to the protocol for more flexibility.\r\n     */\r\n    address public pauserAddress;\r\n\r\n    /**\r\n     * @dev Collectively held by ZetaChain validators.\r\n     */\r\n    address public tssAddress;\r\n\r\n    /**\r\n     * @dev This address will start pointing to a multisig contract, then it will become the TSS address itself.\r\n     */\r\n    address public tssAddressUpdater;\r\n\r\n    event ZetaSent(\r\n        address sourceTxOriginAddress,\r\n        address indexed zetaTxSenderAddress,\r\n        uint256 indexed destinationChainId,\r\n        bytes destinationAddress,\r\n        uint256 zetaValueAndGas,\r\n        uint256 destinationGasLimit,\r\n        bytes message,\r\n        bytes zetaParams\r\n    );\r\n\r\n    event ZetaReceived(\r\n        bytes zetaTxSenderAddress,\r\n        uint256 indexed sourceChainId,\r\n        address indexed destinationAddress,\r\n        uint256 zetaValue,\r\n        bytes message,\r\n        bytes32 indexed internalSendHash\r\n    );\r\n\r\n    event ZetaReverted(\r\n        address zetaTxSenderAddress,\r\n        uint256 sourceChainId,\r\n        uint256 indexed destinationChainId,\r\n        bytes destinationAddress,\r\n        uint256 remainingZetaValue,\r\n        bytes message,\r\n        bytes32 indexed internalSendHash\r\n    );\r\n\r\n    event TSSAddressUpdated(address callerAddress, address newTssAddress);\r\n\r\n    event TSSAddressUpdaterUpdated(address callerAddress, address newTssUpdaterAddress);\r\n\r\n    event PauserAddressUpdated(address callerAddress, address newTssAddress);\r\n\r\n    /**\r\n     * @dev Constructor requires initial addresses.\r\n     * zetaToken address is the only immutable one, while others can be updated.\r\n     */\r\n    constructor(address zetaToken_, address tssAddress_, address tssAddressUpdater_, address pauserAddress_) {\r\n        if (\r\n            zetaToken_ == address(0) ||\r\n            tssAddress_ == address(0) ||\r\n            tssAddressUpdater_ == address(0) ||\r\n            pauserAddress_ == address(0)\r\n        ) {\r\n            revert ZetaCommonErrors.InvalidAddress();\r\n        }\r\n\r\n        zetaToken = zetaToken_;\r\n        tssAddress = tssAddress_;\r\n        tssAddressUpdater = tssAddressUpdater_;\r\n        pauserAddress = pauserAddress_;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict actions to pauser address.\r\n     */\r\n    modifier onlyPauser() {\r\n        if (msg.sender != pauserAddress) revert CallerIsNotPauser(msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict actions to TSS address.\r\n     */\r\n    modifier onlyTssAddress() {\r\n        if (msg.sender != tssAddress) revert CallerIsNotTss(msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict actions to TSS updater address.\r\n     */\r\n    modifier onlyTssUpdater() {\r\n        if (msg.sender != tssAddressUpdater) revert CallerIsNotTssUpdater(msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the pauser address. The only address allowed to do that is the current pauser.\r\n     */\r\n    function updatePauserAddress(address pauserAddress_) external onlyPauser {\r\n        if (pauserAddress_ == address(0)) revert ZetaCommonErrors.InvalidAddress();\r\n\r\n        pauserAddress = pauserAddress_;\r\n\r\n        emit PauserAddressUpdated(msg.sender, pauserAddress_);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the TSS address. The address can be updated by the TSS updater or the TSS address itself.\r\n     */\r\n    function updateTssAddress(address tssAddress_) external {\r\n        if (msg.sender != tssAddress && msg.sender != tssAddressUpdater) revert CallerIsNotTssOrUpdater(msg.sender);\r\n        if (tssAddress_ == address(0)) revert ZetaCommonErrors.InvalidAddress();\r\n\r\n        tssAddress = tssAddress_;\r\n\r\n        emit TSSAddressUpdated(msg.sender, tssAddress_);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the ownership of tssAddressUpdater to be the one held by the ZetaChain TSS Signer nodes.\r\n     */\r\n    function renounceTssAddressUpdater() external onlyTssUpdater {\r\n        if (tssAddress == address(0)) revert ZetaCommonErrors.InvalidAddress();\r\n\r\n        tssAddressUpdater = tssAddress;\r\n        emit TSSAddressUpdaterUpdated(msg.sender, tssAddressUpdater);\r\n    }\r\n\r\n    /**\r\n     * @dev Pause the input (send) transactions.\r\n     */\r\n\r\n    function pause() external onlyPauser {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause the contract to allow transactions again.\r\n     */\r\n\r\n    function unpause() external onlyPauser {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Entrypoint to send data and value through ZetaChain.\r\n     */\r\n    function send(ZetaInterfaces.SendInput calldata input) external virtual {}\r\n\r\n    /**\r\n     * @dev Handler to receive data from other chain.\r\n     * This method can be called only by TSS. Access validation is in implementation.\r\n     */\r\n    function onReceive(\r\n        bytes calldata zetaTxSenderAddress,\r\n        uint256 sourceChainId,\r\n        address destinationAddress,\r\n        uint256 zetaValue,\r\n        bytes calldata message,\r\n        bytes32 internalSendHash\r\n    ) external virtual {}\r\n\r\n    /**\r\n     * @dev Handler to receive errors from other chain.\r\n     * This method can be called only by TSS. Access validation is in implementation.\r\n     */\r\n    function onRevert(\r\n        address zetaTxSenderAddress,\r\n        uint256 sourceChainId,\r\n        bytes calldata destinationAddress,\r\n        uint256 destinationChainId,\r\n        uint256 remainingZetaValue,\r\n        bytes calldata message,\r\n        bytes32 internalSendHash\r\n    ) external virtual {}\r\n}\r\n\r\n// File contracts/evm/ZetaConnector.eth.sol\r\n\r\n/**\r\n * @dev ETH implementation of ZetaConnector.\r\n * This contract manages interactions between TSS and different chains.\r\n * This version is only for Ethereum network because in the other chains we mint and burn and in this one we lock and unlock.\r\n */\r\ncontract ZetaConnectorEth is ZetaConnectorBase {\r\n    constructor(\r\n        address zetaToken_,\r\n        address tssAddress_,\r\n        address tssAddressUpdater_,\r\n        address pauserAddress_\r\n    ) ZetaConnectorBase(zetaToken_, tssAddress_, tssAddressUpdater_, pauserAddress_) {}\r\n\r\n    function getLockedAmount() external view returns (uint256) {\r\n        return IERC20(zetaToken).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Entrypoint to send data through ZetaChain\r\n     * This call locks the token on the contract and emits an event with all the data needed by the protocol.\r\n     */\r\n    function send(ZetaInterfaces.SendInput calldata input) external override whenNotPaused {\r\n        bool success = IERC20(zetaToken).transferFrom(msg.sender, address(this), input.zetaValueAndGas);\r\n        if (!success) revert ZetaTransferError();\r\n\r\n        emit ZetaSent(\r\n            tx.origin,\r\n            msg.sender,\r\n            input.destinationChainId,\r\n            input.destinationAddress,\r\n            input.zetaValueAndGas,\r\n            input.destinationGasLimit,\r\n            input.message,\r\n            input.zetaParams\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Handler to receive data from other chain.\r\n     * This method can be called only by TSS.\r\n     * Transfers the Zeta tokens to destination and calls onZetaMessage if it's needed.\r\n     */\r\n    function onReceive(\r\n        bytes calldata zetaTxSenderAddress,\r\n        uint256 sourceChainId,\r\n        address destinationAddress,\r\n        uint256 zetaValue,\r\n        bytes calldata message,\r\n        bytes32 internalSendHash\r\n    ) external override onlyTssAddress {\r\n        bool success = IERC20(zetaToken).transfer(destinationAddress, zetaValue);\r\n        if (!success) revert ZetaTransferError();\r\n\r\n        if (message.length > 0) {\r\n            ZetaReceiver(destinationAddress).onZetaMessage(\r\n                ZetaInterfaces.ZetaMessage(zetaTxSenderAddress, sourceChainId, destinationAddress, zetaValue, message)\r\n            );\r\n        }\r\n\r\n        emit ZetaReceived(zetaTxSenderAddress, sourceChainId, destinationAddress, zetaValue, message, internalSendHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Handler to receive errors from other chain.\r\n     * This method can be called only by TSS.\r\n     * Transfers the Zeta tokens to destination and calls onZetaRevert if it's needed.\r\n     */\r\n    function onRevert(\r\n        address zetaTxSenderAddress,\r\n        uint256 sourceChainId,\r\n        bytes calldata destinationAddress,\r\n        uint256 destinationChainId,\r\n        uint256 remainingZetaValue,\r\n        bytes calldata message,\r\n        bytes32 internalSendHash\r\n    ) external override whenNotPaused onlyTssAddress {\r\n        bool success = IERC20(zetaToken).transfer(zetaTxSenderAddress, remainingZetaValue);\r\n        if (!success) revert ZetaTransferError();\r\n\r\n        if (message.length > 0) {\r\n            ZetaReceiver(zetaTxSenderAddress).onZetaRevert(\r\n                ZetaInterfaces.ZetaRevert(\r\n                    zetaTxSenderAddress,\r\n                    sourceChainId,\r\n                    destinationAddress,\r\n                    destinationChainId,\r\n                    remainingZetaValue,\r\n                    message\r\n                )\r\n            );\r\n        }\r\n\r\n        emit ZetaReverted(\r\n            zetaTxSenderAddress,\r\n            sourceChainId,\r\n            destinationChainId,\r\n            destinationAddress,\r\n            remainingZetaValue,\r\n            message,\r\n            internalSendHash\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zetaToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tssAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tssAddressUpdater_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauserAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotPauser\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotTss\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotTssOrUpdater\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotTssUpdater\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"ExceedsMaxSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZetaTransferError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTssAddress\",\"type\":\"address\"}],\"name\":\"PauserAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTssAddress\",\"type\":\"address\"}],\"name\":\"TSSAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTssUpdaterAddress\",\"type\":\"address\"}],\"name\":\"TSSAddressUpdaterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zetaTxSenderAddress\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zetaValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"internalSendHash\",\"type\":\"bytes32\"}],\"name\":\"ZetaReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zetaTxSenderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"destinationAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingZetaValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"internalSendHash\",\"type\":\"bytes32\"}],\"name\":\"ZetaReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sourceTxOriginAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zetaTxSenderAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"destinationAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zetaValueAndGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationGasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zetaParams\",\"type\":\"bytes\"}],\"name\":\"ZetaSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"zetaTxSenderAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"zetaValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"internalSendHash\",\"type\":\"bytes32\"}],\"name\":\"onReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zetaTxSenderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"destinationAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingZetaValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"internalSendHash\",\"type\":\"bytes32\"}],\"name\":\"onRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauserAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceTssAddressUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"destinationAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"destinationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"zetaValueAndGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zetaParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ZetaInterfaces.SendInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tssAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tssAddressUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pauserAddress_\",\"type\":\"address\"}],\"name\":\"updatePauserAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tssAddress_\",\"type\":\"address\"}],\"name\":\"updateTssAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zetaToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZetaConnectorEth", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000f091867ec603a6628ed83d274e835539d82e9cc8000000000000000000000000aeb6ddb7708467814d557e340283248be8e43124000000000000000000000000aeb6ddb7708467814d557e340283248be8e43124000000000000000000000000aeb6ddb7708467814d557e340283248be8e43124", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c386ec06beb54bf2f1fa9d6ebdcbce1a2c994b9dc5c90038fe0d0a4b8174e1ea"}