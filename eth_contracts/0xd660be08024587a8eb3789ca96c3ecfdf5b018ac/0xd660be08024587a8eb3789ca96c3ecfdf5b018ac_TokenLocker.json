{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.14;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function owner() external view returns (address);\\n    function getOwner() external view returns (address);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function mint(address to, uint value) external;\\n    function burn(address from, uint value) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenLocker.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.14;\\n\\ninterface ITokenLocker {\\n    struct LockedToken {\\n        address locker;\\n        uint256 endTime;\\n        uint256 amount;\\n    }\\n\\n    event TokenLocked(address indexed user, address indexed token, uint256 amount, uint256 duration);\\n    event LockAmountIncreased(address indexed user, address indexed token, uint256 amountIncreased);\\n    event LockDurationIncreased(address indexed user, address indexed token, uint256 durationIncreased);\\n    event TokenWithdrawn(address indexed user, address indexed token, uint256 amount);\\n\\n    function lockToken(address _user, address _token, uint256 _amount, uint256 _duration) external;\\n    function withdrawToken(address _user, address _token, uint256 _amount) external;\\n    function userLockedToken(address _user, address _token) external returns(LockedToken memory);\\n}\"\r\n    },\r\n    \"contracts/TokenLocker.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.14;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITokenLocker.sol\\\";\\n\\ncontract TokenLocker is ITokenLocker {\\n    address public immutable masterChef;\\n    mapping(address => mapping(address => LockedToken)) internal _userLockedToken;\\n\\n    // This contract will be deployed thru create2 directly from the MasterChef contract\\n    constructor() {\\n        masterChef = msg.sender;\\n    }\\n\\n    bool private _locked;\\n    modifier nonReentrant() {\\n        require(_locked == false, \\\"TokenLocker: REENTRANT_CALL\\\");\\n        _locked = true;\\n        _;\\n        _locked = false;\\n    }\\n\\n    function lockToken(address _user, address _token, uint256 _amount, uint256 _duration) external nonReentrant {\\n        require(msg.sender == _userLockedToken[_user][_token].locker || (_userLockedToken[_user][_token].locker == address(0) && (msg.sender == _user || msg.sender == masterChef)), \\\"TokenLocker: FORBIDDEN_WITHDRAW\\\");\\n        require(IERC20(_token).balanceOf(msg.sender) >= _amount, \\\"TokenLocker: AMOUNT_EXCEEDS_BALANCE\\\");\\n\\n        // If this token has already an amount locked by this caller, just increase its locking amount by _amount;\\n        // And increase its locking duration by _duration (if endTime is not met yet) or set it to \\\"now\\\" + _duration\\n        // (if endTime is already passed). Avoids exploiting of _duration to decrease the lock period.\\n        if (_userLockedToken[_user][_token].amount > 0) {\\n            if (_amount > 0) {\\n                _increaseLockedAmount(_user, _token, _amount);\\n            }\\n            if (_duration > 0) {\\n                _increaseLockDuration(_user, _token, _duration);\\n            }\\n            return;\\n        }\\n\\n        if (_amount > 0) {\\n            _userLockedToken[_user][_token] = LockedToken({\\n                locker: msg.sender,\\n                endTime: block.timestamp + _duration,\\n                amount: _amount\\n            });\\n\\n            IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n\\n            emit TokenLocked(_user, _token, _amount, _duration);\\n        }\\n    }\\n\\n    function _increaseLockedAmount(address _user, address _token, uint256 _amount) internal {\\n        _userLockedToken[_user][_token].amount += _amount;\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n\\n        emit LockAmountIncreased(_user, _token, _amount);\\n    }\\n\\n    function _increaseLockDuration(address _user, address _token, uint256 _increaseBy) internal {\\n        if (_userLockedToken[_user][_token].endTime >= block.timestamp) {\\n            _userLockedToken[_user][_token].endTime += _increaseBy;\\n        } else {\\n            _increaseBy += (block.timestamp - _userLockedToken[_user][_token].endTime);\\n            _userLockedToken[_user][_token].endTime += _increaseBy;\\n        }\\n\\n        emit LockDurationIncreased(msg.sender, _token, _increaseBy);\\n    }\\n\\n    function withdrawToken(address _user, address _token, uint256 _amount) external nonReentrant {\\n        if (_amount == 0) {\\n            return;\\n        }\\n        require(msg.sender == _userLockedToken[_user][_token].locker, \\\"TokenLocker: FORBIDDEN_WITHDRAW\\\");\\n        require(_userLockedToken[_user][_token].endTime <= block.timestamp, \\\"TokenLocker: TOKEN_STILL_LOCKED\\\");\\n        require(_amount <= _userLockedToken[_user][_token].amount, \\\"TokenLocker: AMOUNT_EXCEEDS_LOCKED_AMOUNT\\\");\\n    \\n        _userLockedToken[_user][_token].amount -= _amount;\\n    \\n        IERC20(_token).transfer(msg.sender, _amount);\\n    \\n        emit TokenWithdrawn(_user, _token, _amount);\\n    }\\n\\n    function userLockedToken(address _user, address _token) external view returns(LockedToken memory) {\\n        return _userLockedToken[_user][_token];\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIncreased\",\"type\":\"uint256\"}],\"name\":\"LockAmountIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"durationIncreased\",\"type\":\"uint256\"}],\"name\":\"LockDurationIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"userLockedToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenLocker.LockedToken\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenLocker", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}