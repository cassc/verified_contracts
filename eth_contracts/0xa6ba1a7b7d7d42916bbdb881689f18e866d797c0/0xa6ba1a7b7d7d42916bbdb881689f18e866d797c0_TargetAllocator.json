{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.2 <0.9.0;\r\n\r\ntype Id is bytes32;\r\n\r\nstruct MarketParams {\r\n    address loanToken;\r\n    address collateralToken;\r\n    address oracle;\r\n    address irm;\r\n    uint256 lltv;\r\n}\r\n\r\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\r\n/// accrual.\r\nstruct Position {\r\n    uint256 supplyShares;\r\n    uint128 borrowShares;\r\n    uint128 collateral;\r\n}\r\n\r\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\r\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\r\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\r\n/// interest accrual.\r\nstruct Market {\r\n    uint128 totalSupplyAssets;\r\n    uint128 totalSupplyShares;\r\n    uint128 totalBorrowAssets;\r\n    uint128 totalBorrowShares;\r\n    uint128 lastUpdate;\r\n    uint128 fee;\r\n}\r\n\r\nstruct Authorization {\r\n    address authorizer;\r\n    address authorized;\r\n    bool isAuthorized;\r\n    uint256 nonce;\r\n    uint256 deadline;\r\n}\r\n\r\nstruct Signature {\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n}\r\n\r\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\r\n/// @dev Consider using the IMorpho interface instead of this one.\r\ninterface IMorphoBase {\r\n    /// @notice The EIP-712 domain separator.\r\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\r\n    /// the same chain id because the domain separator would be the same.\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    /// @notice The owner of the contract.\r\n    /// @dev It has the power to change the owner.\r\n    /// @dev It has the power to set fees on markets and set the fee recipient.\r\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice The fee recipient of all markets.\r\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\r\n    function feeRecipient() external view returns (address);\r\n\r\n    /// @notice Whether the `irm` is enabled.\r\n    function isIrmEnabled(address irm) external view returns (bool);\r\n\r\n    /// @notice Whether the `lltv` is enabled.\r\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\r\n\r\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s positions.\r\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\r\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\r\n\r\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\r\n    function nonce(address authorizer) external view returns (uint256);\r\n\r\n    /// @notice Sets `newOwner` as `owner` of the contract.\r\n    /// @dev Warning: No two-step transfer ownership.\r\n    /// @dev Warning: The owner can be set to the zero address.\r\n    function setOwner(address newOwner) external;\r\n\r\n    /// @notice Enables `irm` as a possible IRM for market creation.\r\n    /// @dev Warning: It is not possible to disable an IRM.\r\n    function enableIrm(address irm) external;\r\n\r\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\r\n    /// @dev Warning: It is not possible to disable a LLTV.\r\n    function enableLltv(uint256 lltv) external;\r\n\r\n    /// @notice Sets the `newFee` for the given market `marketParams`.\r\n    /// @dev Warning: The recipient can be the zero address.\r\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\r\n\r\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\r\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\r\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\r\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\r\n    function setFeeRecipient(address newFeeRecipient) external;\r\n\r\n    /// @notice Creates the market `marketParams`.\r\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\r\n    /// Morpho behaves as expected:\r\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\r\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\r\n    /// burn functions are not supported.\r\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\r\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\r\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\r\n    /// - The IRM should not re-enter Morpho.\r\n    /// - The oracle should return a price with the correct scaling.\r\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\r\n    /// (funds could get stuck):\r\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\r\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\r\n    /// `toSharesDown` overflow.\r\n    /// - The IRM can revert on `borrowRate`.\r\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\r\n    /// overflow.\r\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\r\n    /// `liquidate` from being used under certain market conditions.\r\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\r\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\r\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\r\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\r\n    function createMarket(MarketParams memory marketParams) external;\r\n\r\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\r\n    /// `onMorphoSupply` function with the given `data`.\r\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\r\n    /// is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific amount\r\n    /// of shares is given for full compatibility and precision.\r\n    /// @dev If the supply of a market gets depleted, the supply share price instantly resets to\r\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\r\n    /// @dev Supplying a large amount can revert for overflow.\r\n    /// @param marketParams The market to supply assets to.\r\n    /// @param assets The amount of assets to supply.\r\n    /// @param shares The amount of shares to mint.\r\n    /// @param onBehalf The address that will own the increased supply position.\r\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\r\n    /// @return assetsSupplied The amount of assets supplied.\r\n    /// @return sharesSupplied The amount of shares minted.\r\n    function supply(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        bytes memory data\r\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\r\n\r\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` to `receiver`.\r\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\r\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\r\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\r\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\r\n    /// conversion roundings between shares and assets.\r\n    /// @param marketParams The market to withdraw assets from.\r\n    /// @param assets The amount of assets to withdraw.\r\n    /// @param shares The amount of shares to burn.\r\n    /// @param onBehalf The address of the owner of the supply position.\r\n    /// @param receiver The address that will receive the withdrawn assets.\r\n    /// @return assetsWithdrawn The amount of assets withdrawn.\r\n    /// @return sharesWithdrawn The amount of shares burned.\r\n    function withdraw(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\r\n\r\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` to `receiver`.\r\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\r\n    /// is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is given for\r\n    /// full compatibility and precision.\r\n    /// @dev If the borrow of a market gets depleted, the borrow share price instantly resets to\r\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\r\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\r\n    /// @dev Borrowing a large amount can revert for overflow.\r\n    /// @param marketParams The market to borrow assets from.\r\n    /// @param assets The amount of assets to borrow.\r\n    /// @param shares The amount of shares to mint.\r\n    /// @param onBehalf The address that will own the increased borrow position.\r\n    /// @param receiver The address that will receive the borrowed assets.\r\n    /// @return assetsBorrowed The amount of assets borrowed.\r\n    /// @return sharesBorrowed The amount of shares minted.\r\n    function borrow(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\r\n\r\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\r\n    /// `onMorphoReplay` function with the given `data`.\r\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\r\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\r\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\r\n    /// roundings between shares and assets.\r\n    /// @param marketParams The market to repay assets to.\r\n    /// @param assets The amount of assets to repay.\r\n    /// @param shares The amount of shares to burn.\r\n    /// @param onBehalf The address of the owner of the debt position.\r\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\r\n    /// @return assetsRepaid The amount of assets repaid.\r\n    /// @return sharesRepaid The amount of shares burned.\r\n    function repay(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        bytes memory data\r\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\r\n\r\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\r\n    /// `onMorphoSupplyCollateral` function with the given `data`.\r\n    /// @dev Interest are not accrued since it's not required and it saves gas.\r\n    /// @dev Supplying a large amount can revert for overflow.\r\n    /// @param marketParams The market to supply collateral to.\r\n    /// @param assets The amount of collateral to supply.\r\n    /// @param onBehalf The address that will own the increased collateral position.\r\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\r\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\r\n        external;\r\n\r\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` to `receiver`.\r\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\r\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\r\n    /// @param marketParams The market to withdraw collateral from.\r\n    /// @param assets The amount of collateral to withdraw.\r\n    /// @param onBehalf The address of the owner of the collateral position.\r\n    /// @param receiver The address that will receive the collateral assets.\r\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\r\n        external;\r\n\r\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\r\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\r\n    /// `onMorphoLiquidate` function with the given `data`.\r\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\r\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\r\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\r\n    /// @param marketParams The market of the position.\r\n    /// @param borrower The owner of the position.\r\n    /// @param seizedAssets The amount of collateral to seize.\r\n    /// @param repaidShares The amount of shares to repay.\r\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\r\n    /// @return The amount of assets seized.\r\n    /// @return The amount of assets repaid.\r\n    function liquidate(\r\n        MarketParams memory marketParams,\r\n        address borrower,\r\n        uint256 seizedAssets,\r\n        uint256 repaidShares,\r\n        bytes memory data\r\n    ) external returns (uint256, uint256);\r\n\r\n    /// @notice Executes a flash loan.\r\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\r\n    /// markets combined, plus donations).\r\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\r\n    /// - `flashFee` is zero.\r\n    /// - `maxFlashLoan` is the token's balance of this contract.\r\n    /// - The receiver of `assets` is the caller.\r\n    /// @param token The token to flash loan.\r\n    /// @param assets The amount of assets to flash loan.\r\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\r\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\r\n\r\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\r\n    /// @param authorized The authorized address.\r\n    /// @param newIsAuthorized The new authorization status.\r\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\r\n\r\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\r\n    /// @dev Warning: Reverts if the signature has already been submitted.\r\n    /// @dev The signature is malleable, but it has no impact on the security here.\r\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\r\n    /// @param authorization The `Authorization` struct.\r\n    /// @param signature The signature.\r\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\r\n\r\n    /// @notice Accrues interest for the given market `marketParams`.\r\n    function accrueInterest(MarketParams memory marketParams) external;\r\n\r\n    /// @notice Returns the data stored on the different `slots`.\r\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\r\n}\r\n\r\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\r\n/// @dev Consider using the IMorpho interface instead of this one.\r\ninterface IMorphoStaticTyping is IMorphoBase {\r\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\r\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\r\n    /// accrual.\r\n    function position(Id id, address user)\r\n        external\r\n        view\r\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\r\n\r\n    /// @notice The state of the market corresponding to `id`.\r\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\r\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\r\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\r\n    /// accrual.\r\n    function market(Id id)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 totalSupplyAssets,\r\n            uint128 totalSupplyShares,\r\n            uint128 totalBorrowAssets,\r\n            uint128 totalBorrowShares,\r\n            uint128 lastUpdate,\r\n            uint128 fee\r\n        );\r\n\r\n    /// @notice The market params corresponding to `id`.\r\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\r\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\r\n    function idToMarketParams(Id id)\r\n        external\r\n        view\r\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\r\n}\r\n\r\n/// @title IMorpho\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\r\ninterface IMorpho is IMorphoBase {\r\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\r\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\r\n    /// accrual.\r\n    function position(Id id, address user) external view returns (Position memory p);\r\n\r\n    /// @notice The state of the market corresponding to `id`.\r\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\r\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\r\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\r\n    /// interest accrual.\r\n    function market(Id id) external view returns (Market memory m);\r\n\r\n    /// @notice The market params corresponding to `id`.\r\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\r\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\r\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n */\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * ==== Security Considerations\r\n *\r\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\r\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\r\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\r\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\r\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\r\n * generally recommended is:\r\n *\r\n * ```solidity\r\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\r\n *     doThing(..., value);\r\n * }\r\n *\r\n * function doThing(..., uint256 value) public {\r\n *     token.safeTransferFrom(msg.sender, address(this), value);\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\r\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\r\n * {SafeERC20-safeTransferFrom}).\r\n *\r\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\r\n * contracts should have entry points that don't rely on permit.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\nstruct MarketConfig {\r\n    /// @notice The maximum amount of assets that can be allocated to the market.\r\n    uint184 cap;\r\n    /// @notice Whether the market is in the withdraw queue.\r\n    bool enabled;\r\n    /// @notice The timestamp at which the market can be instantly removed from the withdraw queue.\r\n    uint64 removableAt;\r\n}\r\n\r\nstruct PendingUint192 {\r\n    /// @notice The pending value to set.\r\n    uint192 value;\r\n    /// @notice The timestamp at which the pending value becomes valid.\r\n    uint64 validAt;\r\n}\r\n\r\nstruct PendingAddress {\r\n    /// @notice The pending value to set.\r\n    address value;\r\n    /// @notice The timestamp at which the pending value becomes valid.\r\n    uint64 validAt;\r\n}\r\n\r\n/// @title PendingLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Library to manage pending values and their validity timestamp.\r\nlibrary PendingLib {\r\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\r\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\r\n    function update(PendingUint192 storage pending, uint184 newValue, uint256 timelock) internal {\r\n        pending.value = newValue;\r\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\r\n        pending.validAt = uint64(block.timestamp + timelock);\r\n    }\r\n\r\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\r\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\r\n    function update(PendingAddress storage pending, address newValue, uint256 timelock) internal {\r\n        pending.value = newValue;\r\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\r\n        pending.validAt = uint64(block.timestamp + timelock);\r\n    }\r\n}\r\n\r\n/// @dev Either `assets` or `shares` should be zero.\r\nstruct MarketAllocation {\r\n    /// @notice The market to allocate.\r\n    MarketParams marketParams;\r\n    /// @notice The amount of assets to allocate.\r\n    uint256 assets;\r\n}\r\n\r\ninterface IMulticall {\r\n    function multicall(bytes[] calldata) external returns (bytes[] memory);\r\n}\r\n\r\ninterface IOwnable {\r\n    function owner() external returns (address);\r\n    function transferOwnership(address) external;\r\n    function renounceOwnership() external;\r\n    function acceptOwnership() external;\r\n    function pendingOwner() external view returns (address);\r\n}\r\n\r\n/// @dev This interface is used for factorizing IMetaMorphoStaticTyping and IMetaMorpho.\r\n/// @dev Consider using the IMetaMorpho interface instead of this one.\r\ninterface IMetaMorphoBase {\r\n    /// @notice The address of the Morpho contract.\r\n    function MORPHO() external view returns (IMorpho);\r\n\r\n    /// @notice The address of the curator.\r\n    function curator() external view returns (address);\r\n\r\n    /// @notice Stores whether an address is an allocator or not.\r\n    function isAllocator(address target) external view returns (bool);\r\n\r\n    /// @notice The current guardian. Can be set even without the timelock set.\r\n    function guardian() external view returns (address);\r\n\r\n    /// @notice The current fee.\r\n    function fee() external view returns (uint96);\r\n\r\n    /// @notice The fee recipient.\r\n    function feeRecipient() external view returns (address);\r\n\r\n    /// @notice The skim recipient.\r\n    function skimRecipient() external view returns (address);\r\n\r\n    /// @notice The current timelock.\r\n    function timelock() external view returns (uint256);\r\n\r\n    /// @dev Stores the order of markets on which liquidity is supplied upon deposit.\r\n    /// @dev Can contain any market. A market is skipped as soon as its supply cap is reached.\r\n    function supplyQueue(uint256) external view returns (Id);\r\n\r\n    /// @notice Returns the length of the supply queue.\r\n    function supplyQueueLength() external view returns (uint256);\r\n\r\n    /// @dev Stores the order of markets from which liquidity is withdrawn upon withdrawal.\r\n    /// @dev Always contain all non-zero cap markets as well as all markets on which the vault supplies liquidity,\r\n    /// without duplicate.\r\n    function withdrawQueue(uint256) external view returns (Id);\r\n\r\n    /// @notice Returns the length of the withdraw queue.\r\n    function withdrawQueueLength() external view returns (uint256);\r\n\r\n    /// @notice Stores the total assets managed by this vault when the fee was last accrued.\r\n    /// @dev May be a little off `totalAssets()` after each interaction, due to some roundings.\r\n    function lastTotalAssets() external view returns (uint256);\r\n\r\n    /// @notice Submits a `newTimelock`.\r\n    /// @dev In case the new timelock is higher than the current one, the timelock is set immediately.\r\n    /// @dev Warning: Submitting a timelock will overwrite the current pending timelock.\r\n    function submitTimelock(uint256 newTimelock) external;\r\n\r\n    /// @notice Accepts the pending timelock.\r\n    function acceptTimelock() external;\r\n\r\n    /// @notice Revokes the pending timelock.\r\n    function revokePendingTimelock() external;\r\n\r\n    /// @notice Submits a `newSupplyCap` for the market defined by `marketParams`.\r\n    /// @dev In case the new cap is lower than the current one, the cap is set immediately.\r\n    /// @dev Warning: Submitting a cap will overwrite the current pending cap.\r\n    function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external;\r\n\r\n    /// @notice Accepts the pending cap of the market defined by `id`.\r\n    function acceptCap(Id id) external;\r\n\r\n    /// @notice Revokes the pending cap of the market defined by `id`.\r\n    function revokePendingCap(Id id) external;\r\n\r\n    /// @notice Submits a forced market removal from the vault, potentially losing all funds supplied to the market.\r\n    /// @dev Warning: Submitting a forced removal will overwrite the timestamp at which the market will be removable.\r\n    function submitMarketRemoval(Id id) external;\r\n\r\n    /// @notice Revokes the pending removal of the market defined by `id`.\r\n    function revokePendingMarketRemoval(Id id) external;\r\n\r\n    /// @notice Submits a `newGuardian`.\r\n    /// @notice Warning: a malicious guardian could disrupt the vault's operation, and would have the power to revoke\r\n    /// any pending guardian.\r\n    /// @dev In case there is no guardian, the gardian is set immediately.\r\n    /// @dev Warning: Submitting a gardian will overwrite the current pending gardian.\r\n    function submitGuardian(address newGuardian) external;\r\n\r\n    /// @notice Accepts the pending guardian.\r\n    function acceptGuardian() external;\r\n\r\n    /// @notice Revokes the pending guardian.\r\n    function revokePendingGuardian() external;\r\n\r\n    /// @notice Skims the vault `token` balance to `skimRecipient`.\r\n    function skim(address) external;\r\n\r\n    /// @notice Sets `newAllocator` as an allocator or not (`newIsAllocator`).\r\n    function setIsAllocator(address newAllocator, bool newIsAllocator) external;\r\n\r\n    /// @notice Sets `curator` to `newCurator`.\r\n    function setCurator(address newCurator) external;\r\n\r\n    /// @notice Sets the `fee` to `newFee`.\r\n    function setFee(uint256 newFee) external;\r\n\r\n    /// @notice Sets `feeRecipient` to `newFeeRecipient`.\r\n    function setFeeRecipient(address newFeeRecipient) external;\r\n\r\n    /// @notice Sets `skimRecipient` to `newSkimRecipient`.\r\n    function setSkimRecipient(address newSkimRecipient) external;\r\n\r\n    /// @notice Sets `supplyQueue` to `newSupplyQueue`.\r\n    /// @param newSupplyQueue is an array of enabled markets, and can contain duplicate markets, but it would only\r\n    /// increase the cost of depositing to the vault.\r\n    function setSupplyQueue(Id[] calldata newSupplyQueue) external;\r\n\r\n    /// @notice Sets the withdraw queue as a permutation of the previous one, although markets with both zero cap and\r\n    /// zero vault's supply can be removed from the permutation.\r\n    /// @notice This is the only entry point to disable a market.\r\n    /// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the\r\n    /// vault so the call to `updateWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can\r\n    /// simply bundle a reallocation that withdraws max from this market with a call to `updateWithdrawQueue`.\r\n    /// @param indexes The indexes of each market in the previous withdraw queue, in the new withdraw queue's order.\r\n    function updateWithdrawQueue(uint256[] calldata indexes) external;\r\n\r\n    /// @notice Reallocates the vault's liquidity so as to reach a given allocation of assets on each given market.\r\n    /// @notice The allocator can withdraw from any market, even if it's not in the withdraw queue, as long as the loan\r\n    /// token of the market is the same as the vault's asset.\r\n    /// @dev The behavior of the reallocation can be altered by state changes, including:\r\n    /// - Deposits on the vault that supplies to markets that are expected to be supplied to during reallocation.\r\n    /// - Withdrawals from the vault that withdraws from markets that are expected to be withdrawn from during\r\n    /// reallocation.\r\n    /// - Donations to the vault on markets that are expected to be supplied to during reallocation.\r\n    /// - Withdrawals from markets that are expected to be withdrawn from during reallocation.\r\n    function reallocate(MarketAllocation[] calldata allocations) external;\r\n}\r\n\r\n/// @dev This interface is inherited by MetaMorpho so that function signatures are checked by the compiler.\r\n/// @dev Consider using the IMetaMorpho interface instead of this one.\r\ninterface IMetaMorphoStaticTyping is IMetaMorphoBase {\r\n    /// @notice Returns the current configuration of each market.\r\n    function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);\r\n\r\n    /// @notice Returns the pending guardian.\r\n    function pendingGuardian() external view returns (address guardian, uint64 validAt);\r\n\r\n    /// @notice Returns the pending cap for each market.\r\n    function pendingCap(Id) external view returns (uint192 value, uint64 validAt);\r\n\r\n    /// @notice Returns the pending timelock.\r\n    function pendingTimelock() external view returns (uint192 value, uint64 validAt);\r\n}\r\n\r\n/// @title IMetaMorpho\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @dev Use this interface for MetaMorpho to have access to all the functions with the appropriate function signatures.\r\ninterface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {\r\n    /// @notice Returns the current configuration of each market.\r\n    function config(Id) external view returns (MarketConfig memory);\r\n\r\n    /// @notice Returns the pending guardian.\r\n    function pendingGuardian() external view returns (PendingAddress memory);\r\n\r\n    /// @notice Returns the pending cap for each market.\r\n    function pendingCap(Id) external view returns (PendingUint192 memory);\r\n\r\n    /// @notice Returns the pending timelock.\r\n    function pendingTimelock() external view returns (PendingUint192 memory);\r\n}\r\n\r\n/// @title MarketParamsLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Library to convert a market to its id.\r\nlibrary MarketParamsLib {\r\n    /// @notice The length of the data used to compute the id of a market.\r\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\r\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\r\n\r\n    /// @notice Returns the id of the market `marketParams`.\r\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\r\n        assembly (\"memory-safe\") {\r\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\r\n        }\r\n    }\r\n}\r\n\r\nuint256 constant WAD = 1e18;\r\n\r\n/// @title MathLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Library to manage fixed-point arithmetic.\r\nlibrary MathLib {\r\n    /// @dev Returns (`x` * `y`) / `WAD` rounded down.\r\n    function wMulDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD);\r\n    }\r\n\r\n    /// @dev Returns (`x` * `WAD`) / `y` rounded down.\r\n    function wDivDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y);\r\n    }\r\n\r\n    /// @dev Returns (`x` * `WAD`) / `y` rounded up.\r\n    function wDivUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y);\r\n    }\r\n\r\n    /// @dev Returns (`x` * `y`) / `d` rounded down.\r\n    function mulDivDown(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\r\n        return (x * y) / d;\r\n    }\r\n\r\n    /// @dev Returns (`x` * `y`) / `d` rounded up.\r\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\r\n        return (x * y + (d - 1)) / d;\r\n    }\r\n\r\n    /// @dev Returns the sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1, to approximate a\r\n    /// continuous compound interest rate.\r\n    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 firstTerm = x * n;\r\n        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD);\r\n        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);\r\n\r\n        return firstTerm + secondTerm + thirdTerm;\r\n    }\r\n}\r\n\r\n/// @title SharesMathLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Shares management library.\r\n/// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\r\n/// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\r\nlibrary SharesMathLib {\r\n    using MathLib for uint256;\r\n\r\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\r\n    /// high precision computations.\r\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\r\n\r\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\r\n    /// empty.\r\n    uint256 internal constant VIRTUAL_ASSETS = 1;\r\n\r\n    /// @dev Calculates the value of `assets` quoted in shares, rounding down.\r\n    function toSharesDown(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\r\n        return assets.mulDivDown(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\r\n    }\r\n\r\n    /// @dev Calculates the value of `shares` quoted in assets, rounding down.\r\n    function toAssetsDown(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\r\n        return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\r\n    }\r\n\r\n    /// @dev Calculates the value of `assets` quoted in shares, rounding up.\r\n    function toSharesUp(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\r\n        return assets.mulDivUp(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\r\n    }\r\n\r\n    /// @dev Calculates the value of `shares` quoted in assets, rounding up.\r\n    function toAssetsUp(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\r\n        return shares.mulDivUp(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\r\n    }\r\n}\r\n\r\n/// @title IIrm\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Interface that Interest Rate Models (IRMs) used by Morpho must implement.\r\ninterface IIrm {\r\n    /// @notice Returns the borrow rate of the market `marketParams`.\r\n    /// @dev Assumes that `market` corresponds to `marketParams`.\r\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256);\r\n\r\n    /// @notice Returns the borrow rate of the market `marketParams` without modifying any storage.\r\n    /// @dev Assumes that `market` corresponds to `marketParams`.\r\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\r\n}\r\n\r\n/// @title ErrorsLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Library exposing error messages.\r\nlibrary ErrorsLib {\r\n    /// @notice Thrown when the caller is not the owner.\r\n    string internal constant NOT_OWNER = \"not owner\";\r\n\r\n    /// @notice Thrown when the LLTV to enable exceeds the maximum LLTV.\r\n    string internal constant MAX_LLTV_EXCEEDED = \"max LLTV exceeded\";\r\n\r\n    /// @notice Thrown when the fee to set exceeds the maximum fee.\r\n    string internal constant MAX_FEE_EXCEEDED = \"max fee exceeded\";\r\n\r\n    /// @notice Thrown when the value is already set.\r\n    string internal constant ALREADY_SET = \"already set\";\r\n\r\n    /// @notice Thrown when the IRM is not enabled at market creation.\r\n    string internal constant IRM_NOT_ENABLED = \"IRM not enabled\";\r\n\r\n    /// @notice Thrown when the LLTV is not enabled at market creation.\r\n    string internal constant LLTV_NOT_ENABLED = \"LLTV not enabled\";\r\n\r\n    /// @notice Thrown when the market is already created.\r\n    string internal constant MARKET_ALREADY_CREATED = \"market already created\";\r\n\r\n    /// @notice Thrown when the market is not created.\r\n    string internal constant MARKET_NOT_CREATED = \"market not created\";\r\n\r\n    /// @notice Thrown when not exactly one of the input amount is zero.\r\n    string internal constant INCONSISTENT_INPUT = \"inconsistent input\";\r\n\r\n    /// @notice Thrown when zero assets is passed as input.\r\n    string internal constant ZERO_ASSETS = \"zero assets\";\r\n\r\n    /// @notice Thrown when a zero address is passed as input.\r\n    string internal constant ZERO_ADDRESS = \"zero address\";\r\n\r\n    /// @notice Thrown when the caller is not authorized to conduct an action.\r\n    string internal constant UNAUTHORIZED = \"unauthorized\";\r\n\r\n    /// @notice Thrown when the collateral is insufficient to `borrow` or `withdrawCollateral`.\r\n    string internal constant INSUFFICIENT_COLLATERAL = \"insufficient collateral\";\r\n\r\n    /// @notice Thrown when the liquidity is insufficient to `withdraw` or `borrow`.\r\n    string internal constant INSUFFICIENT_LIQUIDITY = \"insufficient liquidity\";\r\n\r\n    /// @notice Thrown when the position to liquidate is healthy.\r\n    string internal constant HEALTHY_POSITION = \"position is healthy\";\r\n\r\n    /// @notice Thrown when the authorization signature is invalid.\r\n    string internal constant INVALID_SIGNATURE = \"invalid signature\";\r\n\r\n    /// @notice Thrown when the authorization signature is expired.\r\n    string internal constant SIGNATURE_EXPIRED = \"signature expired\";\r\n\r\n    /// @notice Thrown when the nonce is invalid.\r\n    string internal constant INVALID_NONCE = \"invalid nonce\";\r\n\r\n    /// @notice Thrown when a token transfer reverted.\r\n    string internal constant TRANSFER_REVERTED = \"transfer reverted\";\r\n\r\n    /// @notice Thrown when a token transfer returned false.\r\n    string internal constant TRANSFER_RETURNED_FALSE = \"transfer returned false\";\r\n\r\n    /// @notice Thrown when a token transferFrom reverted.\r\n    string internal constant TRANSFER_FROM_REVERTED = \"transferFrom reverted\";\r\n\r\n    /// @notice Thrown when a token transferFrom returned false\r\n    string internal constant TRANSFER_FROM_RETURNED_FALSE = \"transferFrom returned false\";\r\n\r\n    /// @notice Thrown when the maximum uint128 is exceeded.\r\n    string internal constant MAX_UINT128_EXCEEDED = \"max uint128 exceeded\";\r\n}\r\n\r\n/// @title UtilsLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Library exposing helpers.\r\n/// @dev Inspired by https://github.com/morpho-org/morpho-utils.\r\nlibrary UtilsLib {\r\n    /// @dev Returns true if there is exactly one zero among `x` and `y`.\r\n    function exactlyOneZero(uint256 x, uint256 y) internal pure returns (bool z) {\r\n        assembly {\r\n            z := xor(iszero(x), iszero(y))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the min of `x` and `y`.\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assembly {\r\n            z := xor(x, mul(xor(x, y), lt(y, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x` safely cast to uint128.\r\n    function toUint128(uint256 x) internal pure returns (uint128) {\r\n        require(x <= type(uint128).max, ErrorsLib.MAX_UINT128_EXCEEDED);\r\n        return uint128(x);\r\n    }\r\n\r\n    /// @dev Returns max(x - y, 0).\r\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assembly {\r\n            z := mul(gt(x, y), sub(x, y))\r\n        }\r\n    }\r\n}\r\n\r\n/// @title MorphoStorageLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Helper library exposing getters to access Morpho storage variables' slot.\r\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\r\nlibrary MorphoStorageLib {\r\n    /* SLOTS */\r\n\r\n    uint256 internal constant OWNER_SLOT = 0;\r\n    uint256 internal constant FEE_RECIPIENT_SLOT = 1;\r\n    uint256 internal constant POSITION_SLOT = 2;\r\n    uint256 internal constant MARKET_SLOT = 3;\r\n    uint256 internal constant IS_IRM_ENABLED_SLOT = 4;\r\n    uint256 internal constant IS_LLTV_ENABLED_SLOT = 5;\r\n    uint256 internal constant IS_AUTHORIZED_SLOT = 6;\r\n    uint256 internal constant NONCE_SLOT = 7;\r\n    uint256 internal constant ID_TO_MARKET_PARAMS_SLOT = 8;\r\n\r\n    /* SLOT OFFSETS */\r\n\r\n    uint256 internal constant LOAN_TOKEN_OFFSET = 0;\r\n    uint256 internal constant COLLATERAL_TOKEN_OFFSET = 1;\r\n    uint256 internal constant ORACLE_OFFSET = 2;\r\n    uint256 internal constant IRM_OFFSET = 3;\r\n    uint256 internal constant LLTV_OFFSET = 4;\r\n\r\n    uint256 internal constant SUPPLY_SHARES_OFFSET = 0;\r\n    uint256 internal constant BORROW_SHARES_AND_COLLATERAL_OFFSET = 1;\r\n\r\n    uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;\r\n    uint256 internal constant TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1;\r\n    uint256 internal constant LAST_UPDATE_AND_FEE_OFFSET = 2;\r\n\r\n    /* GETTERS */\r\n\r\n    function ownerSlot() internal pure returns (bytes32) {\r\n        return bytes32(OWNER_SLOT);\r\n    }\r\n\r\n    function feeRecipientSlot() internal pure returns (bytes32) {\r\n        return bytes32(FEE_RECIPIENT_SLOT);\r\n    }\r\n\r\n    function positionSupplySharesSlot(Id id, address user) internal pure returns (bytes32) {\r\n        return bytes32(\r\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET\r\n        );\r\n    }\r\n\r\n    function positionBorrowSharesAndCollateralSlot(Id id, address user) internal pure returns (bytes32) {\r\n        return bytes32(\r\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT)))))\r\n                + BORROW_SHARES_AND_COLLATERAL_OFFSET\r\n        );\r\n    }\r\n\r\n    function marketTotalSupplyAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET);\r\n    }\r\n\r\n    function marketTotalBorrowAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET);\r\n    }\r\n\r\n    function marketLastUpdateAndFeeSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET);\r\n    }\r\n\r\n    function isIrmEnabledSlot(address irm) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(irm, IS_IRM_ENABLED_SLOT));\r\n    }\r\n\r\n    function isLltvEnabledSlot(uint256 lltv) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(lltv, IS_LLTV_ENABLED_SLOT));\r\n    }\r\n\r\n    function isAuthorizedSlot(address authorizer, address authorizee) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(authorizee, keccak256(abi.encode(authorizer, IS_AUTHORIZED_SLOT))));\r\n    }\r\n\r\n    function nonceSlot(address authorizer) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(authorizer, NONCE_SLOT));\r\n    }\r\n\r\n    function idToLoanTokenSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET);\r\n    }\r\n\r\n    function idToCollateralTokenSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET);\r\n    }\r\n\r\n    function idToOracleSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET);\r\n    }\r\n\r\n    function idToIrmSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET);\r\n    }\r\n\r\n    function idToLltvSlot(Id id) internal pure returns (bytes32) {\r\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET);\r\n    }\r\n}\r\n\r\n/// @title MorphoLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Helper library to access Morpho storage variables.\r\n/// @dev Warning: Supply and borrow getters may return outdated values that do not include accrued interest.\r\nlibrary MorphoLib {\r\n    function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));\r\n        return uint256(morpho.extSloads(slot)[0]);\r\n    }\r\n\r\n    function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\r\n        return uint128(uint256(morpho.extSloads(slot)[0]));\r\n    }\r\n\r\n    function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\r\n        return uint256(morpho.extSloads(slot)[0] >> 128);\r\n    }\r\n\r\n    function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\r\n        return uint128(uint256(morpho.extSloads(slot)[0]));\r\n    }\r\n\r\n    function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\r\n        return uint256(morpho.extSloads(slot)[0] >> 128);\r\n    }\r\n\r\n    function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\r\n        return uint128(uint256(morpho.extSloads(slot)[0]));\r\n    }\r\n\r\n    function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\r\n        return uint256(morpho.extSloads(slot)[0] >> 128);\r\n    }\r\n\r\n    function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\r\n        return uint128(uint256(morpho.extSloads(slot)[0]));\r\n    }\r\n\r\n    function fee(IMorpho morpho, Id id) internal view returns (uint256) {\r\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\r\n        return uint256(morpho.extSloads(slot)[0] >> 128);\r\n    }\r\n\r\n    function _array(bytes32 x) private pure returns (bytes32[] memory) {\r\n        bytes32[] memory res = new bytes32[](1);\r\n        res[0] = x;\r\n        return res;\r\n    }\r\n}\r\n\r\n/// @title MorphoBalancesLib\r\n/// @author Morpho Labs\r\n/// @custom:contact security@morpho.org\r\n/// @notice Helper library exposing getters with the expected value after interest accrual.\r\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\r\n/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply\r\n/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.\r\nlibrary MorphoBalancesLib {\r\n    using MathLib for uint256;\r\n    using MathLib for uint128;\r\n    using UtilsLib for uint256;\r\n    using MorphoLib for IMorpho;\r\n    using SharesMathLib for uint256;\r\n    using MarketParamsLib for MarketParams;\r\n\r\n    /// @notice Returns the expected market balances of a market after having accrued interest.\r\n    /// @return The expected total supply assets.\r\n    /// @return The expected total supply shares.\r\n    /// @return The expected total borrow assets.\r\n    /// @return The expected total borrow shares.\r\n    function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)\r\n        internal\r\n        view\r\n        returns (uint256, uint256, uint256, uint256)\r\n    {\r\n        Id id = marketParams.id();\r\n\r\n        Market memory market = morpho.market(id);\r\n\r\n        uint256 elapsed = block.timestamp - market.lastUpdate;\r\n\r\n        // Skipped if elapsed == 0 of if totalBorrowAssets == 0 because interest would be null.\r\n        if (elapsed != 0 && market.totalBorrowAssets != 0) {\r\n            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\r\n            uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\r\n            market.totalBorrowAssets += interest.toUint128();\r\n            market.totalSupplyAssets += interest.toUint128();\r\n\r\n            if (market.fee != 0) {\r\n                uint256 feeAmount = interest.wMulDown(market.fee);\r\n                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact\r\n                // that total supply is already updated.\r\n                uint256 feeShares =\r\n                    feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);\r\n                market.totalSupplyShares += feeShares.toUint128();\r\n            }\r\n        }\r\n\r\n        return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);\r\n    }\r\n\r\n    /// @notice Returns the expected total supply assets of a market after having accrued interest.\r\n    function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)\r\n        internal\r\n        view\r\n        returns (uint256 totalSupplyAssets)\r\n    {\r\n        (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);\r\n    }\r\n\r\n    /// @notice Returns the expected total borrow assets of a market after having accrued interest.\r\n    function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)\r\n        internal\r\n        view\r\n        returns (uint256 totalBorrowAssets)\r\n    {\r\n        (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);\r\n    }\r\n\r\n    /// @notice Returns the expected total supply shares of a market after having accrued interest.\r\n    function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)\r\n        internal\r\n        view\r\n        returns (uint256 totalSupplyShares)\r\n    {\r\n        (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\r\n    }\r\n\r\n    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.\r\n    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.\r\n    /// @dev Warning: Withdrawing a supply position using the expected assets balance can lead to a revert due to\r\n    /// conversion roundings between shares and assets.\r\n    function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Id id = marketParams.id();\r\n        uint256 supplyShares = morpho.supplyShares(id, user);\r\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\r\n\r\n        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\r\n    }\r\n\r\n    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.\r\n    /// @dev Warning: repaying a borrow position using the expected assets balance can lead to a revert due to\r\n    /// conversion roundings between shares and assets.\r\n    function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Id id = marketParams.id();\r\n        uint256 borrowShares = morpho.borrowShares(id, user);\r\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);\r\n\r\n        return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);\r\n    }\r\n}\r\n\r\ninterface IReallocationLogic {\r\n  function setParams(\r\n    TargetAllocator _targetAllocator,\r\n    address _vaultAddress,\r\n    IMorpho _morpho,\r\n    Id _idleMarketId,\r\n    uint _minReallocationSize\r\n  ) external;\r\n\r\n  function checkReallocationNeeded() external view returns (bool, MarketAllocation[] memory);\r\n}\r\n\r\ncontract ReallocationLogic {\r\n  using MorphoBalancesLib for IMorpho;\r\n  using MarketParamsLib for MarketParams;\r\n  using SharesMathLib for uint256;\r\n  using MathLib for uint256;\r\n  using MorphoLib for IMorpho;\r\n  using UtilsLib for uint256;\r\n\r\n  TargetAllocator targetAllocator;\r\n  address VAULT_ADDRESS;\r\n  IMorpho MORPHO;\r\n  Id IDLE_MARKET_ID;\r\n  uint minReallocationSize;\r\n\r\n  function setParams(\r\n    TargetAllocator _targetAllocator,\r\n    address _vaultAddress,\r\n    IMorpho _morpho,\r\n    Id _idleMarketId,\r\n    uint _minReallocationSize\r\n  ) public {\r\n    targetAllocator = _targetAllocator;\r\n    VAULT_ADDRESS = _vaultAddress;\r\n    MORPHO = _morpho;\r\n    IDLE_MARKET_ID = _idleMarketId;\r\n    minReallocationSize = _minReallocationSize;\r\n  }\r\n\r\n  /** CHECK FUNCTIONS */\r\n\r\n  /// @notice Checks if reallocation is needed across all markets based on current and target utilizations.\r\n  /// @return bool Indicates if reallocation is needed.\r\n  /// @return marketAllocations The array of market allocations to be performed if reallocation is needed.\r\n  function checkReallocationNeeded() public view returns (bool, MarketAllocation[] memory) {\r\n    uint256 nbMarkets = IMetaMorpho(VAULT_ADDRESS).withdrawQueueLength();\r\n\r\n    MarketParams memory idleMarketParams = MORPHO.idToMarketParams(IDLE_MARKET_ID);\r\n    uint256 idleAssetsAvailable = getAvailableIdleAssets(idleMarketParams);\r\n    for (uint256 i = 0; i < nbMarkets; i++) {\r\n      Id marketId = IMetaMorpho(VAULT_ADDRESS).withdrawQueue(i);\r\n      (bool mustReallocate, MarketAllocation[] memory allocations) = checkMarket(\r\n        marketId,\r\n        idleAssetsAvailable,\r\n        idleMarketParams\r\n      );\r\n\r\n      if (mustReallocate) {\r\n        return (true, allocations);\r\n      }\r\n    }\r\n\r\n    return (false, new MarketAllocation[](0));\r\n  }\r\n\r\n  /// @notice Gets the available assets of the vault currently in the idle market.\r\n  /// @return uint256 Amount of assets available in to be reallocated from the idle market\r\n  function getAvailableIdleAssets(MarketParams memory idleMarketParams) public view returns (uint256) {\r\n    (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets, ) = MORPHO.expectedMarketBalances(\r\n      idleMarketParams\r\n    );\r\n\r\n    uint256 supplyShares = MORPHO.supplyShares(IDLE_MARKET_ID, VAULT_ADDRESS);\r\n    uint256 supplyAssets = supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\r\n    uint256 availableLiquidity = totalSupplyAssets - totalBorrowAssets;\r\n\r\n    uint256 idleAssetsAvailable = UtilsLib.min(supplyAssets, availableLiquidity);\r\n\r\n    return idleAssetsAvailable;\r\n  }\r\n\r\n  /// @notice Checks a specific market to determine if reallocation is necessary based on its current utilization and target allocation settings.\r\n  /// @param marketId The market identifier to check.\r\n  /// @param idleAssetsAvailable The amount of assets available in the idle market that can be reallocated.\r\n  /// @param idleMarketParams The market parameters of the idle market.\r\n  /// @return bool Indicates if reallocation is needed for the market.\r\n  /// @return marketAllocations The array of market allocations to be performed if reallocation is needed.\r\n  function checkMarket(\r\n    Id marketId,\r\n    uint256 idleAssetsAvailable,\r\n    MarketParams memory idleMarketParams\r\n  ) public view returns (bool, MarketAllocation[] memory marketAllocations) {\r\n    MarketParams memory marketParams = MORPHO.idToMarketParams(marketId);\r\n\r\n    if (marketParams.collateralToken == address(0)) {\r\n      // do not check idle market\r\n      return (false, marketAllocations);\r\n    }\r\n\r\n    TargetAllocator.TargetAllocation memory targetAllocation = targetAllocator.getTargetAllocation(marketId);\r\n\r\n    // if target allocation for market not set, ignore market\r\n    if (targetAllocation.targetUtilization == 0) {\r\n      return (false, marketAllocations);\r\n    }\r\n\r\n    (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets, ) = MORPHO.expectedMarketBalances(\r\n      marketParams\r\n    );\r\n\r\n    // compute utilization and target total supply assets\r\n    uint256 currentUtilization = (totalBorrowAssets * 1e18) / totalSupplyAssets;\r\n\r\n    uint256 targetTotalSupplyAssets = (totalBorrowAssets * 1e18) / targetAllocation.targetUtilization;\r\n\r\n    // check if we need to reallocate\r\n    if (currentUtilization > targetAllocation.maxUtilization) {\r\n      // utilization > max target utilization, we should add liquidity from idle\r\n      // compute amount to supply\r\n      // min between the amount available in the idle market and the amount we need to supply\r\n      uint256 amountToSupply = UtilsLib.min(idleAssetsAvailable, targetTotalSupplyAssets - totalSupplyAssets);\r\n\r\n      // only reallocate if sufficient amount\r\n      if (amountToSupply < minReallocationSize) {\r\n        return (false, marketAllocations);\r\n      }\r\n\r\n      marketAllocations = new MarketAllocation[](2);\r\n      // create allocation: withdraw from idle\r\n      marketAllocations[0] = MarketAllocation({\r\n        marketParams: idleMarketParams,\r\n        // new assets value for the idle market\r\n        // = idleAssetsAvailable minus amount to supply\r\n        assets: idleAssetsAvailable - amountToSupply\r\n      });\r\n      // create allocation: supply all withdrawn to market\r\n      marketAllocations[1] = MarketAllocation({marketParams: marketParams, assets: type(uint256).max});\r\n\r\n      return (true, marketAllocations);\r\n    } else if (currentUtilization < targetAllocation.minUtilization) {\r\n      // utilization < min target utilization, we should withdraw to the idle market\r\n\r\n      // Keep at least targetAllocation.minLiquidity available\r\n      // this is done because if total supply = 10, total borrow = 5 target utilization = 80% and minLiquidity = 4\r\n      // currently, available liquidity is 10 - 5 = 5 and the current utilization is 50%\r\n      // so to reach 80% we would need to lower the supply to 6.25 => 5/6.25 = 0.8. But if we do that,\r\n      // the remaining liquidity will be 6.25 - 5 = 1.25 which is < 4\r\n      // in this case we will then define the targetTotalSupplyAssets as totalBorrowAssets + targetAllocation.minLiquidity => (5 + 4) = 9\r\n      // this mean a utilization of 55%, better than the current 50% but keeping the minLiquidity as desired\r\n      if (targetTotalSupplyAssets < totalBorrowAssets + targetAllocation.minLiquidity) {\r\n        targetTotalSupplyAssets = totalBorrowAssets + targetAllocation.minLiquidity;\r\n      }\r\n\r\n      uint256 supplyShares = MORPHO.supplyShares(marketParams.id(), VAULT_ADDRESS);\r\n      uint256 supplyAssets = supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\r\n      uint256 availableLiquidity = totalSupplyAssets - totalBorrowAssets;\r\n\r\n      // if the available liquidity is less than our threshold, do not change anything\r\n      if (availableLiquidity < targetAllocation.minLiquidity) {\r\n        return (false, marketAllocations);\r\n      }\r\n\r\n      uint256 amountToWithdraw = UtilsLib.min(availableLiquidity, totalSupplyAssets - targetTotalSupplyAssets);\r\n      // do not try to withdraw more than what was supplied by the vault\r\n      amountToWithdraw = UtilsLib.min(amountToWithdraw, supplyAssets);\r\n\r\n      // only reallocate if sufficient amount\r\n      if (amountToWithdraw < minReallocationSize) {\r\n        return (false, marketAllocations);\r\n      }\r\n\r\n      marketAllocations = new MarketAllocation[](2);\r\n      // create allocation: withdraw from the market\r\n      marketAllocations[0] = MarketAllocation({\r\n        marketParams: marketParams,\r\n        // new assets value for the non idle market\r\n        // = current vault supply minus amount to withdraw\r\n        assets: supplyAssets - amountToWithdraw\r\n      });\r\n      // create allocation: supply all withdrawn to idle market\r\n      marketAllocations[1] = MarketAllocation({marketParams: idleMarketParams, assets: type(uint256).max});\r\n\r\n      return (true, marketAllocations);\r\n    }\r\n\r\n    return (false, marketAllocations);\r\n  }\r\n}\r\n\r\ncontract TargetAllocator {\r\n  using MorphoBalancesLib for IMorpho;\r\n  using MarketParamsLib for MarketParams;\r\n  using SharesMathLib for uint256;\r\n  using MathLib for uint256;\r\n  using MorphoLib for IMorpho;\r\n  using UtilsLib for uint256;\r\n\r\n  struct TargetAllocation {\r\n    uint64 maxUtilization; // percentage with 18 decimals. Max = ~1844% with uint64\r\n    uint64 targetUtilization; // percentage with 18 decimals. Max = ~1844%  with uint64\r\n    uint64 minUtilization; // percentage with 18 decimals. Max = ~1844% with uint64\r\n    uint256 minLiquidity; // absolute amount in wei\r\n  }\r\n\r\n  /// @notice this is the idle market from/to which we will reallocate, set in the ctor\r\n  Id public immutable IDLE_MARKET_ID;\r\n\r\n  /// @notice the metamorpho vault address, set in the ctor\r\n  address public immutable VAULT_ADDRESS;\r\n\r\n  /// @notice the Morpho blue contract, set in the ctor\r\n  IMorpho public immutable MORPHO;\r\n\r\n  /// @notice the last reallocation performed by the keeperCall function\r\n  uint256 public lastReallocationTimestamp;\r\n\r\n  /// @notice the minimum delay between two reallocation by the keeperCall function\r\n  uint256 public minDelayBetweenReallocations;\r\n\r\n  /// @notice mapping of marketId => target allocation parameters\r\n  /// set in the constructor but can be modified by any of the vault allocators\r\n  mapping(Id => TargetAllocation) public targetAllocations;\r\n\r\n  /// @notice the minimum reallocation size, used to not broadcast a transaction for moving dust amount of an asset\r\n  uint256 public minReallocationSize;\r\n\r\n  /// @notice the keeper (bot) address that will be used to automatically call the keeperCheck and keeperCall functions\r\n  address public keeperAddress;\r\n\r\n  /// @notice Initializes a new TargetAllocator contract with specific market target allocations and operational settings.\r\n  /// @param _idleMarketId The market identifier for the idle market.\r\n  /// @param _vault The address of the Morpho vault.\r\n  /// @param _minDelayBetweenReallocations The minimum delay between two reallocation actions.\r\n  /// @param _minReallocationSize The minimum size of assets to be considered for reallocation.\r\n  /// @param _keeperAddress The address of the keeper responsible for triggering reallocations.\r\n  /// @param _marketIds An array of market identifiers for which target allocations are being set.\r\n  /// @param _targetAllocations An array of target allocation settings corresponding to the market identifiers.\r\n  constructor(\r\n    bytes32 _idleMarketId,\r\n    address _vault,\r\n    uint256 _minDelayBetweenReallocations,\r\n    uint256 _minReallocationSize,\r\n    address _keeperAddress,\r\n    bytes32[] memory _marketIds,\r\n    TargetAllocation[] memory _targetAllocations\r\n  ) {\r\n    require(\r\n      _marketIds.length == _targetAllocations.length,\r\n      \"TargetAllocator: length mismatch [_marketIds, _targetAllocations]\"\r\n    );\r\n\r\n    IDLE_MARKET_ID = Id.wrap(_idleMarketId);\r\n    VAULT_ADDRESS = _vault;\r\n    MORPHO = IMetaMorpho(VAULT_ADDRESS).MORPHO();\r\n    minDelayBetweenReallocations = _minDelayBetweenReallocations;\r\n    lastReallocationTimestamp = 1; // initialize storage slot to cost less for next usage\r\n    minReallocationSize = _minReallocationSize;\r\n    keeperAddress = _keeperAddress;\r\n\r\n    for (uint256 i = 0; i < _marketIds.length; ) {\r\n      targetAllocations[Id.wrap(_marketIds[i])] = _targetAllocations[i];\r\n\r\n      // use less gas\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getTargetAllocation(Id id) public view returns(TargetAllocation memory) {\r\n    return targetAllocations[id];\r\n  }\r\n\r\n  /** ONLY ALLOCATORS SETTER FUNCTIONS */\r\n\r\n  /// @notice Sets the minimum delay between reallocations.\r\n  /// @param _newValue The new minimum delay value in seconds.\r\n  function setMinDelayBetweenReallocations(uint256 _newValue) external {\r\n    require(isVaultAllocator(msg.sender), \"TargetAllocator: caller not allowed\");\r\n    minDelayBetweenReallocations = _newValue;\r\n  }\r\n\r\n  /// @notice Sets the minimum size for reallocations to avoid transactions for negligible amounts.\r\n  /// @param _newValue The new minimum reallocation size in the asset's smallest unit.\r\n  function setMinReallocationSize(uint256 _newValue) external {\r\n    require(isVaultAllocator(msg.sender), \"TargetAllocator: caller not allowed\");\r\n    minReallocationSize = _newValue;\r\n  }\r\n\r\n  /// @notice Sets the keeper address responsible for triggering reallocations.\r\n  /// @param _newValue The new address of the keeper.\r\n  function setKeeperAddress(address _newValue) external {\r\n    require(isVaultAllocator(msg.sender), \"TargetAllocator: caller not allowed\");\r\n    keeperAddress = _newValue;\r\n  }\r\n\r\n  /// @notice Sets target allocation parameters for a given market.\r\n  /// @param marketId The market identifier for which to set the target allocation.\r\n  /// @param targetAllocation The target allocation parameters including max, target, and min utilization percentages, and min liquidity.\r\n  function setTargetAllocation(bytes32 marketId, TargetAllocation memory targetAllocation) external {\r\n    require(isVaultAllocator(msg.sender), \"TargetAllocator: caller not allowed\");\r\n    targetAllocations[Id.wrap(marketId)] = targetAllocation;\r\n  }\r\n\r\n  /** CHECK FUNCTIONS */\r\n\r\n  /// @notice Checks if reallocation is needed across all markets based on current and target utilizations.\r\n  /// @return bool Indicates if reallocation is needed.\r\n  /// @return marketAllocations The array of market allocations to be performed if reallocation is needed.\r\n  function checkReallocationNeeded(bytes memory checkerBytecode) public /*view*/ returns (bool, MarketAllocation[] memory) {\r\n      // deploy\r\n      address child;\r\n      assembly{\r\n        mstore(0x0, checkerBytecode)\r\n        child := create(0,0xa0, calldatasize())\r\n      }\r\n      IReallocationLogic logic = IReallocationLogic(child);\r\n      \r\n      // set params\r\n      logic.setParams(this, VAULT_ADDRESS, MORPHO, IDLE_MARKET_ID, minReallocationSize);\r\n\r\n      return logic.checkReallocationNeeded();\r\n  }\r\n\r\n  /** KEEPER FUNCTIONS */\r\n\r\n  /// @notice Checks if a reallocation action is necessary and returns the encoded call data to perform the reallocation if so.\r\n  /// @return bool Indicates if a reallocation action should be taken.\r\n  /// @return call The encoded call data to execute the reallocation.\r\n  function keeperCheck(bytes memory checkerBytecode) external /*view*/ returns (bool, bytes memory call) {\r\n    if (lastReallocationTimestamp + minDelayBetweenReallocations > block.timestamp) {\r\n      return (false, call);\r\n    }\r\n\r\n    (bool mustReallocate, MarketAllocation[] memory allocations) = checkReallocationNeeded(checkerBytecode);\r\n\r\n    if (mustReallocate) {\r\n      call = abi.encodeCall(IMetaMorphoBase.reallocate, allocations);\r\n      return (true, call);\r\n    }\r\n\r\n    // return false for the keeper bot\r\n    return (false, call);\r\n  }\r\n\r\n  /// @notice Executes a reallocation action based on call data provided by the keeperCheck function.\r\n  /// @param call The encoded call data for the reallocation action.\r\n  function keeperCall(bytes calldata call) external {\r\n    require(msg.sender == keeperAddress || isVaultAllocator(msg.sender), \"TargetAllocator: caller not allowed\");\r\n\r\n    (bool success, bytes memory result) = VAULT_ADDRESS.call(call);\r\n    if (success) {\r\n      lastReallocationTimestamp = block.timestamp;\r\n    } else {\r\n      _getRevertMsg(result);\r\n    }\r\n  }\r\n\r\n  /// @notice Checks if the sender is an authorized vault allocator.\r\n  /// @param sender The address to check.\r\n  /// @return bool Indicates if the address is an authorized allocator.\r\n  function isVaultAllocator(address sender) public view returns (bool) {\r\n    return IMetaMorpho(VAULT_ADDRESS).isAllocator(sender);\r\n  }\r\n\r\n  error CallError(bytes innerError);\r\n\r\n  /// @dev Extracts a revert message from failed call return data.\r\n  /// @param _returnData The return data from the failed call.\r\n  function _getRevertMsg(bytes memory _returnData) internal pure {\r\n    // If the _res length is less than 68, then\r\n    // the transaction failed with custom error or silently (without a revert message)\r\n    if (_returnData.length < 68) {\r\n      revert CallError(_returnData);\r\n    }\r\n\r\n    assembly {\r\n      // Slice the sighash.\r\n      _returnData := add(_returnData, 0x04)\r\n    }\r\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_idleMarketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDelayBetweenReallocations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReallocationSize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_keeperAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_marketIds\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"maxUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"}],\"internalType\":\"struct TargetAllocator.TargetAllocation[]\",\"name\":\"_targetAllocations\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"innerError\",\"type\":\"bytes\"}],\"name\":\"CallError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IDLE_MARKET_ID\",\"outputs\":[{\"internalType\":\"Id\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MORPHO\",\"outputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkerBytecode\",\"type\":\"bytes\"}],\"name\":\"checkReallocationNeeded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lltv\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketParams\",\"name\":\"marketParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketAllocation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getTargetAllocation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"maxUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"}],\"internalType\":\"struct TargetAllocator.TargetAllocation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"isVaultAllocator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"}],\"name\":\"keeperCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkerBytecode\",\"type\":\"bytes\"}],\"name\":\"keeperCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastReallocationTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDelayBetweenReallocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minReallocationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newValue\",\"type\":\"address\"}],\"name\":\"setKeeperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setMinDelayBetweenReallocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setMinReallocationSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"maxUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"}],\"internalType\":\"struct TargetAllocator.TargetAllocation\",\"name\":\"targetAllocation\",\"type\":\"tuple\"}],\"name\":\"setTargetAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"targetAllocations\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"maxUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minUtilization\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TargetAllocator", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "58e212060645d18eab6d9b2af3d56fbc906a92ff5667385f616f662c7037228400000000000000000000000038989bba00bdf8181f4082995b3deae96163ac5d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8cabda30f0a7aa971818036bbaf41c27524f9688ec758fbaba93cad1771e4844"}