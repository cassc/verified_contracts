{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tconstructor() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, \"Only the owner can call this function.\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0), \"New owner address is invalid.\");\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Multiplies two numbers, throws on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers, truncating the quotient.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, throws on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint);\r\n\r\n\tfunction balanceOf(address account) external view returns (uint);\r\n\r\n\tfunction transfer(address recipient, uint amount) external returns (bool);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\tfunction approve(address spender, uint amount) external returns (bool);\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is IERC20 {\r\n\tuint public totalSupply;\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(address => mapping(address => uint)) public allowance;\r\n\r\n\tfunction transfer(address recipient, uint amount) external returns (bool) {\r\n\t\tbalanceOf[msg.sender] -= amount;\r\n\t\tbalanceOf[recipient] += amount;\r\n\t\temit Transfer(msg.sender, recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint amount) external returns (bool) {\r\n\t\tallowance[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint amount) external returns (bool) {\r\n\t\tallowance[sender][msg.sender] -= amount;\r\n\t\tbalanceOf[sender] -= amount;\r\n\t\tbalanceOf[recipient] += amount;\r\n\t\temit Transfer(sender, recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction mint(uint amount) external {\r\n\t\tbalanceOf[msg.sender] += amount;\r\n\t\ttotalSupply += amount;\r\n\t\temit Transfer(address(0), msg.sender, amount);\r\n\t}\r\n\r\n\tfunction burn(uint amount) external {\r\n\t\tbalanceOf[msg.sender] -= amount;\r\n\t\ttotalSupply -= amount;\r\n\t\temit Transfer(msg.sender, address(0), amount);\r\n\t}\r\n}\r\n\r\ncontract MultiTransaction is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * @dev Send token to multiple address\r\n\t * @param _tokenAddress The address of the ERC20 token.\r\n\t * @param _investors The addresses of EOA that can receive token from this contract.\r\n\t * @param _tokenAmounts The values of token are sent from this contract.\r\n\t */\r\n\tfunction batchTransferFrom(\r\n\t\taddress _tokenAddress,\r\n\t\taddress[] memory _investors,\r\n\t\tuint[] memory _tokenAmounts\r\n\t) public onlyOwner {\r\n\t\tERC20 token = ERC20(_tokenAddress);\r\n\t\trequire(_investors.length == _tokenAmounts.length && _investors.length != 0, \"Array lengths do not match.\");\r\n\r\n\t\tfor (uint i = 0; i < _investors.length; i++) {\r\n\t\t\trequire(_tokenAmounts[i] > 0 && _investors[i] != address(0), \"Invalid input values.\");\r\n\t\t\ttoken.transferFrom(msg.sender, _investors[i], _tokenAmounts[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send tokens from multiple investors to multiple recipients.\r\n\t * @param _tokenAddress The address of the ERC20 token.\r\n\t * @param _investors The addresses of investors.\r\n\t * @param _to The addresses of recipient.\r\n\t * @param _tokenAmounts The values of tokens to be sent from investors to recipient.\r\n\t */\r\n\tfunction batchTransferTo(\r\n\t\taddress _tokenAddress,\r\n\t\taddress[] memory _investors,\r\n\t\taddress _to,\r\n\t\tuint[] memory _tokenAmounts\r\n\t) public onlyOwner {\r\n\t\tERC20 token = ERC20(_tokenAddress);\r\n\t\trequire(_investors.length == _tokenAmounts.length && _investors.length != 0, \"Array lengths do not match.\");\r\n\r\n\t\tfor (uint i = 0; i < _investors.length; i++) {\r\n\t\t\trequire(_tokenAmounts[i] > 0 && _investors[i] != address(0) && _to != address(0), \"address is invalid.\");\r\n\t\t\ttoken.transferFrom(_investors[i], _to, _tokenAmounts[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send tokens from multiple investors to multiple recipients.\r\n\t * @param _tokenAddress The address of the ERC20 token.\r\n\t * @param _investors The addresses of investors.\r\n\t * @param _to The addresses of recipients.\r\n\t */\r\n\tfunction batchTransferToAll(\r\n\t\taddress _tokenAddress,\r\n\t\taddress[] memory _investors,\r\n\t\taddress[] memory _to\r\n\t) public onlyOwner {\r\n\t\tERC20 token = ERC20(_tokenAddress);\r\n\t\trequire(_investors.length != 0, \"No investors provided.\");\r\n\r\n\t\tfor (uint i = 0; i < _investors.length; i++) {\r\n\t\t\trequire(\r\n\t\t\t\ttoken.balanceOf(_investors[i]) > 0 && _investors[i] != address(0) && _to[i] != address(0),\r\n\t\t\t\t\"Invalid input values.\"\r\n\t\t\t);\r\n\t\t\ttoken.transferFrom(_investors[i], _to[i], token.balanceOf(_investors[i]));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev return token balance this contract has\r\n\t * @param _tokenAddress The address of the ERC20 token.\r\n\t * @param _address token balance this contract has.\r\n\t * @return The token balance that this contract has for the given address.\r\n\t */\r\n\tfunction balanceOfContract(address _tokenAddress, address _address) public view onlyOwner returns (uint) {\r\n\t\tERC20 token = ERC20(_tokenAddress);\r\n\t\treturn token.balanceOf(_address);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the total amount to be sent in the array of amounts.\r\n\t * @param _amounts The array of amounts.\r\n\t * @return totalSendingAmount The total amount to be sent.\r\n\t */\r\n\tfunction getTotalSendingAmount(uint256[] memory _amounts) private pure returns (uint totalSendingAmount) {\r\n\t\tfor (uint i = 0; i < _amounts.length; i++) {\r\n\t\t\trequire(_amounts[i] > 0, \"Invalid input values.\");\r\n\t\t\ttotalSendingAmount += _amounts[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// Events allow light clients to react on\r\n\t// changes efficiently.\r\n\tevent Sent(address from, address to, uint amount);\r\n\r\n\t/**\r\n\t * @dev Sends Ether to multiple addresses.\r\n\t * @param receivers The addresses of recipients.\r\n\t * @param amounts The amounts of Ether to send to each recipient.\r\n\t */\r\n\tfunction transferMulti(address[] memory receivers, uint256[] memory amounts) public payable onlyOwner {\r\n\t\trequire(\r\n\t\t\tmsg.value != 0 && msg.value >= getTotalSendingAmount(amounts),\r\n\t\t\t\"Invalid Ether value or insufficient balance.\"\r\n\t\t);\r\n\r\n\t\tfor (uint256 j = 0; j < amounts.length; j++) {\r\n\t\t\taddress payable receiver = payable(receivers[j]);\r\n\t\t\treceiver.transfer(amounts[j]);\r\n\t\t\temit Sent(msg.sender, receiver, amounts[j]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Withdraw the amount of token that is remaining in this contract.\r\n\t * @param _address The address of EOA that can receive token from this contract.\r\n\t */\r\n\tfunction withdraw(address _address) public onlyOwner {\r\n\t\trequire(_address != address(0), \"Invalid recipient address.\");\r\n\t\taddress payable receiver = payable(_address);\r\n\t\treceiver.transfer(address(this).balance);\r\n\t}\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOfContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_investors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_investors\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_investors\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"batchTransferToAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferMulti\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MultiTransaction", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://70292b11b494bbc5b5b4316b17a1bbe841016773cf156c067d3f8393bec55dbb"}