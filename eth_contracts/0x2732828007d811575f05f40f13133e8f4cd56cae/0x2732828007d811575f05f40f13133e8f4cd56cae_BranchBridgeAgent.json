{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ExcessivelySafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ExcessivelySafeCall {\\n    uint256 constant LOW_28_MASK =\\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := call(\\n            _gas, // gas\\n            _target, // recipient\\n            0, // ether value\\n            add(_calldata, 0x20), // inloc\\n            mload(_calldata), // inlen\\n            0, // outloc\\n            0 // outlen\\n            )\\n        // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n        // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n        // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeStaticCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal view returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := staticcall(\\n            _gas, // gas\\n            _target, // recipient\\n            add(_calldata, 0x20), // inloc\\n            mload(_calldata), // inlen\\n            0, // outloc\\n            0 // outlen\\n            )\\n        // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n        // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n        // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /**\\n     * @notice Swaps function selectors in encoded contract calls\\n     * @dev Allows reuse of encoded calldata for functions with identical\\n     * argument types but different names. It simply swaps out the first 4 bytes\\n     * for the new selector. This function modifies memory in place, and should\\n     * only be used with caution.\\n     * @param _newSelector The new 4-byte selector\\n     * @param _buf The encoded contract args\\n     */\\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\\n    internal\\n    pure\\n    {\\n        require(_buf.length >= 4);\\n        uint256 _mask = LOW_28_MASK;\\n        assembly {\\n        // load the first word of\\n            let _word := mload(add(_buf, 0x20))\\n        // mask out the top 4 bytes\\n        // /x\\n            _word := and(_word, _mask)\\n            _word := or(_newSelector, _word)\\n            mstore(add(_buf, 0x20), _word)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/BranchBridgeAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeTransferLib} from \\\"lib/solady/src/utils/SafeTransferLib.sol\\\";\\n\\nimport {ReentrancyGuard} from \\\"lib/solmate/src/utils/ReentrancyGuard.sol\\\";\\n\\nimport {ExcessivelySafeCall} from \\\"lib/ExcessivelySafeCall.sol\\\";\\n\\nimport {BridgeAgentConstants} from \\\"./interfaces/BridgeAgentConstants.sol\\\";\\nimport {\\n    Deposit,\\n    DepositInput,\\n    DepositMultipleInput,\\n    GasParams,\\n    IBranchBridgeAgent,\\n    ILayerZeroReceiver,\\n    SettlementMultipleParams\\n} from \\\"./interfaces/IBranchBridgeAgent.sol\\\";\\nimport {IBranchPort as IPort} from \\\"./interfaces/IBranchPort.sol\\\";\\nimport {ILayerZeroEndpoint} from \\\"./interfaces/ILayerZeroEndpoint.sol\\\";\\n\\nimport {DecodeBridgeInMultipleParams} from \\\"./lib/DecodeBridgeInMultipleParams.sol\\\";\\n\\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \\\"./BranchBridgeAgentExecutor.sol\\\";\\n\\n/// @title Library for Branch Bridge Agent Deployment\\nlibrary DeployBranchBridgeAgent {\\n    function deploy(\\n        uint16 _rootChainId,\\n        uint16 _localChainId,\\n        address _rootBridgeAgentAddress,\\n        address _lzEndpointAddress,\\n        address _localRouterAddress,\\n        address _localPortAddress\\n    ) external returns (BranchBridgeAgent) {\\n        return new BranchBridgeAgent(\\n            _rootChainId,\\n            _localChainId,\\n            _rootBridgeAgentAddress,\\n            _lzEndpointAddress,\\n            _localRouterAddress,\\n            _localPortAddress\\n        );\\n    }\\n}\\n\\n/// @title Branch Bridge Agent Contract\\n/// @author MaiaDAO\\ncontract BranchBridgeAgent is IBranchBridgeAgent, ReentrancyGuard, BridgeAgentConstants {\\n    using ExcessivelySafeCall for address;\\n    using SafeTransferLib for address;\\n    using DecodeBridgeInMultipleParams for bytes;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         BRIDGE AGENT STATE\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Chain Id for Root Chain where liquidity is virtualized(e.g. 4).\\n    uint16 public immutable rootChainId;\\n\\n    /// @notice Chain Id for Local Chain.\\n    uint16 public immutable localChainId;\\n\\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address\\n    ///         where cross-chain requests are executed in the Root Chain.\\n    address public immutable rootBridgeAgentAddress;\\n\\n    /// @notice Layer Zero messaging layer path for Root Bridge Agent Address where cross-chain requests\\n    ///         are sent to the Root Chain Router.\\n    bytes private rootBridgeAgentPath;\\n\\n    /// @notice Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\\n    address public immutable lzEndpointAddress;\\n\\n    /// @notice Address for Local Router used for custom actions for different hApps.\\n    address public immutable localRouterAddress;\\n\\n    /// @notice Address for Local Port Address\\n    ///         where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\\n    address public immutable localPortAddress;\\n\\n    /// @notice Address for Bridge Agent Executor used for executing cross-chain requests.\\n    address public immutable bridgeAgentExecutorAddress;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DEPOSITS STATE\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deposit nonce used for identifying the transaction.\\n    uint32 public depositNonce;\\n\\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\\n    mapping(uint256 depositNonce => Deposit depositInfo) public getDeposit;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        SETTLEMENT EXECUTION STATE\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice If true, the bridge agent has already served a request with this nonce from a given chain.\\n    mapping(uint256 settlementNonce => uint256 state) public executionState;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Constructor for Branch Bridge Agent.\\n     * @param _rootChainId Chain Id for Root Chain where liquidity is virtualized and assets are managed.\\n     * @param _localChainId Chain Id for Local Chain.\\n     * @param _rootBridgeAgentAddress Address for Bridge Agent who processes requests sent to and from the Root Chain.\\n     * @param _lzEndpointAddress Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\\n     * @param _localRouterAddress Address for Local Router used for custom actions for different Omnichain dApps.\\n     * @param _localPortAddress Address for Local Port Address where funds deposited from this chain are kept, managed\\n     *                          and supplied to different Port Strategies.\\n     */\\n    constructor(\\n        uint16 _rootChainId,\\n        uint16 _localChainId,\\n        address _rootBridgeAgentAddress,\\n        address _lzEndpointAddress,\\n        address _localRouterAddress,\\n        address _localPortAddress\\n    ) {\\n        if (_rootBridgeAgentAddress == address(0)) revert InvalidRootBridgeAgentAddress();\\n        if (_localPortAddress == address(0)) revert InvalidBranchPortAddress();\\n        if (_lzEndpointAddress == address(0)) if (_rootChainId != _localChainId) revert InvalidEndpointAddress();\\n\\n        localChainId = _localChainId;\\n        rootChainId = _rootChainId;\\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\\n        lzEndpointAddress = _lzEndpointAddress;\\n        // Can be zero address\\n        localRouterAddress = _localRouterAddress;\\n        localPortAddress = _localPortAddress;\\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy(_localRouterAddress);\\n        depositNonce = 1;\\n\\n        rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        FALLBACK FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    receive() external payable {}\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        VIEW FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\\n        return getDeposit[_depositNonce];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    USER / BRANCH ROUTER EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOut(address payable _depositOwnerAndGasRefundee, bytes calldata _params, GasParams calldata _gParams)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        requiresRouter\\n    {\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(bytes1(0x01), depositNonce++, _params);\\n\\n        //Perform Call\\n        _performCall(_depositOwnerAndGasRefundee, payload, _gParams, BRANCH_BASE_CALL_OUT_GAS);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOutAndBridge(\\n        address payable _depositOwnerAndGasRefundee,\\n        bytes calldata _params,\\n        DepositInput memory _dParams,\\n        GasParams calldata _gParams\\n    ) external payable override nonReentrant requiresRouter {\\n        //Cache Deposit Nonce\\n        uint32 _depositNonce = depositNonce;\\n\\n        //Create Deposit and Send Cross-Chain request\\n        _createDeposit(\\n            false,\\n            _depositNonce,\\n            _depositOwnerAndGasRefundee,\\n            _dParams.hToken,\\n            _dParams.token,\\n            _dParams.amount,\\n            _dParams.deposit\\n        );\\n\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(\\n            bytes1(0x02), _depositNonce, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _params\\n        );\\n\\n        //Perform Call\\n        _performCall(_depositOwnerAndGasRefundee, payload, _gParams, BRANCH_BASE_CALL_OUT_DEPOSIT_SINGLE_GAS);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOutAndBridgeMultiple(\\n        address payable _depositOwnerAndGasRefundee,\\n        bytes calldata _params,\\n        DepositMultipleInput memory _dParams,\\n        GasParams calldata _gParams\\n    ) external payable override nonReentrant requiresRouter {\\n        //Cache Deposit Nonce\\n        uint32 _depositNonce = depositNonce;\\n\\n        //Create Deposit and Send Cross-Chain request\\n        _createDepositMultiple(\\n            false,\\n            _depositNonce,\\n            _depositOwnerAndGasRefundee,\\n            _dParams.hTokens,\\n            _dParams.tokens,\\n            _dParams.amounts,\\n            _dParams.deposits\\n        );\\n\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(\\n            bytes1(0x03),\\n            uint8(_dParams.hTokens.length),\\n            _depositNonce,\\n            _dParams.hTokens,\\n            _dParams.tokens,\\n            _dParams.amounts,\\n            _dParams.deposits,\\n            _params\\n        );\\n\\n        //Perform Call\\n        _performCall(_depositOwnerAndGasRefundee, payload, _gParams, BRANCH_BASE_CALL_OUT_DEPOSIT_MULTIPLE_GAS);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOutSigned(bytes calldata _params, GasParams calldata _gParams)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n    {\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(bytes1(0x04), msg.sender, depositNonce++, _params);\\n\\n        //Perform Signed Call without deposit\\n        _performCall(payable(msg.sender), payload, _gParams, BRANCH_BASE_CALL_OUT_SIGNED_GAS);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOutSignedAndBridge(\\n        bytes calldata _params,\\n        DepositInput memory _dParams,\\n        GasParams calldata _gParams,\\n        bool _hasFallbackToggled\\n    ) external payable override nonReentrant {\\n        //Cache Deposit Nonce\\n        uint32 _depositNonce = depositNonce;\\n\\n        //Create Deposit and Send Cross-Chain request\\n        _createDeposit(\\n            true, _depositNonce, msg.sender, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit\\n        );\\n\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(\\n            _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\\n            msg.sender,\\n            _depositNonce,\\n            _dParams.hToken,\\n            _dParams.token,\\n            _dParams.amount,\\n            _dParams.deposit,\\n            _params\\n        );\\n\\n        //Perform Call\\n        _performCall(\\n            payable(msg.sender),\\n            payload,\\n            _gParams,\\n            _hasFallbackToggled\\n                ? BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_SINGLE_GAS + BASE_FALLBACK_GAS\\n                : BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_SINGLE_GAS\\n        );\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function callOutSignedAndBridgeMultiple(\\n        bytes calldata _params,\\n        DepositMultipleInput memory _dParams,\\n        GasParams calldata _gParams,\\n        bool _hasFallbackToggled\\n    ) external payable override nonReentrant {\\n        // Cache Deposit Nonce\\n        uint32 _depositNonce = depositNonce;\\n\\n        // Create a Deposit and Send Cross-Chain request\\n        _createDepositMultiple(\\n            true, _depositNonce, msg.sender, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\\n        );\\n\\n        // Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(\\n            _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\\n            msg.sender,\\n            uint8(_dParams.hTokens.length),\\n            _depositNonce,\\n            _dParams.hTokens,\\n            _dParams.tokens,\\n            _dParams.amounts,\\n            _dParams.deposits,\\n            _params\\n        );\\n\\n        //Perform Call\\n        _performCall(\\n            payable(msg.sender),\\n            payload,\\n            _gParams,\\n            _hasFallbackToggled\\n                ? BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_MULTIPLE_GAS + BASE_FALLBACK_GAS\\n                : BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_MULTIPLE_GAS\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    DEPOSIT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function retryDeposit(address _owner, uint32 _depositNonce, bytes calldata _params, GasParams calldata _gParams)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        requiresRouter\\n    {\\n        // Get Settlement Reference\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n\\n        // Check if deposit is signed\\n        if (deposit.isSigned != UNSIGNED_DEPOSIT) revert WrongDepositType();\\n\\n        // Check if deposit belongs to message sender\\n        if (deposit.owner != _owner) revert NotDepositOwner();\\n\\n        // Check if deposit is not failed and in redeem mode\\n        if (deposit.status != STATUS_SUCCESS) revert DepositRedeemUnavailable();\\n\\n        // Pack data for deposit single\\n        if (uint8(deposit.hTokens.length) == 1) {\\n            // Encode Data for cross-chain call.\\n            bytes memory payload = abi.encodePacked(\\n                bytes1(0x02),\\n                _depositNonce,\\n                deposit.hTokens[0],\\n                deposit.tokens[0],\\n                deposit.amounts[0],\\n                deposit.deposits[0],\\n                _params\\n            );\\n\\n            // Validate and perform call\\n            _retryDeposit(payload, _gParams, BRANCH_BASE_CALL_OUT_DEPOSIT_SINGLE_GAS);\\n\\n            // Pack data for deposit multiple\\n        } else if (uint8(deposit.hTokens.length) > 1) {\\n            // Encode Data for cross-chain call.\\n            bytes memory payload = abi.encodePacked(\\n                bytes1(0x03),\\n                uint8(deposit.hTokens.length),\\n                _depositNonce,\\n                deposit.hTokens,\\n                deposit.tokens,\\n                deposit.amounts,\\n                deposit.deposits,\\n                _params\\n            );\\n\\n            // Validate and perform call\\n            _retryDeposit(payload, _gParams, BRANCH_BASE_CALL_OUT_DEPOSIT_MULTIPLE_GAS);\\n        }\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function retryDepositSigned(\\n        uint32 _depositNonce,\\n        bytes calldata _params,\\n        GasParams calldata _gParams,\\n        bool _hasFallbackToggled\\n    ) external payable override nonReentrant {\\n        // Get Settlement Reference\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n\\n        // Check if deposit is signed\\n        if (deposit.isSigned != SIGNED_DEPOSIT) revert WrongDepositType();\\n\\n        // Check if deposit belongs to message sender\\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\\n\\n        // Check if deposit is not failed and in redeem mode\\n        if (deposit.status != STATUS_SUCCESS) revert DepositRedeemUnavailable();\\n\\n        // Pack data for deposit single\\n        if (uint8(deposit.hTokens.length) == 1) {\\n            // Encode Data for cross-chain call.\\n            bytes memory payload = abi.encodePacked(\\n                _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\\n                msg.sender,\\n                _depositNonce,\\n                deposit.hTokens[0],\\n                deposit.tokens[0],\\n                deposit.amounts[0],\\n                deposit.deposits[0],\\n                _params\\n            );\\n\\n            // Validate and perform call\\n            _retryDeposit(\\n                payload,\\n                _gParams,\\n                _hasFallbackToggled\\n                    ? BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_SINGLE_GAS + BASE_FALLBACK_GAS\\n                    : BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_SINGLE_GAS\\n            );\\n\\n            // Pack data for deposit multiple\\n        } else if (uint8(deposit.hTokens.length) > 1) {\\n            // Encode Data for cross-chain call.\\n            bytes memory payload = abi.encodePacked(\\n                _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\\n                msg.sender,\\n                uint8(deposit.hTokens.length),\\n                _depositNonce,\\n                deposit.hTokens,\\n                deposit.tokens,\\n                deposit.amounts,\\n                deposit.deposits,\\n                _params\\n            );\\n\\n            // Validate and perform call\\n            _retryDeposit(\\n                payload,\\n                _gParams,\\n                _hasFallbackToggled\\n                    ? BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_MULTIPLE_GAS + BASE_FALLBACK_GAS\\n                    : BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_MULTIPLE_GAS\\n            );\\n        }\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function retrieveDeposit(uint32 _depositNonce, GasParams calldata _gParams)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n    {\\n        // Check if the deposit belongs to the message sender\\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\\n\\n        // Check if deposit is not already failed and in redeem mode.\\n        if (getDeposit[_depositNonce].status == STATUS_FAILED) revert DepositAlreadyRetrieved();\\n\\n        //Encode Data for cross-chain call.\\n        bytes memory payload = abi.encodePacked(bytes1(0x08), msg.sender, _depositNonce);\\n\\n        //Update State and Perform Call\\n        _performCall(payable(msg.sender), payload, _gParams, BRANCH_BASE_CALL_OUT_GAS);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function redeemDeposit(uint32 _depositNonce, address _recipient) external override nonReentrant {\\n        // Get storage reference\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n\\n        // Check Deposit\\n        if (deposit.status == STATUS_SUCCESS) revert DepositRedeemUnavailable();\\n        if (deposit.owner == address(0)) revert DepositRedeemUnavailable();\\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\\n\\n        // Zero out owner\\n        deposit.owner = address(0);\\n\\n        // Transfer token to depositor / user\\n        for (uint256 i = 0; i < deposit.tokens.length;) {\\n            //Increment tokens clearance counter if address is zero\\n            if (deposit.hTokens[i] != address(0)) {\\n                _clearToken(_recipient, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Delete Failed Deposit Token Info\\n        delete getDeposit[_depositNonce];\\n\\n        emit RedeemDeposit(_depositNonce, _recipient);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function redeemDeposit(uint32 _depositNonce, address _recipient, address _localTokenAddress)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        // Check localTokenAddress not zero\\n        if (_localTokenAddress == address(0)) revert InvalidLocalAddress();\\n\\n        // Get storage reference\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n\\n        // Check Deposit\\n        if (deposit.status == STATUS_SUCCESS) revert DepositRedeemUnavailable();\\n        if (deposit.owner == address(0)) revert DepositRedeemUnavailable();\\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\\n\\n        // Clearance counter\\n        uint256 tokensCleared;\\n\\n        // Cache Length\\n        uint256 length = deposit.tokens.length;\\n\\n        // Transfer token to depositor / user\\n        for (uint256 i = 0; i < length;) {\\n            // Check if hToken is the same as localTokenAddress\\n            if (deposit.hTokens[i] == _localTokenAddress) {\\n                // Clear Tokens back to user\\n                _clearToken(_recipient, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);\\n\\n                // Remove Token Related Info from Deposit Storage\\n                delete deposit.hTokens[i];\\n                delete deposit.tokens[i];\\n                delete deposit.amounts[i];\\n                delete deposit.deposits[i];\\n            }\\n\\n            //Increment tokens clearance counter if address is zero\\n            if (deposit.hTokens[i] == address(0)) {\\n                unchecked {\\n                    ++tokensCleared;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Check if all tokens have been cleared and Delete Failed Deposit Token Info\\n        if (tokensCleared == length) {\\n            delete getDeposit[_depositNonce];\\n            emit RedeemDeposit(_depositNonce, _recipient);\\n        } else {\\n            emit RedeemDeposit(_depositNonce, _recipient, _localTokenAddress);\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    SETTLEMENT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function retrySettlement(\\n        uint32 _settlementNonce,\\n        bytes calldata _params,\\n        GasParams[2] calldata _gParams,\\n        bool _hasFallbackToggled\\n    ) external payable virtual override nonReentrant {\\n        // Check and revert if settlement nonce is not STATUS_READY\\n        if (executionState[_settlementNonce] != STATUS_READY) revert AlreadyExecutedTransaction();\\n\\n        // Encode Retry Settlement Params\\n        bytes memory params = abi.encode(_settlementNonce, msg.sender, _params, _gParams[1]);\\n\\n        // Prepare payload for cross-chain call.\\n        bytes memory payload = abi.encodePacked(_hasFallbackToggled ? bytes1(0x87) : bytes1(0x07), params);\\n\\n        // Perform Call\\n        _performCall(payable(msg.sender), payload, _gParams[0], BRANCH_BASE_CALL_OUT_GAS);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function bridgeIn(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\\n        external\\n        override\\n        requiresAgentExecutor\\n    {\\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\\n    }\\n\\n    /// @inheritdoc IBranchBridgeAgent\\n    function bridgeInMultiple(address _recipient, SettlementMultipleParams calldata _sParams)\\n        external\\n        override\\n        requiresAgentExecutor\\n    {\\n        IPort(localPortAddress).bridgeInMultiple(\\n            _recipient, _sParams.hTokens, _sParams.tokens, _sParams.amounts, _sParams.deposits\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    LAYER ZERO EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc ILayerZeroReceiver\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload)\\n        public\\n        payable\\n        override\\n        returns (bool success)\\n    {\\n        // Perform Excessively Safe Call\\n        (success,) = address(this).excessivelySafeCall(\\n            gasleft() - BASE_EXECUTION_FAILED_GAS,\\n            0,\\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\\n        );\\n\\n        // Check if call was successful if not send any native tokens to rootPort\\n        if (!success) localPortAddress.safeTransferAllETH();\\n    }\\n\\n    /// @inheritdoc ILayerZeroReceiver\\n    function lzReceiveNonBlocking(\\n        address _endpoint,\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        bytes calldata _payload\\n    ) public payable override requiresEndpoint(_srcChainId, _endpoint, _srcAddress) {\\n        //Save Action Flag\\n        bytes1 flag = _payload[0];\\n\\n        // Save settlement nonce\\n        uint32 nonce;\\n\\n        // DEPOSIT FLAG: 1 (No settlement)\\n        if (flag == 0x01) {\\n            // Get Settlement Nonce\\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\\n\\n            //Check if tx has already been executed\\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\\n\\n            // Try to execute the remote request\\n            // Flag 0 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoSettlement(_payload)\\n            _execute(nonce, abi.encodeWithSelector(BranchBridgeAgentExecutor.executeNoSettlement.selector, _payload));\\n\\n            // DEPOSIT FLAG: 2 (Single Asset Settlement)\\n        } else if (flag & 0x7F == 0x02) {\\n            // Parse recipient\\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\\n\\n            // Parse Settlement Nonce\\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\\n\\n            // Check if tx has already been executed\\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\\n\\n            // Try to execute the remote request\\n            // Flag 1 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlement(recipient, _payload)\\n            _execute(\\n                flag == 0x82,\\n                nonce,\\n                recipient,\\n                abi.encodeWithSelector(BranchBridgeAgentExecutor.executeWithSettlement.selector, recipient, _payload)\\n            );\\n\\n            // DEPOSIT FLAG: 3 (Multiple Settlement)\\n        } else if (flag & 0x7F == 0x03) {\\n            // Parse recipient\\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\\n\\n            // Parse deposit nonce\\n            nonce = uint32(bytes4(_payload[22:26]));\\n\\n            //Check if tx has already been executed\\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\\n\\n            // Try to execute remote request\\n            // Flag 2 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlementMultiple(recipient, _payload)\\n            _execute(\\n                flag == 0x83,\\n                nonce,\\n                recipient,\\n                abi.encodeWithSelector(\\n                    BranchBridgeAgentExecutor.executeWithSettlementMultiple.selector, recipient, _payload\\n                )\\n            );\\n\\n            // DEPOSIT FLAG: 4 (Retrieve Settlement)\\n        } else if (flag == 0x04) {\\n            // Parse recipient\\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\\n\\n            // Get nonce\\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\\n\\n            // Check if settlement is in retrieve mode\\n            if (executionState[nonce] == STATUS_DONE) {\\n                revert AlreadyExecutedTransaction();\\n            } else {\\n                // Ensure settlement is set to retrieve mode.\\n                executionState[nonce] = STATUS_RETRIEVE;\\n                // Trigger fallback/Retry failed fallback\\n                _performFallbackCall(recipient, nonce);\\n            }\\n\\n            // DEPOSIT FLAG: 5 (Fallback)\\n        } else if (flag == 0x05) {\\n            // Get nonce\\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\\n\\n            // Reopen Deposit for redemption\\n            getDeposit[nonce].status = STATUS_FAILED;\\n\\n            // Emit Fallback Event\\n            emit LogFallback(nonce);\\n\\n            // Return to prevent unnecessary logic/emits\\n            return;\\n\\n            // Unrecognized Function Selector\\n        } else {\\n            revert UnknownFlag();\\n        }\\n\\n        // Emit Execution Event\\n        emit LogExecute(nonce);\\n    }\\n\\n    /// @inheritdoc ILayerZeroReceiver\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external {\\n        // Anyone can call this function to force resume a receive and unblock the messaging layer channel.\\n        ILayerZeroEndpoint(lzEndpointAddress).forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    SETTLEMENT EXECUTION INTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Internal function requests execution from Branch Bridge Agent Executor Contract.\\n     *   @param _settlementNonce Identifier for nonce being executed.\\n     *   @param _calldata Calldata to be executed by the Branch Bridge Agent Executor Contract.\\n     */\\n    function _execute(uint256 _settlementNonce, bytes memory _calldata) private {\\n        // Update tx state as executed\\n        executionState[_settlementNonce] = STATUS_DONE;\\n\\n        // Try to execute the remote request\\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\\n\\n        //  No fallback is requested revert allowing for settlement retry.\\n        if (!success) revert ExecutionFailure();\\n    }\\n\\n    function _execute(bool _hasFallbackToggled, uint32 _settlementNonce, address _gasRefundee, bytes memory _calldata)\\n        private\\n    {\\n        // Update tx state as executed\\n        executionState[_settlementNonce] = STATUS_DONE;\\n\\n        if (_hasFallbackToggled) {\\n            // Try to execute the remote request\\n            /// @dev If fallback is requested, subtract 50k gas to allow for fallback call.\\n            (bool success,) = bridgeAgentExecutorAddress.call{\\n                gas: gasleft() - BASE_FALLBACK_GAS,\\n                value: address(this).balance\\n            }(_calldata);\\n\\n            // Update tx state if execution failed\\n            if (!success) {\\n                // Update tx state as retrieve only\\n                executionState[_settlementNonce] = STATUS_RETRIEVE;\\n                // Perform the fallback call\\n                _performFallbackCall(payable(_gasRefundee), _settlementNonce);\\n            }\\n        } else {\\n            // Try to execute the remote request\\n            (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\\n\\n            // If no fallback is requested revert allowing for settlement retry.\\n            if (!success) revert ExecutionFailure();\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    LAYER ZERO INTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Internal function to encode the Adapter Params for LayerZero Endpoint.\\n     *   @dev The minimum gas required for cross-chain call is added to the requested gasLimit.\\n     *   @param _gParams LayerZero gas information. (_gasLimit,_remoteBranchExecutionGas,_nativeTokenRecipientOnDstChain)\\n     *   @param _baseExecutionGas Minimum gas required for cross-chain call.\\n     *   @param _callee Address of the contract to be called on the destination chain.\\n     *   @return Gas limit for cross-chain call.\\n     */\\n    function _encodeAdapterParams(GasParams calldata _gParams, uint256 _baseExecutionGas, address _callee)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            uint16(2), _gParams.gasLimit + _baseExecutionGas, _gParams.remoteBranchExecutionGas, _callee\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function performs the call to LayerZero messaging layer Endpoint for cross-chain messaging.\\n     *   @param _gasRefundee address to refund excess gas to.\\n     *   @param _payload params for root bridge agent execution.\\n     *   @param _gParams LayerZero gas information. (_gasLimit,_remoteBranchExecutionGas,_nativeTokenRecipientOnDstChain)\\n     *   @param _baseExecutionGas Minimum gas required for cross-chain call.\\n     */\\n    function _performCall(\\n        address payable _gasRefundee,\\n        bytes memory _payload,\\n        GasParams calldata _gParams,\\n        uint256 _baseExecutionGas\\n    ) internal virtual {\\n        // Sends message to LayerZero messaging layer\\n        ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\\n            rootChainId,\\n            rootBridgeAgentPath,\\n            _payload,\\n            payable(_gasRefundee),\\n            address(0),\\n            _encodeAdapterParams(_gParams, _baseExecutionGas, rootBridgeAgentAddress)\\n        );\\n\\n        // Emit Gas Params Event\\n        emit LogGasParams(_gParams.gasLimit, _gParams.remoteBranchExecutionGas);\\n    }\\n\\n    /**\\n     * @notice Internal function performs the call to Layerzero Endpoint Contract for cross-chain messaging.\\n     *   @param _gasRefundee address to refund excess gas to.\\n     *   @param _settlementNonce root settlement nonce to fallback.\\n     */\\n    function _performFallbackCall(address payable _gasRefundee, uint32 _settlementNonce) internal virtual {\\n        // Sends message to LayerZero messaging layer\\n        ILayerZeroEndpoint(lzEndpointAddress).send{value: address(this).balance}(\\n            rootChainId,\\n            rootBridgeAgentPath,\\n            abi.encodePacked(bytes1(0x09), _settlementNonce),\\n            _gasRefundee,\\n            address(0),\\n            abi.encodePacked(uint16(1), uint256(100_000))\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Internal function to move assets from branch chain to root omnichain environment.\\n     *         Naive assets are deposited and hTokens are bridgedOut.\\n     *   @param _depositNonce Identifier for user deposit.\\n     *   @param _depositOwner owner address of the deposit.\\n     *   @param _hToken Local Input hToken Address.\\n     *   @param _token Native/Underlying Token Address.\\n     *   @param _amount Amount of Local hTokens deposited for trade.\\n     *   @param _deposit Amount of native tokens deposited for trade.\\n     *\\n     */\\n    function _createDeposit(\\n        bool isSigned,\\n        uint32 _depositNonce,\\n        address _depositOwner,\\n        address _hToken,\\n        address _token,\\n        uint256 _amount,\\n        uint256 _deposit\\n    ) internal {\\n        // Update Deposit Nonce\\n        depositNonce = _depositNonce + 1;\\n\\n        // Deposit / nonReentrant Tokens into Port\\n        IPort(localPortAddress).bridgeOut(msg.sender, _hToken, _token, _amount, _deposit);\\n\\n        // Cast to Dynamic\\n        address[] memory addressArray = new address[](1);\\n        uint256[] memory uintArray = new uint256[](1);\\n\\n        // Save deposit to storage\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n        deposit.owner = _depositOwner;\\n\\n        addressArray[0] = _hToken;\\n        deposit.hTokens = addressArray;\\n\\n        addressArray[0] = _token;\\n        deposit.tokens = addressArray;\\n\\n        uintArray[0] = _amount;\\n        deposit.amounts = uintArray;\\n\\n        uintArray[0] = _deposit;\\n        deposit.deposits = uintArray;\\n\\n        if (isSigned) deposit.isSigned = SIGNED_DEPOSIT;\\n    }\\n\\n    /**\\n     * @dev Internal function to move assets from branch chain to root omnichain environment.\\n     *      Naive assets are deposited and hTokens are bridgedOut.\\n     *   @param _depositNonce Identifier for user deposit.\\n     *   @param _depositOwner owner address of the deposit.\\n     *   @param _hTokens Local Input hToken Address.\\n     *   @param _tokens Native/Underlying Token Address.\\n     *   @param _amounts Amount of Local hTokens deposited for trade.\\n     *   @param _deposits  Amount of native tokens deposited for trade.\\n     *\\n     */\\n    function _createDepositMultiple(\\n        bool isSigned,\\n        uint32 _depositNonce,\\n        address _depositOwner,\\n        address[] memory _hTokens,\\n        address[] memory _tokens,\\n        uint256[] memory _amounts,\\n        uint256[] memory _deposits\\n    ) internal {\\n        // Validate Input\\n        if (_hTokens.length > MAX_TOKENS_LENGTH) revert InvalidInput();\\n        if (_hTokens.length != _tokens.length) revert InvalidInput();\\n        if (_tokens.length != _amounts.length) revert InvalidInput();\\n        if (_amounts.length != _deposits.length) revert InvalidInput();\\n\\n        // Update Deposit Nonce\\n        depositNonce = _depositNonce + 1;\\n\\n        // Deposit / nonReentrant Tokens into Port\\n        IPort(localPortAddress).bridgeOutMultiple(msg.sender, _hTokens, _tokens, _amounts, _deposits);\\n\\n        // Update State\\n        Deposit storage deposit = getDeposit[_depositNonce];\\n        deposit.owner = _depositOwner;\\n        deposit.hTokens = _hTokens;\\n        deposit.tokens = _tokens;\\n        deposit.amounts = _amounts;\\n        deposit.deposits = _deposits;\\n\\n        if (isSigned) deposit.isSigned = SIGNED_DEPOSIT;\\n    }\\n\\n    /**\\n     * @notice Internal function for validating and retrying a deposit.\\n     *   @param _payload Payload for cross-chain call.\\n     *   @param _gParams Gas parameters for cross-chain call.\\n     *   @param _minGas Minimum gas required for cross-chain call.\\n     */\\n    function _retryDeposit(bytes memory _payload, GasParams calldata _gParams, uint256 _minGas) internal {\\n        // Check if payload is empty\\n        if (_payload.length == 0) revert DepositRetryUnavailableUseCallout();\\n\\n        // Perform Call\\n        _performCall(payable(msg.sender), _payload, _gParams, _minGas);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                REMOTE USER DEPOSIT INTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to request balance clearance from a Port to a given user.\\n     *   @param _recipient token receiver.\\n     *   @param _hToken  local hToken address to clear balance for.\\n     *   @param _token  native/underlying token address to clear balance for.\\n     *   @param _amount amounts of hToken to clear balance for.\\n     *   @param _deposit amount of native/underlying tokens to clear balance for.\\n     *\\n     */\\n    function _clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\\n        internal\\n    {\\n        if (_amount - _deposit > 0) {\\n            unchecked {\\n                IPort(localPortAddress).bridgeIn(_recipient, _hToken, _amount - _deposit);\\n            }\\n        }\\n\\n        if (_deposit > 0) {\\n            IPort(localPortAddress).withdraw(_recipient, _token, _deposit);\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                MODIFIERS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Modifier verifies the caller is the Layerzero Enpoint or Local Branch Bridge Agent.\\n    modifier requiresEndpoint(uint16 _srcChainId, address _endpoint, bytes calldata _srcAddress) {\\n        _requiresEndpoint(_srcChainId, _endpoint, _srcAddress);\\n        _;\\n    }\\n\\n    /// @notice Internal function for caller verification. To be overwritten in `ArbitrumBranchBridgeAgent'.\\n    function _requiresEndpoint(uint16 _srcChainId, address _endpoint, bytes calldata _srcAddress)\\n        internal\\n        view\\n        virtual\\n    {\\n        //Verify Endpoint\\n        if (msg.sender != address(this)) revert LayerZeroUnauthorizedEndpoint();\\n        if (_endpoint != lzEndpointAddress) if (_endpoint != address(0)) revert LayerZeroUnauthorizedEndpoint();\\n\\n        //Verify Remote Caller\\n        if (_srcChainId != rootChainId) revert LayerZeroUnauthorizedCaller();\\n        if (_srcAddress.length != 40) revert LayerZeroUnauthorizedCaller();\\n        if (rootBridgeAgentAddress != address(uint160(bytes20(_srcAddress[:PARAMS_ADDRESS_SIZE])))) {\\n            revert LayerZeroUnauthorizedCaller();\\n        }\\n    }\\n\\n    /// @notice Modifier that verifies caller is Branch Bridge Agent's Router.\\n    modifier requiresRouter() {\\n        if (localRouterAddress != address(0)) if (msg.sender != localRouterAddress) revert UnrecognizedRouter();\\n        _;\\n    }\\n\\n    /// @notice Modifier that verifies caller is the Bridge Agent Executor.\\n    modifier requiresAgentExecutor() {\\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/BranchBridgeAgentExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from \\\"lib/solady/src/auth/Ownable.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"lib/solady/src/utils/SafeTransferLib.sol\\\";\\n\\nimport {BridgeAgentConstants} from \\\"./interfaces/BridgeAgentConstants.sol\\\";\\nimport {SettlementParams, SettlementMultipleParams} from \\\"./interfaces/IBranchBridgeAgent.sol\\\";\\nimport {IBranchRouter as IRouter} from \\\"./interfaces/IBranchRouter.sol\\\";\\n\\nimport {DecodeBridgeInMultipleParams} from \\\"./lib/DecodeBridgeInMultipleParams.sol\\\";\\n\\nimport {BranchBridgeAgent} from \\\"./BranchBridgeAgent.sol\\\";\\n\\n/// @title Library for Branch Bridge Agent Executor Deployment\\nlibrary DeployBranchBridgeAgentExecutor {\\n    function deploy(address _branchRouter) external returns (address) {\\n        return address(new BranchBridgeAgentExecutor(_branchRouter));\\n    }\\n}\\n\\n/**\\n * @title  Branch Bridge Agent Executor Contract\\n * @author MaiaDAO\\n * @notice This contract is used for requesting token deposit clearance and executing transactions in response to\\n *         requests from the root environment.\\n * @dev    Execution is \\\"sandboxed\\\" meaning upon tx failure both token deposits and interactions with external\\n *         contracts should be reverted and caught by the Branch Bridge Agent.\\n */\\ncontract BranchBridgeAgentExecutor is Ownable, BridgeAgentConstants {\\n    using SafeTransferLib for address;\\n    using DecodeBridgeInMultipleParams for bytes;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                IMMUATABLES\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Router that is responsible for executing the cross-chain requests forwarded by this contract.\\n    IRouter public immutable branchRouter;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Constructor for Branch Bridge Agent Executor.\\n     * @param _branchRouter router that will execute the cross-chain requests forwarded by this contract.\\n     * @dev    Sets the owner of the contract to the Branch Bridge Agent that deploys it.\\n     */\\n    constructor(address _branchRouter) {\\n        branchRouter = IRouter(_branchRouter);\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        EXECUTOR EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to execute a cross-chain request without any settlement.\\n     * @param _payload Data received from the messaging layer.\\n     * @dev SETTLEMENT FLAG: 1 (No settlement)\\n     */\\n    function executeNoSettlement(bytes calldata _payload) external payable onlyOwner {\\n        // Execute Calldata if there is code in the destination router\\n        branchRouter.executeNoSettlement{value: msg.value}(_payload[PARAMS_TKN_START_SIGNED:]);\\n    }\\n\\n    /**\\n     * @notice Function to execute a cross-chain request with a single settlement.\\n     * @param _recipient Address of the recipient of the settlement.\\n     * @param _payload Data received from the messaging layer.\\n     * @dev Router is responsible for managing the msg.value either using it for more remote calls or sending to user.\\n     * @dev SETTLEMENT FLAG: 2 (Single Settlement)\\n     */\\n    function executeWithSettlement(address _recipient, bytes calldata _payload) external payable onlyOwner {\\n        // Clear Token / Execute Settlement\\n        SettlementParams memory sParams = SettlementParams({\\n            settlementNonce: uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED])),\\n            recipient: _recipient,\\n            hToken: address(uint160(bytes20(_payload[PARAMS_TKN_START_SIGNED:45]))),\\n            token: address(uint160(bytes20(_payload[45:65]))),\\n            amount: uint256(bytes32(_payload[65:97])),\\n            deposit: uint256(bytes32(_payload[97:PARAMS_SETTLEMENT_OFFSET]))\\n        });\\n\\n        // Bridge In Assets\\n        BranchBridgeAgent(payable(msg.sender)).bridgeIn(\\n            _recipient, sParams.hToken, sParams.token, sParams.amount, sParams.deposit\\n        );\\n\\n        // Execute Calldata if there is any\\n        if (_payload.length > PARAMS_SETTLEMENT_OFFSET) {\\n            // Execute remote request\\n            branchRouter.executeSettlement{value: msg.value}(_payload[PARAMS_SETTLEMENT_OFFSET:], sParams);\\n        } else if (_recipient == address(branchRouter)) {\\n            // Execute remote request\\n            branchRouter.executeSettlement{value: msg.value}(\\\"\\\", sParams);\\n        } else {\\n            // Send remaininig native / gas token to recipient\\n            _recipient.safeTransferETH(address(this).balance);\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to execute a cross-chain request with multiple settlements.\\n     * @param _recipient Address of the recipient of the settlement.\\n     * @param _payload Data received from the messaging layer.\\n     * @dev Router is responsible for managing the msg.value either using it for more remote calls or sending to user.\\n     * @dev SETTLEMENT FLAG: 3 (Multiple Settlements)\\n     */\\n    function executeWithSettlementMultiple(address _recipient, bytes calldata _payload) external payable onlyOwner {\\n        // Parse Values\\n        uint256 assetsOffset = uint8(bytes1(_payload[PARAMS_START_SIGNED])) * PARAMS_TKN_SET_SIZE_MULTIPLE;\\n        uint256 settlementEndOffset = PARAMS_END_SIGNED_OFFSET + assetsOffset;\\n\\n        // Bridge In Assets and Save Deposit Params\\n        SettlementMultipleParams memory sParams =\\n            _bridgeInMultiple(_recipient, _payload[PARAMS_START_SIGNED:settlementEndOffset]);\\n\\n        // Execute Calldata if there is any\\n        if (_payload.length > settlementEndOffset) {\\n            // Execute remote request\\n            branchRouter.executeSettlementMultiple{value: msg.value}(_payload[settlementEndOffset:], sParams);\\n        } else if (_recipient == address(branchRouter)) {\\n            // Execute remote request\\n            branchRouter.executeSettlementMultiple{value: msg.value}(\\\"\\\", sParams);\\n        } else {\\n            // Send remaininig native / gas token to recipient\\n            _recipient.safeTransferETH(address(this).balance);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to move assets from root omnichain environment to branch chain.\\n     *   @param _recipient Cross-Chain Settlement of Multiple Tokens Params.\\n     *   @param _sParams Cross-Chain Settlement of Multiple Tokens Params.\\n     *   @dev Since the input data payload is encodePacked we need to parse it:\\n     *     1. First byte is the number of assets to be bridged in. Equals length of all arrays.\\n     *     2. Next 4 bytes are the nonce of the deposit.\\n     *     3. Last 32 bytes after the token related information are the chain to bridge to.\\n     *     4. Token related information starts at index PARAMS_TKN_START is encoded as follows:\\n     *         1. N * 32 bytes for the hToken address.\\n     *         2. N * 32 bytes for the underlying token address.\\n     *         3. N * 32 bytes for the amount of tokens to be bridged in.\\n     *         4. N * 32 bytes for the amount of underlying tokens to be bridged in.\\n     *     5. Each of the 4 token related arrays are of length N and start at the following indexes:\\n     *         1. PARAMS_TKN_START [hToken address has no offset from token information start].\\n     *         2. PARAMS_TKN_START + (PARAMS_ADDRESS_SIZE * N)\\n     *         3. PARAMS_TKN_START + (PARAMS_AMT_OFFSET * N)\\n     *         4. PARAMS_TKN_START + (PARAMS_DEPOSIT_OFFSET * N)\\n     */\\n    function _bridgeInMultiple(address _recipient, bytes calldata _sParams)\\n        internal\\n        returns (SettlementMultipleParams memory sParams)\\n    {\\n        // Decode Params\\n        (\\n            uint8 numOfAssets,\\n            uint32 nonce,\\n            address[] memory hTokens,\\n            address[] memory tokens,\\n            uint256[] memory amounts,\\n            uint256[] memory deposits\\n        ) = _sParams.decodeBridgeMultipleInfo();\\n\\n        // Save Deposit Multiple Params\\n        sParams = SettlementMultipleParams(numOfAssets, _recipient, nonce, hTokens, tokens, amounts, deposits);\\n\\n        BranchBridgeAgent(payable(msg.sender)).bridgeInMultiple(_recipient, sParams);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/BridgeAgentConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title  Bridge Agent Constants Contract\\n * @author MaiaDAO\\n * @notice Constants for use in Bridge Agent and Bridge Agent Executor contracts.\\n * @dev    Used for encoding / decoding of the cross-chain messages and state management.\\n */\\ncontract BridgeAgentConstants {\\n    /*///////////////////////////////////////////////////////////////\\n             SETTLEMENT / DEPOSIT EXECUTION STATUS CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Indicates that a settlement or deposit is ready to be executed.\\n    uint8 internal constant STATUS_READY = 0;\\n\\n    /// @notice Indicates that a settlement or deposit has been executed.\\n    uint8 internal constant STATUS_DONE = 1;\\n\\n    /// @notice Indicates that a settlement or deposit has failed and can only be retrieved.\\n    uint8 internal constant STATUS_RETRIEVE = 2;\\n\\n    /*///////////////////////////////////////////////////////////////\\n               SETTLEMENT / DEPOSIT REDEEM STATUS CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Indicates that the request for settlement or deposit was successful.\\n    uint8 internal constant STATUS_SUCCESS = 0;\\n\\n    /// @notice Indicates that the request for settlement or deposit has failed.\\n    uint8 internal constant STATUS_FAILED = 1;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                      DEPOSIT SIGNATURE CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Indicates that the deposit has been signed.\\n    uint8 internal constant SIGNED_DEPOSIT = 1;\\n\\n    /// @notice Indicates that the deposit has not been signed.\\n    uint8 internal constant UNSIGNED_DEPOSIT = 0;\\n\\n    /*///////////////////////////////////////////////////////////////\\n            PAYLOAD ENCODING / DECODING POSITIONAL CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Defines the position in bytes where the payload starts after the flag byte.\\n    ///         Also used to offset number of assets in the payload.\\n    uint256 internal constant PARAMS_START = 1;\\n\\n    /// @notice Defines the position in bytes where the signed payload starts after the flag byte and user address.\\n    uint256 internal constant PARAMS_START_SIGNED = 21;\\n\\n    /// @notice Defines the position in bytes where token-related information starts, after flag byte and nonce.\\n    uint256 internal constant PARAMS_TKN_START = 5;\\n\\n    /// @notice Defines the position in bytes where signed token-related information starts.\\n    /// @dev    After flag byte, user and nonce.\\n    uint256 internal constant PARAMS_TKN_START_SIGNED = 25;\\n\\n    /// @notice Size in bytes for standard Ethereum types / slot size (like uint256).\\n    uint256 internal constant PARAMS_ENTRY_SIZE = 32;\\n\\n    /// @notice Size in bytes for an Ethereum address.\\n    uint256 internal constant PARAMS_ADDRESS_SIZE = 20;\\n\\n    /// @notice Size in bytes for a single set of packed token-related parameters (hToken, token, amount, deposit).\\n    uint256 internal constant PARAMS_TKN_SET_SIZE = 109;\\n\\n    /// @notice Size in bytes for an entry of multiple-token-related parameters, taking padding into account.\\n    /// @dev    (hToken, token, amount, deposit)\\n    uint256 internal constant PARAMS_TKN_SET_SIZE_MULTIPLE = 128;\\n\\n    /// @notice Offset in bytes to mark the end of the standard (deposit related) parameters in the payload.\\n    uint256 internal constant PARAMS_END_OFFSET = 6;\\n\\n    /// @notice Offset in bytes to mark the end of the standard (deposit related) signed parameters in the payload.\\n    uint256 internal constant PARAMS_END_SIGNED_OFFSET = 26;\\n\\n    /// @notice Offset in bytes to mark the end of the standard (settlement related) parameters in the payload.\\n    uint256 internal constant PARAMS_SETTLEMENT_OFFSET = 129;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                DEPOSIT / SETTLEMENT LIMITATION CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maximum length of tokens allowed for deposit or settlement.\\n    uint256 internal constant MAX_TOKENS_LENGTH = 255;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    MINIMUM EXECUTION GAS CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Minimum gas required to safely fail execution.\\n    uint256 internal constant BASE_EXECUTION_FAILED_GAS = 15_000;\\n\\n    /// @notice Minimum gas required for a fallback request.\\n    uint256 internal constant BASE_FALLBACK_GAS = 140_000;\\n\\n    //--------------------BRANCH: Deposit------------------------------\\n\\n    /// @notice Minimum gas required for a callOut request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_GAS = 100_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositSingle request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_DEPOSIT_SINGLE_GAS = 150_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositMultiple request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_DEPOSIT_MULTIPLE_GAS = 200_000;\\n\\n    /// @notice Minimum gas required for a callOut request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_SIGNED_GAS = 100_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositSingle request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_SINGLE_GAS = 150_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositMultiple request.\\n    uint256 internal constant BRANCH_BASE_CALL_OUT_SIGNED_DEPOSIT_MULTIPLE_GAS = 200_000;\\n\\n    //---------------------ROOT: Settlement----------------------------\\n\\n    /// @notice Minimum gas required for a callOut request.\\n    uint256 internal constant ROOT_BASE_CALL_OUT_GAS = 100_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositSingle request.\\n    uint256 internal constant ROOT_BASE_CALL_OUT_SETTLEMENT_SINGLE_GAS = 150_000;\\n\\n    /// @notice Minimum gas required for a callOutDepositMultiple request.\\n    uint256 internal constant ROOT_BASE_CALL_OUT_SETTLEMENT_MULTIPLE_GAS = 200_000;\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/BridgeAgentStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/*///////////////////////////////////////////////////////////////\\n                            STRUCTS\\n//////////////////////////////////////////////////////////////*/\\n\\n/// @notice Struct for storing the gas parameters for a cross-chain call.\\n/// @param gasLimit gas units allocated for a cross-chain call execution.\\n/// @param remoteBranchExecutionGas native token amount to request for destiantion branch usage.\\nstruct GasParams {\\n    uint256 gasLimit;\\n    uint256 remoteBranchExecutionGas;\\n}\\n\\n/// @notice Struct for storing information about a deposit in a Branch Bridge Agent's state.\\n/// @param status status of the deposit. Has 3 states - ready, done, retrieve.\\n/// @param isSigned indicates if the deposit has been signed allowing Virtual Account usage.\\n/// @param owner owner of the deposit.\\n/// @param hTokens array of local hTokens addresses.\\n/// @param tokens array of underlying token addresses.\\n/// @param amounts array of total deposited amounts.\\n/// @param deposits array of underlying token deposited amounts.\\nstruct Deposit {\\n    uint8 status;\\n    uint88 isSigned;\\n    address owner;\\n    address[] hTokens;\\n    address[] tokens;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\\n/// @notice Struct for inputting deposit information into a Branch Bridge Agent.\\n/// @param hToken local hToken address.\\n/// @param token underlying token address.\\n/// @param amount total amount to deposit.\\n/// @param deposit underlying token amount to deposit.\\nstruct DepositInput {\\n    address hToken;\\n    address token;\\n    uint256 amount;\\n    uint256 deposit;\\n}\\n\\n/// @notice Struct for inputting multiple asset deposit information into a Branch Bridge Agent.\\n/// @param hTokens array of local hTokens addresses.\\n/// @param tokens array of underlying token addresses.\\n/// @param amounts array of total amounts to deposit.\\n/// @param deposits array of underlying token amounts to deposit.\\nstruct DepositMultipleInput {\\n    address[] hTokens;\\n    address[] tokens;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\\n/// @notice Struct for encoding deposit information in a cross-chain message.\\n/// @param depositNonce deposit nonce.\\n/// @param hToken local hToken address.\\n/// @param token underlying token address.\\n/// @param amount total amount to deposit.\\n/// @param deposit underlying token amount to deposit.\\nstruct DepositParams {\\n    uint32 depositNonce;\\n    address hToken;\\n    address token;\\n    uint256 amount;\\n    uint256 deposit;\\n}\\n\\n/// @notice Struct for encoding multiple asset deposit information in a cross-chain message.\\n/// @param numberOfAssets number of assets to deposit.\\n/// @param depositNonce deposit nonce.\\n/// @param hTokens array of local hTokens addresses.\\n/// @param tokens array of underlying token addresses.\\n/// @param amounts array of total amounts to deposit.\\n/// @param deposits array of underlying token amounts to deposit.\\nstruct DepositMultipleParams {\\n    uint8 numberOfAssets;\\n    uint32 depositNonce;\\n    address[] hTokens;\\n    address[] tokens;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\\n/// @notice Struct for storing information about a settlement in a Root Bridge Agent's state.\\n/// @param dstChainId destination chain for interaction.\\n/// @param status status of the settlement.\\n/// @param owner owner of the settlement.\\n/// @param recipient recipient of the settlement.\\n/// @param hTokens array of global hTokens addresses.\\n/// @param tokens array of underlying token addresses.\\n/// @param amounts array of total settled amounts.\\n/// @param deposits array of underlying token settled amounts.\\nstruct Settlement {\\n    uint16 dstChainId;\\n    uint80 status;\\n    address owner;\\n    address recipient;\\n    address[] hTokens;\\n    address[] tokens;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\\n/// @notice Struct for inputting token settlement information into a Root Bridge Agent.\\n/// @param globalAddress global hToken address.\\n/// @param amount total amount to settle.\\n/// @param deposit underlying token amount to settle.\\nstruct SettlementInput {\\n    address globalAddress;\\n    uint256 amount;\\n    uint256 deposit;\\n}\\n\\n/// @notice Struct for inputting multiple asset settlement information into a Root Bridge Agent.\\n/// @param globalAddresses array of global hTokens addresses.\\n/// @param amounts array of total amounts to settle.\\n/// @param deposits array of underlying token amounts to settle.\\n\\nstruct SettlementMultipleInput {\\n    address[] globalAddresses;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\\n/// @notice Struct for encoding settlement information in a cross-chain message.\\n/// @param settlementNonce settlement nonce.\\n/// @param recipient recipient of the settlement.\\n/// @param hToken destination local hToken address.\\n/// @param token destination underlying token address.\\n/// @param amount total amount to settle.\\n/// @param deposit underlying token amount to settle.\\nstruct SettlementParams {\\n    uint32 settlementNonce;\\n    address recipient;\\n    address hToken;\\n    address token;\\n    uint256 amount;\\n    uint256 deposit;\\n}\\n\\n/// @notice Struct for encoding multiple asset settlement information in a cross-chain message.\\n/// @param numberOfAssets number of assets to settle.\\n/// @param recipient recipient of the settlement.\\n/// @param settlementNonce settlement nonce.\\n/// @param hTokens array of destination local hTokens addresses.\\n/// @param tokens array of destination underlying token addresses.\\n/// @param amounts array of total amounts to settle.\\n/// @param deposits array of underlying token amounts to settle.\\nstruct SettlementMultipleParams {\\n    uint8 numberOfAssets;\\n    address recipient;\\n    uint32 settlementNonce;\\n    address[] hTokens;\\n    address[] tokens;\\n    uint256[] amounts;\\n    uint256[] deposits;\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/IBranchBridgeAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {\\n    GasParams,\\n    Deposit,\\n    DepositInput,\\n    DepositMultipleInput,\\n    DepositParams,\\n    DepositMultipleParams,\\n    SettlementParams,\\n    SettlementMultipleParams\\n} from \\\"./BridgeAgentStructs.sol\\\";\\nimport {ILayerZeroReceiver} from \\\"./ILayerZeroReceiver.sol\\\";\\n\\n/**\\n * @title  Branch Bridge Agent Contract\\n * @author MaiaDAO\\n * @notice Contract for deployment in Branch Chains of Omnichain System, responsible for interfacing with\\n *         Users and Routers acting as a middleman to access LayerZero cross-chain messaging and requesting/depositing\\n *         assets in the Branch Chain's Ports.\\n * @dev    Bridge Agents allow for the encapsulation of business logic as well as standardize cross-chain communication,\\n *         allowing for the creation of custom Routers to perform actions in response to local / remote user requests.\\n *         This contract is designed for deployment in the Branch Chains of the Ulysses Omnichain Liquidity System.\\n *         The Branch Bridge Agent is responsible for sending/receiving requests to/from the LayerZero Messaging Layer\\n *         for execution, as well as requests tokens clearances and tx execution to the `BranchBridgeAgentExecutor`.\\n *         Remote execution is \\\"sandboxed\\\" within 2 different layers/nestings:\\n *         - 1: Upon receiving a request from LayerZero Messaging Layer to avoid blocking future requests due to\\n *              execution reversion, ensuring our app is Non-Blocking.\\n *              (See https://github.com/LayerZero-Labs/solidity-examples/blob/8e62ebc886407aafc89dbd2a778e61b7c0a25ca0/contracts/lzApp/NonblockingLzApp.sol)\\n *         - 2: The call to `BranchBridgeAgentExecutor` is in charge of requesting token deposits for each remote\\n *              interaction as well as performing the Router calls, if any of the calls initiated by the Router lead\\n *              to an invalid state change both the token deposit clearances as well as the external interactions\\n *              will be reverted and caught by the `BranchBridgeAgent`.\\n *\\n *         **BRANCH BRIDGE AGENT SETTLEMENT FLAGs** Func IDs for calling these functions through the messaging layer\\n *\\n *         | ID   | DESCRIPTION                                                                                       |\\n *         | ---- | ------------------------------------------------------------------------------------------------- |\\n *         | 0x01 | Call to Branch without Settlement.                                                                |\\n *         | 0x02 | Call to Branch with Settlement.                                                                   |\\n *         | 0x03 | Call to Branch with Settlement of Multiple Tokens.                                                |\\n *         | 0x04 | Call to `retrieveSettlement()`. (trigger `_fallback` for a settlement that has not been executed) |\\n *         | 0x05 | Call to `_fallback()`. (reopens a deposit for asset redemption)                                   |\\n *\\n *         Encoding Scheme for different Root Bridge Agent Deposit Flags:\\n *\\n *           - ht = hToken\\n *           - t = Token\\n *           - A = Amount\\n *           - D = Deposit\\n *           - b = bytes\\n *           - n = number of assets\\n *\\n *         | Flag   | Deposit Info                | Token Info              | DATA |\\n *         | ------ | --------------------------- | ----------------------- | ---- |\\n *         | 1 byte | 4-25 bytes                  | 104 or (128 * n) bytes  |      |\\n *         |        |                             | hT - t - A - D          | ...  |\\n *         | 0x1    | 20b(recipient) + 4b(nonce)  |          ---            | ...  |\\n *         | 0x2    | 20b(recipient) + 4b(nonce)  | 20b + 20b + 32b + 32b   | ...  |\\n *         | 0x3    | 1b(n) + 20b(recipient) + 4b | 32b + 32b + 32b + 32b   | ...  |\\n *\\n *         **Generic Contract Interaction Flow:**\\n *         BridgeAgent.lzReceive() -> BridgeAgentExecutor.execute() -> Router.execute()\\n *\\n */\\ninterface IBranchBridgeAgent is ILayerZeroReceiver {\\n    /*///////////////////////////////////////////////////////////////\\n                        VIEW FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice External function to return the Branch Chain's Local Port Address.\\n     * @return address of the Branch Chain's Local Port.\\n     */\\n    function localPortAddress() external view returns (address);\\n\\n    /**\\n     * @notice External function to return the Branch Bridge Agent Executor Address.\\n     * @return address of the Branch Bridge Agent Executor.\\n     */\\n    function bridgeAgentExecutorAddress() external view returns (address);\\n\\n    /**\\n     * @notice External function that returns a given deposit entry.\\n     *  @param depositNonce Identifier for user deposit.\\n     */\\n    function getDepositEntry(uint32 depositNonce) external view returns (Deposit memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    USER AND BRANCH ROUTER FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\\n     *  @param gasRefundee Address to return excess gas deposited in `msg.value` to.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @dev DEPOSIT ID: 1 (Call without deposit)\\n     */\\n    function callOut(address payable gasRefundee, bytes calldata params, GasParams calldata gasParams)\\n        external\\n        payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\\n     *  @param depositOwnerAndGasRefundee Deposit owner and address to return excess gas deposited in `msg.value` to.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param depositParams additional token deposit parameters.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @dev DEPOSIT ID: 2 (Call with single deposit)\\n     */\\n    function callOutAndBridge(\\n        address payable depositOwnerAndGasRefundee,\\n        bytes calldata params,\\n        DepositInput memory depositParams,\\n        GasParams calldata gasParams\\n    ) external payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\\n     *  @param depositOwnerAndGasRefundee Deposit owner and address to return excess gas deposited in `msg.value` to.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param depositParams additional token deposit parameters.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @dev DEPOSIT ID: 3 (Call with multiple deposit)\\n     */\\n    function callOutAndBridgeMultiple(\\n        address payable depositOwnerAndGasRefundee,\\n        bytes calldata params,\\n        DepositMultipleInput memory depositParams,\\n        GasParams calldata gasParams\\n    ) external payable;\\n\\n    /**\\n     * @notice Perform a call to the Root Omnichain Router without token deposit with msg.sender information.\\n     *  @dev msg.sender is gasRefundee in signed calls.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @dev DEPOSIT ID: 4 (Call without deposit and verified sender)\\n     */\\n    function callOutSigned(bytes calldata params, GasParams calldata gasParams) external payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset msg.sender.\\n     *  @dev msg.sender is depositOwnerAndGasRefundee in signed calls.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param depositParams additional token deposit parameters.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @param hasFallbackToggled flag to indicate if the fallback function was toggled.\\n     *  @dev DEPOSIT ID: 5 (Call with single deposit and verified sender)\\n     */\\n    function callOutSignedAndBridge(\\n        bytes calldata params,\\n        DepositInput memory depositParams,\\n        GasParams calldata gasParams,\\n        bool hasFallbackToggled\\n    ) external payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while\\n     *         depositing two or more assets with msg.sender.\\n     *  @dev msg.sender is depositOwnerAndGasRefundee in signed calls.\\n     *  @param params enconded parameters to execute on the root chain router.\\n     *  @param depositParams additional token deposit parameters.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @param hasFallbackToggled flag to indicate if the fallback function was toggled.\\n     *  @dev DEPOSIT ID: 6 (Call with multiple deposit and verified sender)\\n     */\\n    function callOutSignedAndBridgeMultiple(\\n        bytes calldata params,\\n        DepositMultipleInput memory depositParams,\\n        GasParams calldata gasParams,\\n        bool hasFallbackToggled\\n    ) external payable;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    DEPOSIT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Environment\\n     *         retrying a failed non-signed deposit that hasn't been executed yet.\\n     *  @param owner address of the deposit owner.\\n     *  @param depositNonce Identifier for user deposit.\\n     *  @param params parameters to execute on the root chain router.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     */\\n    function retryDeposit(address owner, uint32 depositNonce, bytes calldata params, GasParams calldata gasParams)\\n        external\\n        payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Environment\\n     *         retrying a failed signed deposit that hasn't been executed yet.\\n     *  @param depositNonce Identifier for user deposit.\\n     *  @param params parameters to execute on the root chain router.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @param hasFallbackToggled flag to indicate if the fallback function was toggled.\\n     */\\n    function retryDepositSigned(\\n        uint32 depositNonce,\\n        bytes calldata params,\\n        GasParams calldata gasParams,\\n        bool hasFallbackToggled\\n    ) external payable;\\n\\n    /**\\n     * @notice External function to request tokens back to branch chain after failing omnichain environment interaction.\\n     *  @param depositNonce Identifier for user deposit to retrieve.\\n     *  @param gasParams gas parameters for the cross-chain call.\\n     *  @dev DEPOSIT ID: 8\\n     */\\n    function retrieveDeposit(uint32 depositNonce, GasParams calldata gasParams) external payable;\\n\\n    /**\\n     * @notice External function to retry a failed Deposit entry on this branch chain.\\n     *  @param depositNonce Identifier for user deposit.\\n     *  @param recipient address to receive the redeemed tokens.\\n     */\\n    function redeemDeposit(uint32 depositNonce, address recipient) external;\\n\\n    /**\\n     * @notice External function to retry a failed Deposit entry on this branch chain.\\n     *  @param depositNonce Identifier for user deposit.\\n     *  @param recipient address to receive the redeemed tokens.\\n     *  @param localTokenAddress address of the local token to redeem.\\n     */\\n    function redeemDeposit(uint32 depositNonce, address recipient, address localTokenAddress) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    SETTLEMENT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice External function to retry a failed Settlement entry on the root chain.\\n     *  @param settlementNonce Identifier for user settlement.\\n     *  @param params parameters to execute on the root chain router.\\n     *  @param gasParams gas parameters for the cross-chain call to root chain and for the settlement to branch.\\n     *  @param hasFallbackToggled flag to indicate if the fallback function should be toggled.\\n     *  @dev DEPOSIT ID: 7\\n     */\\n    function retrySettlement(\\n        uint32 settlementNonce,\\n        bytes calldata params,\\n        GasParams[2] calldata gasParams,\\n        bool hasFallbackToggled\\n    ) external payable;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to request balance clearance from a Port to a given user.\\n     *  @param recipient token receiver.\\n     *  @param hToken  local hToken addresse to clear balance for.\\n     *  @param token  native / underlying token addresse to clear balance for.\\n     *  @param amount amounts of token to clear balance for.\\n     *  @param deposit amount of native / underlying tokens to clear balance for.\\n     */\\n    function bridgeIn(address recipient, address hToken, address token, uint256 amount, uint256 deposit) external;\\n\\n    /**\\n     * @notice Function to request balance clearance from a Port to a given address.\\n     *  @param recipient token receiver.\\n     *  @param sParams encode packed multiple settlement info.\\n     */\\n    function bridgeInMultiple(address recipient, SettlementMultipleParams calldata sParams) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Event emitted when a deposit is successfully and fully redeemed.\\n    /// @param depositNonce Identifier for user deposit.\\n    /// @param recipient address to receive the redeemed tokens.\\n    event RedeemDeposit(uint256 indexed depositNonce, address indexed recipient);\\n\\n    /// @notice Event emitted when a single token is redeemed from a deposit and there are other tokens left to redeem.\\n    /// @param depositNonce Identifier for user deposit.\\n    /// @param recipient address to receive the redeemed tokens.\\n    /// @param localTokenAddress address of the local token to redeem.\\n    event RedeemDeposit(uint256 indexed depositNonce, address indexed recipient, address indexed localTokenAddress);\\n\\n    /// @notice Event emitted when a settlement nonce is executed successfully.\\n    /// @param nonce Identifier for user settlement.\\n    event LogExecute(uint256 indexed nonce);\\n\\n    /// @notice Event emitted when fallback is received for a failed deposit nonce.\\n    /// @param nonce Identifier for user deposit.\\n    event LogFallback(uint256 indexed nonce);\\n\\n    /// @notice Event emitted after a message is sent to the Layer Zero Endpoint.\\n    /// @param gasLimit gas limit for the cross-chain call.\\n    /// @param remoteBranchExecutionGas native gas tokens to be sent to the remote branch.\\n    event LogGasParams(uint256 indexed gasLimit, uint256 indexed remoteBranchExecutionGas);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                ERRORS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Error emitted when the provided Root Bridge Agent Address is invalid.\\n    error InvalidRootBridgeAgentAddress();\\n    /// @notice Error emitted when the provided Branch Port Address is invalid.\\n    error InvalidBranchPortAddress();\\n    /// @notice Error emitted when the provided Layer Zero Endpoint Address is invalid.\\n    error InvalidEndpointAddress();\\n\\n    /// @notice Error emitted when the Branch Bridge Agent does not recognize the action flag.\\n    error UnknownFlag();\\n    /// @notice Error emitted when a settlement nonce fails to execute and does not have fallback enabled.\\n    error ExecutionFailure();\\n\\n    /// @notice Error emitted when a Layer Zero remote caller in not recognized as the Root Bridge Agent.\\n    error LayerZeroUnauthorizedCaller();\\n    /// @notice Error emitted when the caller is not the local Layer Zero Endpoint contract.\\n    error LayerZeroUnauthorizedEndpoint();\\n\\n    /// @notice Error emitted when the settlement nonce has already been executed.\\n    error AlreadyExecutedTransaction();\\n\\n    /// @notice Error emitted when the local hToken address is zero.\\n    error InvalidLocalAddress();\\n    /// @notice Error emitted when the deposit information is not valid.\\n    error InvalidInput();\\n\\n    /// @notice Error emitted when the the wrong retryDeposit function for a deposit type (Signed or Unsigned).\\n    error WrongDepositType();\\n    /// @notice Error emitted when caller is not the deposit owner.\\n    error NotDepositOwner();\\n    /// @notice Error emitted when the action of deposit nonce is not retryabable.\\n    error DepositRetryUnavailableUseCallout();\\n    /// @notice Error emitted when the deposit nonce is not in a redeemable state.\\n    error DepositRedeemUnavailable();\\n    /// @notice Error emitted when the deposit nonce is not in a retryable state.\\n    error DepositAlreadyRetrieved();\\n\\n    /// @notice Error emitted when the caller is not the Branch Bridge Agent's Router\\n    error UnrecognizedRouter();\\n    /// @notice Error emitted when the caller is not the Branch Bridge Agent's Executors\\n    error UnrecognizedBridgeAgentExecutor();\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/IBranchPort.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title  Branch Port - Omnichain Token Management Contract\\n * @author MaiaDAO\\n * @notice Ulyses `Port` implementation for Branch Chain deployment. This contract is used to manage the deposit and\\n *         withdrawal of underlying assets from the Branch Chain in response to Branch Bridge Agent requests.\\n *         Manages Bridge Agents and their factories as well as the chain's strategies and their tokens.\\n */\\ninterface IBranchPort {\\n    /*///////////////////////////////////////////////////////////////\\n                            VIEW FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n    /**\\n     * @notice Returns true if the address is a Bridge Agent.\\n     *   @param _bridgeAgent Bridge Agent address.\\n     *   @return bool .\\n     */\\n    function isBridgeAgent(address _bridgeAgent) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is a Strategy Token.\\n     *   @param _token token address.\\n     *   @return bool.\\n     */\\n    function isStrategyToken(address _token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is a Port Strategy.\\n     *   @param _strategy strategy address.\\n     *   @param _token token address.\\n     *   @return bool.\\n     */\\n    function isPortStrategy(address _strategy, address _token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is a Bridge Agent Factory.\\n     *   @param _bridgeAgentFactory Bridge Agent Factory address.\\n     *   @return bool.\\n     */\\n    function isBridgeAgentFactory(address _bridgeAgentFactory) external view returns (bool);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          PORT STRATEGY MANAGEMENT\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Allows active Port Strategy addresses to withdraw assets.\\n     *  @param _token token address.\\n     *  @param _amount amount of tokens.\\n     */\\n    function manage(address _token, uint256 _amount) external;\\n\\n    /**\\n     * @notice allow strategy address to repay borrowed reserves with reserves.\\n     *  @param _amount amount of tokens to repay.\\n     *  @param _token address of the token to repay.\\n     *  @dev must be called by the port strategy itself.\\n     */\\n    function replenishReserves(address _token, uint256 _amount) external;\\n\\n    /**\\n     * @notice allow anyone to request repayment of a strategy's reserves if Port is under minimum reserves ratio.\\n     *  @param _strategy address of the strategy to repay.\\n     *  @param _token address of the token to repay.\\n     *  @dev can be called by anyone to ensure availability of service.\\n     */\\n    function replenishReserves(address _strategy, address _token) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          hTOKEN MANAGEMENT\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to withdraw underlying / native token amount from Port to Branch Bridge Agent.\\n     *   @param _recipient address of the underlying token receiver.\\n     *   @param _underlyingAddress underlying token address.\\n     *   @param _amount amount of tokens.\\n     *   @dev must be called by the bridge agent itself. Matches the burning of global hTokens in root chain.\\n     */\\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _amount) external;\\n\\n    /**\\n     * @notice Function to mint hToken amount to Branch Bridge Agent.\\n     *   @param _recipient address of the hToken receiver.\\n     *   @param _localAddress hToken address.\\n     *   @param _amount amount of hTokens.\\n     *   @dev must be called by the bridge agent itself. Matches the storage of global hTokens in root port.\\n     */\\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount) external;\\n\\n    /**\\n     * @notice Function to withdraw underlying / native tokens and mint local hTokens to Branch Bridge Agent.\\n     *   @param _recipient address of the token receiver.\\n     *   @param _localAddresses local hToken addresses.\\n     *   @param _underlyingAddresses underlying token addresses.\\n     *   @param _amounts total amount of tokens.\\n     *   @param _deposits amount of underlying tokens.\\n     */\\n    function bridgeInMultiple(\\n        address _recipient,\\n        address[] memory _localAddresses,\\n        address[] memory _underlyingAddresses,\\n        uint256[] memory _amounts,\\n        uint256[] memory _deposits\\n    ) external;\\n\\n    /**\\n     * @notice Function to deposit underlying / native tokens in Port and burn hTokens.\\n     *   @param _depositor address of the token depositor.\\n     *   @param _localAddress local hToken addresses.\\n     *   @param _underlyingAddress underlying token addresses.\\n     *   @param _amount total amount of tokens.\\n     *   @param _deposit amount of underlying tokens.\\n     */\\n    function bridgeOut(\\n        address _depositor,\\n        address _localAddress,\\n        address _underlyingAddress,\\n        uint256 _amount,\\n        uint256 _deposit\\n    ) external;\\n\\n    /**\\n     * @notice Setter function to decrease local hToken supply.\\n     *   @param _depositor address of the token depositor.\\n     *   @param _localAddresses local hToken addresses.\\n     *   @param _underlyingAddresses underlying token addresses.\\n     *   @param _amounts total amount of tokens.\\n     *   @param _deposits amount of underlying tokens.\\n     */\\n    function bridgeOutMultiple(\\n        address _depositor,\\n        address[] memory _localAddresses,\\n        address[] memory _underlyingAddresses,\\n        uint256[] memory _amounts,\\n        uint256[] memory _deposits\\n    ) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        ADMIN FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Adds a new bridge agent address to the branch port.\\n     *   @param _bridgeAgent address of the bridge agent to add to the Port\\n     */\\n    function addBridgeAgent(address _bridgeAgent) external;\\n\\n    /**\\n     * @notice Toggle a given bridge agent factory. If it's active, it will de-activate it and vice-versa.\\n     *   @param _bridgeAgentFactory address of the bridge agent factory to add to the Port\\n     */\\n    function toggleBridgeAgentFactory(address _bridgeAgentFactory) external;\\n\\n    /**\\n     * @notice Toggle a given strategy token. If it's active, it will de-activate it and vice-versa.\\n     * @param _token address of the token to add to the Strategy Tokens\\n     * @param _minimumReservesRatio minimum reserves ratio for the token\\n     * @dev Must be between 7000 and 10000 (70% and 100%). Can be any value if the token is being de-activated.\\n     */\\n    function toggleStrategyToken(address _token, uint256 _minimumReservesRatio) external;\\n\\n    /**\\n     * @notice Update an active strategy token's minimum reserves ratio. If it is not active, it will revert.\\n     * @param _token address of the token to add to the Strategy Tokens\\n     * @param _minimumReservesRatio minimum reserves ratio for the token\\n     * @dev Must be between 7000 and 10000 (70% and 100%). Can be any value if the token is being de-activated.\\n     */\\n    function updateStrategyToken(address _token, uint256 _minimumReservesRatio) external;\\n\\n    /**\\n     * @notice Add or Remove a Port Strategy.\\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\\n     * @param _reserveRatioManagementLimit Total reserves management limit of the given token for the Port Strategy.\\n     * @dev Must be between 7000 and 10000 (70% and 100%). Can be any value if the token is being de-activated.\\n     */\\n    function togglePortStrategy(\\n        address _portStrategy,\\n        address _underlyingToken,\\n        uint256 _dailyManagementLimit,\\n        uint256 _reserveRatioManagementLimit\\n    ) external;\\n\\n    /**\\n     * @notice Updates a Port Strategy.\\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\\n     * @param _reserveRatioManagementLimit Total reserves management limit of the given token for the Port Strategy.\\n     * @dev Must be between 7000 and 10000 (70% and 100%). Can be any value if the token is being de-activated.\\n     */\\n    function updatePortStrategy(\\n        address _portStrategy,\\n        address _underlyingToken,\\n        uint256 _dailyManagementLimit,\\n        uint256 _reserveRatioManagementLimit\\n    ) external;\\n\\n    /**\\n     * @notice Sets the core branch router and bridge agent for the branch port.\\n     *   @param _coreBranchRouter address of the new core branch router\\n     *   @param _coreBranchBridgeAgent address of the new core branch bridge agent\\n     */\\n    function setCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent) external;\\n\\n    /**\\n     * @notice Allows governance to claim any native tokens accumulated from failed transactions.\\n     *  @param _recipient address to transfer ETH to.\\n     */\\n    function sweep(address _recipient) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Event emitted when a Port Strategy manages more reserves increasing its debt for a given token.\\n    event DebtCreated(address indexed _strategy, address indexed _token, uint256 _amount);\\n    /// @notice Event emitted when a Port Strategy replenishes reserves decreasing its debt for a given token.\\n    event DebtRepaid(address indexed _strategy, address indexed _token, uint256 _amount);\\n\\n    /// @notice Event emitted when Strategy Token has its details updated.\\n    event StrategyTokenUpdated(address indexed _token, uint256 indexed _minimumReservesRatio);\\n\\n    /// @notice Event emitted when a Port Strategy has its details updated.\\n    event PortStrategyUpdated(\\n        address indexed _portStrategy,\\n        address indexed _token,\\n        uint256 indexed _dailyManagementLimit,\\n        uint256 _reserveRatioManagementLimit\\n    );\\n\\n    /// @notice Event emitted when a Branch Bridge Agent Factory is toggled on or off.\\n    event BridgeAgentFactoryToggled(address indexed _bridgeAgentFactory);\\n\\n    /// @notice Event emitted when a Bridge Agent is toggled on or off.\\n    event BridgeAgentToggled(address indexed _bridgeAgent);\\n\\n    /// @notice Event emitted when a Core Branch Router and Bridge Agent are set.\\n    event CoreBranchSet(address indexed _coreBranchRouter, address indexed _coreBranchBridgeAgent);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERRORS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Error emitted when Bridge Agent is already added.\\n    error AlreadyAddedBridgeAgent();\\n\\n    /// @notice Error emitted when Port Strategy request would exceed the Branch Port's minimum reserves.\\n    error InsufficientReserves();\\n    /// @notice Error emitted when not enough debt.\\n    error InsufficientDebt();\\n\\n    /// @notice Error emitted when Port Strategy request would exceed it's reserve ratio management limit.\\n    error ExceedsReserveRatioManagementLimit();\\n\\n    /// @notice Error emitted when amount requested is zero.\\n    error InvalidAmount();\\n    /// @notice Error emitted when token deposit arrays have different lengths.\\n    error InvalidInputArrays();\\n    /// @notice Error emitted when an invalid underlying token address is provided.\\n    error InvalidUnderlyingAddress();\\n\\n    /// @notice Error emitted when caller is not the Core Branch Router.\\n    error UnrecognizedCore();\\n    /// @notice Error emitted when caller is not an active Branch Bridge Agent.\\n    error UnrecognizedBridgeAgent();\\n    /// @notice Error emitted when caller is not an active Branch Bridge Agent Factory.\\n    error UnrecognizedBridgeAgentFactory();\\n    /// @notice Error emitted when caller is not an active Port Strategy.\\n    error UnrecognizedPortStrategy();\\n    /// @notice Error emitted when caller is not an active Strategy Token.\\n    error UnrecognizedStrategyToken();\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/IBranchRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {\\n    GasParams,\\n    Deposit,\\n    DepositInput,\\n    DepositMultipleInput,\\n    SettlementParams,\\n    SettlementMultipleParams\\n} from \\\"./IBranchBridgeAgent.sol\\\";\\n\\n/**\\n * @title  BaseBranchRouter Contract\\n * @author MaiaDAO\\n * @notice Base Branch Contract for interfacing with Branch Bridge Agents.\\n *         This contract for deployment in Branch Chains of the Ulysses Omnichain System,\\n *         additional logic can be implemented to perform actions before sending cross-chain\\n *         requests, as well as in response to requests from the Root Omnichain Environment.\\n */\\ninterface IBranchRouter {\\n    /*///////////////////////////////////////////////////////////////\\n                            VIEW / STATE\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice External function to return the Branch Chain's Local Port Address.\\n    function localPortAddress() external view returns (address);\\n\\n    /// @notice Address for local Branch Bridge Agent who processes requests and interacts with local port.\\n    function localBridgeAgentAddress() external view returns (address);\\n\\n    /// @notice Local Bridge Agent Executor Address.\\n    function bridgeAgentExecutorAddress() external view returns (address);\\n\\n    /// @notice External function that returns a given deposit entry.\\n    /// @param depositNonce Identifier for user deposit.\\n    function getDepositEntry(uint32 depositNonce) external view returns (Deposit memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\\n     *   @param params enconded parameters to execute on the root chain.\\n     *   @param gParams gas parameters for the cross-chain call.\\n     *   @dev ACTION ID: 1 (Call without deposit)\\n     *\\n     */\\n    function callOut(bytes calldata params, GasParams calldata gParams) external payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\\n     *   @param params encoded parameters to execute on the root chain.\\n     *   @param dParams additional token deposit parameters.\\n     *   @param gParams gas parameters for the cross-chain call.\\n     *   @dev ACTION ID: 2 (Call with single deposit)\\n     *\\n     */\\n    function callOutAndBridge(bytes calldata params, DepositInput calldata dParams, GasParams calldata gParams)\\n        external\\n        payable;\\n\\n    /**\\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\\n     *   @param params encoded parameters to execute on the root chain.\\n     *   @param dParams additional token deposit parameters.\\n     *   @param gParams gas parameters for the cross-chain call.\\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\\n     *\\n     */\\n    function callOutAndBridgeMultiple(\\n        bytes calldata params,\\n        DepositMultipleInput calldata dParams,\\n        GasParams calldata gParams\\n    ) external payable;\\n\\n    /**\\n     * @notice Function to retry a deposit that has failed.\\n     *   @param _depositNonce Identifier for user deposit.\\n     *   @param _params encoded router parameters to execute on the root chain.\\n     *   @param _gParams gas parameters for the cross-chain call.\\n     */\\n    function retryDeposit(uint32 _depositNonce, bytes calldata _params, GasParams calldata _gParams) external payable;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        LAYERZERO EXTERNAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Function responsible of executing a branch router response.\\n     *   @param params data received from messaging layer.\\n     */\\n    function executeNoSettlement(bytes calldata params) external payable;\\n\\n    /**\\n     * @dev Function responsible of executing a crosschain request without any deposit.\\n     *   @param params data received from messaging layer.\\n     *   @param sParams SettlementParams struct.\\n     */\\n    function executeSettlement(bytes calldata params, SettlementParams calldata sParams) external payable;\\n\\n    /**\\n     * @dev Function responsible of executing a crosschain request which contains\\n     *      cross-chain deposit information attached.\\n     *   @param params data received from messaging layer.\\n     *   @param sParams SettlementParams struct containing deposit information.\\n     *\\n     */\\n    function executeSettlementMultiple(bytes calldata params, SettlementMultipleParams calldata sParams)\\n        external\\n        payable;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERRORS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Error emitted when the Branch Router does not recognize the function ID.\\n    error UnrecognizedFunctionId();\\n\\n    /// @notice Error emitted when caller is not the Branch Bridge Agent Executor.\\n    error UnrecognizedBridgeAgentExecutor();\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint256 _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint256 _configType)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroReceiver {\\n    /*///////////////////////////////////////////////////////////////\\n                            LAYER ZERO FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n     *  @param _srcChainId the source endpoint identifier\\n     *  @param _srcAddress the source sending contract address from the source chain\\n     *  @param _nonce the ordered message nonce\\n     *  @param _payload the signed payload is the UA bytes has encoded to be sent\\n     */\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload)\\n        external\\n        payable\\n        returns (bool);\\n\\n    /**\\n     * @notice External function to receive cross-chain messages from LayerZero Endpoint Contract without blocking.\\n     *  @param _endpoint address of the LayerZero Endpoint Contract.\\n     *  @param _srcAddress address path of the recipient + sender.\\n     *  @param _payload Calldata for function call.\\n     */\\n    function lzReceiveNonBlocking(\\n        address _endpoint,\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        bytes calldata _payload\\n    ) external payable;\\n\\n    /**\\n     * @notice Only when the BridgeAgent needs to resume the message flow in blocking mode and clear the stored payload.\\n     *  @param _srcChainId the chainId of the source chain\\n     *  @param _srcAddress the contract address of the source contract at the source chain\\n     */\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"src/ulysses-omnichain/lib/DecodeBridgeInMultipleParams.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title  Decode Params Library\\n * @notice Library for decoding Ulysses cross-chain messages.\\n * @dev    Used for decoding of Ulysses cross-chain messages.\\n */\\nlibrary DecodeBridgeInMultipleParams {\\n    /*///////////////////////////////////////////////////////////////\\n                   PAYLOAD DECODING POSITIONAL CONSTANTS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    // Defines the position in bytes where the payload starts after the flag byte.\\n    // Also used to offset number of assets in the payload.\\n    uint256 internal constant PARAMS_START = 1;\\n\\n    // Defines the position in bytes where token-related information starts, after flag byte and nonce.\\n    uint256 internal constant PARAMS_TKN_START = 5;\\n\\n    // Size in bytes for standard Ethereum types / slot size (like uint256).\\n    uint256 internal constant PARAMS_ENTRY_SIZE = 32;\\n\\n    // Offset in bytes from the start of a slot to the start of an address.\\n    // Considering Ethereum addresses are 20 bytes and fit within the 32 bytes slot.\\n    uint256 internal constant ADDRESS_END_OFFSET = 12;\\n\\n    // Offset in bytes to reach the amount parameter after hToken and token addresses in the token-related info.\\n    uint256 internal constant PARAMS_AMT_OFFSET = 64;\\n\\n    // Offset in bytes to reach the deposit parameter after hToken, token, and amount in the token-related info.\\n    uint256 internal constant PARAMS_DEPOSIT_OFFSET = 96;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    PAYLOAD DECODING POSITIONAL FUNCTIONS\\n    ///////////////////////////////////////////////////////////////*/\\n\\n    function decodeBridgeMultipleInfo(bytes calldata _params)\\n        internal\\n        pure\\n        returns (\\n            uint8 numOfAssets,\\n            uint32 nonce,\\n            address[] memory hTokens,\\n            address[] memory tokens,\\n            uint256[] memory amounts,\\n            uint256[] memory deposits\\n        )\\n    {\\n        // Parse Parameters\\n        numOfAssets = uint8(bytes1(_params[0]));\\n\\n        // Parse Nonce\\n        nonce = uint32(bytes4(_params[PARAMS_START:PARAMS_TKN_START]));\\n\\n        // Initialize Arrays\\n        hTokens = new address[](numOfAssets);\\n        tokens = new address[](numOfAssets);\\n        amounts = new uint256[](numOfAssets);\\n        deposits = new uint256[](numOfAssets);\\n\\n        for (uint256 i = 0; i < numOfAssets;) {\\n            // Cache offset\\n            uint256 currentIterationOffset = PARAMS_START + i;\\n\\n            // Parse Params\\n            hTokens[i] = address(\\n                uint160(\\n                    bytes20(\\n                        bytes32(\\n                            _params[\\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + ADDRESS_END_OFFSET:\\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * currentIterationOffset)\\n                            ]\\n                        )\\n                    )\\n                )\\n            );\\n\\n            tokens[i] = address(\\n                uint160(\\n                    bytes20(\\n                        bytes32(\\n                            _params[\\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * (i + numOfAssets) + ADDRESS_END_OFFSET:\\n                                    PARAMS_TKN_START + PARAMS_ENTRY_SIZE * (currentIterationOffset + numOfAssets)\\n                            ]\\n                        )\\n                    )\\n                )\\n            );\\n\\n            amounts[i] = uint256(\\n                bytes32(\\n                    _params[\\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * i:\\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * currentIterationOffset\\n                    ]\\n                )\\n            );\\n\\n            deposits[i] = uint256(\\n                bytes32(\\n                    _params[\\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * i:\\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * numOfAssets\\n                                + PARAMS_ENTRY_SIZE * currentIterationOffset\\n                    ]\\n                )\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"src/ulysses-omnichain/BranchBridgeAgentExecutor.sol\": {\r\n        \"DeployBranchBridgeAgentExecutor\": \"0x007ec1Bcbb9c1F715D104798aF5e8F1CB2D96064\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_rootChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_localChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_rootBridgeAgentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lzEndpointAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_localRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_localPortAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyExecutedTransaction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositAlreadyRetrieved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositRedeemUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositRetryUnavailableUseCallout\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBranchPortAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLocalAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRootBridgeAgentAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LayerZeroUnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LayerZeroUnauthorizedEndpoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDepositOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownFlag\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognizedBridgeAgentExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognizedRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongDepositType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogFallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"name\":\"LogGasParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"RedeemDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"localTokenAddress\",\"type\":\"address\"}],\"name\":\"RedeemDeposit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridgeAgentExecutorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"bridgeIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"numberOfAssets\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"settlementNonce\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"hTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SettlementMultipleParams\",\"name\":\"_sParams\",\"type\":\"tuple\"}],\"name\":\"bridgeInMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_depositOwnerAndGasRefundee\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"callOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_depositOwnerAndGasRefundee\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"hToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositInput\",\"name\":\"_dParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"callOutAndBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_depositOwnerAndGasRefundee\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"hTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DepositMultipleInput\",\"name\":\"_dParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"callOutAndBridgeMultiple\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"callOutSigned\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"hToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositInput\",\"name\":\"_dParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_hasFallbackToggled\",\"type\":\"bool\"}],\"name\":\"callOutSignedAndBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"hTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DepositMultipleInput\",\"name\":\"_dParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_hasFallbackToggled\",\"type\":\"bool\"}],\"name\":\"callOutSignedAndBridgeMultiple\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositNonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"settlementNonce\",\"type\":\"uint256\"}],\"name\":\"executionState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint88\",\"name\":\"isSigned\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"}],\"name\":\"getDepositEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint88\",\"name\":\"isSigned\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Deposit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localPortAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpointAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceiveNonBlocking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_localTokenAddress\",\"type\":\"address\"}],\"name\":\"redeemDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"retrieveDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"}],\"name\":\"retryDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_depositNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams\",\"name\":\"_gParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_hasFallbackToggled\",\"type\":\"bool\"}],\"name\":\"retryDepositSigned\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_settlementNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remoteBranchExecutionGas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasParams[2]\",\"name\":\"_gParams\",\"type\":\"tuple[2]\"},{\"internalType\":\"bool\",\"name\":\"_hasFallbackToggled\",\"type\":\"bool\"}],\"name\":\"retrySettlement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootBridgeAgentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BranchBridgeAgent", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006e0000000000000000000000000000000000000000000000000000000000000065000000000000000000000000667c3e523aa1a26c4d15901c0d8f24f6c5f51da300000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd675000000000000000000000000435a9e41befdfb8b070df12afea57921f17970c50000000000000000000000006c6d3fb0289039b0fca2e7244a06cf9403464646", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}