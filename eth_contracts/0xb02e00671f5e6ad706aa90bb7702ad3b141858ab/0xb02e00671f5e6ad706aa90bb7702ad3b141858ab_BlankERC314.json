{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ERC314\r\n * @dev Implementation of the ERC314 interface.\r\n * ERC314 is a derivative of ERC20 which aims to integrate a liquidity pool on the token in order to enable native swaps, notably to reduce gas consumption.\r\n */\r\n\r\n// Events interface for ERC314\r\ninterface IEERC314 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event AddLiquidity(uint32 _timeTillUnlockLiquidity, uint256 value);\r\n    event RemoveLiquidity(uint256 value);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n}\r\n\r\ninterface IFactory {\r\n    function getOwner() external view returns (address);\r\n}\r\n\r\nstruct Opt {\r\n    uint32 timeTillUnlockLiquidity;\r\n    bool tradingEnable;\r\n    bool liquidityAdded;\r\n    bool maxWalletEnable;\r\n    bool feeDisable;\r\n    bool ownerRenounced;\r\n    bool liquidityProviderRenounced;\r\n    bool feeCollectorRenounced;\r\n    uint16 fee;\r\n}\r\n\r\nabstract contract ERC314Implementation is IEERC314 {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    Opt private _opt;\r\n\r\n    uint256 public maxWallet;\r\n\r\n    address private _liquidityProvider;\r\n    address private _feeCollector;\r\n\r\n    mapping(address => uint32) public lastTransaction;\r\n    uint256 public accruedFeeAmount;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == this.owner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLiquidityProvider() {\r\n        require(\r\n            msg.sender == this.liquidityProvider(),\r\n            \"You are not the liquidity provider\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyFeeCollector() {\r\n        require(msg.sender == this.feeCollector(), \"You are not the fee collector\");\r\n        _;\r\n    }\r\n\r\n    function initialize(uint256 percentSupplyDeployer) external {\r\n        require(_balances[address(this)] == 0);\r\n        address _owner = this.owner();\r\n        uint _totalSupply = this.totalSupply();\r\n        _balances[_owner] = _totalSupply *percentSupplyDeployer/ 100;\r\n        uint256 liquidityAmount = _totalSupply - _balances[_owner];\r\n        _balances[address(this)] = liquidityAmount;\r\n    }\r\n\r\n    function factory() public view virtual returns (address) {\r\n        assembly {\r\n            extcodecopy(address(), sub(0x20, 0x14), 0x2d, 0x14)\r\n            return(0x0, 0x20)\r\n        }\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        if (_opt.ownerRenounced) return address(0);\r\n        assembly {\r\n            extcodecopy(address(), sub(0x20, 0x14), 0x41, 0x14)\r\n            return(0x0, 0x20)\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view virtual returns (uint _totalSupply) {\r\n        assembly {\r\n            extcodecopy(address(), 0x20, 0x55, 0x4)\r\n            let lengths := mload(0x20)\r\n            let offset := add(0x55, 0x4)\r\n            let length := byte(0x0, lengths)\r\n            extcodecopy(address(), sub(0x20, length), offset, length)\r\n            _totalSupply := mload(0x0)\r\n        }\r\n        return _totalSupply - _balances[address(0)];\r\n    }\r\n\r\n    function fee() public view virtual returns (uint16) {\r\n        if (_opt.feeDisable) return 0;\r\n        if (_opt.fee != 0) return _opt.fee;\r\n        assembly {\r\n            extcodecopy(address(), 0x20, 0x55, 0x4)\r\n            let lengths := mload(0x20)\r\n            let offset := add(0x55, 0x4)\r\n            offset := add(offset, byte(0x0, lengths))\r\n            let length := byte(0x1, lengths)\r\n            extcodecopy(address(), sub(0x20, length), offset, length)\r\n            return(0x0, 0x20)\r\n        }\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        assembly {\r\n            extcodecopy(address(), 0x20, 0x55, 0x4)\r\n            let lengths := mload(0x20)\r\n            let offset := add(0x55, 0x4)\r\n            offset := add(offset, byte(0x0, lengths))\r\n            offset := add(offset, byte(0x1, lengths))\r\n            let length := byte(0x2, lengths)\r\n            extcodecopy(address(), 0x40, offset, length)\r\n            mstore(0x0, 0x20)\r\n            mstore(0x20, length)\r\n            return(0x0, 0x60)\r\n        }\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        assembly {\r\n            extcodecopy(address(), 0x20, 0x55, 0x4)\r\n            let lengths := mload(0x20)\r\n            let offset := add(0x55, 0x4)\r\n            offset := add(offset, byte(0x0, lengths))\r\n            offset := add(offset, byte(0x1, lengths))\r\n            offset := add(offset, byte(0x2, lengths))\r\n            let length := byte(0x3, lengths)\r\n            extcodecopy(address(), 0x40, offset, length)\r\n            mstore(0x0, 0x20)\r\n            mstore(0x20, length)\r\n            return(0x0, 0x60)\r\n        }\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function WETH() public pure virtual returns (address) {\r\n        return address(0x4200000000000000000000000000000000000006);\r\n    }\r\n\r\n    function token0() public pure virtual returns (address) {\r\n        return address(0x4200000000000000000000000000000000000006);\r\n    }\r\n\r\n    function token1() public view virtual returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function liquidityProvider() public view virtual returns (address) {\r\n        if (_opt.liquidityProviderRenounced) return address(0);\r\n        if (_liquidityProvider != address(0)) return _liquidityProvider;\r\n        return this.owner();\r\n    }\r\n\r\n    function feeCollector() public view virtual returns (address) {\r\n        if (_opt.feeCollectorRenounced) return address(0);\r\n        if (_feeCollector != address(0)) return _feeCollector;\r\n        return this.owner();\r\n    }\r\n\r\n    function timeTillUnlockLiquidity() public view virtual returns (uint32) {\r\n        return _opt.timeTillUnlockLiquidity;\r\n    }\r\n\r\n    function tradingEnable() public view virtual returns (bool) {\r\n        return _opt.tradingEnable;\r\n    }\r\n\r\n    function liquidityAdded() public view virtual returns (bool) {\r\n        return _opt.liquidityAdded;\r\n    }\r\n\r\n    function maxWalletEnable() public view virtual returns (bool) {\r\n        return _opt.maxWalletEnable;\r\n    }\r\n \r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public virtual returns (bool) {\r\n     \r\n        _transfer(msg.sender, to, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public virtual returns (bool) {\r\n        require(_allowances[from][msg.sender] >= value, \"ERC314: transfer amount exceeds allowance\");\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowances[from][msg.sender] - value);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address _owner, address spender, uint256 value) internal virtual {\r\n        require(_owner != address(0), \"ERC314: approve from the zero address\");\r\n        require(spender != address(0), \"ERC314: approve to the zero address\");\r\n\r\n        _allowances[_owner][spender] = value;\r\n        emit Approval(_owner, spender, value);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual {\r\n\r\n        require(\r\n            _balances[from] >= value,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n\r\n        unchecked {\r\n            _balances[from] -= value;\r\n        }\r\n\r\n        unchecked {\r\n            _balances[to] += value;\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of ETH and tokens in the contract, used for trading.\r\n     */\r\n    function getReserves() public view returns (uint256, uint256) {\r\n        return (\r\n            (address(this).balance - accruedFeeAmount),\r\n            _balances[address(this)]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables trading.\r\n     * @param _tradingEnable: true to enable trading, false to disable trading.\r\n     * onlyOwner modifier\r\n     */\r\n    function enableTrading(bool _tradingEnable) external onlyOwner {\r\n        _opt.tradingEnable = _tradingEnable;\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables the max wallet.\r\n     * @param _maxWalletEnable: true to enable max wallet, false to disable max wallet.\r\n     * onlyOwner modifier\r\n     */\r\n    function enableMaxWallet(bool _maxWalletEnable) external onlyOwner {\r\n        _opt.maxWalletEnable = _maxWalletEnable;\r\n    }\r\n\r\n    /**\r\n     * @dev Modify trading fees\r\n     * @param _fee: trading fee amount\r\n     * onlyOwner modifier\r\n     */\r\n\r\n    function setTradingFee(uint16 _fee) external onlyOwner {\r\n        require(_fee <= 500, \"max 5% fee\");\r\n        _opt.fee = _fee;\r\n        if (_fee == 0) _opt.feeDisable = true;\r\n        if (_fee != 0) _opt.feeDisable = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables trading fee\r\n     * @param _disable: true to disable fee, false to enable fees.\r\n     * onlyOwner modifier\r\n     */\r\n    function disableFee(bool _disable) external onlyOwner {\r\n        _opt.feeDisable = _disable;\r\n        _opt.fee = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the max wallet.\r\n     * @param _maxWallet_: the new max wallet.\r\n     * onlyOwner modifier\r\n     */\r\n    function setMaxWallet(uint256 _maxWallet_) external onlyOwner {\r\n        maxWallet = _maxWallet_;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @dev Sets the new fee collector\r\n     * @param _newFeeCollector the new fee collector\r\n     * onlyOwner modifier\r\n     */\r\n    function setFeeCollector(address _newFeeCollector) external onlyOwner {\r\n        _feeCollector = _newFeeCollector;\r\n        if (_newFeeCollector == address(0)) _opt.feeCollectorRenounced = true;\r\n        if (_newFeeCollector != address(0)) _opt.feeCollectorRenounced = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of the contract to zero address\r\n     * onlyOwner modifier\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        if (!_opt.feeCollectorRenounced && _feeCollector == address(0)) _feeCollector = this.owner();\r\n        if (!_opt.liquidityProviderRenounced && _liquidityProvider == address(0)) _liquidityProvider = this.owner();\r\n        _opt.ownerRenounced = true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @dev Sets the new liquidity provider\r\n     * @param _newLiquidityProvider the new liquidity provider\r\n     * onlyLiquidityProvider modifier\r\n     */\r\n    function setLiquidityProvider(\r\n        address _newLiquidityProvider\r\n    ) external onlyLiquidityProvider {\r\n        _liquidityProvider = _newLiquidityProvider;\r\n        if (_newLiquidityProvider == address(0)) _opt.liquidityProviderRenounced = true;\r\n        if (_newLiquidityProvider != address(0)) _opt.liquidityProviderRenounced = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to the contract.\r\n     * @param _timeTillUnlockLiquidity: the block timestamp to unlock the liquidity.\r\n     * value: the amount of ETH to add to the liquidity.\r\n     * onlyLiquidityProvider modifier\r\n     */\r\n    function addLiquidity(\r\n        uint32 _timeTillUnlockLiquidity\r\n    ) public payable onlyLiquidityProvider {\r\n        require(_opt.liquidityAdded == false, \"Liquidity already added\");\r\n\r\n        _opt.liquidityAdded = true;\r\n\r\n        require(msg.value > 0, \"No ETH sent\");\r\n        require(\r\n            block.timestamp < _timeTillUnlockLiquidity,\r\n            \"The time until unlock liquidity is too low\"\r\n        );\r\n\r\n        _opt.timeTillUnlockLiquidity = _timeTillUnlockLiquidity;\r\n        _opt.tradingEnable = true;\r\n\r\n        emit AddLiquidity(_timeTillUnlockLiquidity, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from the contract.\r\n     * onlyLiquidityProvider modifier\r\n     */\r\n    function removeLiquidity() public onlyLiquidityProvider {\r\n        require(block.timestamp > _opt.timeTillUnlockLiquidity, \"Liquidity locked\");\r\n\r\n        _opt.tradingEnable = false;\r\n\r\n        (uint256 reserveETH, ) = getReserves();\r\n\r\n        (bool success, ) = payable(msg.sender).call{value: reserveETH}(\"\");\r\n        if (!success) {\r\n            revert(\"Could not remove liquidity\");\r\n        }\r\n\r\n        emit RemoveLiquidity(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Extends the liquidity lock, only if the new block timestamp is higher than the current one.\r\n     * @param _timeTillUnlockLiquidity: the new block timestamp to unlock the liquidity.\r\n     * onlyLiquidityProvider modifier\r\n     */\r\n    function extendLiquidityLock(\r\n        uint32 _timeTillUnlockLiquidity\r\n    ) public onlyLiquidityProvider {\r\n        require(\r\n            _opt.timeTillUnlockLiquidity < _timeTillUnlockLiquidity,\r\n            \"You can't shorten duration\"\r\n        );\r\n\r\n        _opt.timeTillUnlockLiquidity = _timeTillUnlockLiquidity;\r\n    }\r\n\r\n    /**\r\n     * @dev Estimates the amount of tokens or ETH to receive when buying or selling.\r\n     * @param value: the amount of ETH or tokens to swap.\r\n     * @param _buyBool: true if buying, false if selling.\r\n     */\r\n    function getAmountOut(\r\n        uint256 value,\r\n        bool _buyBool\r\n    ) public view returns (uint256) {\r\n        (uint256 reserveETH, uint256 reserveToken) = getReserves();\r\n\r\n        if (_buyBool) {\r\n            uint256 valueAfterFee = (value * (10000 - _opt.fee)) / 10000;\r\n            return ((valueAfterFee * reserveToken)) / (reserveETH + valueAfterFee);\r\n        } else {\r\n            uint256 ethValue = ((value * reserveETH)) / (reserveToken + value);\r\n            ethValue = (ethValue * (10000 - _opt.fee)) / 10000;\r\n            return ethValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Buys tokens with ETH.\r\n     * internal function\r\n     */\r\n    function buy(uint256 amountOutMin) public payable {\r\n        require(_opt.tradingEnable, \"Trading not enable\");\r\n\r\n        uint256 feeAmount = (msg.value * _opt.fee) / 10000;\r\n\r\n        uint256 ETHafterFee;\r\n        unchecked {\r\n            ETHafterFee = msg.value - feeAmount;\r\n        }\r\n\r\n        unchecked {\r\n            accruedFeeAmount += feeAmount;\r\n        }\r\n        (uint256 reserveETH, uint256 reserveToken) = getReserves();\r\n\r\n        uint256 tokenAmount = (ETHafterFee * reserveToken) / reserveETH;\r\n        require(tokenAmount > 0, \"Bought amount too low\");\r\n\r\n        if (_opt.maxWalletEnable) {\r\n            require(\r\n                tokenAmount + _balances[msg.sender] <= maxWallet,\r\n                \"Max wallet exceeded\"\r\n            );\r\n        }\r\n\r\n        require(tokenAmount >= amountOutMin, \"slippage reached\");\r\n\r\n        _transfer(address(this), msg.sender, tokenAmount);\r\n\r\n        emit Swap(msg.sender, msg.value, 0, 0, tokenAmount,msg.sender);\r\n    }\r\n\r\n    // Modify the claimFees function to distribute fees accordingly\r\n    function claimFees() external {\r\n        uint256 totalAccruedAmount = accruedFeeAmount;\r\n        if (totalAccruedAmount > address(this).balance) {\r\n            totalAccruedAmount = address(this).balance;\r\n        }\r\n\r\n        uint256 factoryShare = (totalAccruedAmount * 10) / 100; // 10% to factory owner\r\n        uint256 ownerShare = totalAccruedAmount - factoryShare;\r\n\r\n        accruedFeeAmount = 0;\r\n\r\n        if(factoryShare > 0) {\r\n            (bool successFactory, ) = payable(IFactory(this.factory()).getOwner()).call{value: factoryShare}(\"\");\r\n            require(successFactory, \"Transfer of factory share failed\");\r\n        }\r\n\r\n        (bool successOwner, ) = payable(this.feeCollector()).call{value: ownerShare}(\"\");\r\n        require(successOwner, \"Transfer of owner share failed\");\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sells tokens for ETH.\r\n     * internal function\r\n     */\r\n    function sell(uint256 sellAmount, uint256 amountOutMin) public {\r\n        require(_opt.tradingEnable, \"Trading not enable\");\r\n\r\n        (uint256 reserveETH, uint256 reserveToken) = getReserves();\r\n\r\n        uint256 ethAmount = (sellAmount * reserveETH) /\r\n            (reserveToken + sellAmount);\r\n\r\n        require(reserveETH >= ethAmount, \"Insufficient ETH in reserves\");\r\n\r\n        uint256 feeAmount = (ethAmount * _opt.fee) / 10000;\r\n\r\n        unchecked {\r\n            ethAmount -= feeAmount;\r\n        }\r\n        require(ethAmount > 0, \"Sell amount too low\");\r\n        require(ethAmount >= amountOutMin, \"slippage reached\");\r\n\r\n        unchecked {\r\n            accruedFeeAmount += feeAmount;\r\n        }\r\n\r\n        _transfer(msg.sender, address(this), sellAmount);\r\n\r\n        (bool success, ) = payable(msg.sender).call{value: ethAmount}(\"\");\r\n        if (!success) {\r\n            revert(\"Could not sell\");\r\n        }\r\n\r\n        emit Swap(msg.sender, 0, sellAmount, ethAmount, 0, msg.sender);\r\n    }\r\n\r\n}\r\n\r\n// free function to determine bytes needed to store some number\r\nfunction bytesNeeded(uint x) pure returns (uint8) {\r\n    for (uint i; i < 8; i++) x |= x >> (1 << i);\r\n    unchecked { x = x \r\n        * 0xFF7E7D7C7B7A79787767574737271706D6C6A6968665646261605514941211 \r\n        >> 248; }\r\n    return uint8(bytes(\r\n        hex'00D201EDD37F02F6EED4CAA8804403FBF7EFC2DFD5CB77BDA9918161452504FC'\r\n        hex'F3F8BAF0E5C36FE8E0D6B2CCA0783CC6BEAEAA9A9282677262524636261605FD'\r\n        hex'EBF4A6F9DDBB5FF1E3E69EC4987034E9DBE196D9D7B357CDB5A18979593D1DCF'\r\n        hex'C7BF8EB7AFAB4FA39B93868B83682C7B736B635B534B473F372F271F170F06FE'\r\n        hex'D1EC7EF5C9A743FAC1DE76BC906024F2B9E46EE7B19F3BC5AD996671513515EA'\r\n        hex'A5DC5EE29D9733DA95D856B488581CCE8DB64EA2858A2B7A6A5A4A3E2E1E0ED0'\r\n        hex'7DC842C0758F23B86DB03AAC655014A45D9C329455871B8C4D842A69492D0D7C'\r\n        hex'4174226C3964135C31541A4C29480C402138123019280B2011180A10090807FF'\r\n        )[x]) / 8 + 1; }\r\n\r\ncontract BlankERC314 is ERC314Implementation {\r\n    constructor() {}\r\n}\r\n\r\ncontract EVToken is ERC314Implementation {\r\n    constructor(\r\n        address implementation,\r\n        address factory,\r\n        address owner,\r\n        uint totalSupply,\r\n        uint fee,\r\n        string memory name,\r\n        string memory symbol\r\n    ) {\r\n        require(fee <= 500, \"max 5% fee\");\r\n        require(bytes(symbol).length <= 32, \"symbol too long\");\r\n        require(bytes(name).length <= 32, \"name too long\");\r\n\r\n        uint sizeCursor;\r\n        assembly { sizeCursor := mload(0x40) }\r\n        uint byteCursor = sizeCursor;\r\n        uint byteCursorInit = byteCursor;\r\n\r\n        uint erc1167Left = 0x363d3d373d3d3d363d73;\r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, 0xa)), erc1167Left)) }\r\n        sizeCursor += 0xa;\r\n        byteCursor += 0xa;\r\n        assembly { mstore(0x40, add(mload(0x40), 0xa)) }\r\n\r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, 0x14)), implementation)) }\r\n        sizeCursor += 0x14;\r\n        byteCursor += 0x14;\r\n        assembly { mstore(0x40, add(mload(0x40), 0x14)) }\r\n\r\n        uint erc1167Right = 0x5af43d82803e903d91602b57fd5bf3;\r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, 0xf)), erc1167Right)) }\r\n        sizeCursor += 0xf;\r\n        byteCursor += 0xf;\r\n        assembly { mstore(0x40, add(mload(0x40), 0xf)) }\r\n        \r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, 0x14)), factory)) }\r\n        sizeCursor += 0x14;\r\n        byteCursor += 0x14;\r\n        assembly { mstore(0x40, add(mload(0x40), 0x14)) }\r\n        \r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, 0x14)), owner)) }\r\n        sizeCursor += 0x14;\r\n        byteCursor += 0x14;\r\n        assembly { mstore(0x40, add(mload(0x40), 0x14)) }\r\n\r\n        byteCursor += 0x4;\r\n\r\n        uint8 totalSupplyBytesNeeded = bytesNeeded(totalSupply);\r\n        assembly { mstore8(sizeCursor, totalSupplyBytesNeeded) }\r\n        sizeCursor += 0x1;\r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, totalSupplyBytesNeeded)), totalSupply)) }\r\n        byteCursor += totalSupplyBytesNeeded;\r\n        assembly { mstore(0x40, add(mload(0x40), add(0x1, totalSupplyBytesNeeded))) }\r\n\r\n        uint8 feeBytesNeeded = bytesNeeded(fee);\r\n        assembly { mstore8(sizeCursor, feeBytesNeeded) }\r\n        sizeCursor += 0x1;\r\n        assembly { mstore(byteCursor, shl(mul(0x8, sub(0x20, feeBytesNeeded)), fee)) }\r\n        byteCursor += feeBytesNeeded;\r\n        assembly { mstore(0x40, add(mload(0x40), add(0x1, feeBytesNeeded))) }\r\n\r\n        uint8 nameBytesNeeded = uint8(bytes(name).length);\r\n        assembly { mstore8(sizeCursor, nameBytesNeeded) }\r\n        sizeCursor += 0x1;\r\n        assembly { mstore(byteCursor, mload(add(0x20, name))) }\r\n        byteCursor += nameBytesNeeded;\r\n        assembly { mstore(0x40, add(mload(0x40), add(0x1, nameBytesNeeded))) }\r\n\r\n        uint8 symbolBytesNeeded = uint8(bytes(symbol).length);\r\n        assembly { mstore8(sizeCursor, symbolBytesNeeded) }\r\n        sizeCursor += 0x1;\r\n        assembly { mstore(byteCursor, mload(add(0x20, symbol))) }\r\n        byteCursor += symbolBytesNeeded;\r\n        assembly { mstore(0x40, add(mload(0x40), add(0x1, symbolBytesNeeded))) }\r\n\r\n        assembly { return(byteCursorInit, sub(byteCursor, byteCursorInit)) }\r\n    }\r\n}\r\n\r\ncontract ERC314Factory {\r\n    address public owner;\r\n    uint public deployFee;\r\n    uint16 public split;\r\n    uint public accruedFeeAmount;\r\n    address public evFeeCollector;\r\n    address public dzhvFeeCollector;\r\n\r\n    constructor(uint _deployFee, uint16 _split, address _evFeeCollector, address _dzhvFeeCollector) {\r\n        require(_split <= 10000, \"split cannot exceed 100%\");\r\n        owner = msg.sender;\r\n        deployFee = _deployFee;\r\n        split = _split;\r\n        evFeeCollector = _evFeeCollector;\r\n        dzhvFeeCollector = _dzhvFeeCollector;\r\n    }\r\n\r\n    event TokenCreated(address tokenAddress);\r\n\r\n    function createERC314(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 totalSupply,\r\n        uint256 fee,\r\n        uint256 deployerSupplyPercentage\r\n    ) public payable {\r\n        require(deployerSupplyPercentage <= 100, \"percent cannot exceed 100%\");\r\n        require(msg.value == deployFee, \"deployment fee not paid\");\r\n        accruedFeeAmount += msg.value;\r\n        EVToken newToken = new EVToken(\r\n            address(0xb02e00671f5e6aD706AA90Bb7702aD3B141858ab),\r\n            address(this),\r\n            msg.sender,\r\n            totalSupply,\r\n            fee,\r\n            name,\r\n            symbol\r\n        );\r\n        newToken.initialize(deployerSupplyPercentage);\r\n        emit TokenCreated(address(newToken));\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == this.owner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function setDeployFee(uint _newDeployFee) external onlyOwner {\r\n        deployFee = _newDeployFee;\r\n    }\r\n\r\n    function setFeesWallet(address _evWallet, address _dzhvWallet) external onlyOwner {\r\n        evFeeCollector = _evWallet;\r\n        dzhvFeeCollector = _dzhvWallet;\r\n    }\r\n\r\n    function claimFees() external {\r\n        uint256 totalAccruedAmount = accruedFeeAmount;\r\n        if (totalAccruedAmount > address(this).balance) {\r\n            totalAccruedAmount = address(this).balance;\r\n        }\r\n\r\n        uint256 evTeamShare = (totalAccruedAmount * split) / 10000;\r\n        uint256 dzhvTeamShare = totalAccruedAmount - evTeamShare;\r\n\r\n        accruedFeeAmount = 0;\r\n\r\n        (bool successEvFeeCollect, ) = payable(evFeeCollector).call{value: evTeamShare}(\"\");\r\n        require(successEvFeeCollect, \"Transfer of EV team share failed\");\r\n\r\n        (bool successDzhvFeeCollect, ) = payable(dzhvFeeCollector).call{value: dzhvTeamShare}(\"\");\r\n        require(successDzhvFeeCollect, \"Transfer of DZHV team share failed\");\r\n    }\r\n\r\n    // Add function to retrieve factory owner for fee distribution\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_timeTillUnlockLiquidity\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_timeTillUnlockLiquidity\",\"type\":\"uint32\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_maxWalletEnable\",\"type\":\"bool\"}],\"name\":\"enableMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingEnable\",\"type\":\"bool\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_timeTillUnlockLiquidity\",\"type\":\"uint32\"}],\"name\":\"extendLiquidityLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_buyBool\",\"type\":\"bool\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentSupplyDeployer\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTransaction\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newLiquidityProvider\",\"type\":\"address\"}],\"name\":\"setLiquidityProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet_\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"setTradingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeTillUnlockLiquidity\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlankERC314", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://514a49ca143862225ee9ca973e6da00ed442ffdf8777ee97a538a438f43da6d3"}