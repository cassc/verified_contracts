// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)

// liquidpepe.finance
// https://t.me/LiquidPepeFinance
// https://twitter.com/PepePoolParty
// project by:
// Charles Rookwood - https://t.me/CharlesRookwood 
// and Gregory Hirsch - https://t.me/GregoryHirsch

/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&&@@@@@@@@@&@@@@% ///////*  (@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@% (%*(& %((&((((((/(/(#@ #@&@& @##/ #@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@(& &@      #(#(&%%((@((/  @@        ##.%@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&% @@@       [email protected]#(%(((((% @@@@        @%#( *@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%    @@&     %@%%%((((     @@@@@@@   %#&(,[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@%/         .%%%((((((((             @%(%%#/ @@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@ (@(   @&%%%#((((((((((@         @&%((((%(/ @@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@/ /((((((((((((((((((((((((%%%%%%%((((((((((/.%@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@%  /(((((((@((((((((((((((((((((((((((((((((((#(/ ,@@@@@@@@@@@@@@@@@@
@@@@@@@@@@* (@((((#%&@@@&%#########%&@@@&%%%#(((((((&((((((((/ %@@@@@@@@@@@@@@@@
@@@@@@@@@@%.(&(@###################################@@&#((((((/* @@@@@@@@@@@@@@@@
@@@@@@@@@@@# /((((@////////////////////////////######@((((((((/ @@@@@@@@@@@@@@@@
@@@@@@@@@@@@@,.(((((((&%////////////////////////@#(((((&((%%%/ &@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@./(%&(((((((((((&@@#///(&@@&(((((((((((&%%%%%(/ &@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@&.(((((((#@%(((((((((((((((((#%@%%%%%%%%%%((,/@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@%,   %*(((((((((((((%%%%%%%%%%%%%%%%%%%%%%%((,#@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@&  /((((%%%%%((((((((((((%%%%%%%%%%%%%%%%%%%%#(((&  ,////((///  *@@@@@@@
@@@@@@% /((((((((%%%%&(((((%%%%%%%%%%%%%%%%%%%%%%%%%(((((@((((((((((((((// ,@@@@
@@@@@  /(((((&((((#%@@(((((%%%%%%%%%%%%%%%%%%%%%%%%((((((%(((((((@((((((((/[email protected]@@
@@@@  /(((#(#(((((%%%%@((((@((%%%%%%%%%%%%%%%%%%%%((((((((((((((((((((((((((/ %@
@@@ *(((*((((((((((((((((((%(((((((%%%%%%%%%@%%%%((((((((((((((((((&(((((((((/ @
@* /(((&((((%((((((((((((((((@((((((#%%%%%%@%%((((((((((((((((((((((((((&(((((/
*/
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 *
 * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._
 */
contract liquidPepePoolParty is
    Context,
    AccessControlEnumerable,
    ERC721Enumerable,
    ERC721Burnable,
    ERC721Pausable
{
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;

    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    Counters.Counter private _tokenIdTracker;

    string private _baseTokenURI;

   
    address public lst;         // lido steth
    address public devs;        // dev fee receiver
    uint256 public price;       // starting price
    uint256 public backing;     // amount backing nft's exit value
    uint256 public tokensInCirculation; // amount of tokens in circulation


    // for each nft there is mintingprice
    mapping(uint256 => uint256) public nftPrice;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address _lst, 
        uint256 _price
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
        lst = _lst;
        price = _price;
        devs = msg.sender;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseTokenURI) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _baseTokenURI = baseTokenURI;
    }

    function setDevs(address _devs) external onlyRole(DEFAULT_ADMIN_ROLE) {
        devs = _devs;
    }
    function _syncRebases() internal {
        // check for rebases
        uint256 _balance = IERC20(lst).balanceOf(address(this));
        if(_balance > backing){
            // add to pot
            uint256 surplus = _balance - backing;
            uint256 _toHolders = surplus*9112/10000;
            uint256 _toDevs = surplus*888/10000;
            IERC20(lst).transfer(devs, _toDevs);
            backing += _toHolders;            
        }
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     */
    function mint(address to) payable public virtual {
        require(_tokenIdTracker.current() <= 888,"max minted");
        // sync rebases
        _syncRebases();
        // price modifier
        uint256 _priceMultiplier = (_tokenIdTracker.current() - (_tokenIdTracker.current() % 10))/10;
        // calculate price        
        uint256 _nftMintingPrice = price + price*_priceMultiplier/10;
        // check msg value >= price 
        require(msg.value >= _nftMintingPrice,"msg value to low");
        // set minting price
        nftPrice[_tokenIdTracker.current()] = _nftMintingPrice;
        // mint        
        _mint(to, _tokenIdTracker.current());
        // increment tracker
        _tokenIdTracker.increment();
        // one more in circulation
        tokensInCirculation++;
        
    }

    function getOut(uint256 _nftID) public {
        _syncRebases();
        // transfer in
        transferFrom(msg.sender,address(this),_nftID);
        // calculate size
        uint256 _size = backing/tokensInCirculation;
        // remove from circulation counter
        tokensInCirculation--;
        // decrease backing
        backing -= _size;
        // send funds
        IERC20(lst).transfer(msg.sender, _size);
    }
    
    function convert(uint256 amount) public {
        require(amount > 10000,"amount to small");
        uint256 fraction = amount/10000;
        _syncRebases();
        // send in steth
        IERC20(lst).safeTransferFrom(msg.sender,address(this),amount);
        // get eth
        payable(msg.sender).transfer(amount);
        // add to backing
        backing += fraction*9112;
        // dev
        uint256 _toDevs = fraction*888;
        // send to devs
        IERC20(lst).transfer(devs, _toDevs);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to unpause");
        _unpause();
    }

    // Fallback function 
    fallback() external payable {
    }

    // Receive is a variant of fallback that is triggered when msg.data is empty
    receive() external payable {
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable)  {
        
        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
        
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerable, ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
    function currentMintingPrice()
        public
        view
        returns (uint256 _price)
    {
        // price modifier
        uint256 _priceMultiplier = (_tokenIdTracker.current() - (_tokenIdTracker.current() % 10))/10;
        // calculate price        
        uint256 _nftMintingPrice = price + price*_priceMultiplier/10;
        return _nftMintingPrice;
    }
        
}