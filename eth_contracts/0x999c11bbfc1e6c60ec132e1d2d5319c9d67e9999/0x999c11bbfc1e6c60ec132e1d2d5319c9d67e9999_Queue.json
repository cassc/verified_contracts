{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(\\n        address owner\\n    ) public view virtual override returns (uint256) {\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: address zero is not a valid owner\\\"\\n        );\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(\\n        uint256 tokenId\\n    ) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length > 0\\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n                : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\n            \\\"ERC721: caller is not token owner or approved\\\"\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\n            \\\"ERC721: caller is not token owner or approved\\\"\\n        );\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner ||\\n            isApprovedForAll(owner, spender) ||\\n            getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(\\n            ERC721.ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer from incorrect owner\\\"\\n        );\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(\\n            ERC721.ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer from incorrect owner\\\"\\n        );\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    tokenId,\\n                    data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./ENSResolver.sol\\\";\\n\\ncontract Assets is Ownable {\\n    ENSResolver _ensResolver;\\n    using Strings for uint256;\\n    using Strings for uint32;\\n\\n    bytes public constant header =\\n        \\\"' width='100%' height='100%'><style>.sa {} .sb { animation: sx 130ms ease-out alternate infinite; } .sc { animation: sx 200ms ease-in alternate infinite; } .sd { animation: sx 271ms ease-out alternate infinite; } .se { animation: sx 450ms ease-in alternate infinite; } .sf { animation: sx 682ms ease-out alternate infinite; } .sg { animation: sx 849ms ease-in alternate infinite; } .sh { animation: sx 1000ms ease-out alternate infinite; } .si { animation: sx 1470ms ease-in alternate infinite; } .sj { animation: sy 50ms ease-in alternate infinite; } .sk { animation: sy 152ms ease-in alternate infinite; } .sl { animation: sy 271ms ease-in alternate infinite; } .sm { animation: sy 450ms ease-in alternate infinite; } .sn { animation: sy 682ms ease-in alternate infinite; } .so { animation: sy 849ms ease-in alternate infinite; } .sp { animation: sy 1000ms ease-out alternate infinite; } .s {transform-origin: center;transform-box: fill-box;} @keyframes sx { from { transform: translateX(-1px); } to { transform: translateX(1px); } } @keyframes sy { from { transform: translateY(-1px); } to { transform: translateY(1px); } }.a0 { animation: pulse 5.2s infinite alternate-reverse; } .a1 { animation: pulse 0.8s infinite reverse; } .a2 { animation: pulse 1.7s infinite alternate-reverse; } .a3 { animation: pulse 2.5s infinite alternate-reverse; } .a4 { animation: pulse 1.3s infinite alternate-reverse; } .a5 { animation: pulse 2s infinite alternate-reverse; } .a6 { animation: pulse 4.1s infinite alternate-reverse; } .a7 { animation: pulse 3.7s infinite alternate-reverse; } @keyframes pulse { 0% { r: 20; } 20% { r: 10; } 40% { r: 30; } 60% { r: 10; } 80% { r: 30; } 100% { r: 20; } } .g0 { animation: fade 100s infinite alternate-reverse; } .g1 { animation: fade 0.5s infinite alternate-reverse; } .g2 { animation: fade 1s infinite alternate-reverse; } .g3 { animation: fade 2s infinite alternate-reverse; } .g4 { animation: fade 5s infinite alternate-reverse; } .g5 { animation: fade 10s infinite alternate-reverse; } .g6 { animation: fade 20s infinite alternate-reverse; } .g7 { animation: fade 23s infinite alternate-reverse; } @keyframes fade { 0% { opacity: 0.8; } 20% { opacity: 0.4; } 40% { opacity: 0.6; } 60% { opacity: 0.1; } 80% { opacity: 0.6; } 100% { opacity: 0.8; } } #r { filter: url(#blur); } @media (max-width: 384px) { #r { filter: none; } @keyframes fade {} @keyframes pulse {} }</style><defs><filter id='blur' y='-40%' x='-40%' width='180%' height='180%'> <feGaussianBlur stdDeviation='0. '/></filter><filter id='pb'> <feGaussianBlur stdDeviation='40' /> </filter><filter id='a' y='-100%' x='-100%' width='400%' height='400%'> <feGaussianBlur stdDeviation='5' /> </filter> <filter id='g' y='-100%' x='-100%' width='400%' height='400%'> <feGaussianBlur stdDeviation='10' /> </filter><circle id='a0' r='20' fill='transparent' filter='url(#a)' class='a0' stroke-width='10px'/><circle id='a1' r='20' fill='transparent' filter='url(#a)' class='a1' stroke-width='10px'/> <circle id='a2' r='20' fill='transparent' filter='url(#a)' class='a2' stroke-width='10px'/> <circle id='a3' r='20' fill='transparent' filter='url(#a)' class='a3' stroke-width='10px'/> <circle id='a4' r='20' fill='transparent' filter='url(#a)' class='a4' stroke-width='10px'/> <circle id='a5' r='20' fill='transparent' filter='url(#a)' class='a5' stroke-width='10px'/> <circle id='a6' r='20' fill='transparent' filter='url(#a)' class='a6' stroke-width='10px'/> <circle id='a7' r='20' fill='transparent' filter='url(#a)' class='a7' stroke-width='10px'/><circle r='40' id='g0' filter='url(#g)' class='g0'/><circle r='40' id='g1' filter='url(#g)' class='g1'/> <circle r='40' id='g2' filter='url(#g)' class='g2'/> <circle r='40' id='g3' filter='url(#g)' class='g3'/> <circle r='40' id='g4' filter='url(#g)' class='g4'/> <circle r='40' id='g5' filter='url(#g)' class='g5'/> <circle r='40' id='g6' filter='url(#g)' class='g6'/> <circle r='40' id='g7' filter='url(#g)' class='g7'/></defs><rect x='-30000' y='-30000' width='100000' height='100000' fill='black' />\\\";\\n\\n    bytes public constant path1 =\\n        \\\"<path d='M 20000 20000 l -440 0 l 0 -880 l 1320 0 l 0 1760 l -2200 0 l 0 -2640 l 3080 0 l 0 3520 l -3960 0 l 0 -4400 l 4840 0 l 0 5280 l -5720 0 l 0 -6160 l 6600 0 l 0 7040 l -7480 0 l 0 -7920 l 8360 0 l 0 8800 l -9240 0 l 0 -9680 l 10120 0 l 0 10560 l -11000 0 l 0 -11440 l 11880 0 l 0 12320 l -12760 0 l 0 -13200 l 13640 0 l 0 14080 l -14520 0 l 0 -14960 l 15400 0 l 0 15840 l -16280 0 l 0 -16720 l 17160 0 l 0 17600 l -18040 0 l 0 -18480 l 18920 0 l 0 19360 l -19800 0 l 0 -20240 l 20680 0 l 0 21120 l -21560 0 l 0 -22000 l 22440 0 l 0 22880 l -23320 0 l 0 -23760 l 24200 0 l 0 24640' stroke='hsl(\\\";\\n    bytes public constant path2 = \\\",\\\";\\n    bytes public constant path3 = \\\"%,\\\";\\n    bytes public constant path4 = \\\"%)' transform='rotate(\\\";\\n    bytes public constant path5 =\\n        \\\", 20000, 20000)' filter='url(#pb)' fill='transparent' stroke-width='150px'/>\\\";\\n\\n    bytes constant colors =\\n        \\\"5A7043220F246B715085CD47E1DFDBE0C1EBCDAA89F14037242424090B0AFEFBFB454054949593BED1B2F7F5E9CCD0C8953FCAD3F971F3F3E7ACC8F11A1E1E7DF830B823A47972792A2922591236281C3B24150F262E23658859212231B6A5775B2F2F1111555038DCF8D5D3828ABAADEBC4DC555018130C3AB6445B0BB735551B52492E792F44978F30BFCFBF5D5627A8F0EC322F061F1E19752791350F0D0E100A0B100489484E887235152D22FFFAFC97A432B5A15E4E3C36BD7A7A98B587D1F96CBDC3D004273973493AA298161D2306C2EEFE171212938666F6FEF6CC2A1462ED1DECCDC1C0C596C5C2BF771390283248B386847A746615141AFEFCFAC18D8B928F3A7376198E1E1A1B1109040506C0AF7C5F5397092F49615562314442F9F2FC8A651492FC9C8651464637342C2B17434B51263324726C7ACDBCBC41156F7E7C72E3DCE581724688116086A2E47D2E2B2D1F0133559EDF9D727EA53B6F0652EADDC8E1F6234BE78CF6EAF21D2522F2F8A0251D0418AF899CAB6DD9265C36246BFDFFFAFDE2D37C7850B040694F52426F5CF0656567BEC32C08361ADBDFCD6A583EE1ECDAF8CECFE2E2C6ACDE17F4F4BE202428C3D5C44494191A1414FCE4E8E45349D0CC955259121C2C3B1A1820211D2A596921DEDCF9736045B1803E20221B4E7365205A79D3CAFCC2568587737ABD924CE5E6E54A4B4F93F695BE63BF3135541A181B1A14151E3617321D1A68636E8B416735565AF5FAFFA197BE220906FEE7BE1E193EF3B4CF32302A64606C23240F2512045D745E454A47B4703C21192AF1FDF4156F32191415269230994D70EB759EF2AC922A40266331507D5E1C30181C441109FAFDE3A0A48ECD5B18380600533249C09B967D821CCCDDEB90726AB8D5A478594F251E042E2B297ACA681A1A1EFAE8E5919A796963693E302E798047141504122A0EDFFBE9191A198271C6272636FBB6DDC9CACA388005EBF3CD556742E9D8E1D14C3D8450910E0D11746C20AABB96C24BD86315135346493C4572CAC72196874F84525DE179092C2A51FBFBF8D0C5B43AE494695D682A132438410B158E44090807080623403E3A4354302A1E2396958D2B330AE9CF5850B2C3AA8964747274B8B8A3DE21962A7321ADC6905058460E070C336980338D02827B30C0CC8553466DD9E6CBFD26FD13073113131B2F1E0F201E1EE0DBB26BC78B171216F3F7F5C7CFBA190F1FE8CC593B3411E2EEEBC0C5C846F681100F0A1B082133576657385C87AAB5C2BFAD2E35276A535B3A383EA8A280201D1D070B04130D06EF348E400F0D8D2A111B090CB98ADBE9DAF6AE9F7A550675B3C22E455ABA3E20649AA29C4F567DC8D0F4D5D6D72815281611040E161584828C26252835462A20272D8F66660EAFB4EFE6B9C983C51B281AE3F6FC530E4479819A751E7BFAFDE2524C509DA9759FA2A3FA947AA0A17DC8B9B67A8A9F09110B2B1203DAF6C18E908FEDE9E8E3DDE3423F294D3C19F2B39CF2F7C5E6F2ABD8FDE703453DEEF4FB0DA5316F4294B49941EF9A80DEE292CBFDC9071C22E5E7E4382541F2F3C357387058405E1B2720F3F2F23214108A4F0F94FA611698256B8CB3A09779B38AC7D619EB2577B10D0708BFD5A448671E524642739136A47151BA8C9541433D231E1BEBFCE8232523959D80C6FEB828373EDF30730A06086A4E259F3C552620CFF1D9F784DF16D5EC658BFEAD2B0D1CB0A58D2B77974A07234B883F7D695EF684A2291E23C75B5287754F98A9A41A1F196143192625184C4C4C3B3202C8E1BCE8D3E6EBFDB4C0C242142422F7F7FC135346CBBAF713120C5047447C3E2DF4E4DCD2DECADA8F3E707B322729302E1B142E0A12ABF2EA7B515B901B04B781521A1A1A550714F6EFF27B78BF89989FDE8F4F5CA60CF2C0E6A0AAB1FE342A2C8776F7C3C0271C0716220CEFE9E6A8EE7C2D34331F180FB36B6EA6C3923C552B919D6C77CF4FF0CBC63F523D0D3C40D5D4D9777A75572759725937322C24125E39DFC8EAEDDEE63A2C170DE7A2523249CBA952B096873F2A27A6DE8C635C70AB7259F7FEEC15140AD9D8D909C1C8FCFDFC4234248D5BA443382D040103987D3EBCE5EB030704CEF8DFD8F4069BA3807F92FA505E52862004131006231A1DF6FCCF805ABA060604FCE9DFC17957B85BC8021426A86E6127162197AFF76364AB97D8ACF3EFD3654362BB027D303126231E24C06B5D67EFE18D49538050232B1725CA2ADF91B36B6248473749080386840F13060A414DD0D4B5540E081F1E1E5C2838454903CD9E9D268C2BD9ECCB242225D87B5F7D2A176D6F3E6A4734EBD4B7FBF4BC2A36411C0F0DEDE9A1686B47CECB69253909512A3FFDFDFC6A8A7921ABA27D491C2D2A2BCC7161D1EBDE0CCBE4F736EA1E1E2F03016F383932F8D3F12D6907C1A9B1EF7BC1BB3A4DECFEEC5D6F2F48B04521355E56E52EB5DF537A5761FAD1F8FE7D721B271BD5A090EDE3D9543C21F8F7AFE0D6B3131201E7E8E3F9DDDC7D29C7F42ABB36430A3A5659E6B9945797A8E6EDB0050901101519A9523DA6987D5D1A14CDBCB1FFFAFE3B453CB85656CBCBA46F4D662759506B1F41706E6B2E3747AC402AEBE6E0D583DD0B3003CDC8C60A0900FE8F9C87684FBD862E51115579676C55511B0A5C2C6A1B2E3B4E4F130835969795B0C9C9DE79E23838382D56954E543BFCC05A1C261DAAA7AA98B9C32631501BD006233C6C604270B57898273E4FF3BB95744E5D13A034E2C28D937B39AE9EAA042525CCD9DB4437084C4D4DC878ED0F0E014818492D152BDDD5DAD9E3DF666065FBF4F70B3D2493C2D7B88FBC4A6E308783732223254B4716D5CCD764970C16040451435BEC5BB949FD499560045B20390604044C2F75173F1A232F2DEEA5A63B392BFAF1E5D7DCE0493C31040606584F720E2520D487404C500CF6F8F15F5D3529271EA69B7D233270E3DED8938E7BD699C5D1D2D1B0B0ABE5E2E12A1409684E27463B4ED5DCBC2435381B1819EFF4DC5EBBEDB1B578F5FD531802972C2024F2B21C424B07A59978B4B3B16D6B701A1919A88D67050B1A1C111CA8ABA65B73029AE1376E8B8C37390A0C080815787F5A32764422360C1336B5EF763D1F101B0E1575D1BAA7C3748A1E4F46331B393B3C65467C1C1A03147FEBC4A0921A1B0D1D9202AC615D374D28E4DFD2414862D6C20A3E1E22282B2FFEB19A02C1E314333E1F1F1FFE534DEFE1ECDF68431D1B1D02550E525516E1AC41193638FC4FFCB9B192E7D5D91C1C27BF8C6E4C6EDC23A7D7A6A8679A2D2D24C4F958AF50C1F4F6133149FCF4F3D1DDD0102315D5878506322A071A40E3F2EA4D44F81227910A0506492D42775B325EA4C50E16104A5C5EC0C4AB4936095729450D120F31312F5EEDBE334F0CC5C15974390241348323200198FBE7520A3F343441D8D4B1CBC3CA524A82D0EDF0FDFBF7617568C68D71704D48625309FEE1E238511A7A6C1A745707B76501D8DDD5834425F7F4F3FA6BBE1A1B1E54594535536EDBC2DB0506053D492D2C30173B3F31BCB8B85B575C9477F3FCF9F8383F51F0BDB7888F381D1A3CC1A9A46C56996B6D0D7F381584BF63307E47B6F254425D32403460474C3D5A7C90606C763F3D3BD5A77CD0F547DDA2A76F979B1B132FF6F6EED2CED9DBFAF6103225C8C1C710140A504B071F0505F5F5F52B07364B362AF8F2ED752EFADDB6981D1911C2C0B79DD382B37B7A48453D2E231ED00E0BA7767EF0F2F5E8FCEA79F1997DD2329F9D092F6E79A8866B9C89731209342E37251E1E20BEBFBBD7E0E08A5C74321125541E0783839114102309294EEAC7BD223404272C21695E73AFB5CB1C0E0D7A6C5268743401AD204D55205E44D5221E2AEF01C7141010DADBD23C59DD586C3DBB869A88FB8C998BA73E580ED07C6DB2BF82F4F6DFC0C794C9B49C5CAD5E3A0F08C3BAA2BBAAB6E2AF9814663CCE704094927F19482F9401016D601CABA39CCECCB612080B4898A3392C28A2A49DE561C26986B0671D64F9E6104EBFE4535ADFB79B801B9AE4241F1E3BDE77305C146CBA0DFAFDF7DBD361A28B90C4A3400401130E1415211F1C38434DA6A0C0464544282C07292433E1EAD70F0C0ABED5C92D2D063F100D090606B299A556573DC8CB1A1412107045425D781269F14BC8C0D32622089CF362A380A2B7BCAE18342B7E92AE9F3B09B25C53F4F9C82020278C65217B9664E4D0E75E6378B90E55B4F49F4B8676241414756B619E8D4C50982A1F3D2132232083D8A36481960C1311B270A34C503A4D9979D6D9D3AB98B30E110D1A2322DFFDDD211F2851102FFCF6F24A50448BAA5A221F231B37373366378A7A4CC4A6B89F9989193E392F28332B4C24248A3344E4612A1003F4F6E42423234B4A4FAF4608702A92CF07DA595572C4BFCA2C2C2567287134048634389D95665B3911400F241B8B5B6D50832002C508312411A3051DC6535E070D0D2F2E2DEBD9522C21261A2F0AE4E6F7F5EED64B240125556520E9DC15150FB4AC9C1B2216E7E6E44413131D0C104D5E31580604EAC3BDC0B468573854E2AC182F0404D3DBCDFCF7FBC6422423231FF2D57DD5816CF8FBE0281939B078BF3B2E26A98E9A5F2D0C0309113F6B065C7138B3C2930D6A6ECBE5E78552A3877F5A4B4949DE2B171512171B092AFFFAFA472E35B1D55D2D1A22ED317FC2DD92B877F9DDDDDA072C166466E86118689B68084B2F25A77295583C3E3E1A42F8EFED1910163E299E14130BCBD4C47D7454120F15040401F4FAF97A9419B1A0A4FB74941F2123E6F68EC8E1ADBFABB257480A5B4958757575DC18C5839169805267232716D3DEA05A6D5CC3C1C1FEFEF61E1F1F5855B4C1A7CD568A89665B4DF8A130C0EA1A7DAEF73AD99CC3B713D5B59A060901BDA72E2C2621E557AA13160E3976C0998F8AAAAD8A442E2C0A0D08B5E6141E201369744E6219E1B3ABCFB5A469302108143839163E460F2A0EE6D9D5B590690CC6A085AC110A0805F4BF1FEBED9CA6E7FC826A4F0708094D454284C5300308020B3D478FE699F2647ED9DAD809200E4912734D14145A6BAF1534371A434742461B8FD0FEF7F6F27C8F705F6EB9E9FDBAF2F0F5D3DEDE1E8F8F384229912F2717271EDED3DB4636254319CC4C76AE25242817A5DE382C1A53680DBF63AFFDF8F21E6EA43DDA2FF2F4E7C3FED0505C47FFCCE2ACADA9E2BC9DF8FCFB958391BBDFF6D283AD553A5364574A7B4804264A470B0B09B8FD96FECD716CA94C8444ABFBF1DA0D0709F6FFF0587479CECAD8E2C3C0DBDAD68888869FC2898D8168E6DDDBCEB2976E6F25D1E8738D8777593960292829A5E755244922D1AB2EF5FAF7FBFCFEC0C1BD1F201DF6B1C98E2981495110CBD0BE282F29B9AC8315664C2719169EA38A1E120BF96E0B0A0800D2914BFCF9F7494059A199974729572B3A1D4D4F51C1391AE1DED0133BAAB7B8B2783917253725092439343746BDC0AA5284487407329D86C1577A67362E2BCDCDCBBEB69D1A0524B44B5462403C2A2928A38F620B0C0F3C4338272716401F036E5F72938885D8C7AB475A3F801955CFF2DC35272DA49F1EFBF9F9182F59FDF6F25C4A42FA9542F2DAB1191A044F1E1CE43B253540300D233068A3DF1B090FFAEEE141B9E14B1802826559FBE3A21B22212644135E8D753D340A1C12157754188BA159050500C1A95376566A63BB54094549242729471C0A91A966151A0AC6C2CB63671E08033F846EAF5272361B412EE5E4E14529024D4247ECEAE45E017ACD748F59632CF0EAF634322DC2BEBCC1A3C767745D363E44A1F7D6F6FDFC64E8D83C10132B375A3706140E140B6F5F2F959772F6E4C6D4CC3AF5D2BCCFD2EDE0E35FFAFFFF9F999A676665B386DAFAFAF94F421C342514D0D62E7E1616363536F56A192523222E75B813181B654815E9E32F680BF4B7C0CD4444363D1B0BB0A682FDFEE2969D62D1CBC7EFFA14202331161C1D614860F1DFE6282F19B9EF5D080807CEBF36AEEAD6986792342263BB40079F976FCEF7F5231B1E351308050506311736E7CBCC6EA1A672716E575352928FBD68086443B2CB87ACB0901B092B290D458C53879F32CAEAB81410140F0A0C121617C4E6ED382D3E561A1E0D0206FBF8FBC5E5A4451D1C4458EE7C4B4F0F0A10172117FC74592E2E2D5A3F4843F9C6CAA7963B44A09D93852D433CE49672C1E78417252C405D281D441EBFB1B067B1D59FBD93A59E93EDD3C5130D0B27271B8455AFFEED6C2D26240C1815202C17DCD1E5656B5B4B271B232F197BC05487534AE6DCF9A81CCE5A1B02FCF5DF5948AD371F34084C63E8EFD1345555F4C9C8B0B3A80D100A534145F15D3BAD9776434137A4754CC3B1C4F6816F9A2EA820F0191406011E222981785A26142E0803023F16A7E0D6AE5557144A520588D917556841EBE2C68B8527A7BEAF0B040A4E5638C9C2CB7A5C6E4F40499F6932CDE58A9898B31A0F054F260DFBF2DACCD1C7F9E39FDB6E66DF90B9A6CE7E66330A7B6C3DF5F5EF18191B8E8980F6B493272124CFFA9E531E76948B51958532090A05ECFE77B759D4B4D56D3F1C3B3C4368F4C5BD653E5BBD6593A55CB244132B4F4A081F1924D093E6537F7CEE1B7A95958E392E2855BB0C3E1909FDFDFB2A5549B9875523182A6B865F505D7726A68A04DC1E8C36879CBC62C7C0B8DFCDC8928649604639F6F6F32FA745181820262B2974FBE9F9EDE6E9EDDEF4FCCFB4816A3E2E1E191E298860A9120D0D46AF2CD47F77C153DF186781341E31E0F6EF8238304F4252E8642C56535219262AF6F4C1F2F532226B6D5B6A3E0B060F8F4E3DC6EFB8DADBDC3D3B344D16501D2125E2F8FE4363ADD8BF8DFEFBFE23BFCD1E1E25BDCB95090609CD64375B4033E3F6D5020F18FAF47F8477480B0406156A34796CA30B09107939721412171C4F472A28295F5C61616524F425E2663CAFFEFEFA513D2A260D23211B0DB2F362F45925604A3E184517072627DBD0EC852CA59C938B2815101A2C0295049F4C463D641F89D5AC394418192D2D34F3F8EDFBDF84560B1BFEFDFA79F74B50F26B3D49189D8B62232D01DDDCE536161C102D4CB4C7FDA5A79ABD884C303136585F25213E45272120BFBF6EA5273835323162603C1E11012E3E37F9F8F52F1824D889691D867330243D476D715100082D3937D9C7F4463851782411B3B99DACB0A0010909ECF0F334AD683C2816E8A09B090401F1FDDD3F7D51EEC7A539494C155B475F3A49C0BDC7AC8B62C0A47CC0E2D8444743E8D9A15B4E74B696A57F437F583A59AEAE0997DFF7F1E6E0405443F8F5F11B1319D9C9BF470B1A7A7A7AB86F47CF865EFEF5F0725B7B1B1028DBD8DF20515B93918A599613519480DBDF9FAAB6D42F60790A130789F01460206054595855473F1B19134D47763634378D8220ABF81B1E1122C2AC89FEEBFAA88DCE453D3A4B342F87C328C5677AAC3943FEECEFCFDF53B9ACA7694983767637BC27FC8E5D3E05040684434A3F9D695C6629972052A89BB573552BAB4F8BB05B27289613793899915D46E3B878252E195C2376D4F8C4BEAA7E2F1F38152629301F1C4FE60F1C2C23C7C6C73025174F8722F25602DEB71B372406AE5B94CAE9BAE8D71728053DAA9E502B247ABBB8AF544740D3E7C64545112328342635403E552A9C961CA75401B082A42C2721BAFC4F2E1815090B0B440D27D9C9D4DDDBDABF5D36EEE5A0D9F1888C73362A150E2E1F7A12424F4B625423570F2318342A1F18130E017576471F0C0A5158617DBF92B7CFD7DDEFB3AFCFC0A9F4C68B89892A22262F3121AD7BEA1BE4396F29709E7C0A185431F7F7F891756ED4E170481A19354755B090D51FEABE214A87B99E4BB41813D2F109F7EFDE31622D20312E9185EA19310D615842534036687E5D382906BDB7EBB7B157505747D8B1B7D98C9873CF63C7B3E0551B16B7BE9D541C2C1E32A413B995CBD7C6FBCFCBA43265514F4D000000F7F75EE5F5ED49458218060B9C7791442C17F5E4DB232E34982A71E5E5B8EC905B2AEFD596976DB8B9A2034868090C0BD8EFCDF1D5CB0804028C8E3E3A1D4E97CD7A0203038F9B828F6F0FB69AD064502B4D783F344026450D2C001A51CBD2D8466020F3EE49B6CBA9EEF2E3424B20D1D8CA4BDD663329424A4F4D77706985D945332A4609251264AC4D423F2E1F213D526F3EEAAF7BEB37C1A3A4FAE3E3E3904E478286567816F81B181A0F03006A5A96363635D4878A9F581E97996667570F241E1EC57D9E9F759C23247153232ED7E0C82A2A284BFBD8130D167D909B0A0C080C130F6F5A1F59E3D3D24B6FFCE8D412141609060754271283661B1F120EB3F29167645B2322010909065B1183F3EAD8E2657805E1C431634E49505A0F0D125958546866F0BBB29BF566CA26263BAC63BBC8464D403F88FAFDF6E0DFC71C271C949BB36388920B0A09779BB6ADCA07D99981FDFCF1D9BBFBBE98D278D9B2487F5EA296B0636444102D22A2E7C2ED8CF2E8DAB0E1E3D36A2A2A873231201622C1BBAEAA9FDFA6A3912D3A1D3637344A171E3E2F42BED5D5F7EDF5383633085B0157712D7DB351FAFAFAF8F7A0A964C45B6E861506419E76886A5629483149BD3A284F4940CEA1D332650BEAF6F1A40A5C2E282FFFFFFF000000\\\";\\n\\n    constructor(address ensResolver) {\\n        _ensResolver = ENSResolver(ensResolver);\\n    }\\n\\n    function setENSResolver(address ensResolverAddress) external onlyOwner {\\n        _ensResolver = ENSResolver(ensResolverAddress);\\n    }\\n\\n    function getColors() external pure returns (bytes memory) {\\n        return colors;\\n    }\\n\\n    function getHeader() external pure returns (bytes memory) {\\n        return header;\\n    }\\n\\n    function getPaths()\\n        external\\n        pure\\n        returns (\\n            bytes memory,\\n            bytes memory,\\n            bytes memory,\\n            bytes memory,\\n            bytes memory\\n        )\\n    {\\n        return (path1, path2, path3, path4, path5);\\n    }\\n\\n    function metadataDetails(\\n        uint256 tokenIndex\\n    ) external pure returns (bytes memory) {\\n        bytes memory details = abi.encodePacked(\\n            '{\\\"name\\\":\\\"Q #',\\n            tokenIndex.toString(),\\n            '\\\", \\\"description\\\":\\\"_Rivers know this: there is no hurry. We shall get there some day._ A.A. Milne\\\",\\\"image\\\":\\\"data:image/svg+xml,'\\n        );\\n\\n        return details;\\n    }\\n\\n    function convertWallet(\\n        address wallet\\n    ) public view returns (string memory ensOrHex, bool didFallback) {\\n        (ensOrHex, didFallback) = _ensResolver.resolveWithFallback(wallet);\\n    }\\n\\n    function metadataAttributes(\\n        uint256 peopleCount,\\n        uint256 zoomLevel,\\n        uint256 relativePosition,\\n        uint256 minQueueIndex,\\n        uint256 queueLength,\\n        uint256 updates,\\n        address wallet\\n    ) external view returns (bytes memory) {\\n        bytes memory subjectName;\\n        (string memory subject, ) = convertWallet(wallet);\\n        subjectName = bytes(subject);\\n\\n        bytes memory attributes = abi.encodePacked(\\n            '\\\",\\\"attributes\\\":',\\n            '[{\\\"trait_type\\\":\\\"Height\\\",\\\"value\\\":\\\"',\\n            zoomLevel.toString(),\\n            '\\\"},{\\\"display_type\\\": \\\"number\\\", \\\"trait_type\\\":\\\"Position, Absolute\\\",\\\"value\\\":',\\n            (relativePosition + minQueueIndex).toString(),\\n            '},{\\\"display_type\\\": \\\"number\\\", \\\"trait_type\\\":\\\"Position, Relative\\\",\\\"value\\\":',\\n            (relativePosition).toString(),\\n            '},{\\\"trait_type\\\":\\\"Progress\\\",\\\"value\\\":\\\"',\\n            minQueueIndex.toString()\\n        );\\n        attributes = abi.encodePacked(\\n            attributes,\\n            '\\\"},{\\\"trait_type\\\":\\\"Framed Blocks\\\",\\\"value\\\":\\\"',\\n            peopleCount.toString(),\\n            '\\\"},{\\\"trait_type\\\":\\\"Updates\\\",\\\"value\\\":\\\"',\\n            updates == 0 ? \\\"Original\\\" : updates.toString(),\\n            '\\\"},{\\\"trait_type\\\":\\\"Length\\\",\\\"value\\\":',\\n            (queueLength - minQueueIndex).toString(),\\n            '},{\\\"trait_type\\\":\\\"Subject\\\",\\\"value\\\":\\\"',\\n            subjectName,\\n            '\\\"}]}'\\n        );\\n\\n        return attributes;\\n    }\\n\\n    function _increment(\\n        uint256 segmentLength,\\n        int256 tilt,\\n        int256 SQUARE_SIDE_MARGIN\\n    ) internal pure returns (int32 incrementX, int32 incrementY) {\\n        int256 direction = -(((int256(segmentLength) >> 1) & 1) << 1) + 1;\\n        int256 xDirection = int256((segmentLength) & 1) * direction;\\n        int256 yDirection = (1 - int256((segmentLength) & 1)) * direction;\\n        incrementX =\\n            int32(SQUARE_SIDE_MARGIN * xDirection) +\\n            int32(tilt * yDirection);\\n        incrementY =\\n            int32(SQUARE_SIDE_MARGIN * yDirection) +\\n            int32(tilt * -xDirection);\\n    }\\n\\n    function _renderIteration(\\n        bytes memory buffer,\\n        uint256 count,\\n        uint256 minQueueIndex,\\n        uint160[4096] memory queue,\\n        int32 SQUARE_SIDE_MARGIN\\n    ) internal pure returns (bytes memory) {\\n        uint256 currentLength = 0;\\n        uint256 segmentLength = 0;\\n\\n        int256 tilt = 0;\\n        uint256 tiltRound = 5;\\n        int32 lx = 0;\\n        int32 ly = 0;\\n        for (uint256 i = 0; i < count; ++i) {\\n            (int32 incrementX, int32 incrementY) = _increment(\\n                segmentLength,\\n                tilt,\\n                SQUARE_SIDE_MARGIN\\n            );\\n\\n            lx += incrementX;\\n            ly += incrementY;\\n            if (currentLength == 0 && segmentLength % tiltRound == 4) {\\n                tilt += int256(uint256(queue[i + minQueueIndex] % 5));\\n                tiltRound += 1;\\n            }\\n\\n            currentLength += 1;\\n            if (currentLength == segmentLength + 1 || i == count - 1) {\\n                buffer = abi.encodePacked(buffer, bytes(\\\" l \\\"));\\n                if (lx < 0) {\\n                    buffer = abi.encodePacked(buffer, bytes(\\\"-\\\"));\\n                    lx = lx * -1;\\n                }\\n                buffer = abi.encodePacked(\\n                    buffer,\\n                    bytes(uint32(lx).toString()),\\n                    bytes(\\\" \\\")\\n                );\\n                if (ly < 0) {\\n                    buffer = abi.encodePacked(buffer, bytes(\\\"-\\\"));\\n                    ly = ly * -1;\\n                }\\n                buffer = abi.encodePacked(buffer, bytes(uint32(ly).toString()));\\n                lx = 0;\\n                ly = 0;\\n                currentLength = 0;\\n                segmentLength += 1;\\n            }\\n        }\\n\\n        return buffer;\\n    }\\n\\n    function renderFallback(\\n        uint256 minQueueIndex,\\n        uint256 count,\\n        uint160[4096] memory queue,\\n        uint256 WIDTH,\\n        uint256 HEIGHT,\\n        uint256 HALF_SQUARE_SIDE,\\n        uint256 SQUARE_SIDE,\\n        int32 SQUARE_SIDE_MARGIN\\n    ) external pure returns (bytes memory buffer) {\\n        int32 lx = int32(uint32((WIDTH >> 1) - HALF_SQUARE_SIDE));\\n        int32 ly = int32(uint32((HEIGHT >> 1) - HALF_SQUARE_SIDE));\\n        buffer = abi.encodePacked(\\n            bytes(\\n                \\\"<path id='l' stroke='hsl(0,0%,65%)' fill='transparent' stroke-width='\\\"\\n            ),\\n            bytes(SQUARE_SIDE.toString()),\\n            bytes(\\\"px' stroke-dasharray='\\\"),\\n            bytes(SQUARE_SIDE.toString()),\\n            bytes(\\\"'  d='M \\\"),\\n            bytes(uint32(lx).toString()),\\n            bytes(\\\" \\\"),\\n            bytes(uint32(ly).toString())\\n        );\\n\\n        buffer = _renderIteration(\\n            buffer,\\n            count,\\n            minQueueIndex,\\n            queue,\\n            SQUARE_SIDE_MARGIN\\n        );\\n\\n        buffer = abi.encodePacked(buffer, bytes(\\\"' />\\\"));\\n\\n        return buffer;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\n\\npragma solidity 0.8.21;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\\n/// @notice This library is used to allocate a big amount of container memory\\n//          which will be subsequently filled without needing to reallocate\\n///         memory.\\n/// @dev First, allocate memory.\\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\\n///      bounds checking is required.\\nlibrary DynamicBuffer {\\n    /// @notice Allocates container space for the DynamicBuffer\\n    /// @param capacity_ The intended max amount of bytes in the buffer\\n    /// @return buffer The memory location of the buffer\\n    /// @dev Allocates `capacity_ + 0x60` bytes of space\\n    ///      The buffer array starts at the first container data position,\\n    ///      (i.e. `buffer = container + 0x20`)\\n    function allocate(\\n        uint256 capacity_\\n    ) internal pure returns (bytes memory buffer) {\\n        assembly {\\n            // Get next-free memory address\\n            let container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                // Add 32 bytes safety space for 32B chunked copy\\n                let size := add(capacity_, 0x60)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity_, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Does not perform out-of-bound checks (container capacity)\\n    ///      for efficiency.\\n    function appendUnchecked(\\n        bytes memory buffer,\\n        bytes memory data\\n    ) internal pure {\\n        assembly {\\n            let length := mload(data)\\n            for {\\n                data := add(data, 0x20)\\n                let dataEnd := add(data, length)\\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\\n            } lt(data, dataEnd) {\\n                data := add(data, 0x20)\\n                copyTo := add(copyTo, 0x20)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length, and have allocated an\\n                // additional word to avoid buffer overflow.\\n                mstore(copyTo, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer, add(mload(buffer), length))\\n        }\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\\n        checkOverflow(buffer, data.length);\\n        appendUnchecked(buffer, data);\\n    }\\n\\n    /// @notice Appends data encoded as Base64 to buffer.\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\\n    function appendSafeBase64(\\n        bytes memory buffer,\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure {\\n        uint256 dataLength = data.length;\\n\\n        if (data.length == 0) {\\n            return;\\n        }\\n\\n        uint256 encodedLength;\\n        uint256 r;\\n        assembly {\\n            // For each 3 bytes block, we will have 4 bytes in the base64\\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n            r := mod(dataLength, 3)\\n            if noPadding {\\n                // if r == 0 => no modification\\n                // if r == 1 => encodedLength -= 2\\n                // if r == 2 => encodedLength -= 1\\n                encodedLength := sub(\\n                    encodedLength,\\n                    add(iszero(iszero(r)), eq(r, 1))\\n                )\\n            }\\n        }\\n\\n        checkOverflow(buffer, encodedLength);\\n\\n        assembly {\\n            let nextFree := mload(0x40)\\n\\n            // Store the table into the scratch space.\\n            // Offsetted by -1 byte so that the `mload` will load the character.\\n            // We will rewrite the free memory pointer at `0x40` later with\\n            // the allocated size.\\n            mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n            mstore(\\n                0x3f,\\n                sub(\\n                    \\\"ghijklmnopqrstuvwxyz0123456789-_\\\",\\n                    // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                    mul(iszero(fileSafe), 0x0230)\\n                )\\n            )\\n\\n            // Skip the first slot, which stores the length.\\n            let ptr := add(add(buffer, 0x20), mload(buffer))\\n            let end := add(data, dataLength)\\n\\n            // Run over the input, 3 bytes at a time.\\n            // prettier-ignore\\n            // solhint-disable-next-line no-empty-blocks\\n            for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n            if iszero(noPadding) {\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n            }\\n\\n            mstore(buffer, add(mload(buffer), encodedLength))\\n            mstore(0x40, nextFree)\\n        }\\n    }\\n\\n    /// @notice Returns the capacity of a given buffer.\\n    function capacity(bytes memory buffer) internal pure returns (uint256) {\\n        uint256 cap;\\n        assembly {\\n            cap := sub(mload(sub(buffer, 0x20)), 0x40)\\n        }\\n        return cap;\\n    }\\n\\n    /// @notice Reverts if the buffer will overflow after appending a given\\n    /// number of bytes.\\n    function checkOverflow(\\n        bytes memory buffer,\\n        uint256 addedLength\\n    ) internal pure {\\n        uint256 cap = capacity(buffer);\\n        uint256 newLength = buffer.length + addedLength;\\n        if (cap < newLength) {\\n            revert(\\\"DynamicBuffer: Appending out of bounds.\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ninterface PublicResolver {\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\\ninterface ReverseRegistry {\\n    function node(address addr) external view returns (bytes32);\\n}\\n\\n/// @title On-Chain ENS Resolution\\n/// @author Miragenesi\\n/// @notice Use this contract to resolve the ENS name of an address\\ncontract ENSResolver {\\n    ReverseRegistry _reverseRegistry;\\n    PublicResolver _publicResolver;\\n    bytes32 constant DEFAULT_NAME = keccak256(\\\"reverse.ens.eth\\\");\\n    bytes32 constant EMPTY_NAME = keccak256(\\\"\\\");\\n\\n    constructor(address reverseRegistry, address publicResolver) {\\n        _reverseRegistry = ReverseRegistry(reverseRegistry);\\n        _publicResolver = PublicResolver(publicResolver);\\n    }\\n\\n    /**\\n     * Returns whatever is resolved for this address.\\n     * It might be the ENS name, empty or some default\\n     * result.\\n     * @param addr the requested address\\n     * @return ENS or 0x string of the requested address\\n     * @return always false;\\n     */\\n    function resolve(address addr) public view returns (string memory, bool) {\\n        return _resolve(addr, false);\\n    }\\n\\n    /**\\n     * Returns the ENS of the given address, or the hex-string\\n     * version of the address if no ENS is associated to it.\\n     * @param addr the requested address\\n     * @return ENS or 0x string of the requested address\\n     * @return whether the string represents the ENS or the 0x-address\\n     */\\n    function resolveWithFallback(\\n        address addr\\n    ) public view returns (string memory, bool) {\\n        return _resolve(addr, true);\\n    }\\n\\n    function _resolve(\\n        address addr,\\n        bool fall\\n    ) internal view returns (string memory name, bool didFallback) {\\n        if (\\n            address(_reverseRegistry) != address(0) &&\\n            address(_publicResolver) != address(0)\\n        ) {\\n            try _reverseRegistry.node(addr) returns (bytes32 node) {\\n                try _publicResolver.name(node) returns (string memory name_) {\\n                    name = name_;\\n                } catch (bytes memory) {}\\n            } catch (bytes memory) {}\\n        }\\n\\n        if (fall) {\\n            bytes32 khash = keccak256(abi.encodePacked(name));\\n            if (khash == DEFAULT_NAME || khash == EMPTY_NAME) {\\n                name = Strings.toHexString(addr);\\n                didFallback = true;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Queue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"./QueueRenderer.sol\\\";\\n\\n/**\\n######################### ##############################\\n########################     ###########################\\n####################### #####  #########################\\n#####################  ###    #   ######################\\n####################  ##  ####  ##   ###################\\n##################  ###  ##    #  ###  #################\\n#################  ##  ###  ###  ##  ##   ##############\\n################  ##  ##  ##    #  ##  ###   ###########\\n##############  ##  ##  ##  ##    #  ##   ##   #########\\n#############  ##  #  ##  ##  ##    #  ##   ###   ######\\n############ ##  #  ##  #  ##      #  #  ###  ####  ####\\n########### ## ##  #  #  #   #      ## ##  ###  ####   #\\n#########  #  #                     #  #  ##  ###   #### \\n####  ## ## #    #  #                # ##  ##  #### ## #\\n###  #  #  #  ##  #  #   Queue     #  #  ## ###    ## ##\\n##  #  #  ###  ##  ## #   Wait    # #  #  #    #  #  ###\\n#  #  ####   ##  ##  #     Mint            # ## ##  ####\\n  #####  ###   ##  ##                    #  #  ## ######\\n##   ####   ###  ##  #      ##  #   #  #  ## ##  #######\\n#####  #####  ###  ##  # #   ##  ##  ## ##  ##  ########\\n#######   ####   ##  ##    ##  ##  ##  ##  ## ##########\\n##########   ####  ##  ##    ##  ##  ##  ##  ###########\\n#############   ###   ##  #    ##  ###  ##  ############\\n################   ###  ##  ####  ### ###  #############\\n###################  ###  ##    ###  ### ###############\\n######################  ###  ####  ###  ################\\n########################   ##     ###  #################\\n###########################   ######  ##################\\n##############################   #  ####################\\n#################################  #####################\\n */\\n\\ncontract Queue is ERC721, Ownable, QueueRenderer {\\n    uint256 public mintBegin;\\n    uint256 public queueBegin;\\n    uint256 public startMintingFee;\\n    uint256 public priceIncrement;\\n    uint256 public currentToken = 1;\\n\\n    bytes32 internal _root;\\n    uint256 internal _maxBlocksRich = 600;\\n    uint256 internal _maxBlocksPlain = 1300;\\n    uint256 internal constant DISCOUNTED = 85;\\n\\n    mapping(uint256 => uint256) internal _tokenViews;\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 mintBegin_,\\n        uint256 queueBegin_,\\n        uint256 startMintingFee_,\\n        uint256 priceIncrement_,\\n        address assets\\n    ) QueueRenderer(assets) ERC721(name, symbol) {\\n        mintBegin = mintBegin_;\\n        queueBegin = queueBegin_;\\n        startMintingFee = startMintingFee_;\\n        priceIncrement = priceIncrement_;\\n    }\\n\\n    modifier mintClosed() {\\n        require(block.number < mintBegin, \\\"mint begun\\\");\\n        _;\\n    }\\n\\n    modifier mintOpen() {\\n        require(block.number >= mintBegin, \\\"mint closed\\\");\\n        _;\\n    }\\n\\n    modifier tradingActive() {\\n        require(\\n            currentToken >= queueLength ||\\n                block.number - mintBegin > queueLength,\\n            \\\"trading not active\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier mintInProgress() {\\n        require(block.number < mintBegin + queueLength, \\\"mint ended\\\");\\n        _;\\n    }\\n\\n    // Admin\\n\\n    function withdraw(address to) external onlyOwner {\\n        (bool success, ) = to.call{ value: address(this).balance }(\\\"\\\");\\n        require(success, \\\"fail\\\");\\n    }\\n\\n    function setRoot(bytes32 root) external onlyOwner {\\n        _root = root;\\n    }\\n\\n    function setRenderingThresholds(\\n        uint256 maxBlocksRich_,\\n        uint256 maxBlocksPlain_\\n    ) external onlyOwner {\\n        _maxBlocksRich = maxBlocksRich_;\\n        _maxBlocksPlain = maxBlocksPlain_;\\n    }\\n\\n    function setPrices(\\n        uint256 priceIncrement_,\\n        uint256 startMintingFee_\\n    ) external onlyOwner mintClosed {\\n        priceIncrement = priceIncrement_;\\n        startMintingFee = startMintingFee_;\\n    }\\n\\n    function setAssets(address assets) external onlyOwner {\\n        _assets = Assets(assets);\\n    }\\n\\n    function setTimes(\\n        uint256 mintBegin_,\\n        uint256 queueBegin_\\n    ) external onlyOwner mintClosed {\\n        mintBegin = mintBegin_;\\n        queueBegin = queueBegin_;\\n    }\\n\\n    function mintPrivate(\\n        address[] memory wallets,\\n        uint256[] memory amounts\\n    ) external onlyOwner mintOpen {\\n        uint256 walletLength = wallets.length;\\n\\n        for (uint256 i = 0; i < walletLength; i++) {\\n            uint256 amount = amounts[i];\\n            require(currentToken - 1 + amount <= queueLength, \\\"sales ended\\\");\\n            _mintBatch(wallets[i], amount);\\n        }\\n    }\\n\\n    function mintZero() external onlyOwner {\\n        _mint(owner(), 0);\\n    }\\n\\n    // ***** Public *****\\n    // Write\\n\\n    /**\\n     * Queue up.\\n     */\\n    function enter() external mintClosed {\\n        require(block.number > queueBegin, \\\"wait to wait\\\");\\n        queue[queueLength++] = uint160(msg.sender);\\n    }\\n\\n    /**\\n     * Mint\\n     */\\n    function mint(\\n        uint256 amount,\\n        uint256[] calldata positions\\n    ) public payable mintOpen mintInProgress {\\n        uint256 currentSlot = _calculateSlot(block.number);\\n        _validate(\\n            currentSlot,\\n            amount,\\n            _priceAt(currentSlot, queueLength) * amount,\\n            positions\\n        );\\n        _mintBatch(msg.sender, amount);\\n    }\\n\\n    /**\\n     * Mint with discount options\\n     */\\n    function mintDiscount(\\n        uint256 amount,\\n        uint256[] calldata positions,\\n        uint8 freeAmount,\\n        bytes32[] calldata proof\\n    ) public payable mintOpen mintInProgress {\\n        require(balanceOf(msg.sender) == 0, \\\"voucher used\\\");\\n        bytes32 leaf = keccak256(\\n            bytes.concat(keccak256(abi.encode(msg.sender, freeAmount)))\\n        );\\n        require(MerkleProof.verify(proof, _root, leaf), \\\"invalid proof\\\");\\n        uint256 currentSlot = _calculateSlot(block.number);\\n        uint256 currentPrice = _priceAt(currentSlot, queueLength);\\n        uint256 total = ((currentPrice * DISCOUNTED) / 100) *\\n            (amount - freeAmount);\\n\\n        _validate(currentSlot, amount, total, positions);\\n        _mintBatch(msg.sender, amount);\\n    }\\n\\n    /**\\n     * Explore your queue.\\n     * @param tokenId Your token\\n     * @param height Height of the camera\\n     * @param subjectIndex Centered block, relative to the first block in the queue at *this* stage. Starts from 0.\\n     */\\n    function explore(\\n        uint256 tokenId,\\n        uint256 height,\\n        uint256 subjectIndex\\n    ) public {\\n        require(msg.sender == ownerOf(tokenId), \\\"not the owner\\\");\\n        require(height > 0 && height < 32, \\\"invalid height\\\");\\n        require(subjectIndex < queueLength - (tokenId - 1), \\\"invalid subject\\\");\\n        uint256 updates = ((_tokenViews[tokenId] >> 128) + 1) & (2 ** 123 - 1);\\n        _tokenViews[tokenId] =\\n            (height << 251) |\\n            (updates << 128) |\\n            uint128(subjectIndex);\\n    }\\n\\n    // Read\\n\\n    /**\\n     * It renders the current state of the queue as an svg.\\n     * It will be complete right before the minting starts.\\n     * It will be empy after the minting ends, at which point\\n     * this method becomes pretty much useless\\n     * (unless you are interested in a permanently degree-and-hue-rotating background).\\n     * @param plain if true it will render a plain version of the line\\n     * @return svg an svg string of the queue\\n     * @return index the index currently at the head of the queue\\n     * @return count number of blocks in the queue\\n     */\\n    function renderCurrent(\\n        bool plain\\n    ) public view returns (string memory, uint256, uint256) {\\n        uint256 index = _calculateSlotSafe(block.number);\\n\\n        (bytes memory output, uint256 count) = _renderFrom(index, plain);\\n\\n        return (string(output), index, count);\\n    }\\n\\n    /**\\n     * Returns information related to the account\\n     * @param account the desired account\\n     * @return wallet the ENS or 0x string of the given wallet\\n     * @return svg the block rendering of the given wallet\\n     * @return positions the positions in line, starting from 0\\n     */\\n    function accountData(\\n        address account\\n    )\\n        public\\n        view\\n        returns (\\n            string memory wallet,\\n            string memory svg,\\n            uint256[] memory positions\\n        )\\n    {\\n        (wallet, ) = _assets.convertWallet(account);\\n        svg = _renderWallet(account);\\n\\n        uint256 total;\\n        uint256[] memory positionsTmp = new uint256[](4096);\\n        for (uint256 i = 0; i < queueLength; i++) {\\n            if (queue[i] == uint160(account)) {\\n                positionsTmp[total++] = i;\\n            }\\n        }\\n\\n        positions = new uint256[](total);\\n        for (uint256 i = 0; i < total; i++) {\\n            positions[i] = positionsTmp[i];\\n        }\\n    }\\n\\n    /**\\n     * Returns information related to a given index in line.\\n     * @param index the index, starting from 0\\n     * @return wallet the ENS or 0x string of the wallet at the given index\\n     * @return svg the block rendering of the wallet at the given index\\n     */\\n    function walletAtIndex(\\n        uint256 index\\n    ) public view returns (string memory wallet, string memory svg) {\\n        require(index < queueLength, \\\"index beyond queue\\\");\\n        address account = address(queue[index]);\\n        (wallet, ) = _assets.convertWallet(account);\\n        svg = _renderWallet(account);\\n    }\\n\\n    // Overrides\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"non existing token\\\");\\n\\n        uint256 zoom = 32;\\n        uint256 subject = 0;\\n        uint256 updates = 0;\\n        uint256 minQueueIndex = 0;\\n        uint256 blockNumber = block.number;\\n\\n        if (tokenId > 0) {\\n            blockNumber = mintBegin + tokenId;\\n            (zoom, subject, updates) = _getViewConfig(tokenId);\\n            minQueueIndex = tokenId - 1;\\n        }\\n\\n        bytes memory buffer = DynamicBuffer.allocate(20000);\\n        DynamicBuffer.appendUnchecked(buffer, \\\"data:application/json,\\\");\\n\\n        bytes memory details = _assets.metadataDetails(tokenId);\\n        DynamicBuffer.appendUnchecked(buffer, details);\\n\\n        bytes memory output;\\n        uint256 peopleCount;\\n\\n        if (tokenId > 0) {\\n            (output, peopleCount) = _render(\\n                buffer,\\n                Mode.STANDARD,\\n                queueLength - minQueueIndex,\\n                blockNumber,\\n                minQueueIndex,\\n                subject,\\n                zoom\\n            );\\n            bytes memory attributes = _getAttributes(\\n                minQueueIndex,\\n                subject,\\n                peopleCount,\\n                zoom,\\n                updates\\n            );\\n            DynamicBuffer.appendUnchecked(output, attributes);\\n            return string(output);\\n        } else {\\n            (output, ) = _renderFrom(0, false);\\n            DynamicBuffer.appendUnchecked(buffer, output);\\n            DynamicBuffer.appendUnchecked(buffer, '\\\"}');\\n            return string(buffer);\\n        }\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override tradingActive {\\n        super._transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override tradingActive {\\n        super._approve(to, tokenId);\\n    }\\n\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual override tradingActive {\\n        require(queueLength > 1, \\\"trading not active\\\");\\n        super._setApprovalForAll(owner, operator, approved);\\n    }\\n\\n    //**** Internal *****\\n\\n    // Write\\n\\n    function _mintBatch(address to, uint256 amount) internal {\\n        for (uint256 i = 0; i < amount; i++) {\\n            super._mint(to, currentToken++);\\n        }\\n    }\\n\\n    // Read\\n\\n    function _getAttributes(\\n        uint256 minQueueIndex,\\n        uint256 subject,\\n        uint256 peopleCount,\\n        uint256 zoom,\\n        uint256 updates\\n    ) internal view returns (bytes memory) {\\n        address wallet = address(queue[minQueueIndex + subject]);\\n        return\\n            _assets.metadataAttributes(\\n                peopleCount,\\n                zoom,\\n                subject,\\n                minQueueIndex,\\n                queueLength,\\n                updates,\\n                wallet\\n            );\\n    }\\n\\n    function _priceAt(\\n        uint256 slot,\\n        uint256 length\\n    ) internal view returns (uint256) {\\n        if (slot < length >> 1) {\\n            return startMintingFee + priceIncrement * slot;\\n        } else {\\n            return startMintingFee + priceIncrement * (length - slot - 1);\\n        }\\n    }\\n\\n    function _validate(\\n        uint256 currentSlot,\\n        uint256 amount,\\n        uint256 price,\\n        uint256[] calldata indexes\\n    ) internal view {\\n        require(queue[indexes[0]] == uint160(msg.sender), \\\"invalid index\\\");\\n        uint256 length = indexes.length;\\n        for (uint256 i = 1; i < length; i++) {\\n            require(\\n                indexes[i - 1] < indexes[i] &&\\n                    queue[indexes[i]] == uint160(msg.sender),\\n                \\\"invalid indexes\\\"\\n            );\\n        }\\n        require(\\n            balanceOf(msg.sender) + amount <= length << 1,\\n            \\\"invalid amount\\\"\\n        );\\n        require(currentSlot >= indexes[0], \\\"not your turn\\\");\\n        require(currentToken - 1 + amount <= queueLength, \\\"sales ended\\\");\\n        require(msg.value >= price, \\\"not enough ether\\\");\\n    }\\n\\n    function _calculateSlot(\\n        uint256 blockNumber\\n    ) internal view returns (uint256) {\\n        return blockNumber - mintBegin;\\n    }\\n\\n    function _calculateSlotSafe(\\n        uint256 blockNumber\\n    ) internal view returns (uint256) {\\n        return blockNumber < mintBegin ? 0 : _calculateSlot(blockNumber);\\n    }\\n\\n    function _getViewConfig(\\n        uint256 tokenId\\n    ) internal view returns (uint256 zoom, uint256 subject, uint256 updates) {\\n        uint256 tokenView = _tokenViews[tokenId];\\n        zoom = tokenView >> 251;\\n        updates = (tokenView >> 128) & (2 ** 123 - 1);\\n        subject = uint128(tokenView);\\n        if (zoom == 0) {\\n            uint256 randomness = uint256(\\n                keccak256(abi.encodePacked(tokenId, queueLength))\\n            );\\n            uint256 prob = randomness % queueLength;\\n\\n            if (prob < (queueLength * 850) / 1000) {\\n                zoom = (prob % 5) + 1;\\n            } else if (prob < (queueLength * 950) / 1000) {\\n                zoom = (prob % 6) + 5;\\n            } else if (prob < (queueLength * 999) / 1000) {\\n                zoom = (prob % 11) + 11;\\n            } else {\\n                zoom = 31;\\n            }\\n            subject = uint128(randomness % (queueLength - tokenId + 1));\\n        }\\n    }\\n\\n    function _renderFrom(\\n        uint256 index,\\n        bool plain\\n    ) internal view returns (bytes memory, uint256) {\\n        uint256 count;\\n        if (index < queueLength) {\\n            count = queueLength - index;\\n        }\\n\\n        Mode mode;\\n        if (count < _maxBlocksRich && !plain) {\\n            mode = Mode.FULL_RICH;\\n        } else if (count < _maxBlocksPlain) {\\n            mode = Mode.FULL_PLAIN;\\n        } else {\\n            mode = Mode.FULL_PATH;\\n        }\\n\\n        bytes memory beforeBuffer;\\n        (bytes memory output, ) = _render(\\n            beforeBuffer,\\n            mode,\\n            count,\\n            block.number,\\n            index,\\n            0,\\n            32\\n        );\\n\\n        return (output, count);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/QueueRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./DynamicBuffer.sol\\\";\\nimport \\\"./SVG.sol\\\";\\n\\ncontract QueueRenderer is SVG {\\n    using Strings for uint32;\\n    using Strings for uint256;\\n\\n    uint256 constant SQUARE_SIDE = 100;\\n    uint256 constant HALF_SQUARE_SIDE = 50;\\n    uint256 constant MARGIN = 15;\\n    int32 constant SQUARE_SIDE_MARGIN = int32(uint32(SQUARE_SIDE + MARGIN));\\n    uint256 constant WIDTH = 40000;\\n    uint256 constant HEIGHT = 40000;\\n    uint256 constant GRADIENT_PROB = 4;\\n    uint256 constant CIRCLE_PROB = 2;\\n\\n    uint256 constant MAX_QUEUE_SIZE = 4096;\\n    uint256 constant RANDOMNES_CHUNK_SIZE_WALLET = 160 / 8;\\n    uint256 constant MASK_WALLET = 2 ** RANDOMNES_CHUNK_SIZE_WALLET - 1;\\n\\n    struct Boundaries {\\n        uint32 firstX;\\n        uint32 firstY;\\n        uint32 lastX;\\n        uint32 lastY;\\n        int256 offsetX;\\n        int256 offsetY;\\n    }\\n\\n    enum Mode {\\n        STANDARD,\\n        FULL_PLAIN,\\n        FULL_RICH,\\n        FULL_PATH\\n    }\\n\\n    struct WalletTraits {\\n        uint8 variant;\\n        uint8 gradientAnimation;\\n        uint8 circleAnimation;\\n        uint8 scale;\\n        uint8 useCircle;\\n        uint8 shakeAnimation;\\n        uint8 colorSolid;\\n        uint16 colorBackground;\\n    }\\n\\n    mapping(uint8 => string) _scales;\\n\\n    bytes constant _blurs = hex\\\"343434343636363639393939\\\";\\n    bytes constant _gradients = hex\\\"30303030303030303131323334353637\\\";\\n    bytes constant _animations = hex\\\"6162636465666768696A6B6C6D6E6F70\\\";\\n\\n    uint160[MAX_QUEUE_SIZE] public queue;\\n    uint256 public queueLength;\\n\\n    constructor(address assets) SVG(assets) {\\n        _scales[0] = \\\"0.2\\\";\\n        _scales[1] = \\\"0.4\\\";\\n        _scales[2] = \\\"0.5\\\";\\n        _scales[3] = \\\"0.7\\\";\\n        _scales[4] = \\\"0.8\\\";\\n        _scales[5] = \\\"1.0\\\";\\n        _scales[6] = \\\"1.05\\\";\\n        _scales[7] = \\\"1.1\\\";\\n    }\\n\\n    function _render(\\n        bytes memory beforeBuffer,\\n        Mode mode,\\n        uint256 count,\\n        uint256 mintBlockNumber,\\n        uint256 minQueueIndex,\\n        uint256 zoomedSquare, // relative to minQueueIndex\\n        uint256 shownSquares\\n    ) internal view returns (bytes memory output, uint256 blocksCount) {\\n        bytes memory buffer = DynamicBuffer.allocate(200000);\\n        DynamicBuffer.appendUnchecked(buffer, beforeBuffer);\\n\\n        Data memory data = _precompute(\\n            mintBlockNumber,\\n            minQueueIndex,\\n            zoomedSquare,\\n            count\\n        );\\n        data.showSquares = uint32(shownSquares);\\n\\n        (int256 offsetX, int256 offsetY) = _offset(mode, data);\\n\\n        Boundaries memory boundaries = _boundaries(data, mode);\\n        boundaries.offsetX = offsetX;\\n        boundaries.offsetY = offsetY;\\n        uint256 maxQueueIndex = minQueueIndex + count;\\n\\n        blocksCount = _compose(\\n            buffer,\\n            mode,\\n            minQueueIndex,\\n            maxQueueIndex,\\n            (7 * shownSquares),\\n            data,\\n            boundaries\\n        );\\n        output = buffer;\\n    }\\n\\n    function _compose(\\n        bytes memory buffer,\\n        Mode mode,\\n        uint256 minIndex,\\n        uint256 maxIndex,\\n        uint256 padding,\\n        Data memory data,\\n        Boundaries memory boundaries\\n    ) internal view returns (uint256 peopleCount) {\\n        svgTemplate1(\\n            buffer,\\n            data.showSquares > 10 ? bytes1(0x30) : _blurs[data.showSquares],\\n            boundaries.offsetX - int256(padding >> 1),\\n            boundaries.offsetY - int256(padding >> 1),\\n            padding,\\n            data\\n        );\\n\\n        if (mode == Mode.FULL_PLAIN || mode == Mode.FULL_RICH) {\\n            _renderPlainFull(buffer, data, minIndex, mode == Mode.FULL_PLAIN);\\n        } else if (mode == Mode.FULL_PATH) {\\n            _renderPath(buffer, minIndex, maxIndex - minIndex);\\n        } else {\\n            peopleCount = _renderZoom(buffer, boundaries, data, minIndex);\\n        }\\n        svgTemplate2(buffer);\\n    }\\n\\n    function _renderPlainFull(\\n        bytes memory buffer,\\n        Data memory data,\\n        uint256 minIndex,\\n        bool plain\\n    ) internal view {\\n        bytes memory allColors = _assets.getColors();\\n        uint256 length = data.segments;\\n        for (uint256 i = 0; i < length; ++i) {\\n            int32 startX = int32(data.coords[i][0]);\\n            int32 startY = int32(data.coords[i][1]);\\n            int32 incrementX = data.increments[i][0];\\n            int32 incrementY = data.increments[i][1];\\n\\n            for (uint256 j = 0; j <= i; ++j) {\\n                if (plain) {\\n                    _renderPlainRects(\\n                        buffer,\\n                        uint32(startX + incrementX * int32(int256(j))),\\n                        uint32(startY + incrementY * int32(int256(j))),\\n                        queue[minIndex++],\\n                        allColors\\n                    );\\n                } else {\\n                    _renderRects(\\n                        buffer,\\n                        uint32(startX + incrementX * int32(int256(j))),\\n                        uint32(startY + incrementY * int32(int256(j))),\\n                        queue[minIndex++],\\n                        allColors\\n                    );\\n                }\\n\\n                if (minIndex == queueLength) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _renderZoom(\\n        bytes memory buffer,\\n        Boundaries memory boundaries,\\n        Data memory data,\\n        uint256 minIndex\\n    ) internal view returns (uint256 peopleCount) {\\n        bytes memory allColors = _assets.getColors();\\n        for (uint256 i = 0; i < data.segments; ++i) {\\n            int32 startX = int32(data.coords[i][0]);\\n            int32 startY = int32(data.coords[i][1]);\\n            int32 incrementX = data.increments[i][0];\\n            int32 incrementY = data.increments[i][1];\\n\\n            for (uint256 j = 0; j <= i; ++j) {\\n                uint32 x = uint32(startX + incrementX * int32(int256(j)));\\n                uint32 y = uint32(startY + incrementY * int32(int256(j)));\\n\\n                if (\\n                    x > boundaries.firstX &&\\n                    x < boundaries.lastX &&\\n                    y > boundaries.firstY &&\\n                    y < boundaries.lastY\\n                ) {\\n                    peopleCount++;\\n                    _renderRects(buffer, x, y, queue[minIndex], allColors);\\n                }\\n\\n                minIndex++;\\n\\n                if (minIndex == queueLength) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _renderWallet(\\n        address wallet\\n    ) internal view returns (string memory) {\\n        bytes memory allColors = _assets.getColors();\\n        bytes memory buffer = DynamicBuffer.allocate(200000);\\n        Data memory data;\\n        data.frameSize = uint32(SQUARE_SIDE);\\n\\n        svgTemplate1(buffer, \\\"1\\\", 0, 0, (MARGIN << 1), data);\\n        _renderRects(buffer, MARGIN, MARGIN, uint160(wallet), allColors);\\n        svgTemplate2(buffer);\\n\\n        return string(buffer);\\n    }\\n\\n    function _renderRects(\\n        bytes memory buffer,\\n        uint256 x,\\n        uint256 y,\\n        uint160 wallet,\\n        bytes memory allColors\\n    ) internal view {\\n        WalletTraits memory traits = _walletTraits(wallet);\\n\\n        rectTemplate1(\\n            buffer,\\n            x,\\n            y,\\n            _animations[traits.shakeAnimation],\\n            bytes(_scales[traits.scale])\\n        );\\n\\n        bytes memory color1 = new bytes(6);\\n        bytes memory color2 = new bytes(6);\\n        bytes memory color3 = new bytes(6);\\n        uint256 start = 32 + traits.colorBackground * 6;\\n        if (traits.variant < GRADIENT_PROB) {\\n            assembly {\\n                mstore(add(color1, 32), mload(add(allColors, start)))\\n            }\\n\\n            rectGradientAttributes(buffer, color1);\\n            rectTemplate2(buffer);\\n\\n            if (traits.variant == 0) {\\n                assembly {\\n                    mstore(\\n                        add(color2, 32),\\n                        mload(add(allColors, add(start, 6)))\\n                    )\\n                }\\n\\n                gradient(\\n                    buffer,\\n                    _gradients[traits.gradientAnimation],\\n                    x + 50,\\n                    y + 50,\\n                    color2\\n                );\\n            }\\n        } else {\\n            rectSolidAttributes(buffer, traits.colorSolid);\\n            rectTemplate2(buffer);\\n        }\\n\\n        if (traits.useCircle < CIRCLE_PROB) {\\n            assembly {\\n                mstore(add(color3, 32), mload(add(allColors, add(start, 12))))\\n            }\\n            circle(buffer, traits.circleAnimation, x + 50, y + 50, color3);\\n        }\\n\\n        rectTemplate3(buffer);\\n    }\\n\\n    function _renderPlainRects(\\n        bytes memory buffer,\\n        uint256 x,\\n        uint256 y,\\n        uint160 wallet,\\n        bytes memory allColors\\n    ) internal view {\\n        uint8 variant = uint8(_randomNumberWallet(wallet, 0) & 7);\\n        uint32 colorBackground = uint32(_randomNumberWallet(wallet, 1) & 2047);\\n        uint8 scale = uint8(_randomNumberWallet(wallet, 4) & 7);\\n        uint8 shakeAnimation = uint8(_randomNumberWallet(wallet, 5) & 15);\\n        uint8 colorSolid = uint8(_randomNumberWallet(wallet, 7) & 63) + 18;\\n\\n        rectTemplate1(\\n            buffer,\\n            x,\\n            y,\\n            _animations[shakeAnimation],\\n            bytes(_scales[scale])\\n        );\\n\\n        bytes memory color1 = new bytes(6);\\n        uint256 start = 32 + colorBackground * 6;\\n        if (variant < GRADIENT_PROB) {\\n            assembly {\\n                mstore(add(color1, 32), mload(add(allColors, start)))\\n            }\\n            rectGradientAttributes(buffer, color1);\\n        } else {\\n            rectSolidAttributes(buffer, colorSolid);\\n        }\\n\\n        rectTemplate2(buffer);\\n        rectTemplate3(buffer);\\n    }\\n\\n    function _precompute(\\n        uint256 mintBlockNumber,\\n        uint256 minQueueIndex,\\n        uint256 zoomedSquare,\\n        uint256 count\\n    ) internal view returns (Data memory data) {\\n        _frameTraits(mintBlockNumber, data);\\n        data.zoomedSquare = uint32(zoomedSquare);\\n\\n        int32 x = int32(uint32((WIDTH >> 1) - HALF_SQUARE_SIDE));\\n        int32 y = int32(uint32((HEIGHT >> 1) - HALF_SQUARE_SIDE));\\n\\n        data.minX = data.maxX = data.zoomX = uint32(x);\\n        data.minY = data.maxY = data.zoomY = uint32(y);\\n\\n        int32 segmentIndex = 0;\\n        int256 tilt = 0;\\n        int32 tiltRound = 5;\\n        int32 incrementX = 0;\\n        int32 incrementY = 0;\\n\\n        for (uint256 i = 0; i < count; ) {\\n            uint32 index = uint32(segmentIndex);\\n\\n            if (segmentIndex % tiltRound == 4) {\\n                tilt += int256(uint256(queue[i + minQueueIndex] % 5));\\n                tiltRound += 1;\\n            }\\n\\n            data.coords[index][0] = uint32(x);\\n            data.coords[index][1] = uint32(y);\\n\\n            int256 direction = -(((int256(segmentIndex) >> 1) & 1) << 1) + 1;\\n            int256 xDirection = int256((segmentIndex) & 1) * direction;\\n            int256 yDirection = (1 - int256((segmentIndex) & 1)) * direction;\\n\\n            incrementX = (int32(SQUARE_SIDE_MARGIN * xDirection) +\\n                int32(tilt * yDirection));\\n            incrementY = (int32(SQUARE_SIDE_MARGIN * yDirection) +\\n                int32(tilt * -xDirection));\\n\\n            if (\\n                data.zoomedSquare >= i &&\\n                data.zoomedSquare <= i + uint256(int256(segmentIndex))\\n            ) {\\n                int32 delta = int32(uint32(data.zoomedSquare - i));\\n                data.zoomX = uint32(x + incrementX * delta);\\n                data.zoomY = uint32(y + incrementY * delta);\\n            }\\n\\n            x = x + incrementX * int32(segmentIndex + 1);\\n            y = y + incrementY * int32(segmentIndex + 1);\\n\\n            data.increments[index][0] = incrementX;\\n            data.increments[index][1] = incrementY;\\n\\n            unchecked {\\n                segmentIndex++;\\n                i += uint256(int256(segmentIndex));\\n            }\\n        }\\n\\n        data.segments = uint32(segmentIndex);\\n        _minMax(data, count);\\n\\n        if (count == 0) {\\n            data.minX = uint32(WIDTH / 2 - ((SQUARE_SIDE + MARGIN) * 83) / 2);\\n            data.maxX = uint32(WIDTH / 2 + ((SQUARE_SIDE + MARGIN) * 83) / 2);\\n            data.minY = uint32(HEIGHT / 2 - ((SQUARE_SIDE + MARGIN) * 83) / 2);\\n            data.maxY = uint32(HEIGHT / 2 + ((SQUARE_SIDE + MARGIN) * 83) / 2);\\n        }\\n\\n        data.lengthX = data.maxX - data.minX + uint32(SQUARE_SIDE);\\n        data.lengthY = data.maxY - data.minY + uint32(SQUARE_SIDE);\\n        if (data.lengthX > data.lengthY) {\\n            data.frameSize = data.lengthX;\\n        } else {\\n            data.frameSize = data.lengthY;\\n        }\\n    }\\n\\n    function _minMax(Data memory data, uint256 count) internal pure {\\n        for (uint256 i = 0; i < data.segments; ++i) {\\n            uint32 startX = data.coords[i][0];\\n            uint32 startY = data.coords[i][1];\\n            int32 incrementX = data.increments[i][0];\\n            int32 incrementY = data.increments[i][1];\\n            uint256 numberBlocks = i;\\n            if (numberBlocks >= count) {\\n                numberBlocks = count - 1;\\n            }\\n\\n            uint32 endX = uint32(\\n                int32(startX) + incrementX * int32(int256(numberBlocks))\\n            );\\n            uint32 endY = uint32(\\n                int32(startY) + incrementY * int32(int256(numberBlocks))\\n            );\\n\\n            (uint32 minX, uint32 maxX) = _minAndMax(startX, endX);\\n            if (minX < data.minX) {\\n                data.minX = minX;\\n            } else if (maxX > data.maxX) {\\n                data.maxX = maxX;\\n            }\\n\\n            (uint32 minY, uint32 maxY) = _minAndMax(startY, endY);\\n            if (minY < data.minY) {\\n                data.minY = minY;\\n            } else if (maxY > data.maxY) {\\n                data.maxY = maxY;\\n            }\\n\\n            count -= numberBlocks + 1;\\n        }\\n    }\\n\\n    function _minAndMax(\\n        uint32 a,\\n        uint32 b\\n    ) internal pure returns (uint32 min, uint32 max) {\\n        min = a;\\n        max = b;\\n        if (min > b) {\\n            max = min;\\n            min = b;\\n        }\\n    }\\n\\n    function _renderPath(\\n        bytes memory buffer,\\n        uint256 minQueueIndex,\\n        uint256 count\\n    ) internal view {\\n        DynamicBuffer.appendUnchecked(\\n            buffer,\\n            _assets.renderFallback(\\n                minQueueIndex,\\n                count,\\n                queue,\\n                WIDTH,\\n                HEIGHT,\\n                HALF_SQUARE_SIDE,\\n                SQUARE_SIDE,\\n                SQUARE_SIDE_MARGIN\\n            )\\n        );\\n    }\\n\\n    function _boundaries(\\n        Data memory data,\\n        Mode mode\\n    ) internal pure returns (Boundaries memory boundaries) {\\n        if (mode != Mode.STANDARD) {\\n            boundaries.firstX = 0;\\n            boundaries.firstY = 0;\\n            boundaries.lastX = data.maxX + 100;\\n            boundaries.lastY = data.maxY + 100;\\n        } else {\\n            boundaries.firstX = uint32(\\n                data.zoomX + HALF_SQUARE_SIDE - data.frameSize / 2\\n            );\\n            boundaries.lastX = uint32(\\n                data.zoomX - HALF_SQUARE_SIDE + data.frameSize / 2\\n            );\\n            boundaries.firstY = uint32(\\n                data.zoomY + HALF_SQUARE_SIDE - data.frameSize / 2\\n            );\\n            boundaries.lastY = uint32(\\n                data.zoomY - HALF_SQUARE_SIDE + data.frameSize / 2\\n            );\\n        }\\n    }\\n\\n    function _offset(\\n        Mode mode,\\n        Data memory data\\n    ) internal pure returns (int256 offsetX, int256 offsetY) {\\n        if (mode != Mode.STANDARD) {\\n            int256 frameCenterX = int256(\\n                int32(data.lengthX) / 2 + int32(data.minX)\\n            );\\n            int256 frameCenterY = int256(\\n                int32(data.lengthY) / 2 + int32(data.minY)\\n            );\\n\\n            offsetX = frameCenterX - int32(data.frameSize) / 2;\\n            offsetY = frameCenterY - int32(data.frameSize) / 2;\\n        } else {\\n            int256 frameSize16 = int256(int32(data.frameSize));\\n            int256 center = frameSize16 >> 1;\\n            uint256 zoomLevel = ((uint256(data.frameSize) * 1000) /\\n                (uint256(data.showSquares) *\\n                    SQUARE_SIDE +\\n                    uint256(data.showSquares + 1) *\\n                    MARGIN));\\n\\n            data.frameSize = uint32(\\n                (uint256(data.frameSize) * 1000) / (zoomLevel)\\n            );\\n            int256 diffFrameSize = frameSize16 -\\n                int256(uint256(data.frameSize));\\n\\n            int256 frameCenterX = int256(data.zoomX + HALF_SQUARE_SIDE) +\\n                (diffFrameSize >> 1);\\n            int256 frameCenterY = int256(data.zoomY + HALF_SQUARE_SIDE) +\\n                (diffFrameSize >> 1);\\n\\n            offsetX = frameCenterX - center;\\n            offsetY = frameCenterY - center;\\n        }\\n    }\\n\\n    // Randomness\\n\\n    function _frameTraits(\\n        uint256 mintBlockNumber,\\n        Data memory data\\n    ) internal pure {\\n        data.pathRotation = uint32(mintBlockNumber % 360);\\n        data.pathHue = data.pathRotation;\\n        data.pathSat =\\n            uint8(uint256(keccak256(abi.encodePacked(mintBlockNumber)))) %\\n            100;\\n        data.pathLum = uint8(mintBlockNumber % 5) + 5;\\n    }\\n\\n    function _randomNumberWallet(\\n        uint160 wallet,\\n        uint256 index\\n    ) internal pure returns (uint256) {\\n        return ((wallet >> (RANDOMNES_CHUNK_SIZE_WALLET * index)) &\\n            MASK_WALLET);\\n    }\\n\\n    function _walletTraits(\\n        uint160 wallet\\n    ) internal pure returns (WalletTraits memory traits) {\\n        traits.variant = uint8(_randomNumberWallet(wallet, 0) & 7);\\n        traits.colorBackground = uint16(_randomNumberWallet(wallet, 1) & 2047);\\n        traits.gradientAnimation = uint8(_randomNumberWallet(wallet, 2) & 15);\\n        traits.circleAnimation = uint8(_randomNumberWallet(wallet, 3) & 7);\\n        traits.scale = uint8(_randomNumberWallet(wallet, 4) & 7);\\n        traits.shakeAnimation = uint8(_randomNumberWallet(wallet, 5) & 15);\\n        traits.useCircle = uint8(_randomNumberWallet(wallet, 6) & 7);\\n        traits.colorSolid = uint8(_randomNumberWallet(wallet, 7) & 63) + 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./DynamicBuffer.sol\\\";\\nimport \\\"./Assets.sol\\\";\\n\\ncontract SVG {\\n    Assets _assets;\\n\\n    using Strings for uint256;\\n    using Strings for uint32;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n\\n    struct Data {\\n        uint8 pathSat;\\n        uint8 pathLum;\\n        uint32 minX;\\n        uint32 minY;\\n        uint32 maxX;\\n        uint32 maxY;\\n        uint32 zoomX;\\n        uint32 zoomY;\\n        uint32 lengthX;\\n        uint32 lengthY;\\n        uint32 frameSize;\\n        uint32 showSquares;\\n        uint32 pathHue;\\n        uint32 pathRotation;\\n        uint32 zoomedSquare;\\n        uint32 segments;\\n        uint32[2][100] coords;\\n        int32[2][100] increments;\\n    }\\n\\n    constructor(address assets) {\\n        _assets = Assets(assets);\\n    }\\n\\n    function _path(\\n        bytes memory buffer,\\n        uint256 h,\\n        uint256 s,\\n        uint256 l,\\n        uint256 rotation\\n    ) public view {\\n        (\\n            bytes memory path1,\\n            bytes memory path2,\\n            bytes memory path3,\\n            bytes memory path4,\\n            bytes memory path5\\n        ) = _assets.getPaths();\\n        DynamicBuffer.appendUnchecked(buffer, path1);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(h.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, path2);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(s.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, path3);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(l.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, path4);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(rotation.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, path5);\\n    }\\n\\n    bytes constant gradient1 = bytes(\\\"<use href='#g ' x='\\\");\\n    bytes constant gradient3 = bytes(\\\"' y='\\\");\\n    bytes constant gradient4 = bytes(\\\"' fill='#\\\");\\n    bytes constant gradient5 = bytes(\\\"' />\\\");\\n\\n    function gradient(\\n        bytes memory buffer,\\n        bytes1 id,\\n        uint256 x,\\n        uint256 y,\\n        bytes memory color\\n    ) public pure {\\n        bytes memory gradient1Memory = gradient1;\\n        gradient1Memory[13] = id;\\n        DynamicBuffer.appendUnchecked(buffer, gradient1Memory);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, gradient3);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, gradient4);\\n        DynamicBuffer.appendUnchecked(buffer, color);\\n        DynamicBuffer.appendUnchecked(buffer, gradient5);\\n    }\\n\\n    bytes constant circle1 = bytes(\\\"<use href='#a\\\");\\n    bytes constant circle2 = bytes(\\\"' x='\\\");\\n    bytes constant circle4 = bytes(\\\"' stroke='#\\\");\\n\\n    function circle(\\n        bytes memory buffer,\\n        uint256 circleAnimation,\\n        uint256 x,\\n        uint256 y,\\n        bytes memory color\\n    ) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, circle1);\\n        DynamicBuffer.appendUnchecked(\\n            buffer,\\n            bytes(circleAnimation.toString())\\n        );\\n        DynamicBuffer.appendUnchecked(buffer, circle2);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, gradient3);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, circle4);\\n        DynamicBuffer.appendUnchecked(buffer, color);\\n        DynamicBuffer.appendUnchecked(buffer, gradient5);\\n    }\\n\\n    function rectGradientAttributes(\\n        bytes memory buffer,\\n        bytes memory color\\n    ) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"fill='#\\\"));\\n        DynamicBuffer.appendUnchecked(buffer, color);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"'\\\"));\\n    }\\n\\n    function rectSolidAttributes(bytes memory buffer, uint8 color) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"fill='hsl(25,0%,\\\"));\\n        DynamicBuffer.appendUnchecked(buffer, bytes(color.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"%)'\\\"));\\n    }\\n\\n    bytes constant rect1 = bytes(\\\"<g class='s' transform='scale(\\\");\\n    bytes constant rect2 = bytes(\\\")'><path class='s ' d='M\\\");\\n    bytes constant rect4 = bytes(\\\" \\\");\\n    bytes constant rect5 = bytes(\\\"h100v100h-100' \\\");\\n    bytes constant rect6 = bytes(\\\" >\\\");\\n    bytes constant rect7 = bytes(\\\"</path>\\\");\\n    bytes constant rect8 = bytes(\\\"</g>\\\");\\n\\n    function rectTemplate1(\\n        bytes memory buffer,\\n        uint256 x,\\n        uint256 y,\\n        bytes1 animation,\\n        bytes memory scale\\n    ) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, rect1);\\n        DynamicBuffer.appendUnchecked(buffer, scale);\\n        bytes memory rect2o = rect2;\\n        rect2o[17] = animation;\\n        DynamicBuffer.appendUnchecked(buffer, rect2o);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, rect4);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, rect5);\\n    }\\n\\n    // atributes\\n\\n    function rectTemplate2(bytes memory buffer) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, rect6);\\n        DynamicBuffer.appendUnchecked(buffer, rect7);\\n    }\\n\\n    // content\\n\\n    function rectTemplate3(bytes memory buffer) internal pure {\\n        DynamicBuffer.appendUnchecked(buffer, rect8);\\n    }\\n\\n    function svgTemplate1(\\n        bytes memory buffer,\\n        bytes1 blur,\\n        int256 x,\\n        int256 y,\\n        uint256 padding,\\n        Data memory data\\n    ) public view {\\n        DynamicBuffer.appendUnchecked(\\n            buffer,\\n            bytes(\\\"<svg xmlns='http://www.w3.org/2000/svg' viewBox='\\\")\\n        );\\n\\n        uint256 xU;\\n        if (x < 0) {\\n            DynamicBuffer.appendUnchecked(buffer, bytes(\\\"-\\\"));\\n            xU = uint256(-x);\\n        } else {\\n            xU = uint256(x);\\n        }\\n\\n        DynamicBuffer.appendUnchecked(buffer, bytes(xU.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\" \\\"));\\n\\n        uint256 yU;\\n        if (y < 0) {\\n            DynamicBuffer.appendUnchecked(buffer, bytes(\\\"-\\\"));\\n            yU = uint256(-y);\\n        } else {\\n            yU = uint256(y);\\n        }\\n\\n        DynamicBuffer.appendUnchecked(buffer, bytes(yU.toString()));\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\" \\\"));\\n        DynamicBuffer.appendUnchecked(\\n            buffer,\\n            bytes((data.frameSize + padding).toString())\\n        );\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\" \\\"));\\n        DynamicBuffer.appendUnchecked(\\n            buffer,\\n            bytes((data.frameSize + padding).toString())\\n        );\\n        bytes memory header = bytes(_assets.getHeader());\\n        header[2514] = blur;\\n        DynamicBuffer.appendUnchecked(buffer, header);\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"<g id='r'>\\\"));\\n        _path(buffer, data.pathHue, data.pathSat, data.pathLum, data.pathHue);\\n    }\\n\\n    function svgTemplate2(bytes memory buffer) public pure {\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"</g>\\\"));\\n        DynamicBuffer.appendUnchecked(buffer, bytes(\\\"</svg>\\\"));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"mintBegin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queueBegin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMintingFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceIncrement_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assets\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rotation\",\"type\":\"uint256\"}],\"name\":\"_path\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"wallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"positions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"circleAnimation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"}],\"name\":\"circle\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subjectIndex\",\"type\":\"uint256\"}],\"name\":\"explore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"bytes1\",\"name\":\"id\",\"type\":\"bytes1\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"}],\"name\":\"gradient\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positions\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintBegin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"freeAmount\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mintDiscount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintPrivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queueBegin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"}],\"name\":\"rectGradientAttributes\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"color\",\"type\":\"uint8\"}],\"name\":\"rectSolidAttributes\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"animation\",\"type\":\"bytes1\"},{\"internalType\":\"bytes\",\"name\":\"scale\",\"type\":\"bytes\"}],\"name\":\"rectTemplate1\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"}],\"name\":\"rectTemplate2\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"plain\",\"type\":\"bool\"}],\"name\":\"renderCurrent\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assets\",\"type\":\"address\"}],\"name\":\"setAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceIncrement_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMintingFee_\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBlocksRich_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlocksPlain_\",\"type\":\"uint256\"}],\"name\":\"setRenderingThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintBegin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queueBegin_\",\"type\":\"uint256\"}],\"name\":\"setTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"},{\"internalType\":\"bytes1\",\"name\":\"blur\",\"type\":\"bytes1\"},{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"padding\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"pathSat\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"pathLum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"minX\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minY\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxX\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxY\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"zoomX\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"zoomY\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lengthX\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lengthY\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"frameSize\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"showSquares\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pathHue\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pathRotation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"zoomedSquare\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"segments\",\"type\":\"uint32\"},{\"internalType\":\"uint32[2][100]\",\"name\":\"coords\",\"type\":\"uint32[2][100]\"},{\"internalType\":\"int32[2][100]\",\"name\":\"increments\",\"type\":\"int32[2][100]\"}],\"internalType\":\"struct SVG.Data\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"svgTemplate1\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"buffer\",\"type\":\"bytes\"}],\"name\":\"svgTemplate2\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"walletAtIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"wallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Queue", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000012a1214000000000000000000000000000000000000000000000000000000000129be4300000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000045373e6504de640f63a1c7b95662e12cbadf0b330000000000000000000000000000000000000000000000000000000000000009546865205175657565000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015100000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}