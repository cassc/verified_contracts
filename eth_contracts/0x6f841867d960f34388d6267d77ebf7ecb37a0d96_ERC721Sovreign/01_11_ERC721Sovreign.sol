/*----------------------------------------------------------*|
|*          ███    ██ ██ ███    ██ ███████  █████           *|
|*          ████   ██ ██ ████   ██ ██      ██   ██          *|
|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|
|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|
|*          ██   ████ ██ ██   ████ ██      ██   ██          *|
|*----------------------------------------------------------*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "../extensions/ERC721Enumerable.sol";
import "../extensions/ERC721URIStorage.sol";
import "../extensions/ERC721Burnable.sol";
import "../../common/ERC2981NSovreign.sol";
import "../../../access/AccessControl.sol";

/*************************************************************
 * @title ERC721Sovreign                                     *
 *                                                           *
 * @notice Self-sovreign ERC-721 minter preset               *
 *                                                           *
 * @dev {ERC721} token                                       *
 *                                                           *
 * @custom:security-contact [email protected]                    *
 ************************************************************/

contract ERC721Sovreign is
    ERC721Enumerable,
    ERC721Burnable,
    ERC721URIStorage,
    ERC2981NSovreign,
    AccessControl
{
    /*----------------------------------------------------------*|
    |*  # ACCESS CONTROL                                        *|
    |*----------------------------------------------------------*/

    /**
     * @dev `MINTER_ROLE` is needed in case the deployer may want to use or allow other accounts to mint on their self-sovreign collection
     */
    bytes32 private constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; // keccak256("MINTER_ROLE");
    /**
     * @dev constant set at deployment of master contract, replaces `initializer` modifier reducing the cost of calling `initialize` from the factory contract when a new clone is deployed.
     */
    address private immutable _FACTORY;

    /*----------------------------------------------------------*|
    |*  # MINTING                                               *|
    |*----------------------------------------------------------*/

    /**
     * @dev Implements interface function {IERC721-mint}. Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * @param _tokenURI Replaces deprecated Openzeppelin contracts v4.0 `ERC721URIStorage` extension
     *      See https://forum.openzeppelin.com/t/why-doesnt-openzeppelin-erc721-contain-settokenuri/6373 and https://forum.openzeppelin.com/t/function-settokenuri-in-erc721-is-gone-with-pragma-0-8-0/5978/2
     * @dev when minted for the first time, royalty recipient MUST be set to msg.sender, i.e. minter/artist;
     *      royalty receipient cannot and SHOULD not be set to an address different than the minter's such as a payment splitter or else `setRoyaltyRecipient` function will revert when called (unless receiver )
     */
    function mint(
        bytes32 _tokenURI,
        uint24 royaltyBps_,
        uint24[] calldata recipientsBps_,
        address[] calldata royaltyRecipients_
    ) public onlyRole(MINTER_ROLE) {
        /*----------------------------------------------------------*|
        |*  # MINT                                                  *|
        |*----------------------------------------------------------*/

        uint256 tokenId = _owners.length;
        _mint(msg.sender, tokenId);

        /*----------------------------------------------------------*|
        |*  # URI STORAGE                                           *|
        |*----------------------------------------------------------*/

        _setTokenURI(tokenId, _tokenURI);
        setRoyaltyInfo(
            tokenId,
            royaltyBps_,
            recipientsBps_,
            royaltyRecipients_
        );
    }

    /**
     * @dev Implements interface function {IERC721-mint}. Creates a new token for `msg.sender`. Its token ID will be automatically
     *      assigned (and available on the emitted {IERC721-Transfer} event), and the token
     *      URI autogenerated based on the base URI passed at construction.
     * @dev it is assumed that the caller is the minter and thus the owner of the token,
     *      therefore instead of calling the internal _transfer function, the tansfer logic has been reimplemented in this function
     *      in order to avoid unnecessary `require` statements.
     * @dev when minted for the first time, royalty recipient MUST be set to msg.sender, i.e. minter/artist;
     *      royalty receipient MUST not be set to an address different than the minter's such as a payment splitter or else this function will revert
     */
    function mintAndTransfer(
        address _to,
        bytes32 _tokenURI,
        uint24 royaltyBps_,
        uint24[] calldata recipientsBps_,
        address[] calldata royaltyRecipients_,
        bytes calldata _data
    ) external onlyRole(MINTER_ROLE) {
        /*----------------------------------------------------------*|
        |*  # MINT                                                  *|
        |*----------------------------------------------------------*/

        uint256 tokenId = _owners.length;
        _mintAndTransfer(msg.sender, _to, tokenId, _data);

        /*----------------------------------------------------------*|
        |*  # URI STORAGE                                           *|
        |*----------------------------------------------------------*/

        _setTokenURI(tokenId, _tokenURI);
        setRoyaltyInfo(
            tokenId,
            royaltyBps_,
            recipientsBps_,
            royaltyRecipients_
        );
    }

    /*----------------------------------------------------------*|
    |*  # ROYALTY INFO SETTER                                   *|
    |*----------------------------------------------------------*/

    function setRoyaltyInfo(
        uint256 tokenId_,
        uint24 royaltyBps_,
        uint24[] calldata recipientsBps_,
        address[] calldata royaltyRecipients_
    ) public onlyRole(MINTER_ROLE) {
        _setRoyalties(
            tokenId_,
            royaltyBps_,
            recipientsBps_,
            royaltyRecipients_
        );
    }

    /*----------------------------------------------------------*|
    |*  # URI STORAGE                                           *|
    |*----------------------------------------------------------*/

    function setBaseURI(string calldata baseURI_) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
        _setBaseURI(baseURI_);
    }

    /*----------------------------------------------------------*|
    |*  # OVERRIDES                                             *|
    |*----------------------------------------------------------*/

    function _burn(
        uint256 tokenId
    ) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
        _resetTokenRoyalty(tokenId);
    }

    /*----------------------------------------------------------*|
    |*  # VIEW FUNCTIONS                                        *|
    |*----------------------------------------------------------*/

    /**
     * @dev same function interface as erc1155, so that external contracts, i.e. the marketplace, can check either erc without requiring an if/else statement
     */
    function exists(uint256 _id) external view returns (bool) {
        return _owners[_id] != address(0);
    }

    /*----------------------------------------------------------*|
    |*  # ERC-165                                               *|
    |*----------------------------------------------------------*/

    /**
     * @dev See {IERC165-supportsInterface}.
     * `supportsInterface()` was first implemented by all contracts and later all implementations removed, hardcoding interface IDs in order to save some gas and simplify the code.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) external pure returns (bool) {
        return
            interfaceId == 0x80ac58cd || // type(IERC721).interfaceId
            interfaceId == 0x780e9d63 || // type(IERC721Enumerable).interfaceId
            interfaceId == 0x01ffc9a7 || // type(IERC165).interfaceId
            interfaceId == 0x2a55205a || // type(IERC2981).interfaceId
            interfaceId == 0x7965db0b; // type(IAccessControl).interfaceId;
    }

    /*----------------------------------------------------------*|
    |*  # INITIALIZATION                                        *|
    |*----------------------------------------------------------*/

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the account that deploys the contract.
     *      `MINTER_ROLE` is needed in case the deployer may want to use or allow other accounts to mint on their self-sovreign collection
     */
    function initialize(bytes calldata _data) external {
        require(msg.sender == _FACTORY);

        address owner;
        (name, symbol, owner) = abi.decode(_data, (string, string, address));

        // setRoyaltyInfo(royaltyRecipient, royaltyBps);

        _grantRole(DEFAULT_ADMIN_ROLE, owner); // DEFAULT_ADMIN_ROLE is by default admin of all other roles, i.e. MINTER_ROLE, meaning it can assign MINTER_ROLE to other addresses _grantRole(MINTER_ROLE, msg.sender); // grant MINTER_ROLE to factory contract
        _grantRole(MINTER_ROLE, owner); // grant MINTER_ROLE to owner, this way minting requires only checking for MINTER_ROLE rather than DEFAULT_ADMIN_ROLE, allowing the deployer/admin to grant MINTER_ROLE to other addresses.
    }

    constructor(address factory_) {
        _FACTORY = factory_;
    }
}