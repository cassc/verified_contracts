{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/VerifyTrieProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  _____     _ _         _         _\\n// |_   _|_ _(_) |_____  | |   __ _| |__ ___\\n//   | |/ _` | | / / _ \\\\ | |__/ _` | '_ (_-<\\n//   |_|\\\\__,_|_|_\\\\_\\\\___/ |____\\\\__,_|_.__/__/\\n\\npragma solidity 0.8.24;\\n\\nimport \\\"../thirdparty/optimism/rlp/RLPReader.sol\\\";\\nimport \\\"../thirdparty/optimism/rlp/RLPWriter.sol\\\";\\nimport \\\"../thirdparty/optimism/trie/SecureMerkleTrie.sol\\\";\\n\\n/// @title VerifyTrieProof\\n/// @custom:security-contact security@taiko.xyz\\ncontract VerifyTrieProof {\\n    // The consensus format representing account is RLP encoded in the\\n    // following order: nonce, balance, storageHash, codeHash.\\n    uint256 private constant _ACCOUNT_FIELD_INDEX_STORAGE_HASH = 2;\\n\\n    error VTP_INVALID_ACCOUNT_PROOF();\\n    error VTP_INVALID_INCLUSION_PROOF();\\n\\n    /// @notice Verifies that the value of a slot in the storage of an account is value.\\n    ///\\n    /// @param _rootHash The merkle root of state tree or the account tree. If accountProof's length\\n    /// is zero, it is used as the account's storage root, otherwise it will be used as the state\\n    /// root.\\n    /// @param _addr The address of contract.\\n    /// @param _slot The slot in the contract.\\n    /// @param _value The value to be verified.\\n    /// @param _accountProof The account proof\\n    /// @param _storageProof The storage proof\\n    /// @return storageRoot_ The account's storage root\\n    function verifyMerkleProof(\\n        bytes32 _rootHash,\\n        address _addr,\\n        bytes32 _slot,\\n        bytes32 _value,\\n        bytes[] memory _accountProof,\\n        bytes[] memory _storageProof\\n    )\\n        public\\n        pure\\n        returns (bytes32 storageRoot_)\\n    {\\n        if (_accountProof.length != 0) {\\n            bytes memory rlpAccount =\\n                SecureMerkleTrie.get(abi.encodePacked(_addr), _accountProof, _rootHash);\\n\\n            if (rlpAccount.length == 0) revert VTP_INVALID_ACCOUNT_PROOF();\\n\\n            RLPReader.RLPItem[] memory accountState = RLPReader.readList(rlpAccount);\\n\\n            storageRoot_ =\\n                bytes32(RLPReader.readBytes(accountState[_ACCOUNT_FIELD_INDEX_STORAGE_HASH]));\\n        } else {\\n            storageRoot_ = _rootHash;\\n        }\\n\\n        bool verified = SecureMerkleTrie.verifyInclusionProof(\\n            bytes.concat(_slot), RLPWriter.writeUint(uint256(_value)), _storageProof, storageRoot_\\n        );\\n\\n        if (!verified) revert VTP_INVALID_INCLUSION_PROOF();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/optimism/rlp/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n/// @title RLPReader\\n/// @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n///         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n///         various tweaks to improve readability. (A shout-out to Optimism !)\\nlibrary RLPReader {\\n    /// @notice Custom pointer type to avoid confusion between pointers and uint256s.\\n    type MemoryPointer is uint256;\\n\\n    /// @notice RLP item types.\\n    /// @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n    /// @custom:value LIST_ITEM Represents an RLP list item.\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /// @notice Struct representing an RLP item.\\n    /// @custom:field length Length of the RLP item.\\n    /// @custom:field ptr    Pointer to the RLP item in memory.\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /// @notice Max list length that this library will accept.\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /// @notice Converts bytes to a reference to memory position and length.\\n    /// @param _in Input bytes to convert.\\n    /// @return out_ Output memory reference.\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {\\n        // Empty arrays are not RLP items.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        out_ = RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"RLPReader: decoded item type for list is not a list item\\\"\\n        );\\n\\n        require(\\n            listOffset + listLength == _in.length,\\n            \\\"RLPReader: list item has an invalid data remainder\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        out_ = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(\\n                RLPItem({\\n                    length: _in.length - offset,\\n                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n                })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out_[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out_, itemCount)\\n        }\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {\\n        out_ = readList(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"RLPReader: decoded item type for bytes is not a data item\\\"\\n        );\\n\\n        require(\\n            _in.length == itemOffset + itemLength,\\n            \\\"RLPReader: bytes value contains an invalid remainder\\\"\\n        );\\n\\n        out_ = _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        out_ = readBytes(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads the raw bytes of an RLP item.\\n    /// @param _in RLP item to read.\\n    /// @return out_ Raw RLP bytes.\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        out_ = _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /// @notice Decodes the length of an RLP item.\\n    /// @param _in RLP item to decode.\\n    /// @return offset_ Offset of the encoded data.\\n    /// @return length_ Length of the encoded data.\\n    /// @return type_ RLP item type (LIST_ITEM or DATA_ITEM).\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (uint256 offset_, uint256 length_, RLPItemType type_)\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"RLPReader: length of content must be greater than string length (short string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                strLen != 1 || firstByteOfContent >= 0x80,\\n                \\\"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"RLPReader: length of content must be > than length of string length (long string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long string)\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                strLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long string)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"RLPReader: length of content must be greater than total length (long string)\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"RLPReader: length of content must be greater than list length (short list)\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"RLPReader: length of content must be > than length of list length (long list)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long list)\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                listLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long list)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"RLPReader: length of content must be greater than total length (long list)\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /// @notice Copies the bytes from a memory location.\\n    /// @param _src    Pointer to the location to read from.\\n    /// @param _offset Offset to start reading from.\\n    /// @param _length Number of bytes to read.\\n    /// @return out_ Copied bytes.\\n    function _copy(\\n        MemoryPointer _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (bytes memory out_)\\n    {\\n        out_ = new bytes(_length);\\n        if (_length == 0) {\\n            return out_;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // solhint-disable max-line-length\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out_, 32)\\n            let i := 0\\n            for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }\\n\\n            if gt(i, _length) { mstore(add(dest, _length), 0) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/optimism/rlp/RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n/// @title RLPWriter\\n/// @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n///         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n///         modifications to improve legibility. (A shout-out to Optimism !)\\nlibrary RLPWriter {\\n    /// @notice RLP encodes a byte string.\\n    /// @param _in The byte string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            out_ = _in;\\n        } else {\\n            out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n    }\\n\\n    /// @notice RLP encodes a uint.\\n    /// @param _in The uint256 to encode.\\n    /// @return out_ The RLP encoded uint256 in bytes.\\n    function writeUint(uint256 _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(_toBinary(_in));\\n    }\\n\\n    /// @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n    /// @param _len    The length of the string or the payload.\\n    /// @param _offset 128 if item is string, 192 if item is list.\\n    /// @return out_ RLP encoded bytes.\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {\\n        if (_len < 56) {\\n            out_ = new bytes(1);\\n            out_[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            out_ = new bytes(lenLen + 1);\\n            out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n    }\\n\\n    /// @notice Encode integer in big endian binary form with no leading zeroes.\\n    /// @param _x The integer to encode.\\n    /// @return out_ RLP encoded bytes.\\n    function _toBinary(uint256 _x) private pure returns (bytes memory out_) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        out_ = new bytes(32 - i);\\n        for (uint256 j = 0; j < out_.length; j++) {\\n            out_[j] = b[i++];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport { MerkleTrie } from \\\"./MerkleTrie.sol\\\";\\n\\n/// @title SecureMerkleTrie\\n/// @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\\n///         keys. Ethereum's state trie hashes input keys before storing them.\\nlibrary SecureMerkleTrie {\\n    /// @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        valid_ = MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bytes memory value_)\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        value_ = MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /// @notice Computes the hashed version of the input key.\\n    /// @param _key Key to hash.\\n    /// @return hash_ Hashed version of the key.\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) {\\n        hash_ = abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/optimism/trie/MerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport { Bytes } from \\\"../Bytes.sol\\\";\\nimport { RLPReader } from \\\"../rlp/RLPReader.sol\\\";\\n\\n/// @title MerkleTrie\\n/// @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\\n///         inclusion proofs. By default, this library assumes a hexary trie. One can change the\\n///         trie radix constant to support other trie radixes.\\nlibrary MerkleTrie {\\n    /// @notice Struct representing a node in the trie.\\n    /// @custom:field encoded The RLP-encoded node.\\n    /// @custom:field decoded The RLP-decoded node.\\n    struct TrieNode {\\n        bytes encoded;\\n        RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /// @notice Determines the number of elements per branch node.\\n    uint256 internal constant TREE_RADIX = 16;\\n\\n    /// @notice Branch nodes have TREE_RADIX elements and one value element.\\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n\\n    /// @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    /// @notice Prefix for even-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\\n\\n    /// @notice Prefix for odd-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\\n\\n    /// @notice Prefix for even-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\\n\\n    /// @notice Prefix for odd-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\\n\\n    /// @notice Verifies a proof that a given key/value pair is present in the trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        valid_ = Bytes.equal(_value, get(_key, _proof, _root));\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(\\n        bytes memory _key,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bytes memory value_)\\n    {\\n        require(_key.length > 0, \\\"MerkleTrie: empty key\\\");\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        bytes memory key = Bytes.toNibbles(_key);\\n        bytes memory currentNodeID = abi.encodePacked(_root);\\n        uint256 currentKeyIndex = 0;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            TrieNode memory currentNode = proof[i];\\n\\n            // Key index should never exceed total key length or we'll be out of bounds.\\n            require(currentKeyIndex <= key.length, \\\"MerkleTrie: key index exceeds total key length\\\");\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 32 bytes aren't hashed.\\n                require(\\n                    Bytes.equal(currentNode.encoded, currentNodeID),\\n                    \\\"MerkleTrie: invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // Value is the last element of the decoded list (for branch nodes). There's\\n                    // some ambiguity in the Merkle trie specification because bytes(0) is a\\n                    // valid value to place into the trie, but for branch nodes bytes(0) can exist\\n                    // even when the value wasn't explicitly placed there. Geth treats a value of\\n                    // bytes(0) as \\\"key does not exist\\\" and so we do the same.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);\\n                    require(\\n                        value_.length > 0,\\n                        \\\"MerkleTrie: value length must be greater than zero (branch)\\\"\\n                    );\\n\\n                    // Extra proof elements are not allowed.\\n                    require(\\n                        i == proof.length - 1,\\n                        \\\"MerkleTrie: value node must be last node in proof (branch)\\\"\\n                    );\\n\\n                    return value_;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIndex += 1;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Bytes.slice(path, offset);\\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                // Whether this is a leaf node or an extension node, the path remainder MUST be a\\n                // prefix of the key remainder (or be equal to the key remainder) or the proof is\\n                // considered invalid.\\n                require(\\n                    pathRemainder.length == sharedNibbleLength,\\n                    \\\"MerkleTrie: path remainder must share all nibbles with key\\\"\\n                );\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,\\n                    // the key remainder must be exactly equal to the path remainder. We already\\n                    // did the necessary byte comparison, so it's more efficient here to check that\\n                    // the key remainder length equals the shared nibble length, which implies\\n                    // equality with the path remainder (since we already did the same check with\\n                    // the path remainder and the shared nibble length).\\n                    require(\\n                        keyRemainder.length == sharedNibbleLength,\\n                        \\\"MerkleTrie: key remainder must be identical to path remainder\\\"\\n                    );\\n\\n                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum\\n                    // state trie. Empty values are not allowed in the state trie, so we can safely\\n                    // say that if the value is empty, the key should not exist and the proof is\\n                    // invalid.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[1]);\\n                    require(\\n                        value_.length > 0,\\n                        \\\"MerkleTrie: value length must be greater than zero (leaf)\\\"\\n                    );\\n\\n                    // Extra proof elements are not allowed.\\n                    require(\\n                        i == proof.length - 1,\\n                        \\\"MerkleTrie: value node must be last node in proof (leaf)\\\"\\n                    );\\n\\n                    return value_;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node\\n                    // in the proof and increment the key index by the length of the path remainder\\n                    // which is equal to the shared nibble length.\\n                    currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                    currentKeyIndex += sharedNibbleLength;\\n                } else {\\n                    revert(\\\"MerkleTrie: received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"MerkleTrie: received an unparseable node\\\");\\n            }\\n        }\\n\\n        revert(\\\"MerkleTrie: ran out of proof elements\\\");\\n    }\\n\\n    /// @notice Parses an array of proof elements into a new array that contains both the original\\n    ///         encoded element and the RLP-decoded element.\\n    /// @param _proof Array of proof elements to parse.\\n    /// @return proof_ Proof parsed into easily accessible structs.\\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {\\n        uint256 length = _proof.length;\\n        proof_ = new TrieNode[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\\n        }\\n    }\\n\\n    /// @notice Picks out the ID for a node. Node ID is referred to as the \\\"hash\\\" within the\\n    ///         specification, but nodes < 32 bytes are not actually hashed.\\n    /// @param _node Node to pull an ID for.\\n    /// @return id_ ID for the node, depending on the size of its contents.\\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) {\\n        id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\\n    }\\n\\n    /// @notice Gets the path for a leaf or extension node.\\n    /// @param _node Node to get a path for.\\n    /// @return nibbles_ Node path, converted to an array of nibbles.\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) {\\n        nibbles_ = Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /// @notice Utility; determines the number of nibbles shared between two nibble arrays.\\n    /// @param _a First nibble array.\\n    /// @param _b Second nibble array.\\n    /// @return shared_ Number of shared nibbles.\\n    function _getSharedNibbleLength(\\n        bytes memory _a,\\n        bytes memory _b\\n    )\\n        private\\n        pure\\n        returns (uint256 shared_)\\n    {\\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\\n        for (; shared_ < max && _a[shared_] == _b[shared_];) {\\n            unchecked {\\n                ++shared_;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/optimism/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title Bytes\\n/// @notice Bytes is a library for manipulating byte arrays.\\nlibrary Bytes {\\n    /// @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n    /// @notice Slices a byte array with a given starting index and length. Returns a new byte array\\n    ///         as opposed to a pointer to the original array. Will throw if trying to slice more\\n    ///         bytes than exist in the array.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @param _length Length of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n            require(_start + _length >= _start, \\\"slice_overflow\\\");\\n            require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } { mstore(mc, mload(cc)) }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// @notice Slices a byte array with a given starting index up to the end of the original byte\\n    ///         array. Returns a new array rather than a pointer to the original.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    /// @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\\n    ///         Resulting nibble array will be exactly twice as long as the input byte array.\\n    /// @param _bytes Input byte array to convert.\\n    /// @return Resulting nibble array.\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory _nibbles;\\n        assembly {\\n            // Grab a free memory offset for the new array\\n            _nibbles := mload(0x40)\\n\\n            // Load the length of the passed bytes array from memory\\n            let bytesLength := mload(_bytes)\\n\\n            // Calculate the length of the new nibble array\\n            // This is the length of the input array times 2\\n            let nibblesLength := shl(0x01, bytesLength)\\n\\n            // Update the free memory pointer to allocate memory for the new array.\\n            // To do this, we add the length of the new array + 32 bytes for the array length\\n            // rounded up to the nearest 32 byte boundary to the current free memory pointer.\\n            mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))\\n\\n            // Store the length of the new array in memory\\n            mstore(_nibbles, nibblesLength)\\n\\n            // Store the memory offset of the _bytes array's contents on the stack\\n            let bytesStart := add(_bytes, 0x20)\\n\\n            // Store the memory offset of the nibbles array's contents on the stack\\n            let nibblesStart := add(_nibbles, 0x20)\\n\\n            // Loop through each byte in the input array\\n            for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {\\n                // Get the starting offset of the next 2 bytes in the nibbles array\\n                let offset := add(nibblesStart, shl(0x01, i))\\n                // Load the byte at the current index within the `_bytes` array\\n                let b := byte(0x00, mload(add(bytesStart, i)))\\n\\n                // Pull out the first nibble and store it in the new array\\n                mstore8(offset, shr(0x04, b))\\n                // Pull out the second nibble and store it in the new array\\n                mstore8(add(offset, 0x01), and(b, 0x0F))\\n            }\\n        }\\n        return _nibbles;\\n    }\\n\\n    /// @notice Compares two byte arrays by comparing their keccak256 hashes.\\n    /// @param _bytes First byte array to compare.\\n    /// @param _other Second byte array to compare.\\n    /// @return true if the two byte arrays are equal, false otherwise.\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"solady/=node_modules/solady/\",\r\n      \"forge-std/=node_modules/forge-std/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"p256-verifier/=node_modules/p256-verifier/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"VTP_INVALID_ACCOUNT_PROOF\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VTP_INVALID_INCLUSION_PROOF\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"_accountProof\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_storageProof\",\"type\":\"bytes[]\"}],\"name\":\"verifyMerkleProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"storageRoot_\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "VerifyTrieProof", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}