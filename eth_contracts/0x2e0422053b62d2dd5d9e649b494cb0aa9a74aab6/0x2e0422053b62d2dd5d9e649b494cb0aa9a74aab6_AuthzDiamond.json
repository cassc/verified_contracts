{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/AuthzDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"../facets/task-executor/TaskExecutorLib.sol\\\";\\nimport \\\"../facets/rbac/RBACLib.sol\\\";\\nimport \\\"./IDiamond.sol\\\";\\nimport \\\"./IDiamondFacet.sol\\\";\\nimport \\\"./FacetManager.sol\\\";\\nimport \\\"./IAuthzDiamondInitializer.sol\\\";\\nimport \\\"./IAuthz.sol\\\";\\n\\n/// @notice Use at your own risk\\nlibrary AuthzDiamondInfo {\\n    string public constant VERSION = \\\"2.3.0\\\";\\n}\\n\\ncontract AuthzDiamond is IDiamond, IAuthzDiamondInitializer {\\n\\n    string private _name;\\n    string private _detailsURI;\\n\\n    address private _initializer;\\n    bool private _initialized;\\n    bool private _paused;\\n\\n    event Transfer(\\n        uint8 contractType,\\n        address contractAddr,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount,\\n        string data\\n    );\\n\\n    modifier mustBeInitialized() {\\n        require(_initialized, \\\"ADMND:NI\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthzDiamondAdmin() {\\n        require(RBACLib._hasRole(msg.sender, AuthzLib.ROLE_AUTHZ_DIAMOND_ADMIN), \\\"ADMND:MR\\\");\\n        _;\\n    }\\n\\n    constructor(address initializer) {\\n        _initialized = false;\\n        _initializer = initializer;\\n    }\\n\\n    function initialize(\\n        string memory name,\\n        address taskManager,\\n        address[] memory authzAdmins,\\n        address[] memory authzDiamondAdmins\\n    ) external override {\\n        require(!_initialized, \\\"ADMND:AI\\\");\\n        require(msg.sender == _initializer, \\\"ADMND:WI\\\");\\n        _name = name;\\n        TaskExecutorLib._initialize(taskManager);\\n        for(uint i = 0; i < authzDiamondAdmins.length; i++) {\\n            RBACLib._unsafeGrantRole(\\n                authzDiamondAdmins[i],\\n                AuthzLib.ROLE_AUTHZ_DIAMOND_ADMIN);\\n        }\\n        for(uint i = 0; i < authzAdmins.length; i++) {\\n            RBACLib._unsafeGrantRole(authzAdmins[i], AuthzLib.ROLE_AUTHZ_ADMIN);\\n        }\\n        _initialized = true;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n      public view override mustBeInitialized virtual returns (bool) {\\n        // Querying for IDiamond must always return true\\n        if (\\n            interfaceId == 0xd4bbd4bb ||\\n            interfaceId == type(IDiamond).interfaceId\\n        ) {\\n            return true;\\n        }\\n        // Querying for IDiamondFacet must always return false\\n        if (interfaceId == type(IDiamondFacet).interfaceId) {\\n            return false;\\n        }\\n        // Always return true\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        address[] memory facets = FacetManagerLib._getFacets();\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            address facet = facets[i];\\n            if (!FacetManagerLib._isFacetDeleted(facet) &&\\n                IDiamondFacet(facet).supportsInterface(interfaceId)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function isInitialized() external view returns (bool) {\\n        return _initialized;\\n    }\\n\\n    function getDiamondName()\\n    external view virtual mustBeInitialized override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getDiamondVersion()\\n    external view virtual mustBeInitialized override returns (string memory) {\\n        return AuthzDiamondInfo.VERSION;\\n    }\\n\\n    function setDiamondName(\\n        string memory name\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        _name = name;\\n    }\\n\\n    function getDetailsURI() external view mustBeInitialized returns (string memory) {\\n        return _detailsURI;\\n    }\\n\\n    function setDetailsURI(\\n        string memory detailsURI\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        _detailsURI = detailsURI;\\n    }\\n\\n    function getTaskManager() external view mustBeInitialized returns (address) {\\n        return TaskExecutorLib._getTaskManager(\\\"DEFAULT\\\");\\n    }\\n\\n    function isDiamondFrozen() external view mustBeInitialized returns (bool) {\\n        return FacetManagerLib._isDiamondFrozen();\\n    }\\n\\n    function freezeDiamond(\\n        string memory taskManagerKey,\\n        uint256 adminTaskId\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._freezeDiamond();\\n        TaskExecutorLib._executeAdminTask(taskManagerKey, adminTaskId);\\n    }\\n\\n    function isDiamondLocked() external view mustBeInitialized returns (bool) {\\n        return FacetManagerLib._isDiamondLocked();\\n    }\\n\\n    function setLocked(\\n        string memory taskManagerKey,\\n        uint256 taskId,\\n        bool locked\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._setLocked(locked);\\n        TaskExecutorLib._executeTask(taskManagerKey, taskId);\\n    }\\n\\n    function getFacets()\\n    external view mustBeInitialized override returns (address[] memory) {\\n        return FacetManagerLib._getFacets();\\n    }\\n\\n    function resolve(string[] memory funcSigs)\\n    external view mustBeInitialized returns (address[] memory) {\\n        return FacetManagerLib._resolve(funcSigs);\\n    }\\n\\n    function addFacets(\\n        address[] memory facets\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._addFacets(facets);\\n    }\\n\\n    function deleteFacets(\\n        address[] memory facets\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._deleteFacets(facets);\\n    }\\n\\n    function replaceFacets(\\n        address[] memory toBeDeletedFacets,\\n        address[] memory toBeAddedFacets\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._replaceFacets(toBeDeletedFacets, toBeAddedFacets);\\n    }\\n\\n    function deleteAllFacets() external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._deleteAllFacets();\\n    }\\n\\n    function overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        FacetManagerLib._overrideFuncSigs(funcSigs, facets);\\n    }\\n\\n    function getOverridenFuncSigs()\\n    external view mustBeInitialized returns (string[] memory) {\\n        return FacetManagerLib._getOverridenFuncSigs();\\n    }\\n\\n    function transferTo(\\n        uint8 contractType,\\n        address contractAddr,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount,\\n        string memory data\\n    ) external onlyAuthzDiamondAdmin {\\n        if (contractAddr == address(0)) {\\n            require(amount <= address(this).balance, \\\"DMND:NIB\\\");\\n            /* solhint-disable avoid-low-level-calls */\\n            (bool success, ) = to.call{value: amount}(new bytes(0));\\n            /* solhint-enable avoid-low-level-calls */\\n            require(success, \\\"DMND:TF\\\");\\n            emit Transfer(contractType, contractAddr, to, tokenId, amount, data);\\n        } else if (contractType == 1) { // erc20\\n            address erc20 = contractAddr;\\n            require(amount > 0, \\\"FHI:ZAM\\\");\\n            require(amount <= IERC20(erc20).balanceOf(address(this)), \\\"DMND:NIB2\\\");\\n            bool success = IERC20(erc20).transfer(to, amount);\\n            require(success, \\\"FHI:TF2\\\");\\n            emit Transfer(contractType, contractAddr, to, tokenId, amount, data);\\n        } else if (contractType == 2) { // erc721\\n            address erc721 = contractAddr;\\n            require(IERC721(erc721).ownerOf(tokenId) == address(this), \\\"DMND:NOWN\\\");\\n            IERC721(erc721).transferFrom(address(this), to, tokenId);\\n            emit Transfer(contractType, contractAddr, to, tokenId, amount, data);\\n        } else if (contractType == 3) { // erc1155\\n            address erc1155 = contractAddr;\\n            require(amount > 0, \\\"FHI:ZAM2\\\");\\n            require(amount <= IERC1155(erc1155).balanceOf(address(this), tokenId), \\\"DMND:NIB3\\\");\\n            IERC1155(erc1155).safeTransferFrom(address(this), to, tokenId, amount, bytes(data));\\n            emit Transfer(contractType, contractAddr, to, tokenId, amount, data);\\n        } else {\\n            revert(\\\"DMND:CNSUPP\\\");\\n        }\\n    }\\n\\n    function setPaused(bool paused) external mustBeInitialized onlyAuthzDiamondAdmin {\\n        _paused = paused;\\n    }\\n\\n    /* solhint-disable no-complex-fallback */\\n    fallback() external payable {\\n        require(_initialized, \\\"ADMND:NI\\\");\\n        require(!_paused, \\\"ADMND:PAUS\\\");\\n        address facet = FacetManagerLib._findFacet(msg.sig);\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n\\n    /* solhint-disable no-empty-blocks */\\n    receive() external payable {}\\n    /* solhint-enable no-empty-blocks */\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/FacetManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"./IDiamondFacet.sol\\\";\\n\\n/// @notice Use at your own risk. Just got the basic\\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\\nlibrary FacetManagerStorage {\\n\\n    struct Layout {\\n        // true if diamond is frozen meaning it cannot be changed anymore.\\n        // ATTENTION! once frozen, one WILL NEVER be able to undo that.\\n        bool diamondFrozen;\\n        // true if diamond is locked, meaning it cannot be changed anymore.\\n        // diamonds can be unlocked.\\n        bool diamondLocked;\\n        // list of facet addersses\\n        address[] facets;\\n        mapping(address => uint256) facetsIndex;\\n        // facet address > true if marked as deleted\\n        mapping(address => bool) deletedFacets;\\n        // function selector > facet address\\n        mapping(bytes4 => address) selectorToFacetMap;\\n        // list of overriden function signatures\\n        string[] overridenFuncSigs;\\n        mapping(string => uint256) overridenFuncSigsIndex;\\n        // facet address > true if frozen\\n        mapping(address => bool) frozenFacets;\\n        // function signature > true if protected\\n        mapping(bytes4 => bool) protectedSelectorMap;\\n        // Extra fields (reserved for future)\\n        mapping(bytes32 => bytes) extra;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"qomet-tech.contracts.diamond.facet-manager.storage\\\");\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            s.slot := slot\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\\nlibrary FacetManagerLib {\\n\\n    event FacetAdd(address facet);\\n    event FacetDelete(address facet);\\n    event FreezeDiamond();\\n    event SetLocked(bool locked);\\n    event FuncSigOverride(string funcSig, address facet);\\n    event ProtectFuncSig(string funcSig, bool protect);\\n\\n    function _isDiamondFrozen() internal view returns (bool) {\\n        return __s().diamondFrozen;\\n    }\\n\\n    function _freezeDiamond() internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        __s().diamondFrozen = true;\\n        emit FreezeDiamond();\\n    }\\n\\n    function _isFacetFrozen(address facet) internal view returns (bool) {\\n        return __s().frozenFacets[facet];\\n    }\\n\\n    function _freezeFacet(address facet) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(!__s().frozenFacets[facet], \\\"FMLIB:FAF\\\");\\n        __s().frozenFacets[facet] = true;\\n    }\\n\\n    function _isDiamondLocked() internal view returns (bool) {\\n        return __s().diamondLocked;\\n    }\\n\\n    function _setLocked(bool locked) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        __s().diamondLocked = locked;\\n        emit SetLocked(locked);\\n    }\\n\\n    function _getFacets() internal view returns (address[] memory) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            if (!__s().deletedFacets[__s().facets[i]]) {\\n                count += 1;\\n            }\\n        }\\n        address[] memory facets = new address[](count);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            if (!__s().deletedFacets[__s().facets[i]]) {\\n                facets[index] = __s().facets[i];\\n                index += 1;\\n            }\\n        }\\n        return facets;\\n    }\\n\\n    function _resolve(string[] memory funcSigs) internal view returns (address[] memory) {\\n        address[] memory facets = new address[](funcSigs.length);\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            facets[i] = __s().selectorToFacetMap[selector];\\n            if (__s().deletedFacets[facets[i]]) {\\n                facets[i] = address(0);\\n            }\\n        }\\n        return facets;\\n    }\\n\\n    function _areFuncSigsProtected(\\n        string[] memory funcSigs\\n    ) internal view returns (bool[] memory) {\\n        bool[] memory results = new bool[](funcSigs.length);\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            results[i] = __s().protectedSelectorMap[selector];\\n        }\\n        return results;\\n    }\\n\\n    function _protectFuncSig(\\n        string memory funcSig,\\n        bool protect\\n    ) internal {\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        __protectFuncSig(funcSig, protect);\\n    }\\n\\n    function _isSelectorProtected(bytes4 funcSelector) internal view returns (bool) {\\n        return __s().protectedSelectorMap[funcSelector];\\n    }\\n\\n    function _addFacets(address[] memory facets) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facets.length > 0, \\\"FMLIB:ZL\\\");\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            _addFacet(facets[i]);\\n        }\\n    }\\n\\n    function _deleteFacets(address[] memory facets) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facets.length > 0, \\\"FMLIB:ZL\\\");\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            __deleteFacet(facets[i]);\\n        }\\n    }\\n\\n    function _replaceFacets(\\n        address[] memory toBeDeletedFacets,\\n        address[] memory toBeAddedFacets\\n    ) internal {\\n        _deleteFacets(toBeDeletedFacets);\\n        _addFacets(toBeAddedFacets);\\n    }\\n\\n    function _isFacetDeleted(address facet) internal view returns (bool) {\\n        return __s().deletedFacets[facet];\\n    }\\n\\n    function _deleteAllFacets() internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            __deleteFacet(__s().facets[i]);\\n        }\\n    }\\n\\n    function _overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        __overrideFuncSigs(funcSigs, facets);\\n    }\\n\\n    function _getOverridenFuncSigs() internal view returns (string[] memory) {\\n        return __s().overridenFuncSigs;\\n    }\\n\\n    function _findFacet(bytes4 selector) internal view returns (address) {\\n        address facet = __s().selectorToFacetMap[selector];\\n        require(facet != address(0), \\\"FMLIB:FNF\\\");\\n        require(!__s().deletedFacets[facet], \\\"FMLIB:FREM\\\");\\n        return facet;\\n    }\\n\\n    function _addFacet(address facet) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(\\n            IDiamondFacet(facet).supportsInterface(type(IDiamondFacet).interfaceId),\\n            \\\"FMLIB:IF\\\"\\n        );\\n        string[] memory funcSigs = IDiamondFacet(facet).getFacetPI();\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            address currentFacet = __s().selectorToFacetMap[selector];\\n            if (currentFacet != address(0)) {\\n                // current facet must not be frozen\\n                require(!__s().frozenFacets[currentFacet], \\\"FMLIB:FF\\\");\\n            }\\n            __s().selectorToFacetMap[selector] = facet;\\n            __protectFuncSig(funcSig, false);\\n        }\\n        string[] memory protectedFuncSigs = IDiamondFacet(facet).getFacetProtectedPI();\\n        for (uint256 i = 0; i < protectedFuncSigs.length; i++) {\\n            string memory protectedFuncSig = protectedFuncSigs[i];\\n            __protectFuncSig(protectedFuncSig, true);\\n        }\\n        __s().deletedFacets[facet] = false;\\n        // update facets array\\n        if (__s().facetsIndex[facet] == 0) {\\n            __s().facets.push(facet);\\n            __s().facetsIndex[facet] = __s().facets.length;\\n        }\\n        emit FacetAdd(facet);\\n    }\\n\\n    function _getSelector(string memory funcSig) internal pure returns (bytes4) {\\n        bytes memory funcSigBytes = bytes(funcSig);\\n        for (uint256 i = 0; i < funcSigBytes.length; i++) {\\n            bytes1 b = funcSigBytes[i];\\n            if (\\n                !(b >= 0x30 && b <= 0x39) && // [0-9]\\n                !(b >= 0x41 && b <= 0x5a) && // [A-Z]\\n                !(b >= 0x61 && b <= 0x7a) && // [a-z]\\n                 b != 0x24 && // $\\n                 b != 0x5f && // _\\n                 b != 0x2c && // ,\\n                 b != 0x28 && // (\\n                 b != 0x29 && // )\\n                 b != 0x5b && // [\\n                 b != 0x5d    // ]\\n            ) {\\n                revert(\\\"FMLIB:IFS\\\");\\n            }\\n        }\\n        return bytes4(keccak256(bytes(funcSig)));\\n    }\\n\\n    function __deleteFacet(address facet) private {\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(!__s().frozenFacets[facet], \\\"FMLIB:FF\\\");\\n        __s().deletedFacets[facet] = true;\\n        emit FacetDelete(facet);\\n    }\\n\\n    function __overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) private {\\n        require(funcSigs.length > 0, \\\"FMLIB:ZL\\\");\\n        require(funcSigs.length == facets.length, \\\"FMLIB:IL\\\");\\n        for (uint i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            address facet = facets[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            address currentFacet = __s().selectorToFacetMap[selector];\\n            if (currentFacet != address(0)) {\\n                // current facet must not be frozen\\n                require(!__s().frozenFacets[currentFacet], \\\"FMLIB:FF\\\");\\n            }\\n            __s().selectorToFacetMap[selector] = facet;\\n            __s().deletedFacets[facet] = false;\\n            if (__s().overridenFuncSigsIndex[funcSig] == 0) {\\n                __s().overridenFuncSigs.push(funcSig);\\n                __s().overridenFuncSigsIndex[funcSig] = __s().overridenFuncSigs.length;\\n            }\\n            emit FuncSigOverride(funcSig, facet);\\n        }\\n    }\\n\\n    function __protectFuncSig(string memory funcSig, bool protect) private {\\n        bytes4 selector = _getSelector(funcSig);\\n        bool oldValue = __s().protectedSelectorMap[selector];\\n        __s().protectedSelectorMap[selector] = protect;\\n        if (oldValue != protect) {\\n            emit ProtectFuncSig(funcSig, protect);\\n        }\\n    }\\n\\n    function __s() private pure returns (FacetManagerStorage.Layout storage) {\\n        return FacetManagerStorage.layout();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IAuthz.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk.\\nlibrary AuthzLib {\\n\\n    uint256 public constant ROLE_AUTHZ_DIAMOND_ADMIN = uint256(keccak256(bytes(\\\"ROLE_AUTHZ_DIAMOND_ADMIN\\\")));\\n    uint256 public constant ROLE_AUTHZ_ADMIN = uint256(keccak256(bytes(\\\"ROLE_AUTHZ_ADMIN\\\")));\\n\\n    bytes32 constant public GLOBAL_DOMAIN_ID = keccak256(abi.encodePacked(\\\"global\\\"));\\n    bytes32 constant public MATCH_ALL_WILDCARD_HASH = keccak256(abi.encodePacked(\\\"*\\\"));\\n\\n    // operations\\n    uint256 constant public CALL_OP = 5000;\\n    uint256 constant public MATCH_ALL_WILDCARD_OP = 9999;\\n\\n    // actions\\n    uint256 constant public ACCEPT_ACTION = 1;\\n    uint256 constant public REJECT_ACTION = 100;\\n}\\n\\n/// @notice Use at your own risk\\ninterface IAuthz {\\n\\n    function authorize(\\n        bytes32 domainHash,\\n        bytes32 identityHash,\\n        bytes32[] memory targets,\\n        uint256[] memory ops\\n    ) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IAuthzDiamondInitializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk\\ninterface IAuthzDiamondInitializer {\\n\\n    function initialize(\\n        string memory name,\\n        address taskManager,\\n        address[] memory authzAdmins,\\n        address[] memory authzDiamondAdmins\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\nlibrary DiamondLib {\\n    uint256 public constant ROLE_DIAMOND_ADMIN = uint256(keccak256(bytes(\\\"ROLE_DIAMOND_ADMIN\\\")));\\n}\\n\\n/// @notice Use at your own risk\\ninterface IDiamond is IERC165 {\\n\\n    function getDiamondName() external view returns (string memory);\\n\\n    function getDiamondVersion() external view returns (string memory);\\n\\n    function getFacets() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IDiamondFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\n/// @notice Use at your own risk\\ninterface IDiamondFacet is IERC165 {\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetName() external pure returns (string memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetVersion() external pure returns (string memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetPI() external pure returns (string[] memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetProtectedPI() external pure returns (string[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/facets/hasher/HasherLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk\\nlibrary HasherLib {\\n\\n    function _hashBytes(bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n\\n    function _hashAddress(address addr) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(addr));\\n    }\\n\\n    function _hashStr(string memory str) internal pure returns (bytes32) {\\n        return keccak256(bytes(str));\\n    }\\n\\n    function _hashInt(uint256 num) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"INT\\\", num));\\n    }\\n\\n    function _hashAccount(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"ACCOUNT\\\", account));\\n    }\\n\\n    function _hashVault(address vault) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"VAULT\\\", vault));\\n    }\\n\\n    function _hashReserveId(uint256 reserveId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"RESERVEID\\\", reserveId));\\n    }\\n\\n    function _hashContract(address contractAddr) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"CONTRACT\\\", contractAddr));\\n    }\\n\\n    function _hashTokenId(uint256 tokenId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"TOKENID\\\", tokenId));\\n    }\\n\\n    function _hashRole(string memory roleName) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"ROLE\\\", roleName));\\n    }\\n\\n    function _hashLedgerId(uint256 ledgerId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"LEDGERID\\\", ledgerId));\\n    }\\n\\n    function _mixHash2(\\n        bytes32 d1,\\n        bytes32 d2\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX2_\\\", d1, d2));\\n    }\\n\\n    function _mixHash3(\\n        bytes32 d1,\\n        bytes32 d2,\\n        bytes32 d3\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX3_\\\", d1, d2, d3));\\n    }\\n\\n    function _mixHash4(\\n        bytes32 d1,\\n        bytes32 d2,\\n        bytes32 d3,\\n        bytes32 d4\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX4_\\\", d1, d2, d3, d4));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/rbac/RBACInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"../task-executor/TaskExecutorLib.sol\\\";\\nimport \\\"./RBACStorage.sol\\\";\\n\\n/// @notice Use at your own risk\\nlibrary RBACInternal {\\n\\n    event RoleGrant(uint256 role, address account);\\n    event RoleRevoke(uint256 role, address account);\\n\\n    function _hasRole(\\n        address account,\\n        uint256 role\\n    ) internal view returns (bool) {\\n        return __s().roles[role][account];\\n    }\\n\\n    // ATTENTION! this function MUST NEVER get exposed via a facet\\n    function _unsafeGrantRole(\\n        address account,\\n        uint256 role\\n    ) internal {\\n        require(!__s().roles[role][account], \\\"RBACI:AHR\\\");\\n        __s().roles[role][account] = true;\\n        emit RoleGrant(role, account);\\n    }\\n\\n    function _grantRole(\\n        uint256 taskId,\\n        string memory taskManagerKey,\\n        address account,\\n        uint256 role\\n    ) internal {\\n        _unsafeGrantRole(account, role);\\n        TaskExecutorLib._executeTask(taskManagerKey, taskId);\\n    }\\n\\n    function _revokeRole(\\n        uint256 taskId,\\n        string memory taskManagerKey,\\n        address account,\\n        uint256 role\\n    ) internal {\\n        require(__s().roles[role][account], \\\"RBACI:DHR\\\");\\n        __s().roles[role][account] = false;\\n        emit RoleRevoke(role, account);\\n        TaskExecutorLib._executeTask(taskManagerKey, taskId);\\n    }\\n\\n    function __s() private pure returns (RBACStorage.Layout storage) {\\n        return RBACStorage.layout();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/rbac/RBACLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"./RBACInternal.sol\\\";\\n\\n/// @notice Use at your own risk\\nlibrary RBACLib {\\n\\n    function _hasRole(\\n        address account,\\n        uint256 role\\n    ) internal view returns (bool) {\\n        return RBACInternal._hasRole(account, role);\\n    }\\n\\n    function _unsafeGrantRole(\\n        address account,\\n        uint256 role\\n    ) internal {\\n        RBACInternal._unsafeGrantRole(account, role);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/rbac/RBACStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk. Just got the basic\\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\\nlibrary RBACStorage {\\n\\n    struct Layout {\\n        // role > address > true if granted\\n        mapping (uint256 => mapping(address => bool)) roles;\\n        mapping(bytes32 => bytes) extra;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"qomet-tech.contracts.facets.rbac.storage\\\");\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            s.slot := slot\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/ITaskExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk\\ninterface ITaskExecutor {\\n\\n    event TaskExecuted(address finalizer, address executor, uint256 taskId);\\n\\n    function executeTask(address executor, uint256 taskId) external;\\n\\n    function executeAdminTask(address executor, uint256 taskId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../hasher/HasherLib.sol\\\";\\nimport \\\"./ITaskExecutor.sol\\\";\\nimport \\\"./TaskExecutorStorage.sol\\\";\\n\\n/// @notice Use at your own risk\\nlibrary TaskExecutorInternal {\\n\\n    event TaskManagerSet (\\n        string key,\\n        address taskManager\\n    );\\n\\n    function _initialize(\\n        address newTaskManager\\n    ) internal {\\n        require(!__s().initialized, \\\"TFI:AI\\\");\\n        __setTaskManager(\\\"DEFAULT\\\", newTaskManager);\\n        __s().initialized = true;\\n    }\\n\\n    function _getTaskManagerKeys() internal view returns (string[] memory) {\\n        return __s().keys;\\n    }\\n\\n    function _getTaskManager(string memory key) internal view returns (address) {\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        require(__s().keysIndex[keyHash] > 0, \\\"TFI:KNF\\\");\\n        return __s().taskManagers[keyHash];\\n    }\\n\\n    function _setTaskManager(\\n        uint256 adminTaskId,\\n        string memory key,\\n        address newTaskManager\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        address oldTaskManager = __s().taskManagers[keyHash];\\n        __setTaskManager(key, newTaskManager);\\n        if (oldTaskManager != address(0)) {\\n            ITaskExecutor(oldTaskManager).executeAdminTask(msg.sender, adminTaskId);\\n        } else {\\n            address defaultTaskManager = _getTaskManager(\\\"DEFAULT\\\");\\n            require(defaultTaskManager != address(0), \\\"TFI:ZDTM\\\");\\n            ITaskExecutor(defaultTaskManager).executeAdminTask(msg.sender, adminTaskId);\\n        }\\n    }\\n\\n    function _executeTask(\\n        string memory key,\\n        uint256 taskId\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        address taskManager = _getTaskManager(key);\\n        require(taskManager != address(0), \\\"TFI:ZTM\\\");\\n        ITaskExecutor(taskManager).executeTask(msg.sender, taskId);\\n    }\\n\\n    function _executeAdminTask(\\n        string memory key,\\n        uint256 adminTaskId\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        address taskManager = _getTaskManager(key);\\n        require(taskManager != address(0), \\\"TFI:ZTM\\\");\\n        ITaskExecutor(taskManager).executeAdminTask(msg.sender, adminTaskId);\\n    }\\n\\n    function __setTaskManager(\\n        string memory key,\\n        address newTaskManager\\n    ) internal {\\n        require(newTaskManager != address(0), \\\"TFI:ZA\\\");\\n        require(IERC165(newTaskManager).supportsInterface(type(ITaskExecutor).interfaceId),\\n            \\\"TFI:IC\\\");\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        if (__s().keysIndex[keyHash] == 0) {\\n            __s().keys.push(key);\\n            __s().keysIndex[keyHash] = __s().keys.length;\\n        }\\n        __s().taskManagers[keyHash] = newTaskManager;\\n        emit TaskManagerSet(key, newTaskManager);\\n    }\\n\\n    function __s() private pure returns (TaskExecutorStorage.Layout storage) {\\n        return TaskExecutorStorage.layout();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"./TaskExecutorInternal.sol\\\";\\n\\n/// @notice Use at your own risk\\nlibrary TaskExecutorLib {\\n\\n    function _initialize(\\n        address newTaskManager\\n    ) internal {\\n        TaskExecutorInternal._initialize(newTaskManager);\\n    }\\n\\n    function _getTaskManager(\\n        string memory taskManagerKey\\n    ) internal view returns (address) {\\n        return TaskExecutorInternal._getTaskManager(taskManagerKey);\\n    }\\n\\n    function _executeTask(\\n        string memory key,\\n        uint256 taskId\\n    ) internal {\\n        TaskExecutorInternal._executeTask(key, taskId);\\n    }\\n\\n    function _executeAdminTask(\\n        string memory key,\\n        uint256 adminTaskId\\n    ) internal {\\n        TaskExecutorInternal._executeAdminTask(key, adminTaskId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.20;\\n\\n/// @notice Use at your own risk. Just got the basic\\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\\nlibrary TaskExecutorStorage {\\n\\n    struct Layout {\\n        // list of the keys\\n        string[] keys;\\n        mapping(bytes32 => uint256) keysIndex;\\n        // keccak256(key) > task manager address\\n        mapping(bytes32 => address) taskManagers;\\n        // true if default task manager has been set\\n        bool initialized;\\n        mapping(bytes32 => bytes) extra;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"qomet-tech.contracts.facets.task-finalizer.storage\\\");\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            s.slot := slot\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"FacetAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"FacetDelete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeDiamond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcSig\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"FuncSigOverride\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcSig\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"protect\",\"type\":\"bool\"}],\"name\":\"ProtectFuncSig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"SetLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taskManager\",\"type\":\"address\"}],\"name\":\"TaskManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"addFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deleteAllFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"deleteFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"adminTaskId\",\"type\":\"uint256\"}],\"name\":\"freezeDiamond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDetailsURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiamondName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiamondVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFacets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOverridenFuncSigs\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaskManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"taskManager\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"authzAdmins\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"authzDiamondAdmins\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"funcSigs\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"overrideFuncSigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toBeDeletedFacets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"toBeAddedFacets\",\"type\":\"address[]\"}],\"name\":\"replaceFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"funcSigs\",\"type\":\"string[]\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"detailsURI\",\"type\":\"string\"}],\"name\":\"setDetailsURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setDiamondName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"taskId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"transferTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AuthzDiamond", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000097d18ec889576172eca1988262c3da9af0056ca4", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}