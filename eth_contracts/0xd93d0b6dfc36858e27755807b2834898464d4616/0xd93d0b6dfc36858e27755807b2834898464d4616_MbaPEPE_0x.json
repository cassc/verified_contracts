{"SourceCode": "{{\r\n  \"sources\": {\r\n    \"IDEXV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\ninterface IDEXRouterV2 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n  function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\r\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\r\\n}\\r\\n\\r\\ninterface IDEXFactoryV2 {\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n  function getPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.25;\\n\\ninterface IERC20 {\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address to, uint256 amount) external returns (bool);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"CF_ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\n\\r\\nabstract contract CF_ERC20 is CF_Common {\\r\\n  string internal _name;\\r\\n  string internal _symbol;\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  function name() external view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  function decimals() external view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  function totalSupply() external view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  function balanceOf(address account) external view returns (uint256) {\\r\\n    return _balance[account];\\r\\n  }\\r\\n\\r\\n  function allowance(address owner, address spender) public view returns (uint256) {\\r\\n    return _allowance[owner][spender];\\r\\n  }\\r\\n\\r\\n  function approve(address spender, uint256 amount) external returns (bool) {\\r\\n    _approve(msg.sender, spender, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function transfer(address to, uint256 amount) external returns (bool) {\\r\\n    _transfer(msg.sender, to, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool) {\\r\\n    _spendAllowance(from, msg.sender, amount);\\r\\n    _transfer(from, to, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n    unchecked {\\r\\n      _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n    uint256 currentAllowance = allowance(msg.sender, spender);\\r\\n\\r\\n    require(currentAllowance >= subtractedValue, \\\"Negative allowance\\\");\\r\\n\\r\\n    unchecked {\\r\\n      _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    _allowance[owner][spender] = amount;\\r\\n\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\\r\\n    uint256 currentAllowance = allowance(owner, spender);\\r\\n\\r\\n    require(currentAllowance >= amount, \\\"Insufficient allowance\\\");\\r\\n\\r\\n    unchecked {\\r\\n      _approve(owner, spender, currentAllowance - amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n    require(from != address(0) && to != address(0), \\\"Transfer from/to zero address\\\");\\r\\n    require(_balance[from] >= amount, \\\"Exceeds balance\\\");\\r\\n\\r\\n    if (amount > 0) {\\r\\n      unchecked {\\r\\n        _balance[from] -= amount;\\r\\n        _balance[to] += amount;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    emit Transfer(from, to, amount);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./IDEXV2.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\nabstract contract CF_Common {\\r\\n  string internal constant _version = \\\"1.0.3\\\";\\r\\n\\r\\n  mapping(address => uint256) internal _balance;\\r\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\r\\n  mapping(address => bool) internal _whitelisted;\\r\\n  mapping(address => holderAccount) internal _holder;\\r\\n  mapping(uint8 => taxBeneficiary) internal _taxBeneficiary;\\r\\n  mapping(address => uint256) internal _tokensForTaxDistribution;\\r\\n\\r\\n  address[] internal _holders;\\r\\n\\r\\n  bool internal _autoSwapEnabled;\\r\\n  bool internal _swapping;\\r\\n  bool internal _suspendTaxes;\\r\\n  bool internal _distributing;\\r\\n  bool internal immutable _initialized;\\r\\n\\r\\n  uint8 internal immutable _decimals;\\r\\n  uint24 internal constant _denominator = 1000;\\r\\n  uint24 internal _maxBalancePercent;\\r\\n  uint24 internal _totalTxTax;\\r\\n  uint24 internal _totalBuyTax;\\r\\n  uint24 internal _totalSellTax;\\r\\n  uint24 internal _totalPenaltyTxTax;\\r\\n  uint24 internal _totalPenaltyBuyTax;\\r\\n  uint24 internal _totalPenaltySellTax;\\r\\n  uint24 internal _minAutoSwapPercent;\\r\\n  uint24 internal _maxAutoSwapPercent;\\r\\n  uint24 internal _minAutoAddLiquidityPercent;\\r\\n  uint24 internal _maxAutoAddLiquidityPercent;\\r\\n  uint32 internal _lastTaxDistribution;\\r\\n  uint32 internal _tradingEnabled;\\r\\n  uint32 internal _lastSwap;\\r\\n  uint32 internal _earlyPenaltyTime;\\r\\n  uint256 internal _totalSupply;\\r\\n  uint256 internal _totalBurned;\\r\\n  uint256 internal _maxBalanceAmount;\\r\\n  uint256 internal _minAutoSwapAmount;\\r\\n  uint256 internal _maxAutoSwapAmount;\\r\\n  uint256 internal _minAutoAddLiquidityAmount;\\r\\n  uint256 internal _maxAutoAddLiquidityAmount;\\r\\n  uint256 internal _amountForLiquidity;\\r\\n  uint256 internal _ethForLiquidity;\\r\\n  uint256 internal _totalTaxCollected;\\r\\n  uint256 internal _totalTaxUnclaimed;\\r\\n  uint256 internal _amountForTaxDistribution;\\r\\n  uint256 internal _amountSwappedForTaxDistribution;\\r\\n  uint256 internal _ethForTaxDistribution;\\r\\n\\r\\n  struct Renounced {\\r\\n    bool Whitelist;\\r\\n    bool MaxBalance;\\r\\n    bool Taxable;\\r\\n    bool DEXRouterV2;\\r\\n  }\\r\\n\\r\\n  struct holderAccount {\\r\\n    bool exists;\\r\\n    bool penalty;\\r\\n  }\\r\\n\\r\\n  struct taxBeneficiary {\\r\\n    bool exists;\\r\\n    address account;\\r\\n    uint24[3] percent; // 0: tx, 1: buy, 2: sell\\r\\n    uint24[3] penalty;\\r\\n    uint256 unclaimed;\\r\\n  }\\r\\n\\r\\n  struct DEXRouterV2 {\\r\\n    address router;\\r\\n    address pair;\\r\\n    address token0;\\r\\n    address WETH;\\r\\n    address receiver;\\r\\n  }\\r\\n\\r\\n  Renounced internal _renounced;\\r\\n  IERC20 internal _taxToken;\\r\\n  DEXRouterV2 internal _dex;\\r\\n\\r\\n  function _percentage(uint256 amount, uint256 bps) internal pure returns (uint256) {\\r\\n    unchecked {\\r\\n      return (amount * bps) / (100 * uint256(_denominator));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _timestamp() internal view returns (uint32) {\\r\\n    unchecked {\\r\\n      return uint32(block.timestamp % 2**32);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function denominator() external pure returns (uint24) {\\r\\n    return _denominator;\\r\\n  }\\r\\n\\r\\n  function version() external pure returns (string memory) {\\r\\n    return _version;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nabstract contract CF_Ownable is CF_Common {\\r\\n  address internal _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == msg.sender, \\\"Unauthorized\\\");\\r\\n\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function owner() external view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() external onlyOwner {\\r\\n    _renounced.Whitelist = true;\\r\\n    _renounced.MaxBalance = true;\\r\\n    _renounced.Taxable = true;\\r\\n    _renounced.DEXRouterV2 = true;\\r\\n\\r\\n    _transferOwnership(address(0));\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) external onlyOwner {\\r\\n    require(newOwner != address(0));\\r\\n\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner) internal {\\r\\n    address oldOwner = _owner;\\r\\n    _owner = newOwner;\\r\\n\\r\\n    emit OwnershipTransferred(oldOwner, newOwner);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Taxable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\nimport \\\"./CF_ERC20.sol\\\";\\r\\n\\r\\nabstract contract CF_Taxable is CF_Common, CF_Ownable, CF_ERC20 {\\r\\n  event SetTaxBeneficiary(uint8 slot, address account, uint24[3] percent, uint24[3] penalty);\\r\\n  event SetEarlyPenaltyTime(uint32 time);\\r\\n  event TaxDistributed(uint256 amount);\\r\\n  event RenouncedTaxable();\\r\\n\\r\\n  struct taxBeneficiaryView {\\r\\n    address account;\\r\\n    uint24[3] percent;\\r\\n    uint24[3] penalty;\\r\\n    uint256 unclaimed;\\r\\n  }\\r\\n\\r\\n  modifier lockDistributing {\\r\\n    _distributing = true;\\r\\n    _;\\r\\n    _distributing = false;\\r\\n  }\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to update the tax features\\r\\n  /// @dev Existing settings will continue to be effective\\r\\n  function renounceTaxable() external onlyOwner {\\r\\n    _renounced.Taxable = true;\\r\\n\\r\\n    emit RenouncedTaxable();\\r\\n  }\\r\\n\\r\\n  /// @notice Total amount of taxes collected so far\\r\\n  function totalTaxCollected() external view returns (uint256) {\\r\\n    return _totalTaxCollected;\\r\\n  }\\r\\n  /// @notice Tax applied per transfer\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function txTax() external view returns (uint24) {\\r\\n    return txTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied per transfer\\r\\n  /// @param from Sender address\\r\\n  function txTax(address from) public view returns (uint24) {\\r\\n    unchecked {\\r\\n      return from == address(this) || _whitelisted[from] || from == _dex.pair ? 0 : (_holder[from].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltyTxTax : _totalTxTax);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for buying\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function buyTax() external view returns (uint24) {\\r\\n    return buyTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for buying\\r\\n  /// @param from Buyer's address\\r\\n  function buyTax(address from) public view returns (uint24) {\\r\\n    if (_suspendTaxes) { return 0; }\\r\\n\\r\\n    unchecked {\\r\\n      return from == address(this) || _whitelisted[from] || from == _dex.pair ? 0 : (_holder[from].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltyBuyTax : _totalBuyTax);\\r\\n    }\\r\\n  }\\r\\n  /// @notice Tax applied for selling\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function sellTax() external view returns (uint24) {\\r\\n    return sellTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for selling\\r\\n  /// @param to Seller's address\\r\\n  function sellTax(address to) public view returns (uint24) {\\r\\n    if (_suspendTaxes) { return 0; }\\r\\n\\r\\n    unchecked {\\r\\n      return to == address(this) || _whitelisted[to] || to == _dex.pair || to == _dex.router ? 0 : (_holder[to].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltySellTax : _totalSellTax);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice List of all tax beneficiaries and their assigned percentage, according to type of transfer\\r\\n  /// @custom:return `list[].account` Beneficiary address\\r\\n  /// @custom:return `list[].percent[3]` Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\\r\\n  /// @custom:return `list[].penalty[3]` Index 0 is for tx penalty, 1 is for buy penalty, 2 is for sell penalty, multiplied by denominator\\r\\n  function listTaxBeneficiaries() external view returns (taxBeneficiaryView[] memory list) {\\r\\n    list = new taxBeneficiaryView[](6);\\r\\n\\r\\n    unchecked {\\r\\n      for (uint8 i; i < 6; i++) { list[i] = taxBeneficiaryView(_taxBeneficiary[i].account, _taxBeneficiary[i].percent, _taxBeneficiary[i].penalty, _taxBeneficiary[i].unclaimed); }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Sets a tax beneficiary\\r\\n  /// @dev Maximum of 5 wallets can be assigned\\r\\n  /// @dev Slot 0 is reserved for ChainFactory revenue\\r\\n  /// @param slot Slot number (1 to 5)\\r\\n  /// @param account Beneficiary address\\r\\n  /// @param percent[3] Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\\r\\n  /// @param penalty[3] Index 0 is for tx penalty, 1 is for buy penalty, 2 is for sell penalty, multiplied by denominator\\r\\n  function setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent, uint24[3] memory penalty) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n    require(slot >= 1 && slot <= 5, \\\"Reserved\\\");\\r\\n\\r\\n    _setTaxBeneficiary(slot, account, percent, penalty);\\r\\n  }\\r\\n\\r\\n  function _setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent, uint24[3] memory penalty) internal {\\r\\n    require(slot <= 5);\\r\\n    require(account != address(this) && account != address(0));\\r\\n\\r\\n    taxBeneficiary storage taxBeneficiarySlot = _taxBeneficiary[slot];\\r\\n\\r\\n    if (slot > 0 && account == address(0xdEaD) && taxBeneficiarySlot.unclaimed > 0) { revert(\\\"Unclaimed taxes\\\"); }\\r\\n\\r\\n    unchecked {\\r\\n      _totalTxTax += percent[0] - taxBeneficiarySlot.percent[0];\\r\\n      _totalBuyTax += percent[1] - taxBeneficiarySlot.percent[1];\\r\\n      _totalSellTax += percent[2] - taxBeneficiarySlot.percent[2];\\r\\n      _totalPenaltyTxTax += penalty[0] - taxBeneficiarySlot.penalty[0];\\r\\n      _totalPenaltyBuyTax += penalty[1] - taxBeneficiarySlot.penalty[1];\\r\\n      _totalPenaltySellTax += penalty[2] - taxBeneficiarySlot.penalty[2];\\r\\n\\r\\n      require(_totalTxTax <= 25 * _denominator && ((_totalBuyTax <= 25 * _denominator && _totalSellTax <= 25 * _denominator) && (_totalBuyTax + _totalSellTax <= 25 * _denominator)), \\\"High Tax\\\");\\r\\n      require(_totalPenaltyTxTax <= 90 * _denominator && _totalPenaltyBuyTax <= 90 * _denominator && _totalPenaltySellTax <= 90 * _denominator, \\\"Invalid Penalty\\\");\\r\\n\\r\\n      taxBeneficiarySlot.account = account;\\r\\n      taxBeneficiarySlot.percent = percent;\\r\\n\\r\\n      if (_initialized && slot > 0) { _setTaxBeneficiary(0, _taxBeneficiary[0].account, [ uint24(0), uint24(0), uint24(0) ], [ _taxBeneficiary[0].penalty[0] + uint24((penalty[0] * 10 / 100) - (taxBeneficiarySlot.penalty[0] * 10 / 100)), _taxBeneficiary[0].penalty[1] + uint24((penalty[1] * 10 / 100) - (taxBeneficiarySlot.penalty[1] * 10 / 100)), _taxBeneficiary[0].penalty[2] + uint24((penalty[2] * 10 / 100) - (taxBeneficiarySlot.penalty[2] * 10 / 100)) ]); }\\r\\n\\r\\n      taxBeneficiarySlot.penalty = penalty;\\r\\n    }\\r\\n\\r\\n    if (!taxBeneficiarySlot.exists) { taxBeneficiarySlot.exists = true; }\\r\\n\\r\\n    emit SetTaxBeneficiary(slot, account, percent, penalty);\\r\\n  }\\r\\n\\r\\n  /// @notice Triggers the tax distribution\\r\\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution\\r\\n  function autoTaxDistribute() external {\\r\\n    require(msg.sender == _owner || _whitelisted[msg.sender], \\\"Unauthorized\\\");\\r\\n    require(!_swapping && !_distributing);\\r\\n\\r\\n    _autoTaxDistribute();\\r\\n  }\\r\\n\\r\\n  function _autoTaxDistribute() internal lockDistributing {\\r\\n    if (_totalTaxUnclaimed == 0) { return; }\\r\\n\\r\\n    unchecked {\\r\\n      uint256 distributedTaxes;\\r\\n\\r\\n      for (uint8 i; i < 6; i++) {\\r\\n        taxBeneficiary storage taxBeneficiarySlot = _taxBeneficiary[i];\\r\\n        address account = taxBeneficiarySlot.account;\\r\\n\\r\\n        if (taxBeneficiarySlot.unclaimed == 0 || account == address(0xdEaD) || account == _dex.pair) { continue; }\\r\\n\\r\\n        uint256 unclaimed = _percentage(address(_taxToken) == address(this) ? _amountForTaxDistribution : _amountSwappedForTaxDistribution, (100 * uint256(_denominator) * taxBeneficiarySlot.unclaimed) / _totalTaxUnclaimed);\\r\\n        uint256 _distributedTaxes = _distribute(account, unclaimed);\\r\\n\\r\\n        if (_distributedTaxes > 0) {\\r\\n          taxBeneficiarySlot.unclaimed -= _distributedTaxes;\\r\\n          distributedTaxes += _distributedTaxes;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      _lastTaxDistribution = _timestamp();\\r\\n\\r\\n      if (distributedTaxes > 0) {\\r\\n        _totalTaxUnclaimed -= distributedTaxes;\\r\\n\\r\\n        emit TaxDistributed(distributedTaxes);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _distribute(address account, uint256 unclaimed) private returns (uint256) {\\r\\n    if (unclaimed == 0) { return 0; }\\r\\n\\r\\n    unchecked {\\r\\n      if (address(_taxToken) == address(this)) {\\r\\n        if (_maxBalanceAmount > 0 && _balance[account] + unclaimed > _maxBalanceAmount && !_whitelisted[account]) {\\r\\n          unclaimed = _maxBalanceAmount > _balance[account] ? _maxBalanceAmount - _balance[account] : 0;\\r\\n\\r\\n          if (unclaimed == 0) { return 0; }\\r\\n        }\\r\\n\\r\\n        super._transfer(address(this), account, unclaimed);\\r\\n\\r\\n        _amountForTaxDistribution -= unclaimed;\\r\\n      } else {\\r\\n        uint256 percent = (100 * uint256(_denominator) * unclaimed) / _amountSwappedForTaxDistribution;\\r\\n        uint256 amount;\\r\\n\\r\\n        if (address(_taxToken) == _dex.WETH) {\\r\\n          amount = _percentage(_ethForTaxDistribution, percent);\\r\\n\\r\\n          (bool success, ) = payable(account).call{ value: amount, gas: 30000 }(\\\"\\\");\\r\\n\\r\\n          if (!success) { return 0; }\\r\\n\\r\\n          _ethForTaxDistribution -= amount;\\r\\n        } else {\\r\\n          amount = _percentage(_tokensForTaxDistribution[address(_taxToken)], percent);\\r\\n\\r\\n          try _taxToken.transfer(account, amount) { _tokensForTaxDistribution[address(_taxToken)] -= amount; } catch { return 0; }\\r\\n        }\\r\\n\\r\\n        _amountSwappedForTaxDistribution -= unclaimed;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return unclaimed;\\r\\n  }\\r\\n\\r\\n  /// @notice Suspend or reinstate tax collection\\r\\n  /// @dev Also applies to early penalties\\r\\n  /// @param status True to suspend, False to reinstate existent taxes\\r\\n  function suspendTaxes(bool status) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n\\r\\n    _suspendTaxes = status;\\r\\n  }\\r\\n\\r\\n  /// @notice Checks if tax collection is currently suspended\\r\\n  function taxesSuspended() external view returns (bool) {\\r\\n    return _suspendTaxes;\\r\\n  }\\r\\n\\r\\n  /// @notice Removes the penalty status of a wallet\\r\\n  /// @param account Address to depenalize\\r\\n  function removePenalty(address account) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n\\r\\n    _holder[account].penalty = false;\\r\\n  }\\r\\n\\r\\n  /// @notice Check if a wallet is penalized due to an early transaction\\r\\n  /// @param account Address to check\\r\\n  function isPenalized(address account) external view returns (bool) {\\r\\n    return _holder[account].penalty;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the period of time during which early buyers will be penalized from the time trading was enabled\\r\\n  function getEarlyPenaltyTime() external view returns (uint32) {\\r\\n    return _earlyPenaltyTime;\\r\\n  }\\r\\n\\r\\n  /// @notice Defines the period of time during which early buyers will be penalized from the time trading was enabled\\r\\n  /// @dev Must be less or equal to 1 hour\\r\\n  /// @param time Time, in seconds\\r\\n  function setEarlyPenaltyTime(uint32 time) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n    require(time <= 600);\\r\\n\\r\\n    _setEarlyPenaltyTime(time);\\r\\n  }\\r\\n\\r\\n  function _setEarlyPenaltyTime(uint32 time) internal {\\r\\n    _earlyPenaltyTime = time;\\r\\n\\r\\n    emit SetEarlyPenaltyTime(time);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"MbaPEPE_0x.sol\": {\r\n      \"content\": \"/*\\n\\n  MbaPEPE\\n\\n   Hala Madrid ! Allez France ! The only true MbaPEPE on the Ethereum chain.\\n  \\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.25;\\n\\nimport \\\"./CF_Common.sol\\\";\\nimport \\\"./CF_Ownable.sol\\\";\\nimport \\\"./CF_ERC20.sol\\\";\\nimport \\\"./CF_Recoverable.sol\\\";\\nimport \\\"./CF_Burnable.sol\\\";\\nimport \\\"./CF_Whitelist.sol\\\";\\nimport \\\"./CF_MaxBalance.sol\\\";\\nimport \\\"./CF_Taxable.sol\\\";\\nimport \\\"./CF_DEXRouterV2.sol\\\";\\n\\ncontract MbaPEPE_0x is CF_Common, CF_Ownable, CF_ERC20, CF_Recoverable, CF_Burnable, CF_Whitelist, CF_MaxBalance, CF_Taxable, CF_DEXRouterV2 {\\n  constructor() {\\n    _name = unicode\\\"MbaPEPE\\\";\\n    _symbol = unicode\\\"MPEPE\\\";\\n    _decimals = 18;\\n    _totalSupply = 201219980000000000000000000000; // 201,219,980,000 MPEPE\\n    _transferOwnership(0xd8F986b1aB4a47D4396F43d524Cd2A8bF359ffcB);\\n    _transferInitialSupply(0xd8F986b1aB4a47D4396F43d524Cd2A8bF359ffcB, 100000); // 100%\\n    _setDEXRouterV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    _setEarlyPenaltyTime(600); // 10min\\n    _setTaxToken(address(this));\\n    _autoSwapEnabled = true;\\n    _setAutoSwapPercent(50, 250); // 0.05% -> 0.25% of total supply\\n    _setAutoAddLiquidityPercent(100, 100000); // 0.1% -> 100% of total supply\\n\\n    _setTaxBeneficiary(0, 0x8881d9869aC7C7840971cAac043D7f4D144Abd10, [ uint24(0), uint24(0), uint24(0) ], [ uint24(3000), uint24(3000), uint24(3000) ]); // ChainFactory Anti-Sniper revenue (10%)\\n    _setTaxBeneficiary(1, 0x8E609Eb1Cf61E096ae04dCb1FeB630E886EDB3dd, [ uint24(10000), uint24(10000), uint24(10000) ], [ uint24(30000), uint24(30000), uint24(30000) ]);\\n    _initialWhitelist([ 0xd8F986b1aB4a47D4396F43d524Cd2A8bF359ffcB, 0xD64628371141c72D7C277FE68cb281411F26909A, 0xaB229E55E134236D6652CEF169a072b472A639A4, 0x85ff2e4BEA9f9B2c24F93711f1C5106e98da044d, 0x5631E75965FA7125a021F97BC3F0DD35ECdE4064, 0xdc6AbE3Ef7d1fBc7106468088735bB7e8999EE2E, 0x8E609Eb1Cf61E096ae04dCb1FeB630E886EDB3dd ]);\\n    _setMaxBalancePercent(2000); // 2% of total supply\\n\\n    _initialized = true;\\n  }\\n\\n  function _transfer(address from, address to, uint256 amount) internal virtual override {\\n    if (to == address(0xdEaD)) {\\n      _burn(from, amount);\\n\\n      return;\\n    }\\n\\n    if (!_distributing && !_swapping && (from != _dex.pair && from != _dex.router)) {\\n      _autoSwap(false);\\n      _autoTaxDistribute();\\n    }\\n\\n    if (amount > 0 && !_whitelisted[from] && !_whitelisted[to] && from != address(this) && to != address(this) && to != _dex.router) {\\n      require((from != _dex.pair && to != _dex.pair) || ((from == _dex.pair || to == _dex.pair) && _tradingEnabled > 0), \\\"Trading disabled\\\");\\n\\n      unchecked {\\n        require(_maxBalanceAmount == 0 || to == address(this) || (to == _dex.pair || to == _dex.router) || _balance[to] + amount <= _maxBalanceAmount, \\\"Exceeds maxBalance\\\");\\n\\n        if (!_suspendTaxes && !_distributing && !_swapping) {\\n          uint256 appliedTax;\\n          uint8 taxType;\\n\\n          if (from == _dex.pair || to == _dex.pair) { taxType = from == _dex.pair ? 1 : 2; }\\n\\n          address _account = taxType == 1 ? to : from;\\n\\n          if (_tradingEnabled + _earlyPenaltyTime >= _timestamp() && !_holder[_account].penalty) { _holder[_account].penalty = true; }\\n\\n          for (uint8 i; i < 6; i++) {\\n            uint256 percent = uint256(taxType > 0 ? (taxType == 1 ? (_holder[_account].penalty ? _taxBeneficiary[i].penalty[1] : _taxBeneficiary[i].percent[1]) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[2] : _taxBeneficiary[i].percent[2])) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[0] : _taxBeneficiary[i].percent[0]));\\n\\n            if (percent == 0) { continue; }\\n\\n            uint256 taxAmount = _percentage(amount, percent);\\n\\n            super._transfer(from, address(this), taxAmount);\\n\\n            if (_taxBeneficiary[i].account == _dex.pair) {\\n              _amountForLiquidity += taxAmount;\\n            } else if (_taxBeneficiary[i].account == address(0xdEaD)) {\\n              _burn(address(this), taxAmount);\\n            } else {\\n              _taxBeneficiary[i].unclaimed += taxAmount;\\n              _amountForTaxDistribution += taxAmount;\\n              _totalTaxUnclaimed += taxAmount;\\n            }\\n\\n            appliedTax += taxAmount;\\n          }\\n\\n          if (appliedTax > 0) {\\n            _totalTaxCollected += appliedTax;\\n\\n            amount -= appliedTax;\\n          }\\n        }\\n      }\\n    }\\n\\n    super._transfer(from, to, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual override {\\n    super._burn(account, amount);\\n\\n    _setMaxBalancePercent(_maxBalancePercent);\\n    _setAutoSwapPercent(_minAutoSwapPercent, _maxAutoSwapPercent);\\n    _setAutoAddLiquidityPercent(_minAutoAddLiquidityPercent, _maxAutoAddLiquidityPercent);\\n  }\\n\\n  function _transferInitialSupply(address account, uint24 percent) private {\\n    require(!_initialized);\\n\\n    uint256 amount = _percentage(_totalSupply, uint256(percent));\\n\\n    _balance[account] = amount;\\n\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /// @notice Returns a list specifying the renounce status of each feature\\n  function renounced() external view returns (bool Whitelist, bool MaxBalance, bool DEXRouterV2, bool Taxable) {\\n    return (_renounced.Whitelist, _renounced.MaxBalance, _renounced.DEXRouterV2, _renounced.Taxable);\\n  }\\n\\n  /// @notice Returns basic information about this Smart-Contract\\n  function info() external view returns (string memory name, string memory symbol, uint8 decimals, address owner, uint256 totalSupply, string memory version) {\\n    return (_name, _symbol, _decimals, _owner, _totalSupply, _version);\\n  }\\n\\n  receive() external payable { }\\n  fallback() external payable { }\\n}\\n\\n/*\\n   ________          _       ______           __                  \\n  / ____/ /_  ____ _(_)___  / ____/___ ______/ /_____  _______  __\\n / /   / __ \\\\/ __ `/ / __ \\\\/ /_  / __ `/ ___/ __/ __ \\\\/ ___/ / / /\\n/ /___/ / / / /_/ / / / / / __/ / /_/ / /__/ /_/ /_/ / /  / /_/ / \\n\\\\____/_/ /_/\\\\__,_/_/_/ /_/_/    \\\\__,_/\\\\___/\\\\__/\\\\____/_/   \\\\__, /  \\n                                                         /____/   \\n\\n  Smart-Contract generated by ChainFactory.app\\n\\n  By using this Smart-Contract generated by ChainFactory.app, you\\n  acknowledge and agree that ChainFactory shall not be liable for\\n  any damages arising from the use of this Smart-Contract,\\n  including but not limited to any damages resulting from any\\n  malicious or illegal use of the Smart-Contract by any third\\n  party or by the owner.\\n\\n  The owner of the Smart-Contract generated by ChainFactory.app\\n  agrees not to misuse the Smart-Contract, including but not\\n  limited to:\\n\\n  - Using the Smart-Contract to engage in any illegal or\\n    fraudulent activity, including but not limited to scams,\\n    theft, or money laundering.\\n\\n  - Using the Smart-Contract in any manner that could cause harm\\n    to others, including but not limited to disrupting financial\\n    markets or causing financial loss to others.\\n\\n  - Using the Smart-Contract to infringe upon the intellectual\\n    property rights of others, including but not limited to\\n    copyright, trademark, or patent infringement.\\n\\n  The owner of the Smart-Contract generated by ChainFactory.app\\n  acknowledges that any misuse of the Smart-Contract may result in\\n  legal action, and agrees to indemnify and hold harmless\\n  ChainFactory from any and all claims, damages, or expenses\\n  arising from any such misuse.\\n\\n*/\\n\"\r\n    },\r\n    \"CF_Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_ERC20.sol\\\";\\r\\n\\r\\nabstract contract CF_Burnable is CF_Common, CF_ERC20 {\\r\\n  /// @notice Total amount of tokens burned so far\\r\\n  function totalBurned() external view returns (uint256) {\\r\\n    return _totalBurned;\\r\\n  }\\r\\n\\r\\n  function burn(uint256 amount) external {\\r\\n    _burn(msg.sender, amount);\\r\\n  }\\r\\n\\r\\n  function burnFrom(address account, uint256 amount) external {\\r\\n    _spendAllowance(account, msg.sender, amount);\\r\\n    _burn(account, amount);\\r\\n  }\\r\\n\\r\\n  function _burn(address account, uint256 amount) internal virtual {\\r\\n    require(_balance[account] >= amount, \\\"Exceeds balance\\\");\\r\\n\\r\\n    unchecked {\\r\\n      _balance[account] -= amount;\\r\\n      _totalSupply -= amount;\\r\\n      _totalBurned += amount;\\r\\n    }\\r\\n\\r\\n    emit Transfer(account, address(0xdEaD), amount);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\n\\r\\nabstract contract CF_Whitelist is CF_Common, CF_Ownable {\\r\\n  event Whitelisted(address indexed account, bool status);\\r\\n  event RenouncedWhitelist();\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to update the whitelist\\r\\n  /// @dev Existing entries will continue to be effective\\r\\n  function renounceWhitelist() external onlyOwner {\\r\\n    _renounced.Whitelist = true;\\r\\n\\r\\n    emit RenouncedWhitelist();\\r\\n  }\\r\\n\\r\\n  /// @notice Check if an address is whitelisted\\r\\n  /// @param account Address to check\\r\\n  function isWhitelisted(address account) external view returns (bool) {\\r\\n    return _whitelisted[account];\\r\\n  }\\r\\n\\r\\n  /// @notice Add or remove an address from the whitelist\\r\\n  /// @param status True for adding, False for removing\\r\\n  function whitelist(address account, bool status) public onlyOwner {\\r\\n    _whitelist(account, status);\\r\\n  }\\r\\n\\r\\n  function _whitelist(address account, bool status) internal {\\r\\n    require(!_renounced.Whitelist);\\r\\n    require(account != address(0) && account != address(0xdEaD));\\r\\n    require(account != _dex.router && account != _dex.pair, \\\"DEX router and pair are privileged\\\");\\r\\n\\r\\n\\r\\n    _whitelisted[account] = status;\\r\\n\\r\\n    emit Whitelisted(account, status);\\r\\n  }\\r\\n\\r\\n  /// @notice Add or remove multiple addresses from the whitelist\\r\\n  /// @param status True for adding, False for removing\\r\\n  function whitelist(address[] calldata accounts, bool status) external onlyOwner {\\r\\n    unchecked {\\r\\n      uint256 cnt = accounts.length;\\r\\n\\r\\n      for (uint256 i; i < cnt; i++) { _whitelist(accounts[i], status); }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _initialWhitelist(address[7] memory accounts) internal {\\r\\n    require(!_initialized);\\r\\n\\r\\n    unchecked {\\r\\n      for (uint256 i; i < 7; i++) { _whitelist(accounts[i], true); }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_MaxBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.25;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\n\\r\\nabstract contract CF_MaxBalance is CF_Common, CF_Ownable {\\r\\n  event SetMaxBalancePercent(uint24 percent);\\r\\n  event RenouncedMaxBalance();\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to update the max. balance\\r\\n  /// @dev Existing settings will continue to be effective\\r\\n  function renounceMaxBalance() external onlyOwner {\\r\\n    _renounced.MaxBalance = true;\\r\\n\\r\\n    emit RenouncedMaxBalance();\\r\\n  }\\r\\n\\r\\n  /// @notice Percentage of the max. balance per wallet, depending on total supply\\r\\n  function getMaxBalancePercent() external view returns (uint24) {\\r\\n    return _maxBalancePercent;\\r\\n  }\\r\\n\\r\\n  /// @notice Set the max. percentage of a wallet balance, depending on total supply\\r\\n  /// @param percent Desired percentage, multiplied by denominator (min. 0.1% of total supply, 0 to disable)\\r\\n  function setMaxBalancePercent(uint24 percent) external onlyOwner {\\r\\n    require(!_renounced.MaxBalance);\\r\\n\\r\\n    unchecked {\\r\\n      require(percent == 0 || (percent >= 100 && percent <= 100 * _denominator));\\r\\n    }\\r\\n\\r\\n    _setMaxBalancePercent(percent);\\r\\n\\r\\n    emit SetMaxBalancePercent(percent);\\r\\n  }\\r\\n\\r\\n  function _setMaxBalancePercent(uint24 percent) internal {\\r\\n    _maxBalancePercent = percent;\\r\\n    _maxBalanceAmount = percent > 0 ? _percentage(_totalSupply, uint256(percent)) : 0;\\r\\n\\r\\n    if (!_initialized) { emit SetMaxBalancePercent(percent); }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_DEXRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.25;\\n\\nimport \\\"./CF_Common.sol\\\";\\nimport \\\"./CF_Ownable.sol\\\";\\nimport \\\"./CF_ERC20.sol\\\";\\n\\nabstract contract CF_DEXRouterV2 is CF_Common, CF_Ownable, CF_ERC20 {\\n  event AddedLiquidity(uint256 tokenAmount, uint256 ethAmount, uint256 liquidity);\\n  event SwappedTokensForNative(uint256 tokenAmount, uint256 ethAmount);\\n  event SwappedTokensForTokens(address token, uint256 token0Amount, uint256 token1Amount);\\n  event SetDEXRouterV2(address indexed router, address indexed pair);\\n  event TradingEnabled();\\n  event RenouncedDEXRouterV2();\\n\\n  modifier lockSwapping {\\n    _swapping = true;\\n    _;\\n    _swapping = false;\\n  }\\n\\n  /// @notice Permanently renounce and prevent the owner from being able to update the DEX features\\n  /// @dev Existing settings will continue to be effective\\n  function renounceDEXRouterV2() external onlyOwner {\\n    _renounced.DEXRouterV2 = true;\\n\\n    emit RenouncedDEXRouterV2();\\n  }\\n\\n  function _setDEXRouterV2(address router, address token0) internal {\\n    IDEXRouterV2 _router = IDEXRouterV2(router);\\n    IDEXFactoryV2 factory = IDEXFactoryV2(_router.factory());\\n    address pair = factory.createPair(address(this), token0);\\n\\n    _dex = DEXRouterV2(router, pair, token0, _router.WETH(), address(0));\\n\\n    emit SetDEXRouterV2(router, _dex.pair);\\n  }\\n\\n  /// @notice Returns the DEX router currently in use\\n  function getDEXRouterV2() external view returns (address) {\\n    return _dex.router;\\n  }\\n\\n  /// @notice Returns the trading pair\\n  function getDEXPairV2() external view returns (address) {\\n    return _dex.pair;\\n  }\\n\\n  /// @notice Checks whether the token can be traded through the assigned DEX\\n  function isTradingEnabled() external view returns (bool) {\\n    return _tradingEnabled > 0;\\n  }\\n\\n  /// @notice Returns address of the LP tokens receiver\\n  /// @dev Used for automated liquidity injection through taxes\\n  function getDEXLPTokenReceiver() external view returns (address) {\\n    return _dex.receiver;\\n  }\\n\\n  /// @notice Set the address of the LP tokens receiver\\n  /// @dev Used for automated liquidity injection through taxes\\n  function setDEXLPTokenReceiver(address receiver) external onlyOwner {\\n    _setDEXLPTokenReceiver(receiver);\\n  }\\n\\n  function _setDEXLPTokenReceiver(address receiver) internal {\\n    _dex.receiver = receiver;\\n  }\\n\\n  /// @notice Checks the status of the auto-swapping feature\\n  function isAutoSwapEnabled() external view returns (bool) {\\n    return _autoSwapEnabled;\\n  }\\n\\n  /// @notice Returns the percentage range of the total supply over which the auto-swap will operate when accumulating taxes in the contract balance\\n  function getAutoSwapPercent() external view returns (uint24 min, uint24 max) {\\n    return (_minAutoSwapPercent, _maxAutoSwapPercent);\\n  }\\n\\n  /// @notice Sets the percentage range of the total supply over which the auto-swap will operate when accumulating taxes in the contract balance\\n  /// @param min Desired min. percentage to trigger the auto-swap, multiplied by denominator (0.001% to 1% of total supply)\\n  /// @param max Desired max. percentage to limit the auto-swap, multiplied by denominator (0.001% to 1% of total supply)\\n  function setAutoSwapPercent(uint24 min, uint24 max) external onlyOwner {\\n    require(!_renounced.DEXRouterV2);\\n    require(min >= 1 && min <= 1000, \\\"0.001% to 1%\\\");\\n    require(max >= min && max <= 1000, \\\"0.001% to 1%\\\");\\n\\n    _setAutoSwapPercent(min, max);\\n  }\\n\\n  function _setAutoSwapPercent(uint24 min, uint24 max) internal {\\n    _minAutoSwapPercent = min;\\n    _maxAutoSwapPercent = max;\\n    _minAutoSwapAmount = _percentage(_totalSupply, uint256(min));\\n    _maxAutoSwapAmount = _percentage(_totalSupply, uint256(max));\\n  }\\n\\n  /// @notice Enables or disables the auto-swap function\\n  /// @param status True to enable, False to disable\\n  function enableAutoSwap(bool status) external onlyOwner {\\n    require(!_renounced.DEXRouterV2);\\n    require(!status || _dex.router != address(0), \\\"No DEX\\\");\\n\\n    _autoSwapEnabled = status;\\n  }\\n\\n  /// @notice Swaps the assigned amount to inject liquidity and prepare collected taxes for its distribution\\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution and the min. threshold has been reached\\n  function autoSwap() external {\\n    require(_autoSwapEnabled && !_swapping && !_distributing);\\n\\n    _autoSwap(false);\\n  }\\n\\n  /// @notice Swaps the assigned amount to inject liquidity and prepare collected taxes for its distribution\\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution and the min. threshold has been reached unless forced\\n  /// @param force Ignore the min. and max. threshold amount\\n  function autoSwap(bool force) external {\\n    require(msg.sender == _owner || _whitelisted[msg.sender], \\\"Unauthorized\\\");\\n    require((force || _autoSwapEnabled) && !_swapping && !_distributing);\\n\\n    _autoSwap(force);\\n  }\\n\\n  function _autoSwap(bool force) internal lockSwapping {\\n    if (!force && !_autoSwapEnabled) { return; }\\n\\n    unchecked {\\n      uint256 amountForLiquidityToSwap = _amountForLiquidity > 0 ? _amountForLiquidity / 2 : 0;\\n      uint256 amountForTaxDistributionToSwap = (address(_taxToken) == _dex.WETH ? _amountForTaxDistribution : 0);\\n      uint256 amountToSwap = amountForTaxDistributionToSwap + amountForLiquidityToSwap;\\n\\n      if (!force && amountToSwap > _maxAutoSwapAmount) {\\n        amountForLiquidityToSwap = amountForLiquidityToSwap > 0 ? _percentage(_maxAutoSwapAmount, (100 * uint256(_denominator) * amountForLiquidityToSwap) / amountToSwap) : 0;\\n        amountForTaxDistributionToSwap = amountForTaxDistributionToSwap > 0 ? _percentage(_maxAutoSwapAmount, (100 * uint256(_denominator) * amountForTaxDistributionToSwap) / amountToSwap) : 0;\\n        amountToSwap = amountForTaxDistributionToSwap + amountForLiquidityToSwap;\\n      }\\n\\n      if ((force || amountToSwap >= _minAutoSwapAmount) && _balance[address(this)] >= amountToSwap + amountForLiquidityToSwap) {\\n        uint256 ethBalance = address(this).balance;\\n        address[] memory pathToSwapExactTokensForNative = new address[](2);\\n        pathToSwapExactTokensForNative[0] = address(this);\\n        pathToSwapExactTokensForNative[1] = _dex.WETH;\\n\\n        _approve(address(this), _dex.router, amountToSwap);\\n\\n        try IDEXRouterV2(_dex.router).swapExactTokensForETHSupportingFeeOnTransferTokens(amountToSwap, 0, pathToSwapExactTokensForNative, address(this), block.timestamp) {\\n          if (_amountForLiquidity > 0) { _amountForLiquidity -= amountForLiquidityToSwap; }\\n\\n          uint256 ethAmount = address(this).balance - ethBalance;\\n\\n          emit SwappedTokensForNative(amountToSwap, ethAmount);\\n\\n          if (ethAmount > 0) {\\n            _ethForLiquidity += _percentage(ethAmount, (100 * uint256(_denominator) * amountForLiquidityToSwap) / amountToSwap);\\n\\n            if (address(_taxToken) == _dex.WETH) {\\n              _ethForTaxDistribution += _percentage(ethAmount, (100 * uint256(_denominator) * amountForTaxDistributionToSwap) / amountToSwap);\\n              _amountSwappedForTaxDistribution += amountForTaxDistributionToSwap;\\n              _amountForTaxDistribution -= amountForTaxDistributionToSwap;\\n            }\\n          }\\n        } catch {\\n          _approve(address(this), _dex.router, 0);\\n        }\\n      }\\n\\n      if (address(_taxToken) != address(this) && address(_taxToken) != _dex.WETH) {\\n        amountForTaxDistributionToSwap = _amountForTaxDistribution;\\n\\n        if (!force && amountForTaxDistributionToSwap > _maxAutoSwapAmount) { amountForTaxDistributionToSwap = _maxAutoSwapAmount; }\\n\\n        if ((force || amountForTaxDistributionToSwap >= _minAutoSwapAmount) && _balance[address(this)] >= amountForTaxDistributionToSwap) {\\n          uint256 tokenAmount = _swapTokensForTokens(_taxToken, amountForTaxDistributionToSwap);\\n\\n          if (tokenAmount > 0) {\\n            _tokensForTaxDistribution[address(_taxToken)] += tokenAmount;\\n            _amountSwappedForTaxDistribution += amountForTaxDistributionToSwap;\\n            _amountForTaxDistribution -= amountForTaxDistributionToSwap;\\n          }\\n        }\\n      }\\n    }\\n\\n    _addLiquidity(force);\\n    _lastSwap = _timestamp();\\n  }\\n\\n  function _swapTokensForTokens(IERC20 token, uint256 amount) private returns (uint256 tokenAmount) {\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n    address[] memory pathToSwapExactTokensForTokens = new address[](3);\\n    pathToSwapExactTokensForTokens[0] = address(this);\\n    pathToSwapExactTokensForTokens[1] = _dex.WETH;\\n    pathToSwapExactTokensForTokens[2] = address(token);\\n\\n    _approve(address(this), _dex.router, amount);\\n\\n    try IDEXRouterV2(_dex.router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, pathToSwapExactTokensForTokens, address(this), block.timestamp) {\\n      tokenAmount = token.balanceOf(address(this)) - tokenBalance;\\n\\n      emit SwappedTokensForTokens(address(token), amount, tokenAmount);\\n    } catch {\\n      _approve(address(this), _dex.router, 0);\\n    }\\n  }\\n\\n  function _addLiquidity(bool force) private {\\n    if (!force && (_amountForLiquidity < _minAutoAddLiquidityAmount || _ethForLiquidity == 0)) { return; }\\n\\n    unchecked {\\n      uint256 amountForLiquidityToAdd = !force && _amountForLiquidity > _maxAutoAddLiquidityAmount ? _maxAutoAddLiquidityAmount : _amountForLiquidity;\\n      uint256 ethForLiquidityToAdd = !force && _amountForLiquidity > _maxAutoAddLiquidityAmount ? _percentage(_ethForLiquidity, 100 * uint256(_denominator) * (_maxAutoAddLiquidityAmount / _amountForLiquidity)) : _ethForLiquidity;\\n\\n      _approve(address(this), _dex.router, amountForLiquidityToAdd);\\n\\n      try IDEXRouterV2(_dex.router).addLiquidityETH{ value: ethForLiquidityToAdd }(address(this), amountForLiquidityToAdd, 0, 0, _dex.receiver, block.timestamp) returns (uint256 tokenAmount, uint256 ethAmount, uint256 liquidity) {\\n        emit AddedLiquidity(tokenAmount, ethAmount, liquidity);\\n\\n        _amountForLiquidity -= amountForLiquidityToAdd;\\n        _ethForLiquidity -= ethForLiquidityToAdd;\\n      } catch {\\n        _approve(address(this), _dex.router, 0);\\n      }\\n    }\\n  }\\n\\n  /// @notice Returns the percentage range of the total supply over which the auto add liquidity will operate when accumulating taxes in the contract balance\\n  /// @dev Applies only if a Tax Beneficiary is the liquidity pool\\n  function getAutoAddLiquidityPercent() external view returns (uint24 min, uint24 max) {\\n    return (_minAutoAddLiquidityPercent, _maxAutoAddLiquidityPercent);\\n  }\\n\\n  /// @notice Sets the percentage range of the total supply over which the auto add liquidity will operate when accumulating taxes in the contract balance\\n  /// @param min Desired min. percentage to trigger the auto add liquidity, multiplied by denominator (0.01% to 100% of total supply)\\n  /// @param max Desired max. percentage to limit the auto add liquidity, multiplied by denominator (0.01% to 100% of total supply)\\n  function setAutoAddLiquidityPercent(uint24 min, uint24 max) external onlyOwner {\\n    require(!_renounced.DEXRouterV2);\\n    require(min >= 10 && min <= 100 * _denominator, \\\"0.01% to 100%\\\");\\n    require(max >= min && max <= 100 * _denominator, \\\"0.01% to 100%\\\");\\n\\n    _setAutoAddLiquidityPercent(min, max);\\n  }\\n\\n  function _setAutoAddLiquidityPercent(uint24 min, uint24 max) internal {\\n    _minAutoAddLiquidityPercent = min;\\n    _maxAutoAddLiquidityPercent = max;\\n    _minAutoAddLiquidityAmount = _percentage(_totalSupply, uint256(min));\\n    _maxAutoAddLiquidityAmount = _percentage(_totalSupply, uint256(max));\\n  }\\n\\n  /// @notice Returns the token for tax distribution\\n  function getTaxToken() external view returns (address) {\\n    return address(_taxToken);\\n  }\\n\\n  function _setTaxToken(address token) internal {\\n    require((!_initialized && token == address(0)) || token == address(this) || token == _dex.WETH || IDEXFactoryV2(IDEXRouterV2(_dex.router).factory()).getPair(_dex.WETH, token) != address(0), \\\"No Pair\\\");\\n\\n    _taxToken = IERC20(token == address(0) ? address(this) : token);\\n  }\\n\\n  /// @notice Enables the trading capability via the DEX set up\\n  /// @dev Once enabled, it cannot be reverted\\n  function enableTrading() external onlyOwner {\\n    require(!_renounced.DEXRouterV2);\\n    require(_tradingEnabled == 0, \\\"Already enabled\\\");\\n\\n    _tradingEnabled = _timestamp();\\n\\n    emit TradingEnabled();\\n  }\\n}\\n\"\r\n    },\r\n    \"CF_Recoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.25;\\n\\nimport \\\"./CF_Common.sol\\\";\\nimport \\\"./CF_Ownable.sol\\\";\\n\\nabstract contract CF_Recoverable is CF_Common, CF_Ownable {\\n  /// @notice Recovers a misplaced amount of an ERC-20 token sitting in the contract balance\\n  /// @dev Beware of scam tokens!\\n  /// @dev Note that if the token of this contract is specified, amounts allocated for tax distribution and liquidity are reserved\\n  /// @param token Address of the ERC-20 token\\n  /// @param to Recipient\\n  /// @param amount Amount to be transferred\\n  function recoverERC20(address token, address to, uint256 amount) external onlyOwner {\\n    unchecked {\\n      uint256 balance = IERC20(token).balanceOf(address(this));\\n      uint256 allocated = token == address(this) ? _amountForTaxDistribution + _amountForLiquidity : (address(_taxToken) == token ? _tokensForTaxDistribution[address(_taxToken)] : 0);\\n\\n      require(balance - (allocated >= balance ? balance : allocated) >= amount, \\\"Exceeds balance\\\");\\n    }\\n\\n    IERC20(token).transfer(to, amount);\\n  }\\n\\n  /// @notice Recovers a misplaced amount of native tokens sitting in the contract balance\\n  /// @dev Note that if the reflection token is the wrapped native, amounts allocated for tax distribution and/or liquidity are reserved\\n  /// @param to Recipient\\n  /// @param amount Amount of native tokens to be transferred\\n  function recoverNative(address payable to, uint256 amount) external onlyOwner {\\n    unchecked {\\n      uint256 balance = address(this).balance;\\n      uint256 allocated = address(_taxToken) == _dex.WETH ? _ethForTaxDistribution : 0;\\n\\n      require(balance - (allocated >= balance ? balance : allocated) >= amount, \\\"Exceeds balance\\\");\\n    }\\n\\n    (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n\\n    require(success);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"runs\": 200,\r\n      \"enabled\": true\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"AddedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedDEXRouterV2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedMaxBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedTaxable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"SetDEXRouterV2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"SetEarlyPenaltyTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"percent\",\"type\":\"uint24\"}],\"name\":\"SetMaxBalancePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"},{\"indexed\":false,\"internalType\":\"uint24[3]\",\"name\":\"penalty\",\"type\":\"uint24[3]\"}],\"name\":\"SetTaxBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"SwappedTokensForNative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"}],\"name\":\"SwappedTokensForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"autoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoTaxDistribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"enableAutoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoAddLiquidityPercent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"min\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"max\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoSwapPercent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"min\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"max\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXLPTokenReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXPairV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXRouterV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarlyPenaltyTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBalancePercent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAutoSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPenalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listTaxBeneficiaries\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"},{\"internalType\":\"uint24[3]\",\"name\":\"penalty\",\"type\":\"uint24[3]\"},{\"internalType\":\"uint256\",\"name\":\"unclaimed\",\"type\":\"uint256\"}],\"internalType\":\"struct CF_Taxable.taxBeneficiaryView[]\",\"name\":\"list\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceDEXRouterV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMaxBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceTaxable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"Whitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"MaxBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"DEXRouterV2\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Taxable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"min\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"max\",\"type\":\"uint24\"}],\"name\":\"setAutoAddLiquidityPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"min\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"max\",\"type\":\"uint24\"}],\"name\":\"setAutoSwapPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setDEXLPTokenReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"setEarlyPenaltyTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"percent\",\"type\":\"uint24\"}],\"name\":\"setMaxBalancePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"},{\"internalType\":\"uint24[3]\",\"name\":\"penalty\",\"type\":\"uint24[3]\"}],\"name\":\"setTaxBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"suspendTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesSuspended\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTaxCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"txTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MbaPEPE_0x", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}