{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/NinfaWhitelist.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*----------------------------------------------------------*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"./access/AccessControl.sol\\\";\\n\\n/**\\n *\\n * @title NinfaWhitelist                               *\\n *                                                           *\\n * @notice allowa lazy whitelist and access control          *\\n *                                                           *\\n * @custom:security-contact tech@ninfa.io                    *\\n *\\n */\\n\\n// this contract will need to have the CURATOR_ROLE on the factory\\n// and to be the owner of the marketplace and auction contracts\\ncontract NinfaWhitelist is AccessControl {\\n\\n    address private feeAccount; // this is the address that will receive the fee\\n\\n    bytes32 private DOMAIN_SEPARATOR;\\n    bytes32 private DOMAIN_TYPEHASH;\\n    bytes32 private WHITELIST_PERMIT_TYPEHASH;\\n\\n    // keccak256(\\\"CURATOR_ROLE\\\");\\n    bytes32 private constant CURATOR_ROLE = 0x850d585eb7f024ccee5e68e55f2c26cc72e1e6ee456acf62135757a5eb9d4a10;\\n\\n    uint256 private flatFee;\\n\\n    mapping(bytes => bool) private usedSignatures;\\n\\n    mapping(address => bool) public isWhitelisted;\\n\\n    struct WhitelistPermit {\\n        address collection;\\n        bool isWhitelisted;\\n        bytes32 collectionType;\\n        bytes32 salt;\\n    }\\n\\n    event Whitelist(\\n        address collection, address indexed whitelister, bytes32 indexed collectionType, bool isWhitelisted\\n    );\\n\\n    /**\\n     * @dev whoever has a valid signature can call the whitelistCollection\\n     * function, a flat fee could be payed of any\\n     * @param _permit contains information on what collection to whitelist and\\n     * if it should be whitelisted or not\\n     * @param _signature the signature of the curator\\n     */\\n    function whitelistCollection(WhitelistPermit calldata _permit, bytes memory _signature) external payable {\\n        require(msg.value >= flatFee);\\n\\n        if (flatFee > 0) {\\n            _sendValue(feeAccount, flatFee);\\n        }\\n\\n        address _signer = _recover(_permit, _signature);\\n\\n        require(hasRole(CURATOR_ROLE, _signer) && !usedSignatures[_signature]);\\n\\n        usedSignatures[_signature] = true;\\n\\n        isWhitelisted[_permit.collection] = _permit.isWhitelisted;\\n\\n        emit Whitelist(_permit.collection, msg.sender, _permit.collectionType, _permit.isWhitelisted);\\n    }\\n\\n    /*----------------------------------------------------------*|\\n    |*  # RECOVER FUNCTIONS                                     *|\\n    |*----------------------------------------------------------*/\\n\\n    function _recover(\\n        WhitelistPermit calldata _permit,\\n        bytes memory _signature\\n    )\\n        private\\n        view\\n        returns (address _signer)\\n    {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        WHITELIST_PERMIT_TYPEHASH,\\n                        _permit.collection,\\n                        _permit.isWhitelisted,\\n                        _permit.collectionType,\\n                        _permit.salt\\n                    )\\n                )\\n            )\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(_signature, 0x20))\\n            s := mload(add(_signature, 0x40))\\n            v := byte(0, mload(add(_signature, 0x60)))\\n        }\\n\\n        _signer = ecrecover(digest, v, r, s);\\n        if (_signer == address(0)) revert();\\n    }\\n\\n    /*----------------------------------------------------------*|\\n    |*  # OWNER FUNCTIONS                                       *|\\n    |*----------------------------------------------------------*/\\n\\n    function setFlatFee(uint256 _flatFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        flatFee = _flatFee;\\n    }\\n\\n    function setFeeAccount(address _feeAccount) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        feeAccount = _feeAccount;\\n    }\\n\\n    // this function is used to allow the curator to firectly whitelist a collection\\n    function whitelistCollection(address collection, bool isWhitelisted_) external onlyRole(CURATOR_ROLE) {\\n        isWhitelisted[collection] = isWhitelisted_;\\n    }\\n\\n    function whitelistCollections(address[] memory collections, bool isWhitelisted_) external onlyRole(CURATOR_ROLE) {\\n        for (uint256 i = 0; i < collections.length; i++) {\\n            isWhitelisted[collections[i]] = isWhitelisted_;\\n        }\\n    }\\n\\n    receive() external payable {\\n        revert();\\n    }\\n\\n    /*----------------------------------------------------------*|\\n    |*  #  OTHER                                                *|\\n    |*----------------------------------------------------------*/\\n\\n    function _sendValue(address _receiver, uint256 _amount) private {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = payable(_receiver).call{ value: _amount }(\\\"\\\");\\n        require(success);\\n    }\\n\\n    constructor(string memory _eip712DomainName) {\\n        DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n        WHITELIST_PERMIT_TYPEHASH =\\n            keccak256(\\\"WhitelistPermit(address collection,bool isWhitelisted,bytes32 collectionType,bytes32 salt)\\\");\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(_eip712DomainName)), // name\\n                block.chainid, // chainId\\n                address(this) // verifyingContract\\n            )\\n        );\\n\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow\\n * enumerating role\\n * members except through off-chain means by accessing the contract event logs.\\n * Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role,\\n     * replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 role, bytes32 previousAdminRole, bytes32 newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 role, address account, address sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 role, address account, address sender);\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular\\n     * expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role\\n     * (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular\\n     * expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role\\n     * (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\\"Account is missing role\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external {\\n        require(account == msg.sender); // \\\"AccessControl: can only renounce\\n            // roles for self\\\"\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4194304,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_eip712DomainName\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collectionType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"Whitelist\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_flatFee\",\"type\":\"uint256\"}],\"name\":\"setFlatFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"collectionType\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct NinfaWhitelist.WhitelistPermit\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"whitelistCollection\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted_\",\"type\":\"bool\"}],\"name\":\"whitelistCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted_\",\"type\":\"bool\"}],\"name\":\"whitelistCollections\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NinfaWhitelist", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "4194304", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000086e696e66612e696f000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}