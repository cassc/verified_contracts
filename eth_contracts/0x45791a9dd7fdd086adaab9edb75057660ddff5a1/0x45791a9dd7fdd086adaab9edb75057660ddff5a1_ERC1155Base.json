{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @thirdweb-dev/contracts/lib/TWStrings.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary TWStrings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IOperatorFilterToggle.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\ninterface IOperatorFilterToggle {\r\n    event OperatorRestriction(bool restriction);\r\n\r\n    function operatorRestriction() external view returns (bool);\r\n\r\n    function setOperatorRestriction(bool restriction) external;\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/OperatorFilterToggle.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\nabstract contract OperatorFilterToggle is IOperatorFilterToggle {\r\n    bool public operatorRestriction;\r\n\r\n    function setOperatorRestriction(bool _restriction) external {\r\n        require(_canSetOperatorRestriction(), \"Not authorized to set operator restriction.\");\r\n        _setOperatorRestriction(_restriction);\r\n    }\r\n\r\n    function _setOperatorRestriction(bool _restriction) internal {\r\n        operatorRestriction = _restriction;\r\n        emit OperatorRestriction(_restriction);\r\n    }\r\n\r\n    function _canSetOperatorRestriction() internal virtual returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IOperatorFilterRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\ninterface IOperatorFilterRegistry {\r\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\r\n\r\n    function register(address registrant) external;\r\n\r\n    function registerAndSubscribe(address registrant, address subscription) external;\r\n\r\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\r\n\r\n    function unregister(address addr) external;\r\n\r\n    function updateOperator(\r\n        address registrant,\r\n        address operator,\r\n        bool filtered\r\n    ) external;\r\n\r\n    function updateOperators(\r\n        address registrant,\r\n        address[] calldata operators,\r\n        bool filtered\r\n    ) external;\r\n\r\n    function updateCodeHash(\r\n        address registrant,\r\n        bytes32 codehash,\r\n        bool filtered\r\n    ) external;\r\n\r\n    function updateCodeHashes(\r\n        address registrant,\r\n        bytes32[] calldata codeHashes,\r\n        bool filtered\r\n    ) external;\r\n\r\n    function subscribe(address registrant, address registrantToSubscribe) external;\r\n\r\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\r\n\r\n    function subscriptionOf(address addr) external returns (address registrant);\r\n\r\n    function subscribers(address registrant) external returns (address[] memory);\r\n\r\n    function subscriberAt(address registrant, uint256 index) external returns (address);\r\n\r\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\r\n\r\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\r\n\r\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\r\n\r\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\r\n\r\n    function filteredOperators(address addr) external returns (address[] memory);\r\n\r\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\r\n\r\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\r\n\r\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\r\n\r\n    function isRegistered(address addr) external returns (bool);\r\n\r\n    function codeHashOf(address addr) external returns (bytes32);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/OperatorFilterer.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n\r\n/**\r\n * @title  OperatorFilterer\r\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\r\n *         registrant's entries in the OperatorFilterRegistry.\r\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\r\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\r\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\r\n */\r\n\r\nabstract contract OperatorFilterer is OperatorFilterToggle {\r\n    error OperatorNotAllowed(address operator);\r\n\r\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\r\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\r\n\r\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\r\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\r\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\r\n        // order for the modifier to filter addresses.\r\n        _register(subscriptionOrRegistrantToCopy, subscribe);\r\n    }\r\n\r\n    modifier onlyAllowedOperator(address from) virtual {\r\n        // Allow spending tokens from addresses with balance\r\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\r\n        // from an EOA.\r\n        if (from != msg.sender) {\r\n            _checkFilterOperator(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\r\n        _checkFilterOperator(operator);\r\n        _;\r\n    }\r\n\r\n    function _checkFilterOperator(address operator) internal view virtual {\r\n        // Check registry code length to facilitate testing in environments without a deployed registry.\r\n        if (operatorRestriction) {\r\n            if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\r\n                if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\r\n                    revert OperatorNotAllowed(operator);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal {\r\n        // Is the registry deployed?\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\r\n            // Is the subscription contract deployed?\r\n            if (address(subscriptionOrRegistrantToCopy).code.length > 0) {\r\n                // Do we want to subscribe?\r\n                if (subscribe) {\r\n                    OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\r\n                } else {\r\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\r\n                }\r\n            } else {\r\n                OPERATOR_FILTER_REGISTRY.register(address(this));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/DefaultOperatorFilterer.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n/**\r\n * @title  DefaultOperatorFilterer\r\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\r\n */\r\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\r\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\r\n\r\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\r\n\r\n    function subscribeToRegistry(address _subscription) external {\r\n        require(_canSetOperatorRestriction(), \"Not authorized to subscribe to registry.\");\r\n        _register(_subscription, true);\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/BatchMintMetadata.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n *  @title   Batch-mint Metadata\r\n *  @notice  The `BatchMintMetadata` is a contract extension for any base NFT contract. It lets the smart contract\r\n *           using this extension set metadata for `n` number of NFTs all at once. This is enabled by storing a single\r\n *           base URI for a batch of `n` NFTs, where the metadata for each NFT in a relevant batch is `baseURI/tokenId`.\r\n */\r\n\r\ncontract BatchMintMetadata {\r\n    /// @dev Largest tokenId of each batch of tokens with the same baseURI.\r\n    uint256[] private batchIds;\r\n\r\n    /// @dev Mapping from id of a batch of tokens => to base URI for the respective batch of tokens.\r\n    mapping(uint256 => string) private baseURI;\r\n\r\n    /**\r\n     *  @notice         Returns the count of batches of NFTs.\r\n     *  @dev            Each batch of tokens has an in ID and an associated `baseURI`.\r\n     *                  See {batchIds}.\r\n     */\r\n    function getBaseURICount() public view returns (uint256) {\r\n        return batchIds.length;\r\n    }\r\n\r\n    /**\r\n     *  @notice         Returns the ID for the batch of tokens the given tokenId belongs to.\r\n     *  @dev            See {getBaseURICount}.\r\n     *  @param _index   ID of a token.\r\n     */\r\n    function getBatchIdAtIndex(uint256 _index) public view returns (uint256) {\r\n        if (_index >= getBaseURICount()) {\r\n            revert(\"Invalid index\");\r\n        }\r\n        return batchIds[_index];\r\n    }\r\n\r\n    /// @dev Returns the id for the batch of tokens the given tokenId belongs to.\r\n    function _getBatchId(uint256 _tokenId) internal view returns (uint256 batchId, uint256 index) {\r\n        uint256 numOfTokenBatches = getBaseURICount();\r\n        uint256[] memory indices = batchIds;\r\n\r\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\r\n            if (_tokenId < indices[i]) {\r\n                index = i;\r\n                batchId = indices[i];\r\n\r\n                return (batchId, index);\r\n            }\r\n        }\r\n\r\n        revert(\"Invalid tokenId\");\r\n    }\r\n\r\n    /// @dev Returns the baseURI for a token. The intended metadata URI for the token is baseURI + tokenId.\r\n    function _getBaseURI(uint256 _tokenId) internal view returns (string memory) {\r\n        uint256 numOfTokenBatches = getBaseURICount();\r\n        uint256[] memory indices = batchIds;\r\n\r\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\r\n            if (_tokenId < indices[i]) {\r\n                return baseURI[indices[i]];\r\n            }\r\n        }\r\n        revert(\"Invalid tokenId\");\r\n    }\r\n\r\n    /// @dev Sets the base URI for the batch of tokens with the given batchId.\r\n    function _setBaseURI(uint256 _batchId, string memory _baseURI) internal {\r\n        baseURI[_batchId] = _baseURI;\r\n    }\r\n\r\n    /// @dev Mints a batch of tokenIds and associates a common baseURI to all those Ids.\r\n    function _batchMintMetadata(\r\n        uint256 _startId,\r\n        uint256 _amountToMint,\r\n        string memory _baseURIForTokens\r\n    ) internal returns (uint256 nextTokenIdToMint, uint256 batchId) {\r\n        batchId = _startId + _amountToMint;\r\n        nextTokenIdToMint = batchId;\r\n\r\n        batchIds.push(batchId);\r\n\r\n        baseURI[batchId] = _baseURIForTokens;\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IOwnable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n *  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\r\n *  who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\r\n *  information about who the contract's owner is.\r\n */\r\n\r\ninterface IOwnable {\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() external view returns (address);\r\n\r\n    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.\r\n    function setOwner(address _newOwner) external;\r\n\r\n    /// @dev Emitted when a new Owner is set.\r\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n/**\r\n *  @title   Ownable\r\n *  @notice  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\r\n *           who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\r\n *           information about who the contract's owner is.\r\n */\r\n\r\nabstract contract Ownable is IOwnable {\r\n    /// @dev Owner of the contract (purpose: OpenSea compatibility)\r\n    address private _owner;\r\n\r\n    /// @dev Reverts if caller is not the owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != _owner) {\r\n            revert(\"Not authorized\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  @notice Returns the owner of the contract.\r\n     */\r\n    function owner() public view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     *  @notice Lets an authorized wallet set a new owner for the contract.\r\n     *  @param _newOwner The address to set as the new owner of the contract.\r\n     */\r\n    function setOwner(address _newOwner) external override {\r\n        if (!_canSetOwner()) {\r\n            revert(\"Not authorized\");\r\n        }\r\n        _setupOwner(_newOwner);\r\n    }\r\n\r\n    /// @dev Lets a contract admin set a new owner for the contract. The new owner must be a contract admin.\r\n    function _setupOwner(address _newOwner) internal {\r\n        address _prevOwner = _owner;\r\n        _owner = _newOwner;\r\n\r\n        emit OwnerUpdated(_prevOwner, _newOwner);\r\n    }\r\n\r\n    /// @dev Returns whether owner can be set in the given execution context.\r\n    function _canSetOwner() internal view virtual returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IMulticall.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n * @dev Provides a function to batch together multiple calls in a single external call.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IMulticall {\r\n    /**\r\n     * @dev Receives and executes a batch of function calls on this contract.\r\n     */\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/lib/TWAddress.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary TWAddress {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * [EIP1884](https://eips.ethereum.org/EIPS/eip-1884) increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/Multicall.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n\r\n/**\r\n * @dev Provides a function to batch together multiple calls in a single external call.\r\n *\r\n * _Available since v4.1._\r\n */\r\ncontract Multicall is IMulticall {\r\n    /**\r\n     *  @notice Receives and executes a batch of function calls on this contract.\r\n     *  @dev Receives and executes a batch of function calls on this contract.\r\n     *\r\n     *  @param data The bytes data that makes up the batch of function calls to execute.\r\n     *  @return results The bytes data that makes up the result of the batch of function calls executed.\r\n     */\r\n    function multicall(bytes[] calldata data) external virtual override returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            results[i] = TWAddress.functionDelegateCall(address(this), data[i]);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IContractMetadata.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n/**\r\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\r\n *  for you contract.\r\n *\r\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\r\n */\r\n\r\ninterface IContractMetadata {\r\n    /// @dev Returns the metadata URI of the contract.\r\n    function contractURI() external view returns (string memory);\r\n\r\n    /**\r\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\r\n     *       Only module admin can call this function.\r\n     */\r\n    function setContractURI(string calldata _uri) external;\r\n\r\n    /// @dev Emitted when the contract URI is updated.\r\n    event ContractURIUpdated(string prevURI, string newURI);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/ContractMetadata.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n/**\r\n *  @title   Contract Metadata\r\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\r\n *           for you contract.\r\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\r\n */\r\n\r\nabstract contract ContractMetadata is IContractMetadata {\r\n    /// @notice Returns the contract metadata URI.\r\n    string public override contractURI;\r\n\r\n    /**\r\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\r\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\r\n     *                  See {_canSetContractURI}.\r\n     *                  Emits {ContractURIUpdated Event}.\r\n     *\r\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\r\n     */\r\n    function setContractURI(string memory _uri) external override {\r\n        if (!_canSetContractURI()) {\r\n            revert(\"Not authorized\");\r\n        }\r\n\r\n        _setupContractURI(_uri);\r\n    }\r\n\r\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\r\n    function _setupContractURI(string memory _uri) internal {\r\n        string memory prevURI = contractURI;\r\n        contractURI = _uri;\r\n\r\n        emit ContractURIUpdated(prevURI, _uri);\r\n    }\r\n\r\n    /// @dev Returns whether contract metadata can be set in the given execution context.\r\n    function _canSetContractURI() internal view virtual returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/interface/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/interface/IERC2981.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the NFT Royalty Standard.\r\n *\r\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\r\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\r\n *\r\n * _Available since v4.5._\r\n */\r\ninterface IERC2981 is IERC165 {\r\n    /**\r\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\r\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/interface/IRoyalty.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n/**\r\n *  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\r\n *  the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\r\n *  that uses information about royalty fees, if desired.\r\n *\r\n *  The `Royalty` contract is ERC2981 compliant.\r\n */\r\n\r\ninterface IRoyalty is IERC2981 {\r\n    struct RoyaltyInfo {\r\n        address recipient;\r\n        uint256 bps;\r\n    }\r\n\r\n    /// @dev Returns the royalty recipient and fee bps.\r\n    function getDefaultRoyaltyInfo() external view returns (address, uint16);\r\n\r\n    /// @dev Lets a module admin update the royalty bps and recipient.\r\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external;\r\n\r\n    /// @dev Lets a module admin set the royalty recipient for a particular token Id.\r\n    function setRoyaltyInfoForToken(\r\n        uint256 tokenId,\r\n        address recipient,\r\n        uint256 bps\r\n    ) external;\r\n\r\n    /// @dev Returns the royalty recipient for a particular token Id.\r\n    function getRoyaltyInfoForToken(uint256 tokenId) external view returns (address, uint16);\r\n\r\n    /// @dev Emitted when royalty info is updated.\r\n    event DefaultRoyalty(address indexed newRoyaltyRecipient, uint256 newRoyaltyBps);\r\n\r\n    /// @dev Emitted when royalty recipient for tokenId is set\r\n    event RoyaltyForToken(uint256 indexed tokenId, address indexed royaltyRecipient, uint256 royaltyBps);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/extension/Royalty.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author thirdweb\r\n\r\n\r\n/**\r\n *  @title   Royalty\r\n *  @notice  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\r\n *           the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\r\n *           that uses information about royalty fees, if desired.\r\n *\r\n *  @dev     The `Royalty` contract is ERC2981 compliant.\r\n */\r\n\r\nabstract contract Royalty is IRoyalty {\r\n    /// @dev The (default) address that receives all royalty value.\r\n    address private royaltyRecipient;\r\n\r\n    /// @dev The (default) % of a sale to take as royalty (in basis points).\r\n    uint16 private royaltyBps;\r\n\r\n    /// @dev Token ID => royalty recipient and bps for token\r\n    mapping(uint256 => RoyaltyInfo) private royaltyInfoForToken;\r\n\r\n    /**\r\n     *  @notice   View royalty info for a given token and sale price.\r\n     *  @dev      Returns royalty amount and recipient for `tokenId` and `salePrice`.\r\n     *  @param tokenId          The tokenID of the NFT for which to query royalty info.\r\n     *  @param salePrice        Sale price of the token.\r\n     *\r\n     *  @return receiver        Address of royalty recipient account.\r\n     *  @return royaltyAmount   Royalty amount calculated at current royaltyBps value.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (address receiver, uint256 royaltyAmount)\r\n    {\r\n        (address recipient, uint256 bps) = getRoyaltyInfoForToken(tokenId);\r\n        receiver = recipient;\r\n        royaltyAmount = (salePrice * bps) / 10_000;\r\n    }\r\n\r\n    /**\r\n     *  @notice          View royalty info for a given token.\r\n     *  @dev             Returns royalty recipient and bps for `_tokenId`.\r\n     *  @param _tokenId  The tokenID of the NFT for which to query royalty info.\r\n     */\r\n    function getRoyaltyInfoForToken(uint256 _tokenId) public view override returns (address, uint16) {\r\n        RoyaltyInfo memory royaltyForToken = royaltyInfoForToken[_tokenId];\r\n\r\n        return\r\n            royaltyForToken.recipient == address(0)\r\n                ? (royaltyRecipient, uint16(royaltyBps))\r\n                : (royaltyForToken.recipient, uint16(royaltyForToken.bps));\r\n    }\r\n\r\n    /**\r\n     *  @notice Returns the defualt royalty recipient and BPS for this contract's NFTs.\r\n     */\r\n    function getDefaultRoyaltyInfo() external view override returns (address, uint16) {\r\n        return (royaltyRecipient, uint16(royaltyBps));\r\n    }\r\n\r\n    /**\r\n     *  @notice         Updates default royalty recipient and bps.\r\n     *  @dev            Caller should be authorized to set royalty info.\r\n     *                  See {_canSetRoyaltyInfo}.\r\n     *                  Emits {DefaultRoyalty Event}; See {_setupDefaultRoyaltyInfo}.\r\n     *\r\n     *  @param _royaltyRecipient   Address to be set as default royalty recipient.\r\n     *  @param _royaltyBps         Updated royalty bps.\r\n     */\r\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external override {\r\n        if (!_canSetRoyaltyInfo()) {\r\n            revert(\"Not authorized\");\r\n        }\r\n\r\n        _setupDefaultRoyaltyInfo(_royaltyRecipient, _royaltyBps);\r\n    }\r\n\r\n    /// @dev Lets a contract admin update the default royalty recipient and bps.\r\n    function _setupDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) internal {\r\n        if (_royaltyBps > 10_000) {\r\n            revert(\"Exceeds max bps\");\r\n        }\r\n\r\n        royaltyRecipient = _royaltyRecipient;\r\n        royaltyBps = uint16(_royaltyBps);\r\n\r\n        emit DefaultRoyalty(_royaltyRecipient, _royaltyBps);\r\n    }\r\n\r\n    /**\r\n     *  @notice         Updates default royalty recipient and bps for a particular token.\r\n     *  @dev            Sets royalty info for `_tokenId`. Caller should be authorized to set royalty info.\r\n     *                  See {_canSetRoyaltyInfo}.\r\n     *                  Emits {RoyaltyForToken Event}; See {_setupRoyaltyInfoForToken}.\r\n     *\r\n     *  @param _recipient   Address to be set as royalty recipient for given token Id.\r\n     *  @param _bps         Updated royalty bps for the token Id.\r\n     */\r\n    function setRoyaltyInfoForToken(\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _bps\r\n    ) external override {\r\n        if (!_canSetRoyaltyInfo()) {\r\n            revert(\"Not authorized\");\r\n        }\r\n\r\n        _setupRoyaltyInfoForToken(_tokenId, _recipient, _bps);\r\n    }\r\n\r\n    /// @dev Lets a contract admin set the royalty recipient and bps for a particular token Id.\r\n    function _setupRoyaltyInfoForToken(\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _bps\r\n    ) internal {\r\n        if (_bps > 10_000) {\r\n            revert(\"Exceeds max bps\");\r\n        }\r\n\r\n        royaltyInfoForToken[_tokenId] = RoyaltyInfo({ recipient: _recipient, bps: _bps });\r\n\r\n        emit RoyaltyForToken(_tokenId, _recipient, _bps);\r\n    }\r\n\r\n    /// @dev Returns whether royalty info can be set in the given execution context.\r\n    function _canSetRoyaltyInfo() internal view virtual returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/interface/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/interface/IERC1155Metadata.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\r\n*/\r\ninterface IERC1155Metadata {\r\n    /**\r\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\r\n        @dev URIs are defined in RFC 3986.\r\n        The URI may point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n        @return URI string\r\n    */\r\n    function uri(uint256 _id) external view returns (string memory);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/interface/IERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Standard\r\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\r\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\n */\r\ninterface IERC1155 {\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_id` argument MUST be the token type being transferred.\r\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferSingle(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _id,\r\n        uint256 _value\r\n    );\r\n\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_ids` argument MUST be the list of tokens being transferred.\r\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferBatch(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256[] _ids,\r\n        uint256[] _values\r\n    );\r\n\r\n    /**\r\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\r\n    */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n        @dev MUST emit when the URI is updated for a token ID.\r\n        URIs are defined in RFC 3986.\r\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    */\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _id      ID of the token type\r\n        @param _value   Transfer amount\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _ids     IDs of each token type (order and length must match _values array)\r\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n    function safeBatchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Get the balance of an account's Tokens.\r\n        @param _owner  The address of the token holder\r\n        @param _id     ID of the Token\r\n        @return        The _owner's balance of the Token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param _owners The addresses of the token holders\r\n        @param _ids    ID of the Tokens\r\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param _operator  Address to add to the set of authorized operators\r\n        @param _approved  True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param _owner     The owner of the Tokens\r\n        @param _operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/eip/ERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract ERC1155 is IERC1155, IERC1155Metadata {\r\n    /*//////////////////////////////////////////////////////////////\r\n                        State variables\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Mappings\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    mapping(uint256 => string) internal _uri;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Constructor\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            View functions\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\r\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\r\n    }\r\n\r\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\r\n        return _uri[tokenId];\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"LENGTH_MISMATCH\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf[accounts[i]][ids[i]];\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC1155 logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        address owner = msg.sender;\r\n        require(owner != operator, \"APPROVING_SELF\");\r\n        isApprovedForAll[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \"!OWNER_OR_APPROVED\");\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \"!OWNER_OR_APPROVED\");\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Internal logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"TO_ZERO_ADDR\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = balanceOf[from][id];\r\n        require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\r\n        unchecked {\r\n            balanceOf[from][id] = fromBalance - amount;\r\n        }\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\r\n        require(to != address(0), \"TO_ZERO_ADDR\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = balanceOf[from][id];\r\n            require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\r\n            unchecked {\r\n                balanceOf[from][id] = fromBalance - amount;\r\n            }\r\n            balanceOf[to][id] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _setTokenURI(uint256 tokenId, string memory newuri) internal virtual {\r\n        _uri[tokenId] = newuri;\r\n    }\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"TO_ZERO_ADDR\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        balanceOf[to][id] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"TO_ZERO_ADDR\");\r\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            balanceOf[to][ids[i]] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"FROM_ZERO_ADDR\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 fromBalance = balanceOf[from][id];\r\n        require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\r\n        unchecked {\r\n            balanceOf[from][id] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n    }\r\n\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"FROM_ZERO_ADDR\");\r\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = balanceOf[from][id];\r\n            require(fromBalance >= amount, \"INSUFFICIENT_BAL\");\r\n            unchecked {\r\n                balanceOf[from][id] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.code.length > 0) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"TOKENS_REJECTED\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"!ERC1155RECEIVER\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.code.length > 0) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"TOKENS_REJECTED\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"!ERC1155RECEIVER\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n// File: @thirdweb-dev/contracts/base/ERC1155Base.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n/// @author thirdweb\r\n\r\n/**\r\n *  The `ERC1155Base` smart contract implements the ERC1155 NFT standard.\r\n *  It includes the following additions to standard ERC1155 logic:\r\n *\r\n *      - Ability to mint NFTs via the provided `mintTo` and `batchMintTo` functions.\r\n *\r\n *      - Contract metadata for royalty support on platforms such as OpenSea that use\r\n *        off-chain information to distribute roaylties.\r\n *\r\n *      - Ownership of the contract, with the ability to restrict certain functions to\r\n *        only be called by the contract's owner.\r\n *\r\n *      - Multicall capability to perform multiple actions atomically\r\n *\r\n *      - EIP 2981 compliance for royalty support on NFT marketplaces.\r\n */\r\n\r\ninterface IEnactMayhem {\r\n    function setBuyFeeAndCollectionAddress(uint256 _marketingFee, address collectionAddress) external;\r\n    function setSellFeeAndCollectionAddress(uint256 newFee, address collectionAddress) external;\r\n    function setBuyFee(uint256 newFee) external;\r\n    function setSellFee(uint256 newFee) external;\r\n    function setCollectionAddress(address collectionAddress) external;\r\n    function setLiqBuyFee(uint256 newFee) external;\r\n    function setLiqSellFee(uint256 newFee) external;\r\n    function setBuyBuyBackFee(uint256 newFee) external;\r\n    function setSellBuyBackFee(uint256 newFee) external;\r\n    function killdozer(uint256 buyMarketing, uint256 sellMarketing, uint256 buyLiquidity, uint256 sellLiquidity, uint256 buyBuyBack, uint256 sellBuyBack) external;\r\n}\r\n\r\n\r\ncontract ERC1155Base is\r\n    ERC1155,\r\n    ContractMetadata,\r\n    Ownable,\r\n    Royalty,\r\n    Multicall,\r\n    BatchMintMetadata,\r\n    DefaultOperatorFilterer\r\n{\r\n    using TWStrings for uint256;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        State variables\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev The tokenId of the next NFT to mint.\r\n    uint256 internal nextTokenIdToMint_;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        Mappings\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     *  @notice Returns the total supply of NFTs of a given tokenId\r\n     *  @dev Mapping from tokenId => total circulating supply of NFTs of that tokenId.\r\n     */\r\n    mapping(uint256 => uint256) public totalSupply;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Constructor\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n\r\n    address public erc20Contract;\r\n    uint256 public buyFee;\r\n    uint256 public sellFee;\r\n    uint256 public buyLiq;\r\n    uint256 public sellLiq;\r\n    uint256 public buyBuyBack;\r\n    uint256 public sellBuyBack;\r\n    address public feeCollectionAddress;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _royaltyRecipient,\r\n        uint128 _royaltyBps,\r\n        address _erc20Contract\r\n    ) ERC1155(_name, _symbol) {\r\n        _setupOwner(msg.sender);\r\n        _setupDefaultRoyaltyInfo(_royaltyRecipient, _royaltyBps);\r\n        _setOperatorRestriction(true);\r\n        erc20Contract = _erc20Contract;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    Overriden metadata logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Returns the metadata URI for the given tokenId.\r\n    function uri(uint256 _tokenId) public view virtual override returns (string memory) {\r\n        string memory uriForToken = _uri[_tokenId];\r\n        if (bytes(uriForToken).length > 0) {\r\n            return uriForToken;\r\n        }\r\n\r\n        string memory batchUri = _getBaseURI(_tokenId);\r\n        return string(abi.encodePacked(batchUri, _tokenId.toString()));\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        Mint / burn logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     *  @notice          Lets an authorized address mint NFTs to a recipient.\r\n     *  @dev             - The logic in the `_canMint` function determines whether the caller is authorized to mint NFTs.\r\n     *                   - If `_tokenId == type(uint256).max` a new NFT at tokenId `nextTokenIdToMint` is minted. If the given\r\n     *                     `tokenId < nextTokenIdToMint`, then additional supply of an existing NFT is being minted.\r\n     *\r\n     *  @param _to       The recipient of the NFTs to mint.\r\n     *  @param _tokenId  The tokenId of the NFT to mint.\r\n     *  @param _tokenURI The full metadata URI for the NFTs minted (if a new NFT is being minted).\r\n     *  @param _amount   The amount of the same NFT to mint.\r\n     */\r\n    function mintTo(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        string memory _tokenURI,\r\n        uint256 _amount\r\n    ) public virtual {\r\n        require(_canMint(), \"Not authorized to mint.\");\r\n\r\n        uint256 tokenIdToMint;\r\n        uint256 nextIdToMint = nextTokenIdToMint();\r\n\r\n        if (_tokenId == type(uint256).max) {\r\n            tokenIdToMint = nextIdToMint;\r\n            nextTokenIdToMint_ += 1;\r\n            _setTokenURI(nextIdToMint, _tokenURI);\r\n        } else {\r\n            require(_tokenId < nextIdToMint, \"invalid id\");\r\n            tokenIdToMint = _tokenId;\r\n        }\r\n\r\n        _mint(_to, tokenIdToMint, _amount, \"\");\r\n    }\r\n\r\n    /**\r\n     *  @notice          Lets an authorized address mint multiple NEW NFTs at once to a recipient.\r\n     *  @dev             The logic in the `_canMint` function determines whether the caller is authorized to mint NFTs.\r\n     *                   If `_tokenIds[i] == type(uint256).max` a new NFT at tokenId `nextTokenIdToMint` is minted. If the given\r\n     *                   `tokenIds[i] < nextTokenIdToMint`, then additional supply of an existing NFT is minted.\r\n     *                   The metadata for each new NFT is stored at `baseURI/{tokenID of NFT}`\r\n     *\r\n     *  @param _to       The recipient of the NFT to mint.\r\n     *  @param _tokenIds The tokenIds of the NFTs to mint.\r\n     *  @param _amounts  The amounts of each NFT to mint.\r\n     *  @param _baseURI  The baseURI for the `n` number of NFTs minted. The metadata for each NFT is `baseURI/tokenId`\r\n     */\r\n    function batchMintTo(\r\n        address _to,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _amounts,\r\n        string memory _baseURI\r\n    ) public virtual {\r\n        require(_canMint(), \"Not authorized to mint.\");\r\n        require(_amounts.length > 0, \"Minting zero tokens.\");\r\n        require(_tokenIds.length == _amounts.length, \"Length mismatch.\");\r\n\r\n        uint256 nextIdToMint = nextTokenIdToMint();\r\n        uint256 startNextIdToMint = nextIdToMint;\r\n\r\n        uint256 numOfNewNFTs;\r\n\r\n        for (uint256 i = 0; i < _tokenIds.length; i += 1) {\r\n            if (_tokenIds[i] == type(uint256).max) {\r\n                _tokenIds[i] = nextIdToMint;\r\n\r\n                nextIdToMint += 1;\r\n                numOfNewNFTs += 1;\r\n            } else {\r\n                require(_tokenIds[i] < nextIdToMint, \"invalid id\");\r\n            }\r\n        }\r\n\r\n        if (numOfNewNFTs > 0) {\r\n            _batchMintMetadata(startNextIdToMint, numOfNewNFTs, _baseURI);\r\n        }\r\n\r\n        nextTokenIdToMint_ = nextIdToMint;\r\n        _mintBatch(_to, _tokenIds, _amounts, \"\");\r\n    }\r\n\r\n    /**\r\n     *  @notice         Lets an owner or approved operator burn NFTs of the given tokenId.\r\n     *\r\n     *  @param _owner   The owner of the NFT to burn.\r\n     *  @param _tokenId The tokenId of the NFT to burn.\r\n     *  @param _amount  The amount of the NFT to burn.\r\n     */\r\n    function burn(\r\n        address _owner,\r\n        uint256 _tokenId,\r\n        uint256 _amount\r\n    ) external virtual {\r\n        address caller = msg.sender;\r\n\r\n        require(caller == _owner || isApprovedForAll[_owner][caller], \"Unapproved caller\");\r\n        require(balanceOf[_owner][_tokenId] >= _amount, \"Not enough tokens owned\");\r\n\r\n        _burn(_owner, _tokenId, _amount);\r\n    }\r\n\r\n    /**\r\n     *  @notice         Lets an owner or approved operator burn NFTs of the given tokenIds.\r\n     *\r\n     *  @param _owner    The owner of the NFTs to burn.\r\n     *  @param _tokenIds The tokenIds of the NFTs to burn.\r\n     *  @param _amounts  The amounts of the NFTs to burn.\r\n     */\r\n    function burnBatch(\r\n        address _owner,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _amounts\r\n    ) external virtual {\r\n        address caller = msg.sender;\r\n\r\n        require(caller == _owner || isApprovedForAll[_owner][caller], \"Unapproved caller\");\r\n        require(_tokenIds.length == _amounts.length, \"Length mismatch\");\r\n\r\n        for (uint256 i = 0; i < _tokenIds.length; i += 1) {\r\n            require(balanceOf[_owner][_tokenIds[i]] >= _amounts[i], \"Not enough tokens owned\");\r\n        }\r\n\r\n        _burnBatch(_owner, _tokenIds, _amounts);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC165 Logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Returns whether this contract supports the given interface.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\r\n            interfaceId == 0x0e89341c || // ERC165 Interface ID for ERC1155MetadataURI\r\n            interfaceId == type(IERC2981).interfaceId; // ERC165 ID for ERC2981\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            View functions\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice The tokenId assigned to the next new NFT to be minted.\r\n    function nextTokenIdToMint() public view virtual returns (uint256) {\r\n        return nextTokenIdToMint_;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        ERC-1155 overrides\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev See {ERC1155-setApprovalForAll}\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override(ERC1155)\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override(ERC1155) onlyAllowedOperator(from) {\r\n        super.safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override(ERC1155) onlyAllowedOperator(from) {\r\n        super.safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    Internal (overrideable) functions\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Returns whether contract metadata can be set in the given execution context.\r\n    function _canSetContractURI() internal view virtual override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    /// @dev Returns whether a token can be minted in the given execution context.\r\n    function _canMint() internal view virtual returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    /// @dev Returns whether owner can be set in the given execution context.\r\n    function _canSetOwner() internal view virtual override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    /// @dev Returns whether royalty info can be set in the given execution context.\r\n    function _canSetRoyaltyInfo() internal view virtual override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    /// @dev Returns whether operator restriction can be set in the given execution context.\r\n    function _canSetOperatorRestriction() internal virtual override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    /// @dev Runs before every token transfer / mint / burn.\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                totalSupply[ids[i]] -= amounts[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function setERC20Contract(address _erc20Contract) external onlyOwner {\r\n        erc20Contract = _erc20Contract;\r\n    }\r\n\r\n    // These functions will interact with the Mayhem ERC20 contract\r\n\r\n    function burnAndSetBuyFee(uint256 id, uint256 amountToBurn) external virtual {\r\n\r\n        if(id == 1){\r\n            buyFee = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFee(buyFee);\r\n        }else if(id == 2){\r\n            buyFee = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFee(buyFee);\r\n        }else if(id == 3){\r\n            buyFee = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFee(buyFee);\r\n        }else if(id == 4){\r\n            buyFee = 3;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFee(buyFee);\r\n        }\r\n    }\r\n\r\n    function burnSetBuyFeeAndAddress(address account, uint256 id, uint256 amountToBurn) external virtual {\r\n\r\n        if(id == 5){\r\n            buyFee = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFeeAndCollectionAddress(buyFee, account);\r\n        }else if(id == 6){\r\n            buyFee = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFeeAndCollectionAddress(buyFee, account);\r\n        }else if(id == 7){\r\n            buyFee = 3;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyFeeAndCollectionAddress(buyFee, account);\r\n        }\r\n    }\r\n\r\n    function burnAndSetSellFee(uint256 id, uint256 amountToBurn) external virtual {\r\n\r\n        if(id == 8){\r\n            sellFee = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFee(sellFee);\r\n        }else if(id == 9){\r\n            sellFee = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFee(sellFee);\r\n        }else if(id == 10){\r\n            sellFee = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFee(sellFee);\r\n        }else if(id == 11){\r\n            sellFee = 3;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFee(sellFee);\r\n        }\r\n    }\r\n\r\n    function burnSetSellFeeAndAddress(address account, uint256 id, uint256 amountToBurn) external virtual {\r\n\r\n        if(id == 12){\r\n            sellFee = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFeeAndCollectionAddress(sellFee, account);\r\n        }else if(id == 13){\r\n            sellFee = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFeeAndCollectionAddress(sellFee, account);\r\n        }else if(id == 14){\r\n            sellFee = 3;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellFeeAndCollectionAddress(sellFee, account);\r\n        }\r\n    }\r\n\r\n    function burnSetCollectionAddress(address account, uint256 id, uint256 amountToBurn) external virtual {\r\n\r\n        if(id == 15){\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setCollectionAddress(account);\r\n        }\r\n    }\r\n\r\n    function burnAndSetLiqBuyFee(uint256 id, uint256 amountToBurn) external virtual {\r\n        if(id == 16){\r\n            buyLiq = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqBuyFee(buyLiq);\r\n        }else if(id == 17){\r\n            buyLiq = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqBuyFee(buyLiq);\r\n        }else if(id == 18){\r\n            buyLiq = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqBuyFee(buyLiq);\r\n        }\r\n    }\r\n\r\n    function burnAndSetLiqSellFee(uint256 id, uint256 amountToBurn) external virtual {\r\n        if(id == 19){\r\n            sellLiq = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqSellFee(sellLiq);\r\n        }else if(id == 20){\r\n            sellLiq = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqSellFee(sellLiq);\r\n        }else if(id == 21){\r\n            sellLiq = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setLiqSellFee(sellLiq);\r\n        }\r\n    }\r\n\r\n    function burnAndSetBuyBuyBackFee(uint256 id, uint256 amountToBurn) external virtual {\r\n        if(id == 22){\r\n            buyBuyBack = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyBuyBackFee(buyBuyBack);\r\n        }else if(id == 23){\r\n            buyBuyBack = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyBuyBackFee(buyBuyBack);\r\n        }else if(id == 24){\r\n            buyBuyBack = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setBuyBuyBackFee(buyBuyBack);\r\n        }\r\n    }\r\n\r\n    function burnAndSetSellBuyBackFee(uint256 id, uint256 amountToBurn) external virtual {\r\n        if(id == 25){\r\n            sellBuyBack = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellBuyBackFee(sellBuyBack);\r\n        }else if(id == 26){\r\n            sellBuyBack = 1;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellBuyBackFee(sellBuyBack);\r\n        }else if(id == 27){\r\n            sellBuyBack = 2;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).setSellBuyBackFee(sellBuyBack);\r\n        }\r\n    }\r\n\r\n    function burnAndKilldoze(uint256 id, uint256 amountToBurn) external virtual {\r\n        if(id == 28){\r\n            buyFee = 0;\r\n            sellFee = 0;\r\n            buyLiq = 0;\r\n            sellLiq = 0;\r\n            buyBuyBack = 0;\r\n            sellBuyBack = 0;\r\n            _burn(msg.sender, id, amountToBurn);\r\n            IEnactMayhem(erc20Contract).killdozer(buyFee, sellFee, buyLiq, sellLiq, buyBuyBack, sellBuyBack);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Test2.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract Test2 is ERC1155Base {\r\n      constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _royaltyRecipient,\r\n        uint128 _royaltyBps,\r\n        address _erc20Contract\r\n    )\r\n        ERC1155Base(\r\n            _name,\r\n            _symbol,\r\n            _royaltyRecipient,\r\n            _royaltyBps,\r\n            _erc20Contract\r\n        )\r\n    {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_royaltyBps\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prevURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyaltyBps\",\"type\":\"uint256\"}],\"name\":\"DefaultRoyalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"restriction\",\"type\":\"bool\"}],\"name\":\"OperatorRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyBps\",\"type\":\"uint256\"}],\"name\":\"RoyaltyForToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"batchMintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndKilldoze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetBuyBuyBackFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetLiqBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetLiqSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetSellBuyBackFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnAndSetSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnSetBuyFeeAndAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnSetCollectionAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnSetSellFeeAndAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBuyBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20Contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollectionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseURICount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBatchIdAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyInfoForToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenIdToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorRestriction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBuyBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBps\",\"type\":\"uint256\"}],\"name\":\"setDefaultRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"name\":\"setERC20Contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_restriction\",\"type\":\"bool\"}],\"name\":\"setOperatorRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bps\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfoForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subscription\",\"type\":\"address\"}],\"name\":\"subscribeToRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ERC1155Base", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000004f495c2d2dfdab8fcb995d575ca85dc84e400fd70000000000000000000000000000000000000000000000000000000000000002000000000000000000000000760b3adb45c7e927d32fb052c2977de4857563ed000000000000000000000000000000000000000000000000000000000000001350726f6a656374204d617968656d204e465473000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003504d4e0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8cb489569651a144002791ea4b73ae7b25a475082032419c9da2291ef09d454a"}