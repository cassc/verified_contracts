{"SourceCode": "// Sources flattened with hardhat v2.22.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT AND UNLICENSED\r\n\r\n// File @openzeppelin/contracts/interfaces/draft-IERC6093.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard ERC20 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\r\n */\r\ninterface IERC20Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC721 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\r\n */\r\ninterface IERC721Errors {\r\n    /**\r\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\r\n     * Used in balance queries.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721InvalidOwner(address owner);\r\n\r\n    /**\r\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param tokenId Identifier number of a token.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC721InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC721InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC721InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC721InvalidOperator(address operator);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC1155 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\r\n */\r\ninterface IERC1155Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC1155MissingApprovalForAll(address operator, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC1155InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC1155InvalidOperator(address operator);\r\n\r\n    /**\r\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\r\n     * Used in batch transfers.\r\n     * @param idsLength Length of the array of token identifiers\r\n     * @param valuesLength Length of the array of token amounts\r\n     */\r\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n */\r\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\r\n    mapping(address account => uint256) private _balances;\r\n\r\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `value`.\r\n     */\r\n    function transfer(address to, uint256 value) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `value`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `value`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        if (from == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        if (to == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\r\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\r\n     * this function.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _update(address from, address to, uint256 value) internal virtual {\r\n        if (from == address(0)) {\r\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\r\n            _totalSupply += value;\r\n        } else {\r\n            uint256 fromBalance = _balances[from];\r\n            if (fromBalance < value) {\r\n                revert ERC20InsufficientBalance(from, fromBalance, value);\r\n            }\r\n            unchecked {\r\n                // Overflow not possible: value <= fromBalance <= totalSupply.\r\n                _balances[from] = fromBalance - value;\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            unchecked {\r\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\r\n                _totalSupply -= value;\r\n            }\r\n        } else {\r\n            unchecked {\r\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\r\n                _balances[to] += value;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\r\n     * Relies on the `_update` mechanism\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        if (account == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\r\n     * Relies on the `_update` mechanism.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        if (account == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        _update(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     *\r\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        _approve(owner, spender, value, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\r\n     *\r\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\r\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\r\n     * `Approval` event during `transferFrom` operations.\r\n     *\r\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\r\n     * true using the following override:\r\n     * ```\r\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\r\n     *     super._approve(owner, spender, value, true);\r\n     * }\r\n     * ```\r\n     *\r\n     * Requirements are the same as {_approve}.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\r\n        if (owner == address(0)) {\r\n            revert ERC20InvalidApprover(address(0));\r\n        }\r\n        if (spender == address(0)) {\r\n            revert ERC20InvalidSpender(address(0));\r\n        }\r\n        _allowances[owner][spender] = value;\r\n        if (emitEvent) {\r\n            emit Approval(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\r\n     *\r\n     * Does not update the allowance value in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Does not emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < value) {\r\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\r\n            }\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - value, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 value) public virtual {\r\n        _burn(_msgSender(), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\r\n     * the caller's allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `value`.\r\n     */\r\n    function burnFrom(address account, uint256 value) public virtual {\r\n        _spendAllowance(account, _msgSender(), value);\r\n        _burn(account, value);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Capped.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\r\n */\r\nabstract contract ERC20Capped is ERC20 {\r\n    uint256 private immutable _cap;\r\n\r\n    /**\r\n     * @dev Total supply cap has been exceeded.\r\n     */\r\n    error ERC20ExceededCap(uint256 increasedSupply, uint256 cap);\r\n\r\n    /**\r\n     * @dev The supplied cap is not a valid cap.\r\n     */\r\n    error ERC20InvalidCap(uint256 cap);\r\n\r\n    /**\r\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\r\n     * set once during construction.\r\n     */\r\n    constructor(uint256 cap_) {\r\n        if (cap_ == 0) {\r\n            revert ERC20InvalidCap(0);\r\n        }\r\n        _cap = cap_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the cap on the token's total supply.\r\n     */\r\n    function cap() public view virtual returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_update}.\r\n     */\r\n    function _update(address from, address to, uint256 value) internal virtual override {\r\n        super._update(from, to, value);\r\n\r\n        if (from == address(0)) {\r\n            uint256 maxSupply = cap();\r\n            uint256 supply = totalSupply();\r\n            if (supply > maxSupply) {\r\n                revert ERC20ExceededCap(supply, maxSupply);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Disburser.sol\r\n\r\n// Original license: SPDX_License_Identifier: UNLICENSED\r\npragma solidity ^0.8.24;\r\n\r\n\r\n\r\ncontract Disburser {\r\n    address public owner;\r\n\r\n    address public receiverAddress;\r\n\r\n    uint256 public transactionFee = 50;\r\n\r\n    uint public addressLimit = 7000;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        receiverAddress = msg.sender;\r\n    }\r\n\r\n    event BalanceSent(address token, address receiver, uint256 amount);\r\n\r\n    event EthBulkSent(address _addr, uint256 amount);\r\n\r\n    event TokenBulkSent(address _addr, uint256 amount);\r\n\r\n    event EtherReceived(address _addr, uint amount);\r\n\r\n    event TransactionFeeChange(address _operator, uint256 _feePerAccount);\r\n    event AddressLimitChanged(address _operator, uint256 _arrayLimit);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  transfer ownership of the contract\r\n     * @param newOwner new address to be set as the owner\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the balance held by the contract\r\n     * @param _tokenAddress token address to get the balance held by the contract\r\n     */\r\n    function getBalance(address _tokenAddress) public onlyOwner {\r\n        if (_tokenAddress == 0x000000000000000000000000000000000000bEEF) {\r\n            uint256 balance = address(this).balance;\r\n            require(balance > 0, \"Zero balance\");\r\n            (bool success, ) = receiverAddress.call{value: balance}(\"\");\r\n            require(success, \"Ether transfer failed\");\r\n        } else {\r\n            ERC20 token = ERC20(_tokenAddress);\r\n            uint256 balance = token.balanceOf(address(this));\r\n            require(balance > 0, \"Zero balance\");\r\n            token.transfer(receiverAddress, balance);\r\n            emit BalanceSent(_tokenAddress, receiverAddress, balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *set the receiverAddress\r\n     * @param _addr address to be set as the new receiverAddress\r\n     */\r\n    function setReceiverAddress(address _addr) public onlyOwner {\r\n        require(_addr != address(0));\r\n        receiverAddress = _addr;\r\n    }\r\n\r\n    /**\r\n     * Get the receiver address of the fees\r\n     */\r\n    function getReceiverAddress() public view returns (address) {\r\n        if (receiverAddress == address(0)) {\r\n            return owner;\r\n        }\r\n\r\n        return receiverAddress;\r\n    }\r\n\r\n    /**\r\n     * set transaction fee\r\n     * @param _fee fee value to be set\r\n     */\r\n    function setTransactionFee(uint256 _fee) public onlyOwner {\r\n        transactionFee = _fee;\r\n    }\r\n\r\n    /**\r\n     * get the transaction fee charged\r\n     */\r\n    function getTransactionFee() public view onlyOwner returns (uint) {\r\n        return transactionFee;\r\n    }\r\n\r\n    function calculateFee(uint256 amount) internal view returns (uint256) {\r\n        return (amount * transactionFee) / 10000; // Calculate fee amount based on percentage\r\n    }\r\n\r\n    receive() external payable {\r\n        emit EtherReceived(msg.sender, msg.value);\r\n        // Additional logic (if any) to handle received Ether\r\n    }\r\n\r\n    /**\r\n     *  send eth with same value\r\n     * @param _to addresses to receive the eth\r\n     * @param _value value to be shared to each address\r\n     */\r\n    function ethSendSameValue(\r\n        address payable[] memory _to,\r\n        uint _value\r\n    ) internal {\r\n        // uint sendAmount = (_to.length - 1) * _value;\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n\r\n        uint256 fee = calculateFee(_value);\r\n        uint sendAmount = msg.value;\r\n\r\n        for (uint8 i = 0; i < _to.length; i++) {\r\n            uint256 amount = _value;\r\n            if (fee > 0) {\r\n                amount = _value - fee;\r\n            }\r\n            sendAmount -= amount;\r\n            _to[i].transfer(amount);\r\n        }\r\n\r\n        if (sendAmount > 0) {\r\n            payable(address(this)).transfer(sendAmount);\r\n        }\r\n        emit EthBulkSent(0x000000000000000000000000000000000000bEEF, msg.value);\r\n    }\r\n\r\n    /**\r\n     * bulk send eth with different value\r\n     * @param _to addresses to receive the eth\r\n     * @param _value values to be shared to each address\r\n     */\r\n    function ethSendDifferentValue(\r\n        address payable[] memory _to,\r\n        uint[] memory _value\r\n    ) internal {\r\n        require(\r\n            _to.length == _value.length,\r\n            \"Addresses length and values mistmatch\"\r\n        );\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n\r\n        uint256 sendAmount = msg.value;\r\n\r\n        for (uint8 i = 0; i < _to.length; i++) {\r\n            uint256 fee = calculateFee(_value[i]);\r\n            uint256 amount = _value[i];\r\n            if (fee > 0) {\r\n                amount = _value[i] - fee;\r\n            }\r\n            sendAmount -= amount;\r\n            _to[i].transfer(amount);\r\n        }\r\n\r\n        if (sendAmount > 0) {\r\n            payable(address(this)).transfer(sendAmount);\r\n        }\r\n        emit EthBulkSent(0x000000000000000000000000000000000000bEEF, msg.value);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param _tokenAddress address of token to distributed\r\n     * @param _to addresses to receive the distribution\r\n     * @param _value value to be shared to each addresses\r\n     */\r\n    function tokenSendSameValue(\r\n        address _tokenAddress,\r\n        address payable[] memory _to,\r\n        uint _value\r\n    ) internal {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n\r\n        address from = msg.sender;\r\n        uint256 sendAmount = _to.length * _value;\r\n\r\n        ERC20 tokenContract = ERC20(_tokenAddress);\r\n        require(\r\n            tokenContract.balanceOf(from) >= sendAmount,\r\n            \"Insufficient token balance\"\r\n        );\r\n        // Ensure MyContract is approved to spend tokens on behalf of the message sender\r\n        require(\r\n            tokenContract.allowance(msg.sender, address(this)) >= sendAmount,\r\n            \"Insufficient allowance\"\r\n        );\r\n        uint256 fee = calculateFee(_value);\r\n        uint256 feesTotal = 0;\r\n        for (uint8 i = 0; i < _to.length; i++) {\r\n            uint256 amount = _value;\r\n            if (fee > 0) {\r\n                amount = _value - fee;\r\n                feesTotal += fee;\r\n            }\r\n            sendAmount -= amount;\r\n            tokenContract.transferFrom(from, _to[i], amount);\r\n        }\r\n\r\n        if (sendAmount > 0) {\r\n            tokenContract.transferFrom(from, address(this), sendAmount);\r\n        }\r\n        emit TokenBulkSent(_tokenAddress, sendAmount);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param _tokenAddress address of token to distributed\r\n     * @param _to addresses to receive the distribution\r\n     * @param _value values to be to each addresses\r\n     */\r\n    function tokenSendDifferentValue(\r\n        address _tokenAddress,\r\n        address payable[] memory _to,\r\n        uint[] memory _value\r\n    ) internal {\r\n        uint total = 0;\r\n        for (uint8 i = 0; i < _value.length; i++) {\r\n            total = total + _value[i];\r\n        }\r\n\r\n        require(\r\n            _to.length == _value.length,\r\n            \"Addresses length and values mistmatch\"\r\n        );\r\n\r\n        uint256 sendAmount = total;\r\n        ERC20 tokenContract = ERC20(_tokenAddress);\r\n        require(\r\n            tokenContract.balanceOf(msg.sender) >= sendAmount,\r\n            \"Insufficient token balance\"\r\n        );\r\n        require(\r\n            tokenContract.allowance(msg.sender, address(this)) >= sendAmount,\r\n            \"Insufficient allowance\"\r\n        );\r\n\r\n        for (uint8 i = 0; i < _to.length; i++) {\r\n            uint256 fee = calculateFee(_value[i]);\r\n            uint256 amount = _value[i];\r\n            if (fee > 0) {\r\n                amount = _value[i] - fee;\r\n            }\r\n            sendAmount -= amount;\r\n            tokenContract.transferFrom(msg.sender, _to[i], amount);\r\n        }\r\n        if (sendAmount > 0) {\r\n            tokenContract.transferFrom(msg.sender, address(this), sendAmount);\r\n        }\r\n        emit TokenBulkSent(_tokenAddress, sendAmount);\r\n    }\r\n\r\n    /**\r\n     * bulk send eth with different value\r\n     * @param _to addresses to receive the eth\r\n     * @param _value values to be shared to each address\r\n     */\r\n    function sendEth(address payable[] memory _to, uint _value) public payable {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n        require(msg.value >= _to.length * _value, \"Insufficient ETH sent\");\r\n\r\n        ethSendSameValue(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * bulk send eth with different value\r\n     * @param _to addresses to receive the eth\r\n     * @param _value values to be shared to each address\r\n     */\r\n    function bulkSendETHWithDifferentValue(\r\n        address payable[] memory _to,\r\n        uint[] memory _value\r\n    ) public payable {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n        uint256 total = 0;\r\n        for (uint8 i = 0; i < _value.length; i++) {\r\n            total = total + _value[i];\r\n        }\r\n        require(msg.value >= total, \"Insufficient ETH sent\");\r\n\r\n        require(\r\n            _to.length == _value.length,\r\n            \"addresses and values length mismatch\"\r\n        );\r\n\r\n        ethSendDifferentValue(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * bulk send eth or bnb of same value\r\n     * @param _to addresses to receive the eth\r\n     * @param _value value to be shared\r\n     */\r\n    function bulkSendETHWithSameValue(\r\n        address payable[] memory _to,\r\n        uint _value\r\n    ) public payable {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n        ethSendSameValue(_to, _value);\r\n    }\r\n\r\n    /**\r\n     *  bulk send tokens with same value\r\n     * @param _tokenAddress address of token to be shared\r\n     * @param _to addresses to receive the distribution\r\n     * @param _value value to be receive by each address\r\n     */\r\n    function bulkSendTokenWithSameValue(\r\n        address _tokenAddress,\r\n        address payable[] memory _to,\r\n        uint _value\r\n    ) public payable {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n\r\n        if (_tokenAddress == 0x000000000000000000000000000000000000bEEF) {\r\n            ethSendSameValue(_to, _value);\r\n        } else {\r\n            tokenSendSameValue(_tokenAddress, _to, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param _tokenAddress address of token to distributed\r\n     * @param _to addresses to receive the distribution\r\n     * @param _value values to be to each addresses\r\n     */\r\n    function bulkSendTokenWithDifferentValue(\r\n        address _tokenAddress,\r\n        address payable[] memory _to,\r\n        uint[] memory _value\r\n    ) public payable {\r\n        require(_to.length <= addressLimit, \"too many wallet addresses\");\r\n        require(\r\n            _to.length == _value.length,\r\n            \"addresses and values length mismatch\"\r\n        );\r\n        if (_tokenAddress == 0x000000000000000000000000000000000000bEEF) {\r\n            ethSendDifferentValue(_to, _value);\r\n        } else {\r\n            tokenSendDifferentValue(_tokenAddress, _to, _value);\r\n        }\r\n    }\r\n\r\n    function setAddressLimit(uint256 _addressLimit) external onlyOwner {\r\n        addressLimit = _addressLimit;\r\n        emit AddressLimitChanged(msg.sender, _addressLimit);\r\n    }\r\n\r\n    function getAddressLimit() public view returns (uint256) {\r\n        return addressLimit;\r\n    }\r\n\r\n    /*\r\nCheck the token balance of a wallet in a token contract\r\n\r\nReturns the balance of the token for user. Avoids possible errors:\r\n  - return 0 on non-contract address \r\n  - returns 0 if the contract doesn't implement balanceOf\r\n*/\r\n    function tokenBalance(\r\n        address user,\r\n        address token\r\n    ) public view returns (uint) {\r\n        // check if token is actually a contract\r\n        uint256 tokenCode;\r\n        assembly {\r\n            tokenCode := extcodesize(token)\r\n        } // contract code size\r\n\r\n        // is it a contract and does it implement balanceOf\r\n        if (tokenCode > 0) {\r\n            (bool success, ) = token.staticcall(\r\n                abi.encodeWithSelector(bytes4(0x70a08231), user)\r\n            );\r\n            if (success) {\r\n                return ERC20(token).balanceOf(user);\r\n            }\r\n            return 0;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n    Check the token balances of a wallet for multiple tokens.\r\n    Pass 0x0 as a \"token\" address to get ETH balance.\r\n\r\n    Possible error throws:\r\n      - extremely large arrays for user and or tokens (gas cost too high) \r\n          \r\n    Returns a one-dimensional that's user.length * tokens.length long. The\r\n    array is ordered by all of the 0th users token balances, then the 1th\r\n    user, and so on.\r\n  */\r\n    function balances(\r\n        address[] memory users,\r\n        address[] memory tokens\r\n    ) external view returns (uint[] memory) {\r\n        uint[] memory addrBalances = new uint[](tokens.length * users.length);\r\n\r\n        for (uint i = 0; i < users.length; i++) {\r\n            for (uint j = 0; j < tokens.length; j++) {\r\n                uint addrIdx = j + tokens.length * i;\r\n                if (tokens[j] != address(0x0)) {\r\n                    addrBalances[addrIdx] = tokenBalance(users[i], tokens[j]);\r\n                } else {\r\n                    addrBalances[addrIdx] = users[i].balance; // ETH balance\r\n                }\r\n            }\r\n        }\r\n\r\n        return addrBalances;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MyToken.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\ncontract MyToken is ERC20Capped {\r\n    address payable public owner;\r\n    uint256 public blockReward;\r\n\r\n    constructor(\r\n        uint256 cap,\r\n        uint256 reward\r\n    ) ERC20(\"MyToken\", \"MYT\") ERC20Capped(cap * (10 ** decimals())) {\r\n        owner = payable(msg.sender);\r\n        _mint(owner, 50000000 * (10 ** decimals()));\r\n        blockReward = reward * (10 ** decimals()); // Setting block reward for first deploy\r\n    }\r\n    //reusable modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_arrayLimit\",\"type\":\"uint256\"}],\"name\":\"AddressLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthBulkSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenBulkSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_feePerAccount\",\"type\":\"uint256\"}],\"name\":\"TransactionFeeChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"bulkSendETHWithDifferentValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"bulkSendETHWithSameValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"bulkSendTokenWithDifferentValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"bulkSendTokenWithSameValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceiverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addressLimit\",\"type\":\"uint256\"}],\"name\":\"setAddressLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setReceiverAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTransactionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Disburser", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b3194ca50cd9306f1e564d3a3ed0ec8f30300fa5958c9a7e4749e280fb119f1c"}