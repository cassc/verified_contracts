{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ConstantProduct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC20} from \\\"lib/composable-cow/lib/@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport {Math} from \\\"lib/composable-cow/lib/@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {ConditionalOrdersUtilsLib as Utils} from \\\"lib/composable-cow/src/types/ConditionalOrdersUtilsLib.sol\\\";\\nimport {\\n    IConditionalOrderGenerator,\\n    IConditionalOrder,\\n    IERC165,\\n    GPv2Order\\n} from \\\"lib/composable-cow/src/BaseConditionalOrder.sol\\\";\\n\\nimport {IPriceOracle} from \\\"./interfaces/IPriceOracle.sol\\\";\\nimport {IWatchtowerCustomErrors} from \\\"./interfaces/IWatchtowerCustomErrors.sol\\\";\\n\\n/**\\n * @title CoW AMM\\n * @author CoW Protocol Developers\\n * @dev Automated market maker based on the concept of function-maximising AMMs.\\n * It relies on the CoW Protocol infrastructure to guarantee batch execution of\\n * its orders.\\n * Order creation and execution is based on the Composable CoW base contracts.\\n */\\ncontract ConstantProduct is IConditionalOrderGenerator {\\n    /// All data used by an order to validate the AMM conditions.\\n    struct Data {\\n        /// The first of the tokens traded by this AMM.\\n        IERC20 token0;\\n        /// The second of the tokens traded by this AMM.\\n        IERC20 token1;\\n        /// The minimum amount of token0 that needs to be traded for an order\\n        /// to be created on getTradeableOrder.\\n        uint256 minTradedToken0;\\n        /// An onchain source for the price of the two tokens. The price should\\n        /// be expressed in terms of amount of token0 per amount of token1.\\n        IPriceOracle priceOracle;\\n        /// The data that needs to be provided to the price oracle to retrieve\\n        /// the relative price of the two tokens.\\n        bytes priceOracleData;\\n        /// The app data that must be used in the order.\\n        /// See `GPv2Order.Data` for more information on the app data.\\n        bytes32 appData;\\n    }\\n\\n    /**\\n     * @notice The largest possible duration of any AMM order, starting from the\\n     * current block timestamp.\\n     */\\n    uint32 public constant MAX_ORDER_DURATION = 5 * 60;\\n    /**\\n     * @notice The value representing the absence of a commitment. It signifies\\n     * that the AMM will enforce that the order matches the order obtained from\\n     * calling `getTradeableOrder`.\\n     */\\n    bytes32 public constant EMPTY_COMMITMENT = bytes32(0);\\n    /**\\n     * @notice The address of the CoW Protocol settlement contract. It is the\\n     * only address that can set commitments.\\n     */\\n    address public immutable solutionSettler;\\n    /**\\n     * @notice It associates every order owner to the only order hash that can\\n     * be validated by calling `verify`. The hash corresponding to the constant\\n     * `EMPTY_COMMITMENT` has special semantics, discussed in the related\\n     * documentation.\\n     */\\n    mapping(address => bytes32) public commitment;\\n\\n    /**\\n     * @notice The `commit` function can only be called inside a CoW Swap\\n     * settlement. This error is thrown when the function is called from another\\n     * context.\\n     */\\n    error CommitOutsideOfSettlement();\\n    /**\\n     * @notice Error thrown when a solver tries to settle an AMM order on CoW\\n     * Protocol whose hash doesn't match the one that has been committed to in\\n     * the `commitment` mapping.\\n     */\\n    error OrderDoesNotMatchCommitmentHash();\\n    /**\\n     * @notice If an AMM order is settled and the AMM committment is set to\\n     * empty, then that order must match the output of `getTradeableOrder`.\\n     * This error is thrown when some of the parameters don't match the expected\\n     * ones.\\n     */\\n    error OrderDoesNotMatchDefaultTradeableOrder();\\n\\n    /**\\n     * @param _solutionSettler The CoW Protocol contract used to settle user\\n     * orders on the current chain.\\n     */\\n    constructor(address _solutionSettler) {\\n        solutionSettler = _solutionSettler;\\n    }\\n\\n    /**\\n     * @notice Restricts a specific AMM to being able to trade only the order\\n     * with the specified hash.\\n     * @dev The commitment is used to enforce that exactly one AMM order is\\n     * valid when a CoW Protocol batch is settled.\\n     * @param owner the commitment applies to orders created by this address.\\n     * @param orderHash the order hash that will be enforced by the order\\n     * verification function.\\n     */\\n    function commit(address owner, bytes32 orderHash) public {\\n        if (msg.sender != solutionSettler) {\\n            revert CommitOutsideOfSettlement();\\n        }\\n        commitment[owner] = orderHash;\\n    }\\n\\n    /**\\n     * @notice The order returned by this function is the order that needs to be\\n     * executed for the price on the owner AMM to match that of the reference\\n     * pair.\\n     * @inheritdoc IConditionalOrderGenerator\\n     */\\n    function getTradeableOrder(address owner, address, bytes32, bytes calldata staticInput, bytes calldata)\\n        public\\n        view\\n        override\\n        returns (GPv2Order.Data memory)\\n    {\\n        return _getTradeableOrder(owner, staticInput);\\n    }\\n\\n    /**\\n     * @dev Wrapper for the `getTradeableOrder` function with only the\\n     * parameters that are required for order creation. Compared to implementing\\n     * the logic inside the original function, it frees up some stack slots and\\n     * reduces \\\"stack too deep\\\" issues.\\n     * @param owner the contract who is the owner of the order\\n     * @param staticInput the static input for all discrete orders cut from this\\n     * conditional order\\n     * @return order the tradeable order for submission to the CoW Protocol API\\n     */\\n    function _getTradeableOrder(address owner, bytes calldata staticInput)\\n        internal\\n        view\\n        returns (GPv2Order.Data memory order)\\n    {\\n        ConstantProduct.Data memory data = abi.decode(staticInput, (Data));\\n        IERC20 token0 = data.token0;\\n        IERC20 token1 = data.token1;\\n        (uint256 priceNumerator, uint256 priceDenominator) =\\n            data.priceOracle.getPrice(address(token0), address(token1), data.priceOracleData);\\n        (uint256 selfReserve0, uint256 selfReserve1) = (token0.balanceOf(owner), token1.balanceOf(owner));\\n\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        // Note on rounding: we want to round down the sell amount and up the\\n        // buy amount. This is because the math for the order makes it lie\\n        // precisely on the AMM curve, and a rounding error to the other way\\n        // could cause a valid order to become invalid.\\n        // Note on the if condition: it guarantees that sellAmount is positive\\n        // in the corresponding branch (it would be negative in the other). This\\n        // excludes rounding errors: in this case, the function could revert but\\n        // the amounts involved would be just a few atoms, so we accept that no\\n        // order will be available.\\n        // Note on the order price: The buy amount is not optimal for the AMM\\n        // given the sell amount. This is intended because we want to force\\n        // solvers to maximize the surplus for this order with the price that\\n        // isn't the AMM best price.\\n        uint256 selfReserve0TimesPriceDenominator = selfReserve0 * priceDenominator;\\n        uint256 selfReserve1TimesPriceNumerator = selfReserve1 * priceNumerator;\\n        uint256 tradedAmountToken0;\\n        if (selfReserve1TimesPriceNumerator < selfReserve0TimesPriceDenominator) {\\n            sellToken = token0;\\n            buyToken = token1;\\n            sellAmount = sub(selfReserve0 / 2, Math.ceilDiv(selfReserve1TimesPriceNumerator, 2 * priceDenominator));\\n            buyAmount = Math.mulDiv(\\n                sellAmount,\\n                selfReserve1TimesPriceNumerator + (priceDenominator * sellAmount),\\n                priceNumerator * selfReserve0,\\n                Math.Rounding.Up\\n            );\\n            tradedAmountToken0 = sellAmount;\\n        } else {\\n            sellToken = token1;\\n            buyToken = token0;\\n            sellAmount = sub(selfReserve1 / 2, Math.ceilDiv(selfReserve0TimesPriceDenominator, 2 * priceNumerator));\\n            buyAmount = Math.mulDiv(\\n                sellAmount,\\n                selfReserve0TimesPriceDenominator + (priceNumerator * sellAmount),\\n                priceDenominator * selfReserve1,\\n                Math.Rounding.Up\\n            );\\n            tradedAmountToken0 = buyAmount;\\n        }\\n\\n        if (tradedAmountToken0 < data.minTradedToken0) {\\n            revertPollAtNextBlock(\\\"traded amount too small\\\");\\n        }\\n\\n        order = GPv2Order.Data(\\n            sellToken,\\n            buyToken,\\n            GPv2Order.RECEIVER_SAME_AS_OWNER,\\n            sellAmount,\\n            buyAmount,\\n            Utils.validToBucket(MAX_ORDER_DURATION),\\n            data.appData,\\n            0,\\n            GPv2Order.KIND_SELL,\\n            true,\\n            GPv2Order.BALANCE_ERC20,\\n            GPv2Order.BALANCE_ERC20\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IConditionalOrder\\n     * @dev Most parameters are ignored: we only need to validate the order with\\n     * the current reserves and the validated order parameters.\\n     */\\n    function verify(\\n        address owner,\\n        address,\\n        bytes32 orderHash,\\n        bytes32,\\n        bytes32,\\n        bytes calldata staticInput,\\n        bytes calldata,\\n        GPv2Order.Data calldata order\\n    ) external view override {\\n        _verify(owner, orderHash, staticInput, order);\\n    }\\n\\n    /**\\n     * @dev Wrapper for the `verify` function with only the parameters that are\\n     * required for verification. Compared to implementing the logic inside\\n     * `verify`, it frees up some stack slots and reduces \\\"stack too deep\\\"\\n     * issues.\\n     * @param owner the contract who is the owner of the order\\n     * @param orderHash the hash of the current order as defined by the\\n     * `GPv2Order` library.\\n     * @param staticInput the static input for all discrete orders cut from this\\n     * conditional order\\n     * @param order `GPv2Order.Data` of a discrete order to be verified.\\n     */\\n    function _verify(address owner, bytes32 orderHash, bytes calldata staticInput, GPv2Order.Data calldata order)\\n        internal\\n        view\\n    {\\n        requireMatchingCommitment(owner, orderHash, staticInput, order);\\n        ConstantProduct.Data memory data = abi.decode(staticInput, (Data));\\n\\n        IERC20 sellToken = data.token0;\\n        IERC20 buyToken = data.token1;\\n        uint256 sellReserve = sellToken.balanceOf(owner);\\n        uint256 buyReserve = buyToken.balanceOf(owner);\\n        if (order.sellToken != sellToken) {\\n            if (order.sellToken != buyToken) {\\n                revert IConditionalOrder.OrderNotValid(\\\"invalid sell token\\\");\\n            }\\n            (sellToken, buyToken) = (buyToken, sellToken);\\n            (sellReserve, buyReserve) = (buyReserve, sellReserve);\\n        }\\n        if (order.buyToken != buyToken) {\\n            revert IConditionalOrder.OrderNotValid(\\\"invalid buy token\\\");\\n        }\\n\\n        if (order.receiver != GPv2Order.RECEIVER_SAME_AS_OWNER) {\\n            revert IConditionalOrder.OrderNotValid(\\\"receiver must be zero address\\\");\\n        }\\n        // We add a maximum duration to avoid spamming the orderbook and force\\n        // an order refresh if the order is old.\\n        if (order.validTo > block.timestamp + MAX_ORDER_DURATION) {\\n            revert IConditionalOrder.OrderNotValid(\\\"validity too far in the future\\\");\\n        }\\n        if (order.appData != data.appData) {\\n            revert IConditionalOrder.OrderNotValid(\\\"invalid appData\\\");\\n        }\\n        if (order.feeAmount != 0) {\\n            revert IConditionalOrder.OrderNotValid(\\\"fee amount must be zero\\\");\\n        }\\n        if (order.buyTokenBalance != GPv2Order.BALANCE_ERC20) {\\n            revert IConditionalOrder.OrderNotValid(\\\"buyTokenBalance must be erc20\\\");\\n        }\\n        if (order.sellTokenBalance != GPv2Order.BALANCE_ERC20) {\\n            revert IConditionalOrder.OrderNotValid(\\\"sellTokenBalance must be erc20\\\");\\n        }\\n        // These are the checks needed to satisfy the conditions on in/out\\n        // amounts for a constant-product curve AMM.\\n        if ((sellReserve - order.sellAmount) * order.buyAmount < buyReserve * order.sellAmount) {\\n            revert IConditionalOrder.OrderNotValid(\\\"received amount too low\\\");\\n        }\\n\\n        // No checks on:\\n        // - kind\\n        // - partiallyFillable\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return interfaceId == type(IConditionalOrderGenerator).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /**\\n     * @dev Computes the difference between the two input values. If it detects\\n     * an underflow, the function reverts with a custom error that informs the\\n     * watchtower to poll next.\\n     * If the function reverted with a standard underflow, the watchtower would\\n     * stop polling the order.\\n     * @param lhs The minuend of the subtraction\\n     * @param rhs The subtrahend of the subtraction\\n     * @return The difference of the two input values\\n     */\\n    function sub(uint256 lhs, uint256 rhs) internal view returns (uint256) {\\n        if (lhs < rhs) {\\n            revertPollAtNextBlock(\\\"subtraction underflow\\\");\\n        }\\n        unchecked {\\n            return lhs - rhs;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts call execution with a custom error that indicates to the\\n     * watchtower to poll for new order when the next block is mined.\\n     */\\n    function revertPollAtNextBlock(string memory message) internal view {\\n        revert IWatchtowerCustomErrors.PollTryAtBlock(block.number + 1, message);\\n    }\\n\\n    /**\\n     * @notice This function triggers a revert if either (1) the order hash does\\n     * not match the current commitment of the owner, or (2) in the case of a\\n     * commitment to `EMPTY_COMMITMENT`, the non-constant parameters of the\\n     * order from `getTradeableOrder` don't match those of the input order.\\n     * @param owner the contract that owns the order\\n     * @param orderHash the hash of the current order as defined by the\\n     * `GPv2Order` library.\\n     * @param staticInput the static input for all discrete orders cut from this\\n     * conditional order\\n     * @param order `GPv2Order.Data` of a discrete order to be verified\\n     */\\n    function requireMatchingCommitment(\\n        address owner,\\n        bytes32 orderHash,\\n        bytes calldata staticInput,\\n        GPv2Order.Data calldata order\\n    ) internal view {\\n        bytes32 committedOrderHash = commitment[owner];\\n        if (orderHash != committedOrderHash) {\\n            if (committedOrderHash != EMPTY_COMMITMENT) {\\n                revert OrderDoesNotMatchCommitmentHash();\\n            }\\n            GPv2Order.Data memory computedOrder = _getTradeableOrder(owner, staticInput);\\n            if (!matchFreeOrderParams(order, computedOrder)) {\\n                revert OrderDoesNotMatchDefaultTradeableOrder();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Check if the parameters of the two input orders are the same,\\n     * with the exception of those parameters that have a single possible value\\n     * that passes the validation of `verify`.\\n     * @param lhs a CoW Swap order\\n     * @param rhs another CoW Swap order\\n     * @return true if the order parameters match, false otherwise\\n     */\\n    function matchFreeOrderParams(GPv2Order.Data calldata lhs, GPv2Order.Data memory rhs)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bool sameSellToken = lhs.sellToken == rhs.sellToken;\\n        bool sameBuyToken = lhs.buyToken == rhs.buyToken;\\n        bool sameSellAmount = lhs.sellAmount == rhs.sellAmount;\\n        bool sameBuyAmount = lhs.buyAmount == rhs.buyAmount;\\n        bool sameValidTo = lhs.validTo == rhs.validTo;\\n        bool sameKind = lhs.kind == rhs.kind;\\n        bool samePartiallyFillable = lhs.partiallyFillable == rhs.partiallyFillable;\\n\\n        // The following parameters are untested:\\n        // - receiver\\n        // - appData\\n        // - feeAmount\\n        // - sellTokenBalance\\n        // - buyTokenBalance\\n\\n        return sameSellToken && sameBuyToken && sameSellAmount && sameBuyAmount && sameValidTo && sameKind\\n            && samePartiallyFillable;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/src/types/ConditionalOrdersUtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title ConditionalOrdersUtilsLib - Utility functions for standardising conditional orders.\\n * @author mfw78 <mfw78@rndlabs.xyz>\\n */\\nlibrary ConditionalOrdersUtilsLib {\\n    uint256 constant MAX_BPS = 10000;\\n\\n    /**\\n     * Given the width of the validity bucket, return the timestamp of the *end* of the bucket.\\n     * @param validity The width of the validity bucket in seconds.\\n     */\\n    function validToBucket(uint32 validity) internal view returns (uint32 validTo) {\\n        validTo = ((uint32(block.timestamp) / validity) * validity) + validity;\\n    }\\n\\n    /**\\n     * Given a price returned by a chainlink-like oracle, scale it to the desired amount of decimals\\n     * @param oraclePrice return by a chainlink-like oracle\\n     * @param fromDecimals the decimals the oracle returned (e.g. 8 for USDC)\\n     * @param toDecimals the amount of decimals the price should be scaled to\\n     */\\n    function scalePrice(int256 oraclePrice, uint8 fromDecimals, uint8 toDecimals) internal pure returns (int256) {\\n        if (fromDecimals < toDecimals) {\\n            return oraclePrice * int256(10 ** uint256(toDecimals - fromDecimals));\\n        } else if (fromDecimals > toDecimals) {\\n            return oraclePrice / int256(10 ** uint256(fromDecimals - toDecimals));\\n        }\\n        return oraclePrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/src/BaseConditionalOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {GPv2Order} from \\\"cowprotocol/libraries/GPv2Order.sol\\\";\\n\\nimport \\\"./interfaces/IConditionalOrder.sol\\\";\\n\\n// --- error strings\\n/// @dev This error is returned by the `verify` function if the *generated* order hash does not match\\n///      the hash passed as a parameter.\\nstring constant INVALID_HASH = \\\"invalid hash\\\";\\n\\n/**\\n * @title Base logic for conditional orders.\\n * @dev Enforces the order verification logic for conditional orders, allowing developers\\n *      to focus on the logic for generating the tradeable order.\\n * @author mfw78 <mfw78@rndlabs.xyz>\\n */\\nabstract contract BaseConditionalOrder is IConditionalOrderGenerator {\\n    /**\\n     * @inheritdoc IConditionalOrder\\n     * @dev As an order generator, the `GPv2Order.Data` passed as a parameter is ignored / not validated.\\n     */\\n    function verify(\\n        address owner,\\n        address sender,\\n        bytes32 _hash,\\n        bytes32 domainSeparator,\\n        bytes32 ctx,\\n        bytes calldata staticInput,\\n        bytes calldata offchainInput,\\n        GPv2Order.Data calldata\\n    ) external view override {\\n        GPv2Order.Data memory generatedOrder = getTradeableOrder(owner, sender, ctx, staticInput, offchainInput);\\n\\n        /// @dev Verify that the *generated* order is valid and matches the payload.\\n        if (!(_hash == GPv2Order.hash(generatedOrder, domainSeparator))) {\\n            revert IConditionalOrder.OrderNotValid(INVALID_HASH);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the visibility of this function to `public` to allow `verify` to call it.\\n     * @inheritdoc IConditionalOrderGenerator\\n     */\\n    function getTradeableOrder(\\n        address owner,\\n        address sender,\\n        bytes32 ctx,\\n        bytes calldata staticInput,\\n        bytes calldata offchainInput\\n    ) public view virtual override returns (GPv2Order.Data memory);\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return interfaceId == type(IConditionalOrderGenerator).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title CoW AMM Price Oracle Interface\\n * @author CoW Protocol Developers\\n * @dev A contract that can be used by the CoW AMM as as a price oracle.\\n * The price source depends on the actual implementation; it could rely for\\n * example on Uniswap, Balancer, Chainlink...\\n */\\ninterface IPriceOracle {\\n    /**\\n     * @dev Calling this function returns the price of token1 in terms of token0\\n     * as a fraction (numerator, denominator).\\n     * For example, in a pool where token0 is DAI, token1 is ETH, and ETH is\\n     * worth 2000 DAI, valid output tuples would be (2000, 1), (20000, 10), ...\\n     * @dev To keep the risk of multiplication overflow to a minimum, we\\n     * recommend to use return values that fit the size of a uint128.\\n     * @param token0 The first token, whose price is determined based on the\\n     * second token.\\n     * @param token1 The second token; the price of the first token is\\n     * determined relative to this token.\\n     * @param data Any additional data that may be required by the specific\\n     * oracle implementation. For example, it could be a specific pool id for\\n     * balancer, or the address of a specific price feed for Chainlink.\\n     * We recommend this data be implemented as the abi-encoding of a dedicated\\n     * data struct for ease of type-checking and decoding the input.\\n     * @return priceNumerator The numerator of the price, expressed in amount of\\n     * token1 per amount of token0.\\n     * @return priceDenominator The denominator of the price, expressed in\\n     * amount of token1 per amount of token0.\\n     */\\n    function getPrice(address token0, address token1, bytes calldata data)\\n        external\\n        view\\n        returns (uint256 priceNumerator, uint256 priceDenominator);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWatchtowerCustomErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title Watchtower Custom Error Interface\\n * @author CoW Protocol Developers\\n * @dev An interface that collects all custom error message for the watchtower.\\n * Different error messages lead to different watchtower behaviors when creating\\n * an order.\\n * @dev The watchtower is a service that automatically posts orders to the CoW\\n * Protocol orderbook at regular intervals.\\n */\\ncontract IWatchtowerCustomErrors {\\n    /**\\n     * No order is currently available for trading, but the watchtower should\\n     * try again at the specified block.\\n     */\\n    error PollTryAtBlock(uint256 blockNumber, string message);\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/cowprotocol/src/contracts/libraries/GPv2Order.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Order Library\\n/// @author Gnosis Developers\\nlibrary GPv2Order {\\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\\n    /// all order parameters that are signed for submitting to GP.\\n    struct Data {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"address receiver,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"bytes32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable,\\\" +\\n    ///         \\\"string sellTokenBalance,\\\" +\\n    ///         \\\"string buyTokenBalance\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant TYPE_HASH =\\n        hex\\\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\\\";\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\\n    /// computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"erc20\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_ERC20 =\\n        hex\\\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault external\\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\\n    /// order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"external\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_EXTERNAL =\\n        hex\\\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\\n    /// balances for computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"internal\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_INTERNAL =\\n        hex\\\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\\\";\\n\\n    /// @dev Marker address used to indicate that the receiver of the trade\\n    /// proceeds should the owner of the order.\\n    ///\\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\\n    /// to be the most common case.\\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 internal constant UID_LENGTH = 56;\\n\\n    /// @dev Returns the actual receiver for an order. This function checks\\n    /// whether or not the [`receiver`] field uses the marker value to indicate\\n    /// it is the same as the order owner.\\n    ///\\n    /// @return receiver The actual receiver of trade proceeds.\\n    function actualReceiver(Data memory order, address owner)\\n        internal\\n        pure\\n        returns (address receiver)\\n    {\\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\\n            receiver = owner;\\n        } else {\\n            receiver = order.receiver;\\n        }\\n    }\\n\\n    /// @dev Return the EIP-712 signing hash for the specified order.\\n    ///\\n    /// @param order The order to compute the EIP-712 signing hash for.\\n    /// @param domainSeparator The EIP-712 domain separator to use.\\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\\n    function hash(Data memory order, bytes32 domainSeparator)\\n        internal\\n        pure\\n        returns (bytes32 orderDigest)\\n    {\\n        bytes32 structHash;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n        // in the EIP proposal, noting that the order struct has 12 fields, and\\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, TYPE_HASH)\\n            structHash := keccak256(dataStart, 416)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\\n        // hash using scratch memory past the free memory pointer. The signing\\n        // hash is computed from `\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash`.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n    }\\n\\n    /// @dev Packs order UID parameters into the specified memory location. The\\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\\n    /// it allows re-using the memory for packing the order UID.\\n    ///\\n    /// This function reverts if the order UID buffer is not the correct size.\\n    ///\\n    /// @param orderUid The buffer pack the order UID parameters into.\\n    /// @param orderDigest The EIP-712 struct digest derived from the order\\n    /// parameters.\\n    /// @param owner The address of the user who owns this order.\\n    /// @param validTo The epoch time at which the order will stop being valid.\\n    function packOrderUidParams(\\n        bytes memory orderUid,\\n        bytes32 orderDigest,\\n        address owner,\\n        uint32 validTo\\n    ) internal pure {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: uid buffer overflow\\\");\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // Additionally, since Solidity `bytes memory` are length prefixed,\\n        // 32 needs to be added to all the offsets.\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(add(orderUid, 56), validTo)\\n            mstore(add(orderUid, 52), owner)\\n            mstore(add(orderUid, 32), orderDigest)\\n        }\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(bytes calldata orderUid)\\n        internal\\n        pure\\n        returns (\\n            bytes32 orderDigest,\\n            address owner,\\n            uint32 validTo\\n        )\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: invalid uid\\\");\\n\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/src/interfaces/IConditionalOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {GPv2Order} from \\\"cowprotocol/libraries/GPv2Order.sol\\\";\\nimport {GPv2Interaction} from \\\"cowprotocol/libraries/GPv2Interaction.sol\\\";\\nimport {IERC165} from \\\"safe/interfaces/IERC165.sol\\\";\\n\\n/**\\n * @title Conditional Order Interface\\n * @author CoW Protocol Developers + mfw78 <mfw78@rndlabs.xyz>\\n */\\ninterface IConditionalOrder {\\n    /// @dev This error is returned by the `getTradeableOrder` function if the order condition is not met.\\n    ///      A parameter of `string` type is included to allow the caller to specify the reason for the failure.\\n    error OrderNotValid(string);\\n\\n    /**\\n     * @dev This struct is used to uniquely identify a conditional order for an owner.\\n     *      H(handler || salt || staticInput) **MUST** be unique for an owner.\\n     */\\n    struct ConditionalOrderParams {\\n        IConditionalOrder handler;\\n        bytes32 salt;\\n        bytes staticInput;\\n    }\\n\\n    /**\\n     * Verify if a given discrete order is valid.\\n     * @dev Used in combination with `isValidSafeSignature` to verify that the order is signed by the Safe.\\n     *      **MUST** revert if the order condition is not met.\\n     * @dev The `order` parameter is ignored / not validated by the `IConditionalOrderGenerator` implementation.\\n     *      This parameter is included to allow more granular control over the order verification logic, and to\\n     *      allow a watch tower / user to propose a discrete order without it being generated by on-chain logic.\\n     * @param owner the contract who is the owner of the order\\n     * @param sender the `msg.sender` of the transaction\\n     * @param _hash the hash of the order\\n     * @param domainSeparator the domain separator used to sign the order\\n     * @param ctx the context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet\\n     * @param staticInput the static input for all discrete orders cut from this conditional order\\n     * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order\\n     * @param order `GPv2Order.Data` of a discrete order to be verified (if *not* an `IConditionalOrderGenerator`).\\n     */\\n    function verify(\\n        address owner,\\n        address sender,\\n        bytes32 _hash,\\n        bytes32 domainSeparator,\\n        bytes32 ctx,\\n        bytes calldata staticInput,\\n        bytes calldata offchainInput,\\n        GPv2Order.Data calldata order\\n    ) external view;\\n}\\n\\n/**\\n * @title Conditional Order Generator Interface\\n * @author mfw78 <mfw78@rndlabs.xyz>\\n */\\ninterface IConditionalOrderGenerator is IConditionalOrder, IERC165 {\\n    /**\\n     * @dev This event is emitted when a new conditional order is created.\\n     * @param owner the address that has created the conditional order\\n     * @param params the address / salt / data of the conditional order\\n     */\\n    event ConditionalOrderCreated(address indexed owner, IConditionalOrder.ConditionalOrderParams params);\\n\\n    /**\\n     * @dev Get a tradeable order that can be posted to the CoW Protocol API and would pass signature validation.\\n     *      **MUST** revert if the order condition is not met.\\n     * @param owner the contract who is the owner of the order\\n     * @param sender the `msg.sender` of the parent `isValidSignature` call\\n     * @param ctx the context of the order (bytes32(0) if merkle tree is used, otherwise the H(params))\\n     * @param staticInput the static input for all discrete orders cut from this conditional order\\n     * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order\\n     * @return the tradeable order for submission to the CoW Protocol API\\n     */\\n    function getTradeableOrder(\\n        address owner,\\n        address sender,\\n        bytes32 ctx,\\n        bytes calldata staticInput,\\n        bytes calldata offchainInput\\n    ) external view returns (GPv2Order.Data memory);\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/cowprotocol/src/contracts/libraries/GPv2Interaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @title Gnosis Protocol v2 Interaction Library\\n/// @author Gnosis Developers\\nlibrary GPv2Interaction {\\n    /// @dev Interaction data for performing arbitrary contract interactions.\\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\\n    struct Data {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @dev Execute an arbitrary contract interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    function execute(Data calldata interaction) internal {\\n        address target = interaction.target;\\n        uint256 value = interaction.value;\\n        bytes calldata callData = interaction.callData;\\n\\n        // NOTE: Use assembly to call the interaction instead of a low level\\n        // call for two reasons:\\n        // - We don't want to copy the return data, since we discard it for\\n        // interactions.\\n        // - Solidity will under certain conditions generate code to copy input\\n        // calldata twice to memory (the second being a \\\"memcopy loop\\\").\\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\\n            if iszero(\\n                call(\\n                    gas(),\\n                    target,\\n                    value,\\n                    freeMemoryPointer,\\n                    callData.length,\\n                    0,\\n                    0\\n                )\\n            ) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    /// @return result The 4 byte function selector of the call encoded in\\n    /// this interaction.\\n    function selector(Data calldata interaction)\\n        internal\\n        pure\\n        returns (bytes4 result)\\n    {\\n        bytes calldata callData = interaction.callData;\\n        if (callData.length >= 4) {\\n            // NOTE: Read the first word of the interaction's calldata. The\\n            // value does not need to be shifted since `bytesN` values are left\\n            // aligned, and the value does not need to be masked since masking\\n            // occurs when the value is accessed and not stored:\\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                result := calldataload(callData.offset)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/composable-cow/lib/safe/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n     * See the corresponding EIP section\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"lib/composable-cow:cowprotocol/=lib/composable-cow/lib/cowprotocol/src/contracts/\",\r\n      \"lib/composable-cow:safe/=lib/composable-cow/lib/safe/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/contracts/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"@openzeppelin/=lib/composable-cow/lib/@openzeppelin/\",\r\n      \"@openzeppelin/contracts/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"balancer/=lib/composable-cow/lib/balancer/src/\",\r\n      \"canonical-weth/=lib/composable-cow/lib/canonical-weth/src/\",\r\n      \"composable-cow/=lib/composable-cow/\",\r\n      \"cowprotocol/=lib/composable-cow/lib/cowprotocol/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/composable-cow/lib/@openzeppelin/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"helpers/=lib/composable-cow/lib/balancer/src/lib/helpers/\",\r\n      \"math/=lib/composable-cow/lib/balancer/src/lib/math/\",\r\n      \"murky/=lib/composable-cow/lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/composable-cow/lib/canonical-weth/lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"safe/=lib/composable-cow/lib/safe/\",\r\n      \"uniswap-v2-core/=lib/uniswap-v2-core/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_solutionSettler\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CommitOutsideOfSettlement\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderDoesNotMatchCommitmentHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderDoesNotMatchDefaultTradeableOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"OrderNotValid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"PollTryAtBlock\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IConditionalOrder\",\"name\":\"handler\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"staticInput\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct IConditionalOrder.ConditionalOrderParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"ConditionalOrderCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EMPTY_COMMITMENT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ORDER_DURATION\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitment\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"staticInput\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getTradeableOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validTo\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"appData\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}],\"internalType\":\"struct GPv2Order.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solutionSettler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"staticInput\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validTo\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"appData\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}],\"internalType\":\"struct GPv2Order.Data\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ConstantProduct", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "0000000000000000000000009008d19f58aabd9ed0d60971565aa8510560ab41", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}