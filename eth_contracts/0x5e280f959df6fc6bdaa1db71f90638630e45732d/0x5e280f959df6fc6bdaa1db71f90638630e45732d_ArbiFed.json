{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/arbi-fed/ArbiFed.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nimport \\\"src/interfaces/IERC20.sol\\\";\\nimport \\\"src/interfaces/velo/IDola.sol\\\";\\nimport \\\"src/interfaces/velo/IL1ERC20Bridge.sol\\\";\\nimport \\\"src/arbi-fed/ArbiGasManager.sol\\\";\\nimport {IL1GatewayRouter} from \\\"arbitrum/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\\\";\\n\\ncontract ArbiFed is ArbiGasManager{\\n    address public chair;\\n    uint public underlyingSupply;\\n\\n    IDola public immutable DOLA = IDola(0x865377367054516e17014CcdED1e7d814EDC9ce4);\\n    IL1GatewayRouter public immutable gatewayRouter = IL1GatewayRouter(0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef); \\n    IL1GatewayRouter  public immutable gateway = IL1GatewayRouter(0xb4299A1F5f26fF6a98B7BA35572290C359fde900);\\n    address public immutable l1ERC20Gateway = 0xa3A7B6F88361F48403514059F1F16C8E78d60EeC;\\n\\n    address public auraFarmer; // On L2\\n\\n    event Expansion(uint amount);\\n    event Contraction(uint amount);\\n\\n    error OnlyChair();\\n    error OnlyGuardian();\\n    error CantBurnZeroDOLA();\\n    error DeltaAboveMax();\\n    error ZeroGasPriceBid();\\n    error InsufficientGasFunds();\\n    \\n    constructor(\\n            address _gov,\\n            address _auraFarmer,\\n            address _chair,\\n            address _gasClerk,\\n            address _l2RefundAddress\\n    ) ArbiGasManager(_gov, _gasClerk, _l2RefundAddress)\\n    {\\n        chair = _chair;\\n        gov = _gov;\\n        auraFarmer = _auraFarmer;\\n\\n        DOLA.approve(address(l1ERC20Gateway), type(uint).max); \\n    }\\n\\n    modifier onlyChair {\\n        if (msg.sender != chair) revert OnlyChair();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Mints & deposits `amountToBridge` of DOLA into Arbitrum Gateway to the `auraFarmer` contract\\n     * @param amountToBridge Amount of underlying token to briged into Aura farmer on Arbitrum\\n     */\\n    function expansion(uint amountToBridge) external payable onlyChair {\\n        if (gasPrice == 0) revert ZeroGasPriceBid();\\n        if (msg.value < maxSubmissionCost + defaultGasLimit * gasPrice) revert InsufficientGasFunds();\\n        uint dolaBal = DOLA.balanceOf(address(this));\\n        if(dolaBal < amountToBridge){\\n            uint amountToMint = amountToBridge - dolaBal;\\n            underlyingSupply += amountToMint;\\n            DOLA.mint(address(this), amountToMint);\\n            emit Expansion(amountToMint);\\n        }\\n        bytes memory data = abi.encode(maxSubmissionCost, \\\"\\\");\\n        gatewayRouter.outboundTransferCustomRefund{value: msg.value}(\\n            address(DOLA),\\n            refundAddress,\\n            auraFarmer,\\n            amountToBridge,\\n            defaultGasLimit, \\n            gasPrice, \\n            data\\n        );\\n\\n    }\\n\\n    /**\\n     * @notice Burns `amountUnderlying` of DOLA held in this contract\\n     * @param amountUnderlying Amount of underlying DOLA to burn\\n     */\\n    function contraction(uint amountUnderlying) external onlyChair {\\n\\n        _contraction(amountUnderlying);\\n    }\\n\\n    /**\\n     * @notice Attempts to contract (burn) all DOLA held by this contract\\n     */\\n    function contractAll() external onlyChair {\\n\\n        _contraction(DOLA.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @notice Attempts to contract (burn) `amount` of DOLA. Sends remainder to `gov` if `amount` > DOLA minted by this fed.\\n     * @param amount Amount to contract\\n     */\\n    function _contraction(uint amount) internal {\\n        if (amount == 0) revert CantBurnZeroDOLA();\\n        if(amount > underlyingSupply){\\n            DOLA.burn(underlyingSupply);\\n            DOLA.transfer(gov, amount - underlyingSupply);\\n            emit Contraction(underlyingSupply);\\n            underlyingSupply = 0;\\n        } else {\\n            DOLA.burn(amount);\\n            underlyingSupply -= amount;\\n            emit Contraction(amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Method for current chair of the Arbi FED to resign\\n     */\\n    function resign() external onlyChair {\\n        chair = address(0);\\n    }\\n\\n    /**\\n     * @notice Method for gov to change the chair\\n     */\\n    function changeChair(address newChair) external onlyGov {\\n        chair = newChair;\\n    }\\n\\n    /**\\n     * @notice Method for gov to change the L2 auraFarmer address\\n     */\\n    function changeAuraFarmer(address newAuraFarmer) external onlyGov {\\n        auraFarmer = newAuraFarmer;\\n    }\\n\\n    /**\\n     * @notice Method for gov to withdraw any ERC20 token from this contract\\n     */\\n    function emergecyWithdraw(address token, address to, uint256 amount) external onlyGov {\\n        IERC20(token).transfer(to, amount);\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n\\n     * @dev Returns the decimal points used by the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     \\n    * @dev Returns the amount of tokens owned by `account`.\\n    */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n    \\n    /**\\n     * @dev Burns `amount` of token, shringking total supply\\n     */\\n    function burn(uint amount) external;\\n\\n    /**\\n     * @dev Mints `amount` of token to address `to` increasing total supply\\n     */\\n    function mint(address to, uint amount) external;\\n\\n    //For testing\\n    function addMinter(address minter_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/velo/IDola.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IDola {\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function mint(address recipient, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function addMinter(address minter) external;\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/velo/IL1ERC20Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IL1ERC20Bridge\\n */\\ninterface IL1ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event ERC20DepositInitiated(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event ERC20WithdrawalFinalized(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev get the address of the corresponding L2 bridge contract.\\n     * @return Address of the corresponding L2 bridge contract.\\n     */\\n    function l2TokenBridge() external returns (address);\\n\\n    /**\\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _amount Amount of the ERC20 to deposit\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _to L2 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\\n     * L1 ERC20 token.\\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\\n     *\\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\\n     * @param _from L2 address initiating the transfer.\\n     * @param _to L1 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _data Data provided by the sender on L2. This data is provided\\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *   length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\"\r\n    },\r\n    \"src/arbi-fed/ArbiGasManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\nimport \\\"src/arbi-fed/Governable.sol\\\";\\n\\n\\ncontract ArbiGasManager is Governable{\\n    address public gasClerk;\\n    address public refundAddress;\\n    mapping(bytes32 => uint) public functionGasLimit;\\n    uint public defaultGasLimit;\\n    uint public maxSubmissionCostCeiling;\\n    uint public maxSubmissionCost;\\n    uint public gasPriceCeiling;\\n    uint public gasPrice;\\n\\n    struct L2GasParams {\\n        uint256 _maxSubmissionCost;\\n        uint256 _maxGas;\\n        uint256 _gasPriceBid;\\n    }\\n\\n\\n    constructor(address _gov, address _gasClerk, address _l2RefundAddress) Governable(_gov){\\n        gasClerk = _gasClerk;\\n        refundAddress = _l2RefundAddress;\\n        defaultGasLimit = 10**6; //Same gas stipend as Optimism bridge\\n        maxSubmissionCost = 0.01 ether;\\n        gasPriceCeiling = 2 * 10**10; //20 gWEI\\n        gasPrice = 10**9; //1 gWEI\\n    }\\n\\n    error OnlyGasClerk();\\n    error MaxSubmissionCostAboveCeiling();\\n    error GasPriceAboveCeiling();\\n\\n    modifier onlyGasClerk(){\\n        if(msg.sender != gasClerk) revert OnlyGasClerk();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Sets the default gas limit.\\n     * @dev This function can only be called by the gas clerk.\\n     * @param newDefaultGasLimit The new default gas limit to set.\\n     */\\n    function setDefaultGasLimit(uint newDefaultGasLimit) external onlyGasClerk {\\n        defaultGasLimit = newDefaultGasLimit; \\n    }\\n\\n    /**\\n     * @notice Sets the gas limit for a specific function on a contract.\\n     * @dev This function can only be called by the gas clerk.\\n     * @param contractAddress The address of the contract.\\n     * @param functionSelector The selector of the function to set the gas limit for.\\n     * @param gasLimit The new gas limit to set.\\n     */\\n    function setFunctionGasLimit(address contractAddress, bytes4 functionSelector, uint gasLimit) external onlyGasClerk {\\n        bytes32 hash = keccak256(abi.encodePacked(functionSelector, contractAddress));\\n        functionGasLimit[hash] = gasLimit; \\n    }\\n\\n    /**\\n     * @notice Sets the max submission cost.\\n     * @dev Throws if new submission cost exceeds the ceiling. Can only be called by the gas clerk.\\n     * @param newMaxSubmissionCost The new max submission cost to set.\\n     */\\n    function setMaxSubmissionCost(uint newMaxSubmissionCost) external onlyGasClerk {\\n        if(newMaxSubmissionCost > maxSubmissionCostCeiling) revert MaxSubmissionCostAboveCeiling();\\n        maxSubmissionCost = newMaxSubmissionCost;\\n    }\\n\\n    /**\\n     * @notice Sets the gas price.\\n     * @dev Throws if new gas price exceeds the ceiling. Can only be called by the gas clerk.\\n     * @param newGasPrice The new gas price to set.\\n     */\\n    function setGasPrice(uint newGasPrice) external onlyGasClerk {\\n        if(newGasPrice > gasPriceCeiling) revert GasPriceAboveCeiling();\\n        gasPrice = newGasPrice;\\n    }\\n\\n    /**\\n     * @notice Fetches gas parameters for a specific function on a contract.\\n     * @param contractAddress The address of the contract.\\n     * @param functionSelector The selector of the function to get gas parameters for.\\n     * @return L2GasParams Returns a struct containing gas parameters.\\n     */\\n    function getGasParams(address contractAddress, bytes4 functionSelector) public view returns(L2GasParams memory){\\n        L2GasParams memory gasParams;\\n        gasParams._maxSubmissionCost = maxSubmissionCost;\\n        gasParams._gasPriceBid = gasPrice;\\n        bytes32 hash = keccak256(abi.encodePacked(functionSelector, contractAddress));\\n        uint gasLimit = functionGasLimit[hash]; \\n        if(gasLimit == 0) gasLimit = defaultGasLimit;\\n        gasParams._maxGas = gasLimit;\\n        return gasParams;\\n    }\\n\\n    /**\\n     * @notice Sets the L2 refund address.\\n     * @dev Can only be called by governance.\\n     * @param newRefundAddress The new refund address to set.\\n     */\\n    function setRefundAddress(address newRefundAddress) external onlyGov {\\n        refundAddress = newRefundAddress;\\n    }\\n\\n    /**\\n     * @notice Sets the max submission cost ceiling.\\n     * @dev Can only be called by governance.\\n     * @param newMaxSubmissionCostCeiling The new max submission cost ceiling to set.\\n     */\\n    function setMaxSubmissionCostCeiling(uint newMaxSubmissionCostCeiling) external onlyGov {\\n       maxSubmissionCostCeiling = newMaxSubmissionCostCeiling; \\n    }\\n\\n    /**\\n     * @notice Sets the gas price ceiling.\\n     * @dev Can only be called by governance.\\n     * @param newGasPriceCeiling The new gas price ceiling to set.\\n     */\\n    function setGasPriceCeiling(uint newGasPriceCeiling) external onlyGov {\\n       gasPriceCeiling = newGasPriceCeiling; \\n    }\\n    /**\\n     * @notice Sets the gas clerk address.\\n     * @dev Can only be called by governance.\\n     * @param newGasClerk The new address to be set as the gas clerk.\\n     */\\n    function setGasClerk(address newGasClerk) external onlyGov {\\n        gasClerk = newGasClerk;\\n    }\\n\\n    /**\\n     * @notice Fetches the default minimum call value based on gas settings.\\n     * @return minval Returns the default minimum call value calculated as `gasPrice * gasDefaultLimit + maxSubmissionCost`.\\n     */\\n    function getDefaultMinimumCallValue() public view returns(uint minval){\\n        return gasPrice * defaultGasLimit + maxSubmissionCost;\\n    }\\n\\n    /**\\n     * @notice Fetches the minimum call value for a specific function on a contract based on gas settings.\\n     * @dev This function computes the gas limit using the default if not explicitly set for the function.\\n     * @param contractAddress The address of the L2 contract to be called.\\n     * @param functionSelector The selector of the function to get the minimum call value for.\\n     * @return minval Returns the minimum call value calculated as `gasPrice * gasLimit + maxSubmissionCost`.\\n     */\\n    function getFunctionMinimumCallValue(address contractAddress, bytes4 functionSelector) public view returns (uint minval) {\\n        bytes32 hash = keccak256(abi.encodePacked(functionSelector, contractAddress));\\n        uint gasLimit = functionGasLimit[hash];\\n        if(gasLimit == 0) gasLimit = defaultGasLimit;\\n        return gasPrice * gasLimit + maxSubmissionCost;\\n    }\\n\\n    /**\\n     * @notice Checks if the provided call value is sufficient based on default gas settings.\\n     * @dev This function checks if the provided call value is greater than or equal to the default minimum call value and the current contract balance.\\n     * @param callValue The call value to check for sufficiency.\\n     * @return Returns `true` if the call value is sufficient, otherwise `false`.\\n     */\\n    function isCallValueSufficient(uint callValue) public view returns (bool){\\n        return getDefaultMinimumCallValue() <= callValue + address(this).balance;\\n    }\\n\\n    /**\\n     * @notice Checks if the provided call value is sufficient for a specific function on a contract based on gas settings.\\n     * @dev This function checks if the provided call value is greater than or equal to the minimum call value for the specified function and the current contract balance.\\n     * @param contractAddress The address of the contract.\\n     * @param functionSelector The selector of the function to check the call value for.\\n     * @param callValue The call value to check for sufficiency.\\n     * @return Returns `true` if the call value is sufficient for the specified function, otherwise `false`.\\n     */\\n    function isCallValueSufficient(address contractAddress, bytes4 functionSelector, uint callValue) public view returns (bool){\\n        return getFunctionMinimumCallValue(contractAddress, functionSelector) <= callValue + address(this).balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"../../libraries/gateway/ITokenGateway.sol\\\";\\nimport \\\"../../libraries/IERC165.sol\\\";\\n\\n/**\\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\\n * @notice Router also serves as an L1-L2 token address oracle.\\n */\\ninterface IL1GatewayRouter is ITokenGateway, IERC165 {\\n    /**\\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum using the registered or otherwise default gateway\\n     * @dev Some legacy gateway might not have the outboundTransferCustomRefund method and will revert, in such case use outboundTransfer instead\\n     *      L2 address alias will not be applied to the following types of addresses on L1:\\n     *      - an externally-owned account\\n     *      - a contract in construction\\n     *      - an address where a contract will be created\\n     *      - an address where a contract lived, but was destroyed\\n     * @param _token L1 address of ERC20\\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\\n     * @param _amount Token Amount\\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\\n     * @param _gasPriceBid Gas price for L2 execution\\n     * @param _data encoded data from router and user\\n     * @return res abi encoded inbox sequence number\\n     */\\n    function outboundTransferCustomRefund(\\n        address _token,\\n        address _refundTo,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost,\\n        address _creditBackAddress\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost\\n    ) external payable returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function inbox() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/arbi-fed/Governable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nabstract contract Governable {\\n\\n    address public gov;\\n    address public pendingGov;\\n\\n    constructor(address _gov){\\n        gov = _gov;\\n    }\\n\\n    error OnlyGov();\\n    error OnlyPendingGov();\\n\\n    modifier onlyGov() {\\n        if(msg.sender != gov) revert OnlyGov();\\n        _;\\n    }\\n\\n    modifier onlyPendingGov() {\\n        if(msg.sender != gov) revert OnlyPendingGov();\\n        _;\\n    }\\n\\n    function setPendingGov(address newPendingGov) external onlyGov {\\n        pendingGov = newPendingGov;\\n    }\\n\\n    function claimPendingGov() external onlyPendingGov{\\n        gov = pendingGov;\\n        pendingGov = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface ITokenGateway {\\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\\n    // event OutboundTransferInitiated(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\\n    // event InboundTransferFinalized(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    function outboundTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    function finalizeInboundTransfer(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external payable;\\n\\n    /**\\n     * @notice Calculate the address used when bridging an ERC20 token\\n     * @dev the L1 and L2 address oracles may not always be in sync.\\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\\n     * @param l1ERC20 address of L1 token\\n     * @return L2 address of a bridged ERC20 token\\n     */\\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\\n\\n    function getOutboundCalldata(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\n// With pragma modification to allow interface compatibility with >=0.6.9 <0.9.0\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.6/contracts/utils/introspection/IERC165.sol\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"arbitrum-nitro/=lib/arbitrum-nitro/\",\r\n      \"arbitrum/=lib/arbitrum/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auraFarmer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasClerk\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2RefundAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CantBurnZeroDOLA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeltaAboveMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasPriceAboveCeiling\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientGasFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSubmissionCostAboveCeiling\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyChair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGasClerk\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGov\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGov\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroGasPriceBid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Contraction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Expansion\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOLA\",\"outputs\":[{\"internalType\":\"contract IDola\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auraFarmer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAuraFarmer\",\"type\":\"address\"}],\"name\":\"changeAuraFarmer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChair\",\"type\":\"address\"}],\"name\":\"changeChair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPendingGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"contraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergecyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToBridge\",\"type\":\"uint256\"}],\"name\":\"expansion\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"functionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasClerk\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IL1GatewayRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatewayRouter\",\"outputs\":[{\"internalType\":\"contract IL1GatewayRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultMinimumCallValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minval\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getFunctionMinimumCallValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minval\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getGasParams\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasPriceBid\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbiGasManager.L2GasParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callValue\",\"type\":\"uint256\"}],\"name\":\"isCallValueSufficient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"callValue\",\"type\":\"uint256\"}],\"name\":\"isCallValueSufficient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1ERC20Gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCostCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint256\"}],\"name\":\"setDefaultGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setFunctionGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGasClerk\",\"type\":\"address\"}],\"name\":\"setGasClerk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasPriceCeiling\",\"type\":\"uint256\"}],\"name\":\"setGasPriceCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"setMaxSubmissionCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSubmissionCostCeiling\",\"type\":\"uint256\"}],\"name\":\"setMaxSubmissionCostCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingGov\",\"type\":\"address\"}],\"name\":\"setPendingGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRefundAddress\",\"type\":\"address\"}],\"name\":\"setRefundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ArbiFed", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000008f97cca30dbe80e7a8b462f1dd1a51c32accdfc800000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d00000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}