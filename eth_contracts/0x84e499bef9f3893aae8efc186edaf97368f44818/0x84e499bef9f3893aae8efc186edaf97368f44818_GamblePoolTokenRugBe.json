{"SourceCode": "//   _____                 _     _      _____            _ \r\n//  / ____|               | |   | |    |  __ \\          | |\r\n// | |  __  __ _ _ __ ___ | |__ | | ___| |__) |__   ___ | |\r\n// | | |_ |/ _` | '_ ` _ \\| '_ \\| |/ _ \\  ___/ _ \\ / _ \\| |\r\n// | |__| | (_| | | | | | | |_) | |  __/ |  | (_) | (_) | |\r\n//  \\_____|\\__,_|_| |_| |_|_.__/|_|\\___|_|   \\___/ \\___/|_|\r\n\r\n// website: https://www.gamblepool.xyz/\r\n// community: https://t.me/gamblepool\r\n// Token Rug Gamble allows users to bet on whether a token will experience a 'rug pull'.\r\n\r\npragma solidity 0.8.17;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() external virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract GamblePoolTokenRugBet is Ownable, ReentrancyGuard {\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    struct Player {\r\n        uint256 winnerSelected;\r\n        uint256 amountBet;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        string description;\r\n        string logoPath;\r\n        uint256 eventStartTime;\r\n        uint256 shareOfPlayersBettingRug;\r\n        uint256 shareOfPlayersBettingNotRug;\r\n        uint256 participants;\r\n        mapping(address => Player) players;\r\n        uint256 totalPayout;\r\n        uint256 winner;\r\n        bool active;\r\n        bool betInEth;\r\n        address tokenBetAddress;\r\n    }\r\n\r\n    EnumerableSet.AddressSet private activeTokens;\r\n    EnumerableSet.AddressSet private endedTokens;\r\n    EnumerableSet.AddressSet private validTokens;\r\n\r\n    mapping(address => bool) public isAuthorized;\r\n    mapping(address => uint256) public amountWonByAccount;\r\n    mapping(address => mapping (address => uint256)) public tokenWinningsByAccount;\r\n    mapping(address => mapping (address => uint256)) public tokenWinningsPendingByAccount;\r\n    mapping(address => EnumerableSet.AddressSet) private accountMatchesPending;\r\n    mapping(address => TokenInfo) private tokenInformation;\r\n    mapping(uint256 => address) public tokenIndexToAddress;\r\n    address public feeReceiver;\r\n    uint256 public feePercent = 300;\r\n    uint256 public totalPayoutsPaid;\r\n    uint256 public tokenIndex;\r\n    uint256 public bettingTimeInSeconds = 172800; // In seconds\r\n\r\n    event MatchCreated(address indexed tokenId, string description, uint256 indexed eventStartTime);\r\n    event PlayerBet(address indexed tokenId, address indexed walletAddress, uint256 indexed selection, uint256 amount);\r\n    event TokenClosed(uint256 indexed tokenId);\r\n    event PaidOut(bool isEth, address indexed player, uint256 amount);\r\n    event PaidOutTokens(address token, address indexed player, uint256 amount);\r\n\r\n    constructor() {\r\n        isAuthorized[msg.sender] = true;\r\n        feeReceiver = msg.sender;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(isAuthorized[msg.sender], \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    function setAuthorization(address account, bool authorized) external onlyOwner {\r\n        isAuthorized[account] = authorized;\r\n    }\r\n\r\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\r\n        feeReceiver = _feeReceiver;\r\n    }\r\n\r\n    function setFee(uint256 feePerc) external onlyOwner {\r\n        require(feePerc < 1000, \"Cannot be more than 10%\");\r\n        feePercent = feePerc;\r\n    }\r\n\r\n    function addValidToken(address token) external onlyOwner {\r\n        if(!validTokens.contains(token)){\r\n            validTokens.add(token);\r\n        } else {\r\n            revert(\"Token already added!\");\r\n        }\r\n    }\r\n\r\n    function removeValidToken(address token) external onlyOwner {\r\n        if(validTokens.contains(token)){\r\n            validTokens.remove(token);\r\n        } else {\r\n            revert(\"Token already removed!\");\r\n        }\r\n    }\r\n\r\n    function setBettingTime(uint256 _bettingTimeInSeconds) external onlyOwner {\r\n        require(bettingTimeInSeconds > 0, \"Betting time cannot be 0\");\r\n        bettingTimeInSeconds = _bettingTimeInSeconds;\r\n    }\r\n\r\n    // used to start a match\r\n    function initializeNewToken(\r\n        address tokenId,\r\n        uint256 eventStartTime,\r\n        bool betInEth,\r\n        address tokenBetAddress,\r\n        string memory logoUrl\r\n    ) external onlyAuthorized {\r\n        require(!activeTokens.contains(tokenId), \"Match already created\");\r\n        require(eventStartTime > block.timestamp, \"Match already started\");\r\n        activeTokens.add(tokenId);\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        tokenInfo.description = IERC20(tokenId).name();\r\n        tokenInfo.active = true;\r\n        tokenInfo.betInEth = betInEth;\r\n        tokenInfo.logoPath = logoUrl;\r\n        if(!betInEth){\r\n            require(tokenBetAddress != address(0), \"cannot set token to address 0\");\r\n            require(validTokens.contains(tokenBetAddress), \"invalid token\");\r\n            tokenInfo.tokenBetAddress = tokenBetAddress;\r\n        }\r\n        tokenInfo.eventStartTime = eventStartTime;\r\n        tokenIndex++;\r\n        tokenIndexToAddress[tokenIndex] = tokenId;\r\n        emit MatchCreated(tokenId, tokenInfo.description, eventStartTime);\r\n    }\r\n\r\n    function initializeNewTokens(\r\n        address[] calldata tokenId,\r\n        uint256[] calldata eventStartTime,\r\n        bool[] calldata betInEth,\r\n        address[] calldata tokenBetAddress\r\n    ) external onlyAuthorized {\r\n        require(tokenId.length == eventStartTime.length, \"array length mismatch\");\r\n        for(uint256 i = 0; i < tokenId.length; i++){\r\n            require(!activeTokens.contains(tokenId[i]), \"Match already created\");\r\n            require(eventStartTime[i] > block.timestamp, \"Match already started\");\r\n            activeTokens.add(tokenId[i]);\r\n            TokenInfo storage tokenInfo = tokenInformation[tokenId[i]];\r\n            tokenInfo.description = IERC20(tokenId[i]).name();\r\n            tokenInfo.active = true;\r\n            tokenInfo.betInEth = betInEth[i];\r\n            if(!betInEth[i]){\r\n                require(tokenBetAddress[i] != address(0), \"cannot set token to address 0\");\r\n                require(validTokens.contains(tokenBetAddress[i]), \"invalid token\");\r\n                tokenInfo.tokenBetAddress = tokenBetAddress[i];\r\n            }\r\n            tokenIndex++;\r\n            tokenIndexToAddress[tokenIndex] = tokenId[i];\r\n            tokenInfo.eventStartTime = eventStartTime[i];\r\n            emit MatchCreated(tokenId[i], tokenInfo.description, eventStartTime[i]);\r\n        }\r\n    }\r\n\r\n    // note: Rug = 1, Not Rug = 2\r\n    function setWinner(address tokenId, uint256 winner)\r\n        external\r\n        onlyAuthorized\r\n    {\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        require(activeTokens.contains(tokenId), \"Match is closed\");\r\n        require(\r\n            winner <= 3 && winner != 0,\r\n            \"Can only select Rug, Not Rug, or Cancelled\"\r\n        );\r\n        tokenInfo.winner = winner;\r\n\r\n        uint256 shares;\r\n        if (tokenInfo.winner == 1) {\r\n            shares = tokenInfo.shareOfPlayersBettingRug;\r\n        } else if (tokenInfo.winner == 2) {\r\n            shares = tokenInfo.shareOfPlayersBettingNotRug;\r\n        } else if (tokenInfo.winner == 3) {\r\n            shares = tokenInfo.totalPayout;\r\n        }\r\n\r\n        // in the rare case of NO winners, fee receiver takes pool\r\n        if (shares == 0 && tokenInfo.totalPayout > 0) {\r\n            if(tokenInfo.betInEth){\r\n                (bool success, ) = address(feeReceiver).call{\r\n                    value: tokenInfo.totalPayout\r\n                }(\"\");\r\n                require(success, \"failed to process payment to fee receiver\");\r\n            } else {\r\n                IERC20 bettingToken = IERC20(tokenInfo.tokenBetAddress);\r\n                bettingToken.transferFrom(address(this), feeReceiver, tokenInfo.totalPayout);\r\n            }\r\n        }\r\n\r\n        activeTokens.remove(tokenId);\r\n        endedTokens.add(tokenId);\r\n        tokenInfo.active = false;\r\n    }\r\n\r\n    function claimReward(address tokenId) external nonReentrant {\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        bool success;\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        Player storage player = tokenInfo.players[msg.sender];\r\n        if (\r\n            endedTokens.contains(tokenId) &&\r\n            accountMatchesPending[msg.sender].contains(tokenId)\r\n        ) {\r\n            accountMatchesPending[msg.sender].remove(tokenId);\r\n\r\n            if (player.winnerSelected == tokenInfo.winner) {\r\n                uint256 shares;\r\n                if (tokenInfo.winner == 1) {\r\n                    shares = tokenInfo.shareOfPlayersBettingRug;\r\n                } else if (tokenInfo.winner == 2) {\r\n                    shares = tokenInfo.shareOfPlayersBettingNotRug;\r\n                }\r\n\r\n                uint256 amountForPayout = (player.amountBet *\r\n                    tokenInfo.totalPayout) / shares;\r\n                \r\n                if (amountForPayout > 0) {\r\n                    if(tokenInfo.betInEth){\r\n                        amountWonByAccount[msg.sender] += amountForPayout;\r\n                        (success, ) = address(msg.sender).call{\r\n                            value: amountForPayout\r\n                        }(\"\");\r\n                        require(success, \"withdraw unsuccessful\");\r\n                    } else {\r\n                        IERC20 bettingToken = IERC20(tokenInfo.tokenBetAddress);\r\n                        bettingToken.transferFrom(address(this), msg.sender, amountForPayout);\r\n                        tokenWinningsByAccount[msg.sender][tokenInfo.tokenBetAddress] += amountForPayout;\r\n                        emit PaidOutTokens(tokenInfo.tokenBetAddress, msg.sender, amountForPayout);\r\n                    }\r\n                }\r\n            } else if (tokenInfo.winner == 3 && player.amountBet > 0) {\r\n                if(tokenInfo.betInEth){\r\n                    amountWonByAccount[msg.sender] += player.amountBet;\r\n                    (success, ) = address(msg.sender).call{value: player.amountBet}(\r\n                        \"\"\r\n                    );\r\n                    require(success, \"withdraw unsuccessful\");\r\n                } else {\r\n                    IERC20 bettingToken = IERC20(tokenInfo.tokenBetAddress);\r\n                    bettingToken.transferFrom(address(this), msg.sender, player.amountBet);\r\n                    tokenWinningsByAccount[msg.sender][tokenInfo.tokenBetAddress] += player.amountBet;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimRewardAll() external nonReentrant {\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        address[] memory tokenIds = accountMatchesPending[msg.sender].values();\r\n        uint256 amountForPayout;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            TokenInfo storage tokenInfo = tokenInformation[tokenIds[i]];\r\n            Player storage player = tokenInfo.players[msg.sender];\r\n\r\n            if (\r\n                endedTokens.contains(tokenIds[i]) &&\r\n                accountMatchesPending[msg.sender].contains(tokenIds[i])\r\n            ) {\r\n                accountMatchesPending[msg.sender].remove(tokenIds[i]);\r\n\r\n                uint256 shares;\r\n                if (tokenInfo.winner == 1) {\r\n                    shares = tokenInfo.shareOfPlayersBettingRug;\r\n                } else if (tokenInfo.winner == 2) {\r\n                    shares = tokenInfo.shareOfPlayersBettingNotRug;\r\n                }\r\n\r\n                if (player.winnerSelected == tokenInfo.winner) {\r\n                    if(tokenInfo.betInEth){\r\n                        amountForPayout +=\r\n                            (player.amountBet * tokenInfo.totalPayout) /\r\n                            shares;\r\n                    } else {\r\n                        tokenWinningsPendingByAccount[msg.sender][tokenInfo.tokenBetAddress] += \r\n                            (player.amountBet * tokenInfo.totalPayout) / \r\n                            shares;\r\n                    }\r\n                } else if (tokenInfo.winner == 3) {\r\n                    if(tokenInfo.betInEth){\r\n                        amountForPayout += player.amountBet;\r\n                    } else {\r\n                        tokenWinningsPendingByAccount[msg.sender][tokenInfo.tokenBetAddress] += \r\n                            player.amountBet;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (amountForPayout > 0) {\r\n            amountWonByAccount[msg.sender] += amountForPayout;\r\n            (bool success, ) = address(msg.sender).call{value: amountForPayout}(\r\n                \"\"\r\n            );\r\n            require(success, \"withdraw unsuccessful\");\r\n        }\r\n\r\n        address[] memory tokens = validTokens.values();\r\n        uint256 tokenPayout;\r\n        \r\n        for(uint256 i = 0; i < tokens.length; i++){\r\n            tokenPayout = tokenWinningsPendingByAccount[msg.sender][tokens[i]];\r\n            if(tokenPayout > 0){\r\n                tokenWinningsByAccount[msg.sender][tokens[i]] += tokenPayout;\r\n                tokenWinningsPendingByAccount[msg.sender][tokens[i]] = 0;\r\n                IERC20(tokens[i]).transfer(msg.sender, tokenPayout);\r\n                emit PaidOutTokens(tokens[i], msg.sender, tokenPayout);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAmountClaimableByTokenId(address tokenId, address account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        Player storage player = tokenInfo.players[account];\r\n        if (\r\n            endedTokens.contains(tokenId) &&\r\n            accountMatchesPending[account].contains(tokenId)\r\n        ) {\r\n            if (player.winnerSelected == tokenInfo.winner) {\r\n                uint256 shares;\r\n                if (tokenInfo.winner == 1) {\r\n                    shares = tokenInfo.shareOfPlayersBettingRug;\r\n                } else if (tokenInfo.winner == 2) {\r\n                    shares = tokenInfo.shareOfPlayersBettingNotRug;\r\n                }\r\n                uint256 amountForPayout = (player.amountBet *\r\n                    tokenInfo.totalPayout) / shares;\r\n                return amountForPayout;\r\n            } else if (tokenInfo.winner == 3) {\r\n                uint256 amountForPayout = player.amountBet;\r\n                return amountForPayout;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getAmountTotalClaimable(address account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address[] memory tokenIds = accountMatchesPending[account].values();\r\n        uint256 amountForPayout;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            TokenInfo storage tokenInfo = tokenInformation[tokenIds[i]];\r\n            Player storage player = tokenInfo.players[account];\r\n            if (\r\n                endedTokens.contains(tokenIds[i]) &&\r\n                accountMatchesPending[account].contains(tokenIds[i])\r\n            ) {\r\n                uint256 shares;\r\n\r\n                if (tokenInfo.winner == 1) {\r\n                    shares = tokenInfo.shareOfPlayersBettingRug;\r\n                } else if (tokenInfo.winner == 2) {\r\n                    shares = tokenInfo.shareOfPlayersBettingNotRug;\r\n                }\r\n\r\n                if (player.winnerSelected == tokenInfo.winner) {\r\n                    amountForPayout +=\r\n                        (player.amountBet * tokenInfo.totalPayout) /\r\n                        shares;\r\n                } else if (tokenInfo.winner == 3) {\r\n                    amountForPayout += player.amountBet;\r\n                }\r\n            }\r\n        }\r\n        return amountForPayout;\r\n    }\r\n\r\n    function getTokenInfo(address tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory description,\r\n            uint256 eventStart,\r\n            uint256 rugShares,\r\n            uint256 notRugShares,\r\n            uint256 totalPayout,\r\n            bool active,\r\n            uint256 winner,\r\n            bool isEth,\r\n            address bettingToken,\r\n            string memory logoPath\r\n        )\r\n    {\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        description = tokenInfo.description;\r\n        eventStart = tokenInfo.eventStartTime;\r\n        rugShares = tokenInfo.shareOfPlayersBettingRug;\r\n        notRugShares = tokenInfo.shareOfPlayersBettingNotRug;\r\n        totalPayout = tokenInfo.totalPayout;\r\n        active = tokenInfo.active;\r\n        winner = tokenInfo.winner;\r\n        isEth = tokenInfo.betInEth;\r\n        bettingToken = tokenInfo.tokenBetAddress;\r\n        logoPath = tokenInfo.logoPath;\r\n    }\r\n\r\n    function getPlayerInfoByTokenId(address tokenId, address account)\r\n        external\r\n        view\r\n        returns (uint256 amountBet, uint256 winnerSelected)\r\n    {\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        Player storage player = tokenInfo.players[account];\r\n        amountBet = player.amountBet;\r\n        winnerSelected = player.winnerSelected;\r\n    }\r\n\r\n    function getActiveMatches() external view returns (address[] memory) {\r\n        return activeTokens.values();\r\n    }\r\n\r\n    function getInactiveTokens() external view returns (address[] memory) {\r\n        return endedTokens.values();\r\n    }\r\n\r\n    function getAccountMatchesPending(address account)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return accountMatchesPending[account].values();\r\n    }\r\n    \r\n    function getValidTokens() \r\n        external \r\n        view \r\n        returns (address[] memory)\r\n    {\r\n        return validTokens.values();\r\n    }\r\n\r\n    // note: A = 1, B = 2, Draw = 3\r\n    function betWithEth(address tokenId, uint256 willRug) external payable nonReentrant {\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        require(tokenInfo.betInEth, \"Must bet in Tokens\");\r\n        require(msg.value >= 0 ether, \"Cannot bet 0\");\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        \r\n        require(tokenInfo.eventStartTime + (bettingTimeInSeconds * 1 seconds) > block.timestamp, \"Cannot bet anymore\");\r\n        Player storage player = tokenInfo.players[msg.sender];\r\n        require(player.winnerSelected == 0, \"Cannot select again or add more to bet\");\r\n        require(willRug <= 2 && willRug != 0, \"Can only select rug or not rug\");\r\n        uint256 amountForBet = msg.value;\r\n\r\n        // handle fees\r\n        if (feePercent > 0) {\r\n            bool success;\r\n            uint256 amountForFee = (msg.value * feePercent) / 10000;\r\n            (success, ) = address(feeReceiver).call{value: amountForFee}(\"\");\r\n            amountForBet -= amountForFee;\r\n        }\r\n\r\n        tokenInfo.participants += 1;\r\n        player.winnerSelected = willRug;\r\n        player.amountBet = amountForBet;\r\n        accountMatchesPending[msg.sender].add(tokenId);\r\n        tokenInfo.totalPayout += amountForBet;\r\n\r\n        if (willRug == 1) {\r\n            tokenInfo.shareOfPlayersBettingRug += amountForBet;\r\n        } else if (willRug == 2) {\r\n            tokenInfo.shareOfPlayersBettingNotRug += amountForBet;\r\n        }\r\n        emit PlayerBet(tokenId, msg.sender, willRug, amountForBet);\r\n    }\r\n\r\n    // note: A = 1, B = 2, Draw = 3\r\n    function betWithTokens(address tokenId, uint256 willRug, uint256 amount)\r\n        external\r\n        nonReentrant\r\n    {\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        TokenInfo storage tokenInfo = tokenInformation[tokenId];\r\n        require(!tokenInfo.betInEth, \"Must bet in ETH\");\r\n        IERC20 bettingToken = IERC20(tokenInfo.tokenBetAddress);\r\n        require(amount >= 0 ether, \"Cannot bet 0\");\r\n        require(\r\n            tokenInfo.eventStartTime + (bettingTimeInSeconds * 1 seconds) > block.timestamp,\r\n            \"Cannot bet anymore\"\r\n        );\r\n        Player storage player = tokenInfo.players[msg.sender];\r\n        require(player.winnerSelected == 0, \"Cannot select again or add more to bet\");\r\n        require(willRug <= 3 && willRug != 0, \"Can only select team A, B, or Draw\");\r\n        uint256 amountForBet = amount;\r\n\r\n        // handle fees\r\n        if (feePercent > 0) {\r\n            uint256 amountForFee = (amount * feePercent) / 10000;\r\n            bettingToken.transferFrom(msg.sender, feeReceiver, amountForFee);\r\n            amountForBet -= amountForFee;\r\n        }\r\n\r\n        bettingToken.transferFrom(msg.sender, address(this), amountForBet);\r\n        tokenInfo.participants += 1;\r\n        player.winnerSelected = willRug;\r\n        player.amountBet = amountForBet;\r\n        accountMatchesPending[msg.sender].add(tokenId);\r\n        tokenInfo.totalPayout += amountForBet;\r\n\r\n        if (willRug == 1) {\r\n            tokenInfo.shareOfPlayersBettingRug += amountForBet;\r\n        } else if (willRug == 2) {\r\n            tokenInfo.shareOfPlayersBettingNotRug += amountForBet;\r\n        }\r\n        emit PlayerBet(tokenId, msg.sender, willRug, amountForBet);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eventStartTime\",\"type\":\"uint256\"}],\"name\":\"MatchCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEth\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaidOutTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"selection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenClosed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addValidToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountWonByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"willRug\",\"type\":\"uint256\"}],\"name\":\"betWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"willRug\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betWithTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bettingTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewardAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountMatchesPending\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveMatches\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAmountClaimableByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAmountTotalClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInactiveTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerSelected\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"eventStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rugShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notRugShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"bettingToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"logoPath\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventStartTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"betInEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenBetAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"logoUrl\",\"type\":\"string\"}],\"name\":\"initializeNewToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenId\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"eventStartTime\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"betInEth\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBetAddress\",\"type\":\"address[]\"}],\"name\":\"initializeNewTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeValidToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bettingTimeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setBettingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feePerc\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"}],\"name\":\"setWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWinningsByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWinningsPendingByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutsPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GamblePoolTokenRugBet", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7741124da09928e1e1bbd06b947ae89ddc5275ad5a17f9652a750a4cf4042c56"}