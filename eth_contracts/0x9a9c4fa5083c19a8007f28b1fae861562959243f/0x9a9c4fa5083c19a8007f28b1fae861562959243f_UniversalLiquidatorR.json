{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/UniversalLiquidatorRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// imported contracts and libraries\\nimport \\\"openzeppelin/access/Ownable.sol\\\";\\n\\n// interfaces\\nimport \\\"../interfaces/IUniversalLiquidatorRegistry.sol\\\";\\n\\n// libraries\\nimport \\\"../libraries/DataTypes.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\n// constants and types\\nimport {ULRegistryStorage} from \\\"./storage/ULRegistry.sol\\\";\\n\\ncontract UniversalLiquidatorRegistry is Ownable, IUniversalLiquidatorRegistry, ULRegistryStorage {\\n    function getPath(address _sellToken, address _buyToken) public view override returns (DataTypes.SwapInfo[] memory) {\\n        if (paths[_sellToken][_buyToken].dex != bytes32(0)) {\\n            DataTypes.SwapInfo[] memory retPaths = new DataTypes.SwapInfo[](1);\\n            retPaths[0] = DataTypes.SwapInfo(dexesInfo[paths[_sellToken][_buyToken].dex], paths[_sellToken][_buyToken].paths);\\n            return retPaths;\\n        }\\n\\n        for (uint256 idx; idx < _intermediateTokens.length;) {\\n            if (\\n                paths[_sellToken][_intermediateTokens[idx]].dex != bytes32(0)\\n                    && paths[_intermediateTokens[idx]][_buyToken].dex != bytes32(0)\\n            ) {\\n                // found the intermediateToken and intermediateDex\\n                DataTypes.SwapInfo[] memory retPaths = new DataTypes.SwapInfo[](\\r\\n                    2\\n                );\\n                retPaths[0] = DataTypes.SwapInfo(\\n                    dexesInfo[paths[_sellToken][_intermediateTokens[idx]].dex], paths[_sellToken][_intermediateTokens[idx]].paths\\n                );\\n                retPaths[1] = DataTypes.SwapInfo(\\n                    dexesInfo[paths[_intermediateTokens[idx]][_buyToken].dex], paths[_intermediateTokens[idx]][_buyToken].paths\\n                );\\n                return retPaths;\\n            }\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n        revert Errors.PathsNotExist();\\n    }\\n\\n    function setPath(bytes32 _dex, address[] memory _paths) external override onlyOwner {\\n        // dex should exist\\n        if (!_dexExists(_dex)) revert Errors.DexDoesNotExist();\\n        // path could also be an empty array\\n        if (_paths.length < 2) revert Errors.InvalidLength();\\n\\n        // path can also be empty\\n        paths[_paths[0]][_paths[_paths.length - 1]] = DataTypes.PathInfo(_dex, _paths);\\n    }\\n\\n    function setIntermediateToken(address[] memory _token) public override onlyOwner {\\n        _intermediateTokens = _token;\\n    }\\n\\n    function addDex(bytes32 _name, address _dex) public override onlyOwner {\\n        if (_dexExists(_name)) revert Errors.DexExists();\\n        dexesInfo[_name] = _dex;\\n        _allDexes.push(_name);\\n    }\\n\\n    function changeDexAddress(bytes32 _name, address _dex) public override onlyOwner {\\n        if (!_dexExists(_name)) revert Errors.DexDoesNotExist();\\n        dexesInfo[_name] = _dex;\\n    }\\n\\n    function getAllDexes() public view override returns (bytes32[] memory) {\\n        uint256 totalDexes = 0;\\n\\n        for (uint256 idx = 0; idx < _allDexes.length;) {\\n            if (dexesInfo[_allDexes[idx]] != address(0)) {\\n                totalDexes++;\\n            }\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        bytes32[] memory retDexes = new bytes32[](totalDexes);\\n        uint256 retIdx = 0;\\n\\n        for (uint256 idx; idx < _allDexes.length;) {\\n            if (dexesInfo[_allDexes[idx]] != address(0)) {\\n                retDexes[retIdx] = _allDexes[idx];\\n                retIdx++;\\n            }\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        return retDexes;\\n    }\\n\\n    function getAllIntermediateTokens() public view override returns (address[] memory) {\\n        return _intermediateTokens;\\n    }\\n\\n    function _dexExists(bytes32 _name) internal view returns (bool) {\\n        return dexesInfo[_name] != address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniversalLiquidatorRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// libraries\\nimport \\\"../libraries/DataTypes.sol\\\";\\n\\ninterface IUniversalLiquidatorRegistry {\\n    function getPath(address _sellToken, address _buyToken) external view returns (DataTypes.SwapInfo[] memory);\\n\\n    function setPath(bytes32 _dex, address[] memory _paths) external;\\n\\n    function setIntermediateToken(address[] memory _token) external;\\n\\n    function addDex(bytes32 _name, address _address) external;\\n\\n    function changeDexAddress(bytes32 _name, address _address) external;\\n\\n    function getAllDexes() external view returns (bytes32[] memory);\\n\\n    function getAllIntermediateTokens() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"src/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary DataTypes {\\n    struct PathInfo {\\n        bytes32 dex;\\n        address[] paths;\\n    }\\n\\n    struct SwapInfo {\\n        address dex;\\n        address[] paths;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary Errors {\\n    // UniversalLiquidatorRegistry errors\\n    error InvalidLength();\\n    error DexExists();\\n    error DexDoesNotExist();\\n    error PathsNotExist();\\n    // UniversalLiquidator errors\\n    error InvalidAddress();\\n}\\n\"\r\n    },\r\n    \"src/core/storage/ULRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../libraries/DataTypes.sol\\\";\\n\\nabstract contract ULRegistryStorage {\\n    mapping(address => mapping(address => DataTypes.PathInfo)) public paths;\\n    mapping(bytes32 => address) public dexesInfo;\\n\\n    bytes32[] internal _allDexes;\\n    address[] internal _intermediateTokens;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"DexDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DexExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PathsNotExist\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_dex\",\"type\":\"address\"}],\"name\":\"addDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_dex\",\"type\":\"address\"}],\"name\":\"changeDexAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dexesInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDexes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllIntermediateTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyToken\",\"type\":\"address\"}],\"name\":\"getPath\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"paths\",\"type\":\"address[]\"}],\"internalType\":\"struct DataTypes.SwapInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"paths\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"dex\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"}],\"name\":\"setIntermediateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dex\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_paths\",\"type\":\"address[]\"}],\"name\":\"setPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UniversalLiquidatorRegistry", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}