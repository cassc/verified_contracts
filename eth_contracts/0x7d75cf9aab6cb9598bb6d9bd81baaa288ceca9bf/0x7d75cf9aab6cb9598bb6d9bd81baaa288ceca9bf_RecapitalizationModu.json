{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RecapitalizationModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport { IGlobalsLike, IMapleTokenLike } from \\\"./interfaces/Interfaces.sol\\\";\\n\\nimport { IRecapitalizationModule } from \\\"./interfaces/IRecapitalizationModule.sol\\\";\\n\\n/*\\n * The recapitalization module has a defined schedule of recapitalization that defines how new tokens will be issued over time.\\n * Here is an example of an recapitalization schedule with three windows, the first two windows have a defined start and end.\\n * The last window has a defined start but lasts indefinitely after it starts since it is the last window in the schedule.\\n *\\n * |--------|------|---------------->\\n *     W1      W2          W3\\n *\\n * Each window has a separate issuance rate, which defines how many tokens per second will be issued during it's duration.\\n * The issuance rate generally increases over time and is used to simulate the effect of compounding (for example on a yearly basis).\\n * However the issuance rate can also be zero to indicate that no tokens should be issued.\\n *\\n * |----|==============|________|\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261>\\n *   W1        W2          W3         W4\\n *\\n * New windows can be scheduled, but only from the current time, retroactive scheduling is not possible.\\n * When new windows are scheduled after the last window in the schedule starts, they will be appended to the schedule.\\n *\\n * |--------|----------|----------------->\\n *     W1        W2         ^  W3\\n *                          |\\n * |--------|----------|----|------------>\\n *     W1        W2      W3       W4\\n *\\n * When new windows are scheduled before any of the existing windows in the schedule start, they will replace them instead.\\n *\\n * |--------|----------|--------------->\\n *     W1        W2 ^         W3\\n *                  |\\n * |--------|-------|------------------>\\n *     W1        W2          W4\\n */\\n\\ncontract RecapitalizationModule is IRecapitalizationModule {\\n\\n    struct Window {\\n        uint16  nextWindowId;  // Identifier of the window that takes effect after this one (zero if there is none).\\n        uint32  windowStart;   // Timestamp that marks when the window starts. It lasts until the start of the next window (or forever).\\n        uint208 issuanceRate;  // Defines the amount of tokens per second that will be issued (zero indicates no issuance).\\n    }\\n\\n    address public immutable token;\\n\\n    uint16 public lastClaimedWindowId;\\n    uint16 public lastScheduledWindowId;\\n\\n    uint32 public lastClaimedTimestamp;\\n\\n    mapping(uint16 => Window) public windows;\\n\\n    constructor(address token_) {\\n        token = token_;\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** Modifiers                                                                                                                      ***/\\n    /**************************************************************************************************************************************/\\n\\n    modifier onlyClaimer {\\n        require(IGlobalsLike(_globals()).isInstanceOf(\\\"RECAPITALIZATION_CLAIMER\\\", msg.sender), \\\"RM:NOT_CLAIMER\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyGovernorAndScheduled(bytes32 functionId_) {\\n        IGlobalsLike globals_ = IGlobalsLike(_globals());\\n\\n        require(msg.sender == globals_.governor(), \\\"RM:NOT_GOVERNOR\\\");\\n\\n        bool isScheduledCall_ = globals_.isValidScheduledCall(msg.sender, address(this), functionId_, msg.data);\\n\\n        require(isScheduledCall_, \\\"RM:NOT_SCHEDULED\\\");\\n\\n        globals_.unscheduleCall(msg.sender, functionId_, msg.data);\\n\\n        _;\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** External Functions                                                                                                             ***/\\n    /**************************************************************************************************************************************/\\n\\n    function claim() external onlyClaimer returns (uint256 amountClaimed_) {\\n\\n        (\\n            uint16  lastClaimableWindowId_,\\n            uint256 claimableAmount_\\n        ) = _claimable(lastClaimedWindowId, lastClaimedTimestamp, uint32(block.timestamp));\\n\\n        require(claimableAmount_ > 0, \\\"RM:C:ZERO_CLAIM\\\");\\n\\n        lastClaimedTimestamp = uint32(block.timestamp);\\n        lastClaimedWindowId  = lastClaimableWindowId_;\\n\\n        emit Claimed(claimableAmount_, lastClaimableWindowId_);\\n\\n        IMapleTokenLike(token).mint(IGlobalsLike(_globals()).mapleTreasury(), amountClaimed_ = claimableAmount_);\\n    }\\n\\n    function schedule(uint32[] memory windowStarts_, uint208[] memory issuanceRates_) external onlyGovernorAndScheduled(\\\"RM:SCHEDULE\\\") {\\n        _validateWindows(windowStarts_, issuanceRates_);\\n\\n        // Find at which point in the linked list to insert the new windows.\\n        uint16 previousWindowId_ = _findInsertionPoint(windowStarts_[0]);\\n        uint16 newWindowId_      = lastScheduledWindowId + 1;\\n\\n        require(windowStarts_[0] > windows[previousWindowId_].windowStart, \\\"RM:S:DUPLICATE_WINDOW\\\");\\n\\n        windows[previousWindowId_].nextWindowId = newWindowId_;\\n\\n        // Create all the new windows and link them up to each other.\\n        uint16 newWindowCount_ = uint16(windowStarts_.length);\\n\\n        for (uint16 index_; index_ < newWindowCount_; ++index_) {\\n            windows[newWindowId_] = Window({\\n                nextWindowId: index_ < newWindowCount_ - 1 ? newWindowId_ + 1 : 0,\\n                windowStart:  windowStarts_[index_],\\n                issuanceRate: issuanceRates_[index_]\\n            });\\n\\n            emit WindowScheduled(newWindowId_, windowStarts_[index_], issuanceRates_[index_], previousWindowId_);\\n\\n            previousWindowId_ = newWindowId_;\\n            ++newWindowId_;\\n        }\\n\\n        lastScheduledWindowId = newWindowId_ - 1;\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** View Functions                                                                                                                 ***/\\n    /**************************************************************************************************************************************/\\n\\n    function claimable(uint32 to_) external view returns (uint256 claimableAmount_) {\\n        uint32 lastClaimedTimestamp_ = lastClaimedTimestamp;\\n\\n        if (to_ <= lastClaimedTimestamp_) return 0;\\n\\n        ( , claimableAmount_ ) = _claimable(lastClaimedWindowId, lastClaimedTimestamp_, to_);\\n    }\\n\\n    function currentIssuanceRate() external view returns (uint208 issuanceRate_) {\\n        issuanceRate_ = windows[currentWindowId()].issuanceRate;\\n    }\\n\\n    function currentWindowId() public view returns (uint16 windowId_) {\\n        windowId_ = _findInsertionPoint(uint32(block.timestamp));\\n\\n        uint16 nextWindowId_ = windows[windowId_].nextWindowId;\\n\\n        if (block.timestamp == windows[nextWindowId_].windowStart) windowId_ = nextWindowId_;\\n    }\\n\\n    function currentWindowStart() external view returns (uint32 windowStart_) {\\n        windowStart_ = windows[currentWindowId()].windowStart;\\n    }\\n\\n    /**************************************************************************************************************************************/\\n    /*** Internal Functions                                                                                                             ***/\\n    /**************************************************************************************************************************************/\\n\\n    function _claimable(\\n        uint16 windowId_,\\n        uint32 from_,\\n        uint32 to_\\n    )\\n        internal view returns (\\n            uint16  lastClaimableWindowId_,\\n            uint256 claimableAmount_\\n        )\\n    {\\n        Window memory window_ = windows[windowId_];\\n        Window memory nextWindow_;\\n\\n        while (from_ < to_) {\\n            bool isLastWindow_ = window_.nextWindowId == 0;\\n\\n            if (!isLastWindow_) {\\n                nextWindow_ = windows[window_.nextWindowId];\\n            }\\n\\n            bool isCurrentWindow_ = isLastWindow_ ? true : to_ < nextWindow_.windowStart;\\n\\n            uint32 windowEnd_ = isCurrentWindow_ ? to_ : nextWindow_.windowStart;\\n\\n            claimableAmount_ += window_.issuanceRate * (windowEnd_ - from_);\\n\\n            if (isCurrentWindow_) break;\\n\\n            from_     = windowEnd_;\\n            windowId_ = window_.nextWindowId;\\n            window_   = nextWindow_;\\n        }\\n\\n        lastClaimableWindowId_ = windowId_;\\n    }\\n\\n    function _findInsertionPoint(uint32 windowStart_) internal view returns (uint16 windowId_) {\\n        windowId_ = lastClaimedWindowId;\\n\\n        Window memory window_ = windows[windowId_];\\n\\n        while (true) {\\n            uint16 nextWindowId_ = window_.nextWindowId;\\n\\n            if (nextWindowId_ == 0) break;\\n\\n            window_ = windows[nextWindowId_];\\n\\n            if (windowStart_ <= window_.windowStart) break;\\n\\n            windowId_ = nextWindowId_;\\n        }\\n    }\\n\\n    function _globals() internal view returns (address globals_) {\\n        globals_ = IMapleTokenLike(token).globals();\\n    }\\n\\n    function _validateWindows(uint32[] memory windowStarts_, uint208[] memory issuanceRates_) internal view {\\n        require(windowStarts_.length == issuanceRates_.length, \\\"RM:VW:LENGTH_MISMATCH\\\");\\n        require(windowStarts_.length > 0,                      \\\"RM:VW:EMPTY_ARRAYS\\\");\\n        require(windowStarts_[0] >= block.timestamp,           \\\"RM:VW:OUT_OF_DATE\\\");\\n\\n        for (uint256 index_ = 0; index_ < windowStarts_.length - 1; ++index_) {\\n            require(windowStarts_[index_] < windowStarts_[index_ + 1], \\\"RM:VW:OUT_OF_ORDER\\\");\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IERC20Like {\\n\\n    function burn(address from, uint256 value) external;\\n\\n    function mint(address to, uint256 value) external;\\n\\n    function totalSupply() external view returns (uint256 totalSupply);\\n\\n}\\n\\ninterface IGlobalsLike {\\n\\n    function governor() external view returns (address governor);\\n\\n    function isInstanceOf(bytes32 instanceKey, address instance) external view returns (bool isInstance);\\n\\n    function isValidScheduledCall(\\n        address          caller,\\n        address          target,\\n        bytes32          functionId,\\n        bytes   calldata callData\\n    ) external view returns (bool isValidScheduledCall);\\n\\n    function mapleTreasury() external view returns (address mapleTreasury);\\n\\n    function unscheduleCall(address caller, bytes32 functionId, bytes calldata callData) external;\\n\\n}\\n\\ninterface IMapleTokenInitializerLike {\\n\\n    function initialize(address migrator, address treasury) external;\\n\\n}\\n\\ninterface IMapleTokenLike is IERC20Like {\\n\\n    function globals() external view returns (address globals);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRecapitalizationModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IRecapitalizationModule {\\n\\n    /**************************************************************************************************************************************/\\n    /*** Events                                                                                                                         ***/\\n    /**************************************************************************************************************************************/\\n\\n    /**\\n     *  @dev   Emitted when tokens are claimed.\\n     *  @param amountClaimed       The amount of tokens that were claimed.\\n     *  @param lastClaimedWindowId The identifier of the window during which the tokens were claimed.\\n     */\\n    event Claimed(uint256 amountClaimed, uint16 lastClaimedWindowId);\\n\\n    /**\\n     *  @dev   Emitted when a new window is scheduled.\\n     *  @param newWindowId      The identifier of the new window that was scheduled.\\n     *  @param windowStart      The timestamp that marks when the new windows starts.\\n     *  @param issuanceRate     The issuance rate that will be applied to the new window.\\n     *  @param previousWindowId The identifier of the window that comes before the newly scheduled window (zero if there is none).\\n     */\\n    event WindowScheduled(uint16 indexed newWindowId, uint32 indexed windowStart, uint208 issuanceRate, uint16 previousWindowId);\\n\\n    /**************************************************************************************************************************************/\\n    /*** Functions                                                                                                                      ***/\\n    /**************************************************************************************************************************************/\\n\\n    /**\\n     *  @dev    Claims tokens from the time of the last claim up until the current time.\\n     *  @return claimedAmount The amount of tokens that were claimed.\\n     */\\n    function claim() external returns (uint256 claimedAmount);\\n\\n    /**\\n     *  @dev    Calculates how many tokens would be claimable from the time of the last claim up to the specified point in time.\\n     *  @return claimableAmount The amount of tokens that are claimable from the time of the last claim up to the specified time.\\n     */\\n    function claimable(uint32 to) external view returns (uint256 claimableAmount);\\n\\n    /**\\n     *  @dev    Returns the amount of tokens issue per second for the current window.\\n     *  @return issuanceRate The amount of tokens issued per second for the current window.\\n     */\\n    function currentIssuanceRate() external view returns (uint208 issuanceRate);\\n\\n    /**\\n     *  @dev    Returns the identifier of the current window.\\n     *  @return windowId The identifier of the current window.\\n     */\\n    function currentWindowId() external view returns (uint16 windowId);\\n\\n    /**\\n     *  @dev    Returns the timestamp of the start of the current window.\\n     *  @return windowStart The timestamp of the start of the current window.\\n     */\\n    function currentWindowStart() external view returns (uint32 windowStart);\\n\\n    /**\\n     *  @dev    Returns the timestamp of the last time tokens were claimed.\\n     *  @return lastClaimedTimestamp Timestamp of the last time tokens were claimed.\\n     */\\n    function lastClaimedTimestamp() external view returns (uint32 lastClaimedTimestamp);\\n\\n    /**\\n     *  @dev    Returns the identifier of the window during which tokens were last claimed.\\n     *  @return lastClaimedWindowId Identifier of the window during which tokens were last claimed.\\n     */\\n    function lastClaimedWindowId() external view returns (uint16 lastClaimedWindowId);\\n\\n    /**\\n     *  @dev    Returns the identifier that was assigned to the last scheduled window.\\n     *  @return lastScheduledWindowId Identifier that was assigned to the last scheduled window.\\n     */\\n    function lastScheduledWindowId() external view returns (uint16 lastScheduledWindowId);\\n\\n    /**\\n     *  @dev   Schedules new windows that define when tokens will be issued.\\n     *  @param windowStarts  An array of window start times.\\n     *  @param issuanceRates An array of corresponding issuance rates.\\n     */\\n    function schedule(uint32[] memory windowStarts, uint208[] memory issuanceRates) external;\\n\\n    /**\\n     *  @dev    Returns the address of the Maple treasury.\\n     *  @return token The address of the underlying token being managed.\\n     */\\n    function token() external view returns (address token);\\n\\n    /**\\n     *  @dev    Returns thew window parameters given a window identifier.\\n     *  @param  windowId     The window identifier.\\n     *  @return nextWindowId The identifier of the window that takes effect after the provided one (zero if there is none).\\n     *  @return windowStart  The timestamp that marks when the window starts. It lasts until the start of the next window (or forever).\\n     *  @return issuanceRate The rate (per second) at which tokens will be issued (zero indicates no issuance).\\n     */\\n    function windows(uint16 windowId) external view returns (uint16 nextWindowId, uint32 windowStart, uint208 issuanceRate);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"address-registry/=modules/address-registry/contracts/\",\r\n      \"contract-test-utils/=modules/globals/modules/contract-test-utils/contracts/\",\r\n      \"ds-test/=modules/forge-std/lib/ds-test/src/\",\r\n      \"erc20/=modules/erc20/\",\r\n      \"forge-std/=modules/forge-std/src/\",\r\n      \"globals/=modules/globals/\",\r\n      \"migrator/=modules/migrator/modules/erc20-helper/src/\",\r\n      \"non-transparent-proxy/=modules/globals/modules/non-transparent-proxy/\",\r\n      \"ntp/=modules/ntp/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"lastClaimedWindowId\",\"type\":\"uint16\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"newWindowId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"windowStart\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint208\",\"name\":\"issuanceRate\",\"type\":\"uint208\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"previousWindowId\",\"type\":\"uint16\"}],\"name\":\"WindowScheduled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountClaimed_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"to_\",\"type\":\"uint32\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimableAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIssuanceRate\",\"outputs\":[{\"internalType\":\"uint208\",\"name\":\"issuanceRate_\",\"type\":\"uint208\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentWindowId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"windowId_\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentWindowStart\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"windowStart_\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastClaimedTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastClaimedWindowId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastScheduledWindowId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"windowStarts_\",\"type\":\"uint32[]\"},{\"internalType\":\"uint208[]\",\"name\":\"issuanceRates_\",\"type\":\"uint208[]\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"windows\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"nextWindowId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"windowStart\",\"type\":\"uint32\"},{\"internalType\":\"uint208\",\"name\":\"issuanceRate\",\"type\":\"uint208\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RecapitalizationModule", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001915a8de08a92b846df7c845e140e4b0714820bd", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}