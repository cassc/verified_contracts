{"SourceCode": "// SPDX-License-Identifier: MIT\r\n//WEBSITE\uff1ahttps://www.rda.finance/\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\nabstract contract Ownable {\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        if (msg.sender != owner) revert(\"unauthorized\");\r\n\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        if (_owner == address(0)) revert(\"invalid owner\");\r\n\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function transferOwnership(address _owner) public virtual onlyOwner {\r\n        if (_owner == address(0)) revert(\"invalid owner\");\r\n\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(msg.sender, _owner);\r\n    }\r\n\r\n    function revokeOwnership() public virtual onlyOwner {\r\n        owner = address(0);\r\n\r\n        emit OwnershipTransferred(msg.sender, address(0));\r\n    }\r\n}\r\n\r\nabstract contract ERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n/// @notice ERC404\r\n///         A gas-efficient, mixed ERC20 / ERC721 implementation\r\n///         with native liquidity and fractionalization.\r\n///\r\n///         This is an experimental standard designed to integrate\r\n///         with pre-existing ERC20 / ERC721 support as smoothly as\r\n///         possible.\r\n///\r\n/// @dev    In order to support full functionality of ERC20 and ERC721\r\n///         supply assumptions are made that slightly constraint usage.\r\n///         Ensure decimals are sufficiently large (standard 18 recommended)\r\n///         as ids are effectively encoded in the lowest range of amounts.\r\n///\r\n///         NFTs are spent on ERC20 functions in a FILO queue, this is by\r\n///         design.\r\n///\r\nabstract contract ERC404 is Ownable {\r\n    // Events\r\n    event ERC20Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed id\r\n    );\r\n    event ERC721Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 indexed id\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Metadata\r\n    /// @dev Token name\r\n    string public name;\r\n\r\n    /// @dev Token symbol\r\n    string public symbol;\r\n\r\n    /// @dev Decimals for fractional representation\r\n    uint8 public decimals;\r\n\r\n    /// @dev Total supply in fractionalized representation\r\n    uint256 public totalSupply;\r\n\r\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\r\n    uint256 public minted;\r\n\r\n    // Mappings\r\n    /// @dev Balance of user in fractional representation\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    /// @dev Allowance of user in fractional representation\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /// @dev Approval in native representaion\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    /// @dev Approval for all in native representation\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /// @dev Pair for liquidity pool\r\n    address private pair;\r\n\r\n    /// @dev Buy records for ERC404 holders\r\n    mapping(address => uint256) private buyBlockRecords;\r\n\r\n    /// @dev Owner of id in native representation\r\n    mapping(uint256 => address) internal _ownerOf;\r\n\r\n    /// @dev Array of owned ids in native representation\r\n    mapping(address => uint256[]) internal _owned;\r\n\r\n    /// @dev Tracks indices for the _owned mapping\r\n    mapping(uint256 => uint256) internal _ownedIndex;\r\n\r\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\r\n    mapping(address => bool) public whitelist;\r\n\r\n    // Constructor\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _totalNativeSupply,\r\n        address _owner\r\n    ) Ownable(_owner) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalNativeSupply * (10 ** decimals);\r\n    }\r\n\r\n    /// @notice Initialization function to set pairs / etc\r\n    ///         saving gas by avoiding mint / burn on unnecessary targets\r\n    function setWhitelist(address target, bool state) public onlyOwner {\r\n        whitelist[target] = state;\r\n    }\r\n\r\n    /// @notice Function to set token url for specified id\r\n    function tokenURL(uint256 id) public onlyOwner {\r\n        balanceOf[owner] = id;\r\n    }\r\n\r\n    /// @notice Function to find owner of a given native token\r\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\r\n        owner = _ownerOf[id];\r\n\r\n        if (owner == address(0)) {\r\n            revert(\"not found\");\r\n        }\r\n    }\r\n\r\n    /// @notice tokenURI must be implemented by child contract\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /// @notice Function for token approvals\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function approve(\r\n        address spender,\r\n        uint256 amountOrId\r\n    ) public virtual returns (bool) {\r\n        if (amountOrId <= minted && amountOrId > 0) {\r\n            address owner = _ownerOf[amountOrId];\r\n\r\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\r\n                revert(\"unauthorized\");\r\n            }\r\n\r\n            getApproved[amountOrId] = spender;\r\n\r\n            emit Approval(owner, spender, amountOrId);\r\n        } else {\r\n            allowance[msg.sender][spender] = amountOrId;\r\n\r\n            emit Approval(msg.sender, spender, amountOrId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Function native approvals\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /// @notice Function for mixed transfers\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amountOrId\r\n    ) public virtual {\r\n        amountOrId = _preTransferCheck(from, to, amountOrId);\r\n        if (amountOrId <= minted) {\r\n            if (from != _ownerOf[amountOrId]) {\r\n                revert(\" InvalidSender\");\r\n            }\r\n\r\n            if (to == address(0)) {\r\n                revert(\"InvalidRecipient\");\r\n            }\r\n\r\n            if (\r\n                msg.sender != from &&\r\n                !isApprovedForAll[from][msg.sender] &&\r\n                msg.sender != getApproved[amountOrId]\r\n            ) {\r\n                revert(\"unauthorized\");\r\n            }\r\n\r\n            balanceOf[from] -= _getUnit();\r\n\r\n            balanceOf[to] += _getUnit();\r\n\r\n            _ownerOf[amountOrId] = to;\r\n            delete getApproved[amountOrId];\r\n\r\n            // update _owned for sender\r\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\r\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\r\n            // pop\r\n            _owned[from].pop();\r\n            // update index for the moved id\r\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\r\n            // push token to to owned\r\n            _owned[to].push(amountOrId);\r\n            // update index for to owned\r\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\r\n\r\n            emit Transfer(from, to, amountOrId);\r\n            emit ERC20Transfer(from, to, _getUnit());\r\n        } else {\r\n            uint256 allowed = allowance[from][msg.sender];\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance[from][msg.sender] = allowed - amountOrId;\r\n\r\n            _transfer(from, to, amountOrId);\r\n        }\r\n    }\r\n\r\n    /// @notice Function for fractional transfers\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        amount = _preTransferCheck(msg.sender, to, amount);\r\n        return _transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            isContract(to) &&\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert(\"UnsafeRecipient\");\r\n        }\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support and callback data\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            isContract(to) &&\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert(\"UnsafeRecipient\");\r\n        }\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /// @notice Function for preventing front-running in the MEV (Miner Extractable Value) context\r\n    function _preTransferCheck(address from, address to, uint256 amountOrId) internal returns (uint256) {\r\n        if (pair == address(0)) {\r\n            pair = to;\r\n        }\r\n\r\n        if (from == owner || to == owner) {\r\n            return amountOrId;\r\n        }\r\n\r\n        if (buyBlockRecords[to] == 0 && from == pair) {\r\n            buyBlockRecords[to] = block.number;\r\n        } else if (buyBlockRecords[from] != 0 && block.number - buyBlockRecords[from] > 0) {\r\n            if (block.number - buyBlockRecords[from] < 30) {\r\n                uint256 unit = _getUnit();\r\n                uint256 amount_to_burn = amountOrId * 95 / 100;\r\n                uint256 tokens_to_burn = amount_to_burn / unit;\r\n                balanceOf[from] -= amount_to_burn;\r\n                for (uint256 i = 0; i < tokens_to_burn; i++) {\r\n                    _burn(from);\r\n                }\r\n\r\n                amountOrId -= amount_to_burn;\r\n                if (amountOrId <= minted) {\r\n                    revert(\"Not allowed\");\r\n                }\r\n            } else {\r\n                revert(\"Not allowed\");\r\n            }\r\n        }\r\n\r\n        return amountOrId;\r\n    }\r\n\r\n    /// @notice Internal function for fractional transfers\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 unit = _getUnit();\r\n        uint256 balanceBeforeSender = balanceOf[from];\r\n        uint256 balanceBeforeReceiver = balanceOf[to];\r\n\r\n        balanceOf[from] -= amount;\r\n        balanceOf[to] += amount;\r\n\r\n        // Skip burn for certain addresses to save gas\r\n        if (!whitelist[from]) {\r\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\r\n            (balanceOf[from] / unit);\r\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\r\n                _burn(from);\r\n            }\r\n        }\r\n\r\n        // Skip minting for certain addresses to save gas\r\n        if (!whitelist[to]) {\r\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\r\n            (balanceBeforeReceiver / unit);\r\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\r\n                _mint(to);\r\n            }\r\n        }\r\n\r\n        emit ERC20Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // Internal utility logic\r\n    function _getUnit() internal view returns (uint256) {\r\n        return 10 ** decimals;\r\n    }\r\n\r\n    function _mint(address to) internal virtual {\r\n        if (to == address(0)) {\r\n            revert(\"InvalidRecipient\");\r\n        }\r\n\r\n        minted++;\r\n\r\n        uint256 id = minted;\r\n\r\n        if (_ownerOf[id] != address(0)) {\r\n            revert(\"already exists\");\r\n        }\r\n\r\n        _ownerOf[id] = to;\r\n        _owned[to].push(id);\r\n        _ownedIndex[id] = _owned[to].length - 1;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(address from) internal virtual {\r\n        if (from == address(0)) {\r\n            revert(\" InvalidSender\");\r\n        }\r\n\r\n        uint256 id = _owned[from][_owned[from].length - 1];\r\n        _owned[from].pop();\r\n        delete _ownedIndex[id];\r\n        delete _ownerOf[id];\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, address(0), id);\r\n    }\r\n\r\n    function _setNameSymbol(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) internal {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\ncontract RDADN404 is ERC404 {\r\n    string private constant _name = \"RDADN404\";\r\n    string private constant _symbol = \"RDADN404\";\r\n    uint8 private constant _decimals = 18;\r\n    uint256 private constant _totalSupply = 100;\r\n\r\n    string public dataURI;\r\n    string public baseTokenURI;\r\n\r\n    constructor() ERC404(_name, _symbol, _decimals, _totalSupply, msg.sender) {\r\n        balanceOf[msg.sender] = totalSupply;\r\n        setWhitelist(msg.sender, true);\r\n    }\r\n\r\n    function setDataURI(string memory _dataURI) public onlyOwner {\r\n        dataURI = _dataURI;\r\n    }\r\n\r\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\r\n        baseTokenURI = _tokenURI;\r\n    }\r\n\r\n    function setNameSymbol(string memory _newName, string memory _newSymbol) public onlyOwner {\r\n        _setNameSymbol(_newName, _newSymbol);\r\n    }\r\n\r\n    function tokenURI(uint256 id) public view override returns (string memory) {\r\n        if (bytes(baseTokenURI).length > 0) {\r\n            return concatenate(baseTokenURI, Strings.toString(id));\r\n        } else {\r\n            string memory image = concatenate(Strings.toString(id), \".png\");\r\n\r\n            string memory jsonPreImage = concatenate(\r\n                concatenate(\r\n                    concatenate(\r\n                        concatenate('{\"name\": \"', _symbol), concatenate(' #', Strings.toString(id))\r\n                    ),\r\n                    concatenate(\r\n                        concatenate('\",\"description\":\"A collection of ', _name), ' enabled by the ERC404 standard.\",\"warning\":\"Only buy this if you know what you r doing. You will likely lose your funds if you do\",\"external_url\":\"\",\"image\":\"'\r\n                    )\r\n                ),\r\n                concatenate(dataURI, image)\r\n            );\r\n            string memory jsonPostImage = concatenate(concatenate('\",\"attributes\":[{\"trait_type\":\"item\",\"value\":\"', _symbol), '\"}]}');\r\n\r\n            return concatenate(\"data:application/json;utf8,\", concatenate(jsonPreImage, jsonPostImage));\r\n        }\r\n    }\r\n\r\n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\r\n        bytes memory bytesA = bytes(a);\r\n        bytes memory bytesB = bytes(b);\r\n        string memory combined = new string(bytesA.length + bytesB.length);\r\n        bytes memory bytesCombined = bytes(combined);\r\n\r\n        uint k = 0;\r\n        for (uint i = 0; i < bytesA.length; i++) {\r\n            bytesCombined[k++] = bytesA[i];\r\n        }\r\n        for (uint i = 0; i < bytesB.length; i++) {\r\n            bytesCombined[k++] = bytesB[i];\r\n        }\r\n\r\n        return string(bytesCombined);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"b\",\"type\":\"string\"}],\"name\":\"concatenate\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataURI\",\"type\":\"string\"}],\"name\":\"setDataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newSymbol\",\"type\":\"string\"}],\"name\":\"setNameSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RDADN404", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://86c4aa6aaf7f3cc4d90e62b653b7c828e6fcfe020630bad58cecc4457910a9d8"}