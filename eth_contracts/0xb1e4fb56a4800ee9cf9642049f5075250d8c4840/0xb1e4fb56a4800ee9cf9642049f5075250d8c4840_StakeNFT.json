{"SourceCode": "// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: contracts/NFTStake/Stake.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ninterface INFTMinter {\r\n    function nftcallermint(address recipient, uint256 count)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\ncontract StakeNFT is Context, ReentrancyGuard {\r\n    struct ClaimInfo {\r\n        bool hasClaimedNFT;\r\n        bool hasRefundedETH;\r\n        uint256 refundAmount;\r\n        uint256 transferAmount;\r\n        uint256 nftCount;\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 id;\r\n        address staker;\r\n        uint256 price;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    event StakeEV(\r\n        address indexed staker,\r\n        uint256 indexed id,\r\n        uint256 indexed timestamp,\r\n        uint256 price\r\n    );\r\n    event Airdrop(\r\n        address indexed staker,\r\n        uint256 indexed nftAmount,\r\n        uint256 indexed transferAmount\r\n    );\r\n    event Refund(address indexed staker, uint256 indexed refundAmount);\r\n    event RaffleWon(uint256 indexed winner);\r\n\r\n    address public immutable manager; /// The address of the contract manager.\r\n    address public nftAddress; ///The address of the NFT contract.\r\n    address public revenueWallet; ///The address of the wallet where revenue from NFT mints will be sent.\r\n    uint256 public allstakeStart; ///The start time of the staking period.\r\n    uint256 public allstakeEnd; ///The end time of the staking period.\r\n    uint256 public GTDStart; ///The start time of the GTD whitelist staking period.\r\n    uint256 public GTDEnd; ///The end time of the GTD whitelist staking period.\r\n    uint256 public BackupEnd; ///The end time of the backup staking period.\r\n    uint256 public revealRaffle; /// The time when the raffle will be revealed.\r\n    uint256 public refundTime; /// The time when the user to airdrop/refund.\r\n    uint256 private _counter;\r\n    uint256 private immutable _ExtendAllstakeEnd;\r\n    uint256 private immutable _ExtendGTDEnd;\r\n    uint256 private immutable _ExtendBackupEnd;\r\n    uint256 private immutable _ExtendRaffleEnd;\r\n    uint256 private immutable _ExtendRefundTime;\r\n    uint256 public immutable raffleCount; ///The number of NFTs that will be awarded to stakers during the raffle.\r\n    uint256 public remainRaffleCount; ///The number of NFTs that will be awarded to stakers during the raffle.\r\n    uint256 public avaWLCount; ///The number of NFTs that are available for Backup staking.\r\n    uint256 public constant WHITESTAKEPRICE = 0.3 ether;\r\n    uint256 public constant PUBLICSTAKEPRICE = 0.4 ether;\r\n    uint256 public constant ONEDAY = 1 days;\r\n    uint256 private executeNumber;\r\n    uint256 private seedsInitialized;\r\n    string public seeds;\r\n    address[] public stakes;\r\n    uint256[] private _publicStakesId; ///The array of staking ids in the allstakeStart~allstakeEnd period.\r\n    uint256[] private _whiteStakesId; ///The array of staking ids in the GTDStart~BackupEnd period.\r\n\r\n    mapping(address => bool) private _inStakes; ///Maps sender to whether he is in the staking array or not.\r\n    mapping(address => uint256[]) private _userStakes; ///Maps stakers to their all staking IDs.\r\n    mapping(uint256 => Stake) public stakeIdInfo; ///Maps staking IDs to their staking information.\r\n    mapping(address => bool) public hasClaimedNFT; ///Maps stakers to whether they have claimed their NFTs or not.\r\n    mapping(address => bool) public hasRefundedETH; ///Maps stakers to whether they have received a refund or not.\r\n    mapping(uint256 => bool) public raffleWon; ///Maps staking IDs to whether they have won the raffle or not.\r\n    mapping(address => bool) public GTDAddress; ///Maps sender to whether they are GTD whitelisted or not.\r\n    mapping(address => uint256) public GTDTickets; ///Maps GTD whitelisted sender to their allowed staking number.\r\n    mapping(address => bool) public BackupAddress; ///Maps sender to whether they are Backup whitelisted or not.\r\n    mapping(address => bool) public BackupStaked; ///Maps Backup whitelisted sender to whether they have staked or not.\r\n\r\n    constructor(\r\n        address _manager,\r\n        address _nftAddress,\r\n        address _revenueWallet,\r\n        uint256 _raffleCount,\r\n        uint256 _avaWLCount,\r\n        uint256 _allstakeStart,\r\n        uint256 _allstakeEnd,\r\n        uint256 _GTDStart,\r\n        uint256 _GTDEnd,\r\n        uint256 _BackupEnd,\r\n        uint256 _revealRaffle,\r\n        uint256 _refundTime\r\n    ) {\r\n        require(\r\n            _allstakeEnd >= _allstakeStart,\r\n            \"allstakeStart less than allstakeEnd\"\r\n        );\r\n        require(_GTDEnd >= _GTDStart, \"GTDEnd less than GTDStart\");\r\n        require(_BackupEnd >= _GTDEnd, \"BackupEnd less than GTDEnd\");\r\n        require(\r\n            _revealRaffle >= _BackupEnd,\r\n            \"revealRaffle less than BackupEnd\"\r\n        );\r\n        require(\r\n            _refundTime >= _revealRaffle,\r\n            \"refundTime less than revealRaffle\"\r\n        );\r\n        require(_manager != address(0), \"invalid _manager address\");\r\n        require(_nftAddress != address(0), \"invalid _nftAddress address\");\r\n        require(_revenueWallet != address(0), \"invalid _revenueWallet address\");\r\n        manager = _manager;\r\n        nftAddress = _nftAddress;\r\n        revenueWallet = _revenueWallet;\r\n        raffleCount = _raffleCount;\r\n        remainRaffleCount = raffleCount;\r\n        avaWLCount = _avaWLCount;\r\n        allstakeStart = _allstakeStart;\r\n        allstakeEnd = _allstakeEnd;\r\n        _ExtendAllstakeEnd = ONEDAY + allstakeEnd;\r\n        GTDStart = _GTDStart;\r\n        GTDEnd = _GTDEnd;\r\n        _ExtendGTDEnd = ONEDAY + GTDEnd;\r\n        BackupEnd = _BackupEnd;\r\n        _ExtendBackupEnd = ONEDAY + BackupEnd;\r\n        revealRaffle = _revealRaffle;\r\n        _ExtendRaffleEnd = ONEDAY + revealRaffle;\r\n        refundTime = _refundTime;\r\n        _ExtendRefundTime = refundTime + refundTime;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(_msgSender() == manager, \"ONLY_MANAGER_ROLE\");\r\n        _;\r\n    }\r\n\r\n    /// @notice  update revenueWallet.\r\n    function setRevenueWallet(address addr) external onlyManager {\r\n        require(addr != address(0), \"invalid address\");\r\n        revenueWallet = addr;\r\n    }\r\n\r\n    /// @notice  update nftAddress.\r\n    function setNftAddress(address addr) external onlyManager {\r\n        require(addr != address(0), \"invalid address\");\r\n        require(block.timestamp <= refundTime, \"Staking end\");\r\n        nftAddress = addr;\r\n    }\r\n\r\n    /// @notice  update allstakeEnd.\r\n    function setAllEndTime(uint256 time) external onlyManager {\r\n        require(time <= _ExtendAllstakeEnd, \"exceed maximum period\");\r\n        require(time >= allstakeStart, \"must more than allstakeStart time\");\r\n        allstakeEnd = time;\r\n    }\r\n\r\n    /// @notice  update GTDEnd.\r\n    function setGTDEndTime(uint256 time) external onlyManager {\r\n        require(time <= _ExtendGTDEnd, \"exceed maximum period\");\r\n        require(time >= GTDStart, \"must more than GTDStart time\");\r\n        GTDEnd = time;\r\n    }\r\n\r\n    /// @notice  update BackupEnd.\r\n    function setBackupEndTime(uint256 time) external onlyManager {\r\n        require(time <= _ExtendBackupEnd, \"exceed maximum period\");\r\n        require(time >= GTDEnd, \"must more than GTDEnd time\");\r\n        BackupEnd = time;\r\n    }\r\n\r\n    /// @notice  update revealRaffle.\r\n    function setRaffleTime(uint256 time) external onlyManager {\r\n        require(time <= _ExtendRaffleEnd, \"exceed maximum period\");\r\n        require(time >= BackupEnd, \"must more than BackupEnd time\");\r\n        revealRaffle = time;\r\n    }\r\n\r\n    /// @notice  update refundTime.\r\n    function setOperationTime(uint256 time) external onlyManager {\r\n        require(time <= _ExtendRefundTime, \"exceed maximum period\");\r\n        require(time >= revealRaffle, \"must more than revealRaffle\");\r\n        refundTime = time;\r\n    }\r\n\r\n    /// @notice  set non-duplicated GTD whitelist address and their allowed staking tickets.\r\n    function setGTDlist(\r\n        address[] calldata GTDAddrs,\r\n        uint256[] calldata GTDTicks\r\n    ) external onlyManager {\r\n        uint256 GTDAddrLength = GTDAddrs.length;\r\n        uint256 GTDTickslength = GTDTicks.length;\r\n        require(GTDAddrLength == GTDTickslength, \"Mismatched length\");\r\n        address waddr;\r\n        uint256 ticket;\r\n        for (uint256 i = 0; i < GTDTickslength; i++) {\r\n            waddr = GTDAddrs[i];\r\n            ticket = GTDTicks[i];\r\n            GTDAddress[waddr] = true;\r\n            GTDTickets[waddr] = ticket;\r\n        }\r\n    }\r\n\r\n    /// @notice  set non-duplicated Backup whitelist address.\r\n    function setBackuplist(address[] calldata BackupAddrs)\r\n        external\r\n        onlyManager\r\n    {\r\n        address waddr;\r\n        uint256 length = BackupAddrs.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            waddr = BackupAddrs[i];\r\n            BackupAddress[waddr] = true;\r\n        }\r\n    }\r\n\r\n    /// @notice Allows users to stake ETH during a certain period of time.\r\n    function allStake() external payable {\r\n        require(\r\n            block.timestamp >= allstakeStart,\r\n            \"StakeNFT: public stake not start\"\r\n        );\r\n        require(block.timestamp <= allstakeEnd, \"StakeNFT: public stake ended\");\r\n        uint256 value = msg.value;\r\n        require(value != 0, \"StakeNFT: invalid staking value\");\r\n        require(\r\n            value % PUBLICSTAKEPRICE == 0,\r\n            \"StakeNFT: invalid staking value\"\r\n        );\r\n        uint256 tickets = value / PUBLICSTAKEPRICE;\r\n        for (uint256 i = 0; i < tickets; i++) {\r\n            uint256 newId = uint256(keccak256(abi.encodePacked(_counter)));\r\n            _counter += 1;\r\n            Stake memory newStake = Stake(\r\n                newId,\r\n                _msgSender(),\r\n                PUBLICSTAKEPRICE,\r\n                block.timestamp\r\n            );\r\n            _userStakes[_msgSender()].push(newId);\r\n            _publicStakesId.push(newId);\r\n            stakeIdInfo[newId] = newStake;\r\n            emit StakeEV(\r\n                _msgSender(),\r\n                newId,\r\n                block.timestamp,\r\n                PUBLICSTAKEPRICE\r\n            );\r\n        }\r\n        if (!_inStakes[_msgSender()]) {\r\n            _inStakes[_msgSender()] = true;\r\n            stakes.push(_msgSender());\r\n        }\r\n    }\r\n\r\n    /// @notice  Allows users who have been GTDwhitelisted to stake NFTs during a separate period of time.\r\n    function GTDStake() external payable {\r\n        require(block.timestamp >= GTDStart, \"StakeNFT: GTD not start\");\r\n        require(block.timestamp < GTDEnd, \"StakeNFT: GTD ended\");\r\n        require(GTDAddress[_msgSender()], \"StakeNFT: not GTD address\");\r\n        uint256 tickets = GTDTickets[_msgSender()];\r\n        require(tickets != 0, \"StakeNFT: no qualifications left\");\r\n        uint256 value = msg.value;\r\n        require(value != 0, \"StakeNFT: invalid staking value\");\r\n        require(\r\n            value % WHITESTAKEPRICE == 0,\r\n            \"StakeNFT: invalid staking value\"\r\n        );\r\n        require(\r\n            value <= tickets * WHITESTAKEPRICE,\r\n            \"StakeNFT: exceed maximum staking value\"\r\n        );\r\n\r\n        tickets = value / WHITESTAKEPRICE;\r\n        require(\r\n            tickets <= avaWLCount,\r\n            \"StakeNFT: exceed maximum left staking qualifications\"\r\n        );\r\n        avaWLCount -= tickets;\r\n        GTDTickets[_msgSender()] -= tickets;\r\n        for (uint256 i = 0; i < tickets; i++) {\r\n            uint256 newId = uint256(keccak256(abi.encodePacked(_counter)));\r\n            _counter += 1;\r\n            Stake memory newStake = Stake(\r\n                newId,\r\n                _msgSender(),\r\n                WHITESTAKEPRICE,\r\n                block.timestamp\r\n            );\r\n            _userStakes[_msgSender()].push(newId);\r\n            _whiteStakesId.push(newId);\r\n            stakeIdInfo[newId] = newStake;\r\n            emit StakeEV(_msgSender(), newId, block.timestamp, WHITESTAKEPRICE);\r\n        }\r\n        if (!_inStakes[_msgSender()]) {\r\n            _inStakes[_msgSender()] = true;\r\n            stakes.push(_msgSender());\r\n        }\r\n    }\r\n\r\n    /// @notice  Allows users who have been Backupwhitelisted to stake NFTs during a separate period of time.\r\n    function backupStake() external payable {\r\n        require(avaWLCount != 0, \"StakeNFT: no stake qualifications left\");\r\n        require(block.timestamp >= GTDEnd, \"StakeNFT: Backup not start\");\r\n        require(block.timestamp <= BackupEnd, \"StakeNFT: Backup ended\");\r\n        require(BackupAddress[_msgSender()], \"StakeNFT: not Backup address\");\r\n\r\n        uint256 value = msg.value;\r\n        require(value == WHITESTAKEPRICE, \"StakeNFT: invalid staking value\");\r\n        require(!BackupStaked[_msgSender()], \"StakeNFT: already staked\");\r\n        avaWLCount -= 1;\r\n        BackupStaked[_msgSender()] = true;\r\n\r\n        uint256 newId = uint256(keccak256(abi.encodePacked(_counter)));\r\n        _counter += 1;\r\n        Stake memory newStake = Stake(\r\n            newId,\r\n            _msgSender(),\r\n            WHITESTAKEPRICE,\r\n            block.timestamp\r\n        );\r\n        _userStakes[_msgSender()].push(newId);\r\n        _whiteStakesId.push(newId);\r\n        stakeIdInfo[newId] = newStake;\r\n        if (!_inStakes[_msgSender()]) {\r\n            _inStakes[_msgSender()] = true;\r\n            stakes.push(_msgSender());\r\n        }\r\n        emit StakeEV(_msgSender(), newId, block.timestamp, WHITESTAKEPRICE);\r\n    }\r\n\r\n    /// @notice  Input random seeds.\r\n    /// @param seed The random seed generated off-chain, which is a public and random info that could be verified anytime and anyone.\r\n    function raffleSeed(string memory seed) external onlyManager {\r\n        require(seedsInitialized == 0, \"seeds already initialized\");\r\n        require(\r\n            block.timestamp >= BackupEnd,\r\n            \"StakeNFT: raffle seeds not start\"\r\n        );\r\n        require(block.timestamp <= refundTime, \"StakeNFT: raffle seeds ended\");\r\n        seedsInitialized = 1;\r\n        seeds = seed;\r\n    }\r\n\r\n    /// @notice  Executes a raffle to determine which stakers win NFTs.\r\n    /// @param count The count determines how many stakes will be executed raffle in this loop condition.\r\n    function executeRaffle(uint256 count) external {\r\n        require(seedsInitialized == 1, \"seeds not initialized\");\r\n        uint256 length = _publicStakesId.length;\r\n        if (length <= raffleCount) {\r\n            uint256 ncount = executeNumber + count >= length\r\n                ? length\r\n                : executeNumber + count;\r\n            uint256 temp = executeNumber;\r\n            executeNumber = ncount;\r\n            for (uint256 i = temp; i < ncount; i++) {\r\n                uint256 stakeid = _publicStakesId[i];\r\n                raffleWon[stakeid] = true;\r\n                emit RaffleWon(stakeid);\r\n            }\r\n        } else {\r\n            if (count > remainRaffleCount) {\r\n                count = remainRaffleCount;\r\n            }\r\n            remainRaffleCount -= count;\r\n            for (uint256 i = 0; i < count; i++) {\r\n                executeNumber++;\r\n                uint256 index = uint256(\r\n                    keccak256(abi.encodePacked(seeds, executeNumber, i))\r\n                ) % length;\r\n                uint256 stakeid = _publicStakesId[index];\r\n                while (raffleWon[stakeid]) {\r\n                    index = index < length - 1 ? index + 1 : 0;\r\n                    stakeid = _publicStakesId[index];\r\n                }\r\n                raffleWon[stakeid] = true;\r\n                emit RaffleWon(stakeid);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice   Returns information about a staker's stake, including whether they have claimed their NFTs or received a refund\r\n    function claimInfo() external view returns (ClaimInfo memory info) {\r\n        info = claimInfo(_msgSender());\r\n    }\r\n\r\n    function claimInfo(address addr)\r\n        public\r\n        view\r\n        returns (ClaimInfo memory info)\r\n    {\r\n        if (block.timestamp < revealRaffle) {\r\n            return info;\r\n        }\r\n        info.hasRefundedETH = hasRefundedETH[addr];\r\n        info.hasClaimedNFT = hasClaimedNFT[addr];\r\n        info.refundAmount = 0;\r\n        info.nftCount = 0;\r\n        info.transferAmount = 0;\r\n        uint256[] memory stakedId = _userStakes[addr];\r\n        uint256 length = stakedId.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 stakeId = stakedId[i];\r\n            Stake memory stakeInfo = stakeIdInfo[stakeId];\r\n            uint256 stakedPrice = stakeInfo.price;\r\n            if (stakedPrice == WHITESTAKEPRICE || raffleWon[stakeId]) {\r\n                info.nftCount += 1;\r\n                info.transferAmount += stakedPrice;\r\n            } else {\r\n                info.refundAmount += stakedPrice;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice   Airdrop stakers NFTs if they have won the raffle.\r\n    /// @param start The start determines the start position of the stakers array in this loop condition.\r\n    /// @param count The count determines how many stakes will be airdroped in this loop condition.\r\n    function airdrop(uint256 start, uint256 count) external nonReentrant {\r\n        require(block.timestamp >= refundTime, \"StakeNFT: airdrop not start\");\r\n        uint256 length = stakes.length;\r\n        uint256 ncount = start + count >= length ? length : start + count;\r\n        for (uint256 j = start; j < ncount; j++) {\r\n            address staker = stakes[j];\r\n            ClaimInfo memory info = claimInfo(staker);\r\n            if (!info.hasClaimedNFT) {\r\n                hasClaimedNFT[staker] = true;\r\n                if (info.transferAmount != 0) {\r\n                    Address.sendValue(\r\n                        payable(revenueWallet),\r\n                        info.transferAmount\r\n                    );\r\n                }\r\n\r\n                if (info.nftCount != 0) {\r\n                    require(\r\n                        INFTMinter(nftAddress).nftcallermint(\r\n                            staker,\r\n                            info.nftCount\r\n                        ),\r\n                        \"nftcallermint failed\"\r\n                    );\r\n                }\r\n                emit Airdrop(staker, info.nftCount, info.transferAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice   Allows stakers to receive a refund if they have not won the raffle.\r\n    function refund() external nonReentrant {\r\n        require(block.timestamp >= refundTime, \"StakeNFT: refund not start\");\r\n        address staker = _msgSender();\r\n        ClaimInfo memory info = claimInfo(staker);\r\n\r\n        require(!info.hasRefundedETH, \"StakeNFT: has refunded\");\r\n        require(info.refundAmount > 0, \"StakeNFT: nothing to refund\");\r\n\r\n        hasRefundedETH[staker] = true;\r\n        Address.sendValue(payable(staker), info.refundAmount);\r\n\r\n        emit Refund(staker, info.refundAmount);\r\n    }\r\n\r\n    /**************** View Functions ****************/\r\n    function tvl() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getUserStakes(\r\n        address addr,\r\n        uint256 start,\r\n        uint256 count\r\n    ) external view returns (Stake[] memory stakesinfo) {\r\n        uint256[] memory stakeId = getUserTickets(addr, start, count);\r\n        uint256 length = stakeId.length;\r\n        stakesinfo = new Stake[](length);\r\n        for (uint256 j = 0; j < length; j++) {\r\n            uint256 id = stakeId[j];\r\n            stakesinfo[j] = stakeIdInfo[id];\r\n        }\r\n    }\r\n\r\n    function getUserTickets(\r\n        address addr,\r\n        uint256 start,\r\n        uint256 count\r\n    ) public view returns (uint256[] memory) {\r\n        uint256 length = _userStakes[addr].length;\r\n        uint256 ncount = start + count >= length ? length : start + count;\r\n        uint256 index;\r\n        uint256 arraylen = ncount - start;\r\n        uint256[] memory usertickets = new uint256[](arraylen);\r\n        for (uint256 j = start; j < ncount; j++) {\r\n            usertickets[index] = _userStakes[addr][j];\r\n            index++;\r\n        }\r\n        return usertickets;\r\n    }\r\n\r\n    function getWhiStakeIds() external view returns (uint256) {\r\n        return _whiteStakesId.length;\r\n    }\r\n\r\n    function getWhiStakeIdInfo() external view returns (uint256[] memory) {\r\n        return _whiteStakesId;\r\n    }\r\n\r\n    function getPubStakeIds() external view returns (uint256) {\r\n        return _publicStakesId.length;\r\n    }\r\n\r\n    function getPubStakeIdInfo() external view returns (uint256[] memory) {\r\n        return _publicStakesId;\r\n    }\r\n\r\n    function getRaffledId(uint256 start, uint256 count)\r\n        external\r\n        view\r\n        returns (uint256[] memory raffleIds)\r\n    {\r\n        if (block.timestamp < revealRaffle) {\r\n            return raffleIds;\r\n        }\r\n        uint256 length = _publicStakesId.length;\r\n        uint256 ncount = start + count >= length ? length : start + count;\r\n        uint256 counts = ncount - start;\r\n        uint256[] memory raffleId = new uint256[](counts);\r\n        uint256 index;\r\n\r\n        for (uint256 j = start; j < ncount; j++) {\r\n            uint256 stakeid = _publicStakesId[j];\r\n            if (raffleWon[stakeid]) {\r\n                raffleId[index] = stakeid;\r\n                index++;\r\n            }\r\n        }\r\n        return raffleId;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_revenueWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_raffleCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_avaWLCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allstakeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allstakeEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GTDStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GTDEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_BackupEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_revealRaffle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refundTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"}],\"name\":\"RaffleWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"StakeEV\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BackupAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BackupEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BackupStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GTDAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GTDEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GTDStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GTDStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GTDTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONEDAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLICSTAKEPRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITESTAKEPRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allstakeEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allstakeStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avaWLCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backupStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasClaimedNFT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasRefundedETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeNFT.ClaimInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasClaimedNFT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasRefundedETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeNFT.ClaimInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"executeRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPubStakeIdInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPubStakeIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getRaffledId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"raffleIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeNFT.Stake[]\",\"name\":\"stakesinfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getUserTickets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhiStakeIdInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhiStakeIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimedNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasRefundedETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"}],\"name\":\"raffleSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raffleWon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainRaffleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seeds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setAllEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setBackupEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"BackupAddrs\",\"type\":\"address[]\"}],\"name\":\"setBackuplist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setGTDEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"GTDAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"GTDTicks\",\"type\":\"uint256[]\"}],\"name\":\"setGTDlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNftAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setOperationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setRaffleTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRevenueWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeIdInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tvl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakeNFT", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000464868685f5ed7cc8260840a8a0e797f48b0dbd00000000000000000000000001d7fd49d1d46c7a6bea0502f63e66bac1a8830eb0000000000000000000000001e00cbb7fc2ee47a344dd87e631de2c2f4d4c40c00000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000004dd0000000000000000000000000000000000000000000000000000000066013d10000000000000000000000000000000000000000000000000000000006603e0100000000000000000000000000000000000000000000000000000000066040a4000000000000000000000000000000000000000000000000000000000660442800000000000000000000000000000000000000000000000000000000066047ac0000000000000000000000000000000000000000000000000000000006604dd300000000000000000000000000000000000000000000000000000000066053fa0", "EVMVersion": "paris", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f625bc06d901928f611eb76b78b84b0f4ef767956f2933994fcce7fd778d4d98"}