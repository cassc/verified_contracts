// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract Monsterra is
    Initializable,
    ContextUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC721Upgradeable,
    ERC721EnumerableUpgradeable,
    ERC721BurnableUpgradeable,
    ERC721PausableUpgradeable,
    UUPSUpgradeable
{
    using AddressUpgradeable for address;
    using StringsUpgradeable for uint256;

    enum Type {
        MONGEN,
        SOULCORE,
        LAND,
        PLOT,
        BOX
    }

    struct NFTdata {
        string data;
        Type nftType;
        uint256 mintTime;
    }

    struct NFTdto {
        uint256 tokenId;
        NFTdata nftData;
    }

    event Stake(uint256 indexed tokenId, Type nftType);
    event Burn(uint256 indexed tokenId, Type nftType);
    event MintBatch(address indexed from, uint256[] ids, string indexed nonce);

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant SERVER_ROLE = keccak256("SERVER_ROLE");

    uint256 private _tokenIdTracker;

    string private _baseTokenURI;

    mapping(uint256 => NFTdata) private _datas;
    mapping(uint256 => address) private _owners;

    uint256 private _blockingPeriod;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) public initializer {
        __Monsterra_init(name, symbol, baseTokenURI);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function __Monsterra_init(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __AccessControl_init_unchained();
        __AccessControlEnumerable_init_unchained();
        __ERC721_init_unchained(name, symbol);
        __ERC721Enumerable_init_unchained();
        __ERC721Burnable_init_unchained();
        __Pausable_init_unchained();
        __ERC721Pausable_init_unchained();
        __Monsterra_init_unchained(baseTokenURI);
        __UUPSUpgradeable_init();
    }

    function __Monsterra_init_unchained(string memory baseTokenURI)
        internal
        initializer
    {
        _baseTokenURI = baseTokenURI;
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    modifier adminGuard() {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),
            "Monsterra: must have admin role"
        );
        _;
    }

    modifier minterGuard() {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "Monsterra: must have minter role"
        );
        _;
    }

    modifier pauserGuard() {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            "Monsterra: must have pauser role"
        );
        _;
    }

    function transferAdmin(address _to) public adminGuard {
        _setupRole(DEFAULT_ADMIN_ROLE, _to);
        _setupRole(MINTER_ROLE, _to);
        _setupRole(PAUSER_ROLE, _to);
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function getCurrentTokenId() public view returns (uint256) {
        return _tokenIdTracker;
    }

    function getData(uint256 id) public view returns (NFTdata memory) {
        return (_datas[id]);
    }

    function addMinter(address _admin) public {
        super.grantRole(MINTER_ROLE, _admin);
    }

    function addServer(address _server) public adminGuard {
        super.grantRole(SERVER_ROLE, _server);
    }

    function removeServer(address _server) public adminGuard {
        super.revokeRole(SERVER_ROLE, _server);
    }

    function getOwnedToken(address owner)
        public
        view
        returns (NFTdto[] memory)
    {
        uint256 balance = super.balanceOf(owner);
        NFTdto[] memory result = new NFTdto[](balance);
        for (uint256 i = 0; i < balance; i++) {
            uint256 tokenId = tokenOfOwnerByIndex(owner, i);
            NFTdata memory nft = _datas[tokenId];
            result[i] = NFTdto(tokenOfOwnerByIndex(owner, i), nft);
        }
        return result;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 _tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(_tokenId),
            "Monsterra: URI query for nonexistent token"
        );

        string memory baseURI = _baseURI();
        return
            bytes(baseURI).length > 0
                ? string(abi.encodePacked(baseURI, _tokenId.toString()))
                : "";
    }

    function updateURI(string memory _uri) public adminGuard {
        _baseTokenURI = _uri;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function _mint(
        address _to,
        uint256 _id,
        string memory _data,
        Type _type
    ) private {
        if (_owners[_id] != address(0) && _to == _owners[_id]) {
            address ownerId = _owners[_id];
            delete _owners[_id];
            Monsterra(address(this)).transferFrom(address(this), ownerId, _id);
            return;
        }

        _mint(_to, _id);
        _datas[_id] = NFTdata(_data, _type, block.timestamp);
        if (_tokenIdTracker < _id) {
            _tokenIdTracker = _id;
        }
    }

    function mintBatch(address _to, uint256[] calldata _tokenIds, string[] calldata _dataArr, Type[] calldata _typeArr) external minterGuard {
        require(_dataArr.length == _typeArr.length, "Monsterra: all data arrays's length must be same");

        for (uint256 i = 0; i < _dataArr.length; i++) {
            _mint(_to, _tokenIds[i], _dataArr[i], _typeArr[i]);
        }
    }

    function mint(address _to, uint256 _tokenId, string calldata _data, Type _type) external minterGuard {
        require(_to != address(0), "invalid-address");
        _mint(_to, _tokenId, _data, _type);
    }

    function mintBatch(
        uint256[] calldata _tokenIds,
        string[] calldata _dataArr,
        Type[] calldata _typeArr,
        string calldata _nonce,
        uint256 _timestamp,
        bytes calldata _signature
    ) external {
        require(
            _tokenIds.length == _typeArr.length,
            "Monsterra: all data arrays's length must be same"
        );
        require(
            _dataArr.length == _typeArr.length,
            "Monsterra: all data arrays's length must be same"
        );

        _verify(_tokenIds, _nonce, _timestamp, _signature); 

        for (uint256 i = 0; i < _dataArr.length; i++) {
            _mint(_msgSender(), _tokenIds[i], _dataArr[i], _typeArr[i]);
        }
        emit MintBatch(_msgSender(), _tokenIds, _nonce);
    }

    function burn(uint256 _tokenId) public override {
        super.burn(_tokenId);
        emit Burn(_tokenId, _datas[_tokenId].nftType);
        delete _datas[_tokenId];
    }

    function burnBatch(uint256[] calldata _tokenIdArr) external {
        for (uint256 i = 0; i < _tokenIdArr.length; i++) {
            burn(_tokenIdArr[i]);
        }
    }

    function _stake(uint256 _tokenId) private {
        require(
            block.timestamp >= _datas[_tokenId].mintTime + _blockingPeriod,
            string(
                abi.encodePacked(
                    "Monsterra: required ",
                    _blockingPeriod,
                    "s after minted time to stake again"
                )
            )
        );
        transferFrom(_msgSender(), address(this), _tokenId);
        _owners[_tokenId] = _msgSender();
        emit Stake(_tokenId, _datas[_tokenId].nftType);
    }

    function stakeBatch(uint256[] calldata _tokenIdArr) external virtual {
        for (uint256 i = 0; i < _tokenIdArr.length; i++) {
            _stake(_tokenIdArr[i]);
        }
    }

    function getBlockingPeriod() public view adminGuard returns (uint256) {
        return _blockingPeriod;
    }

    function setBlockingPeriod(uint256 _seconds) public adminGuard {
        _blockingPeriod = _seconds;
    }

    function getUsedNonce(string calldata _nonce) public view returns (bool){
        return _usedNonces[_nonce];
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual pauserGuard {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual pauserGuard {
        _unpause();
    }

    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    )
        internal
        virtual
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            ERC721PausableUpgradeable
        )
    {
        super._beforeTokenTransfer(_from, _to, _tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 _interfaceId)
        public
        view
        virtual
        override(
            AccessControlEnumerableUpgradeable,
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable
        )
        returns (bool)
    {
        return super.supportsInterface(_interfaceId);
    }

    function _verify(
        uint256[] calldata _tokenIds,
        string calldata _nonce,
        uint256 _timestamp,
        bytes calldata _signature
    ) private {
        require(_timestamp + 60 *2  > block.timestamp,  "MonsterraStaking: signature expired");

        require(!_usedNonces[_nonce], "MonsterraStaking: nonce has been used");
        _usedNonces[_nonce] = true;

        bytes32 messageHash = keccak256(
            abi.encodePacked(_msgSender(), address(this), _tokenIds, _nonce, _timestamp)
        );
        bytes32 ethSignMessageHash = ECDSAUpgradeable.toEthSignedMessageHash(
            messageHash
        );
        address signer = ECDSAUpgradeable.recover(
            ethSignMessageHash,
            _signature
        );
        require(
            hasRole(SERVER_ROLE, signer),
            "MonsterraStaking: must have server signature"
        );
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        override
        adminGuard
    {
        // Do something here.
    }

    uint256[45] private __gap;
    mapping(string => bool) private _usedNonces;
}