{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/QUILMultiVoucherClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.26;\\n\\nimport {ISignatureMintERC20} from \\\"./ISignatureMintERC20.sol\\\";\\n\\n/// @title An optimized QUIL voucher claimer\\ncontract QUILMultiVoucherClaimer {\\n    ISignatureMintERC20 constant wQUIL = ISignatureMintERC20(0x8143182a775C54578c8B7b3Ef77982498866945D);\\n\\n    /// @notice Claim all of the claims embedded in `claims` or fail. All claims\\n    ///         are assumed to be signed by msg.sender.\\n    /// @param validityEndTimestamp Timestamp shared by all the claims.\\n    /// @param claims Packed bytes of a list of reduced claims.\\n    function claim(uint128 validityEndTimestamp, bytes calldata claims) external {\\n        ISignatureMintERC20.MintRequest memory mintRequest = ISignatureMintERC20.MintRequest({\\n            to: msg.sender,\\n            primarySaleRecipient: 0xE35F2aAE042640D56c50b3c1B90bAf7D59c7cACC,\\n            quantity: 5000000000,\\n            price: 0,\\n            currency: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,\\n            validityStartTimestamp: 0,\\n            validityEndTimestamp: validityEndTimestamp,\\n            uid: 0x0\\n        });\\n\\n        uint256 length = claims.length / 97;\\n        uint256 offset = 0;\\n        for (uint256 i = 0; i < length; i++) {\\n            // The list of claims is a packing of multiple uids and signatures in sequence.\\n            // > abi.encodePacked(  uid      ,  signature  ,\\n            //                      uid2     ,  signature2 ,\\n            //                      ...                    )\\n            // = abi.encodePacked(  bytes32  ,  65 bytes   ,\\n            //                      bytes32  ,  65 bytes   ,\\n            //                      ...                    )\\n\\n            uint256 endUid = offset + 32;\\n            mintRequest.uid = bytes32(claims[offset:endUid]);\\n\\n            offset += 97;\\n\\n            wQUIL.mintWithSignature(mintRequest, claims[endUid:offset]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ISignatureMintERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n *  The 'signature minting' mechanism used in thirdweb Token smart contracts is a way for a contract admin to authorize an external party's\\n *  request to mint tokens on the admin's contract.\\n *\\n *  At a high level, this means you can authorize some external party to mint tokens on your contract, and specify what exactly will be\\n *  minted by that external party.\\n */\\ninterface ISignatureMintERC20 {\\n    /**\\n     *  @notice The body of a request to mint tokens.\\n     *\\n     *  @param to The receiver of the tokens to mint.\\n     *  @param primarySaleRecipient The recipient of the minted token's primary sales proceeds.\\n     *  @param quantity The quantity of tokens to mint.\\n     *  @param pricePerToken The price to pay per quantity of tokens minted.\\n     *  @param currency The currency in which to pay the price per token minted.\\n     *  @param validityStartTimestamp The unix timestamp after which the payload is valid.\\n     *  @param validityEndTimestamp The unix timestamp at which the payload expires.\\n     *  @param uid A unique identifier for the payload.\\n     */\\n    struct MintRequest {\\n        address to;\\n        address primarySaleRecipient;\\n        uint256 quantity;\\n        uint256 price;\\n        address currency;\\n        uint128 validityStartTimestamp;\\n        uint128 validityEndTimestamp;\\n        bytes32 uid;\\n    }\\n\\n    /// @dev Emitted when tokens are minted.\\n    event TokensMintedWithSignature(address indexed signer, address indexed mintedTo, MintRequest mintRequest);\\n\\n    /**\\n     *  @notice Verifies that a mint request is signed by an account holding\\n     *          MINTER_ROLE (at the time of the function call).\\n     *\\n     *  @param req The payload / mint request.\\n     *  @param signature The signature produced by an account signing the mint request.\\n     *\\n     *  returns (success, signer) Result of verification and the recovered address.\\n     */\\n    function verify(MintRequest calldata req, bytes calldata signature)\\n        external\\n        view\\n        returns (bool success, address signer);\\n\\n    /**\\n     *  @notice Mints tokens according to the provided mint request.\\n     *\\n     *  @param req The payload / mint request.\\n     *  @param signature The signature produced by an account signing the mint request.\\n     */\\n    function mintWithSignature(MintRequest calldata req, bytes calldata signature)\\n        external\\n        payable\\n        returns (address signer);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"validityEndTimestamp\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"claims\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "QUILMultiVoucherClaimer", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}