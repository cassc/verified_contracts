{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CurveDepositFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"Clones.sol\\\";\\nimport \\\"PrismaOwnable.sol\\\";\\nimport \\\"ICurveProxy.sol\\\";\\n\\ninterface ICurveDepositToken {\\n    function initialize(address _gauge) external;\\n\\n    function lpToken() external view returns (address);\\n\\n    function gauge() external view returns (address);\\n}\\n\\n/**\\n    @notice Prisma Curve Factory\\n    @title Deploys clones of `CurveDepositToken` as directed by the Prisma DAO\\n */\\ncontract CurveFactory is PrismaOwnable {\\n    using Clones for address;\\n\\n    ICurveProxy public immutable curveProxy;\\n    address public depositTokenImpl;\\n\\n    mapping(address gauge => address depositToken) public getDepositToken;\\n\\n    event NewDeployment(address depositToken, address lpToken, address gauge);\\n    event ImplementationSet(address depositTokenImpl);\\n\\n    constructor(\\n        address _prismaCore,\\n        ICurveProxy _curveProxy,\\n        address _depositTokenImpl,\\n        address[] memory _existingDeployments\\n    ) PrismaOwnable(_prismaCore) {\\n        curveProxy = _curveProxy;\\n        depositTokenImpl = _depositTokenImpl;\\n        emit ImplementationSet(_depositTokenImpl);\\n\\n        for (uint i = 0; i < _existingDeployments.length; i++) {\\n            address depositToken = _existingDeployments[i];\\n            address lpToken = ICurveDepositToken(depositToken).lpToken();\\n            address gauge = ICurveDepositToken(depositToken).gauge();\\n            getDepositToken[gauge] = depositToken;\\n            emit NewDeployment(depositToken, lpToken, gauge);\\n        }\\n    }\\n\\n    /**\\n        @dev After calling this function, the owner should also call `Vault.registerReceiver`\\n             to enable PRISMA emissions on the newly deployed `CurveDepositToken`\\n     */\\n    function deployNewInstance(address gauge) external onlyOwner {\\n        // no duplicate deployments because deposits and rewards must route via `CurveProxy`\\n        require(getDepositToken[gauge] == address(0), \\\"Deposit token already deployed\\\");\\n        address depositToken = depositTokenImpl.cloneDeterministic(bytes32(bytes20(gauge)));\\n\\n        curveProxy.setPerGaugeApproval(depositToken, gauge);\\n        ICurveDepositToken(depositToken).initialize(gauge);\\n        getDepositToken[gauge] = depositToken;\\n\\n        emit NewDeployment(depositToken, ICurveDepositToken(depositToken).lpToken(), gauge);\\n    }\\n\\n    function getDeterministicAddress(address gauge) external view returns (address) {\\n        return Clones.predictDeterministicAddress(depositTokenImpl, bytes32(bytes20(gauge)));\\n    }\\n\\n    function setImplementation(address impl) external onlyOwner {\\n        depositTokenImpl = impl;\\n        emit ImplementationSet(impl);\\n    }\\n}\\n\"\r\n    },\r\n    \"Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"PrismaOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"IPrismaCore.sol\\\";\\n\\n/**\\n    @title Prisma Ownable\\n    @notice Contracts inheriting `PrismaOwnable` have the same owner as `PrismaCore`.\\n            The ownership cannot be independently modified or renounced.\\n */\\ncontract PrismaOwnable {\\n    IPrismaCore public immutable PRISMA_CORE;\\n\\n    constructor(address _prismaCore) {\\n        PRISMA_CORE = IPrismaCore(_prismaCore);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == PRISMA_CORE.owner(), \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return PRISMA_CORE.owner();\\n    }\\n\\n    function guardian() public view returns (address) {\\n        return PRISMA_CORE.guardian();\\n    }\\n}\\n\"\r\n    },\r\n    \"IPrismaCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPrismaCore {\\n    event FeeReceiverSet(address feeReceiver);\\n    event GuardianSet(address guardian);\\n    event NewOwnerAccepted(address oldOwner, address owner);\\n    event NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);\\n    event NewOwnerRevoked(address owner, address revokedOwner);\\n    event Paused();\\n    event PriceFeedSet(address priceFeed);\\n    event Unpaused();\\n\\n    function acceptTransferOwnership() external;\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function revokeTransferOwnership() external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setGuardian(address _guardian) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPriceFeed(address _priceFeed) external;\\n\\n    function OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);\\n\\n    function feeReceiver() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function ownershipTransferDeadline() external view returns (uint256);\\n\\n    function paused() external view returns (bool);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function startTime() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"ICurveProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ICurveProxy {\\n    struct GaugeWeightVote {\\n        address gauge;\\n        uint256 weight;\\n    }\\n\\n    struct TokenBalance {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    event CrvFeePctSet(uint256 feePct);\\n\\n    function approveGaugeDeposit(address gauge, address depositor) external returns (bool);\\n\\n    function claimFees() external returns (uint256);\\n\\n    function execute(address target, bytes calldata data) external returns (bytes memory);\\n\\n    function lockCRV() external returns (bool);\\n\\n    function mintCRV(address gauge, address receiver) external returns (uint256);\\n\\n    function setCrvFeePct(uint64 _feePct) external returns (bool);\\n\\n    function setDepositManager(address _depositManager) external returns (bool);\\n\\n    function setExecutePermissions(\\n        address caller,\\n        address target,\\n        bytes4[] calldata selectors,\\n        bool permitted\\n    ) external returns (bool);\\n\\n    function setGaugeRewardsReceiver(address gauge, address receiver) external returns (bool);\\n\\n    function setPerGaugeApproval(address caller, address gauge) external returns (bool);\\n\\n    function setVoteManager(address _voteManager) external returns (bool);\\n\\n    function transferTokens(address receiver, TokenBalance[] calldata balances) external returns (bool);\\n\\n    function voteForGaugeWeights(GaugeWeightVote[] calldata votes) external returns (bool);\\n\\n    function voteInCurveDao(address aragon, uint256 id, bool support) external returns (bool);\\n\\n    function withdrawFromGauge(\\n        address gauge,\\n        address lpToken,\\n        uint256 amount,\\n        address receiver\\n    ) external returns (bool);\\n\\n    function CRV() external view returns (address);\\n\\n    function PRISMA_CORE() external view returns (address);\\n\\n    function crvFeePct() external view returns (uint64);\\n\\n    function depositManager() external view returns (address);\\n\\n    function feeDistributor() external view returns (address);\\n\\n    function feeToken() external view returns (address);\\n\\n    function gaugeController() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function minter() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function perGaugeApproval(address caller) external view returns (address gauge);\\n\\n    function unlockTime() external view returns (uint64);\\n\\n    function voteManager() external view returns (address);\\n\\n    function votingEscrow() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CurveDepositFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_prismaCore\",\"type\":\"address\"},{\"internalType\":\"contract ICurveProxy\",\"name\":\"_curveProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositTokenImpl\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_existingDeployments\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositTokenImpl\",\"type\":\"address\"}],\"name\":\"ImplementationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"NewDeployment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRISMA_CORE\",\"outputs\":[{\"internalType\":\"contract IPrismaCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveProxy\",\"outputs\":[{\"internalType\":\"contract ICurveProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"deployNewInstance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositTokenImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getDepositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getDeterministicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CurveFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005d17ea085f2ff5da3e6979d5d26f1dbab664ccf8000000000000000000000000490b8c6007ffa5d3728a49c2ee199e51f05d2f7e000000000000000000000000dc6932c4084e6fbb3c9a57920da512e12dd52498000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000005f8d4319c27a940b5783b4495cca6626e880532e00000000000000000000000071ad6c1d92546065b13bf701a7524c69b409e25c0000000000000000000000006d3cd0dd2c05fa4eb8d1159159bef445593a93fc", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}