{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RangoCometIntermediary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n// Interface for Rango Receiver contract\\ninterface IRangoMessageReceiver {\\n  enum ProcessStatus {\\n    SUCCESS,\\n    REFUND_IN_SOURCE,\\n    REFUND_IN_DESTINATION\\n  }\\n\\n  function handleRangoMessage(\\n    address token,\\n    uint amount,\\n    ProcessStatus status,\\n    bytes memory message\\n  ) external;\\n}\\n\\n// Interface for compound WETH contract\\n// https://github.com/compound-finance/comet/blob/main/contracts/IWETH9.sol\\ninterface IWETH9 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint wad) external;\\n\\n  function approve(address guy, uint wad) external returns (bool);\\n}\\n\\n// Interface for Compound Comet contract\\n// https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol\\n// https://github.com/compound-finance/comet/blob/main/contracts/CometExt.sol\\ninterface IComet {\\n  /**\\n   * @notice Supply an amount of asset to dst\\n   * @param dst The address which will hold the balance\\n   * @param asset The asset to supply\\n   * @param amount The quantity to supply\\n   */\\n  function supplyTo(address dst, address asset, uint amount) external;\\n\\n  /**\\n   * @notice Withdraw an amount of asset from src to `to`, if allowed\\n   * @param src The sender address\\n   * @param to The recipient address\\n   * @param asset The asset to withdraw\\n   * @param amount The quantity to withdraw\\n   */\\n  function withdrawFrom(\\n    address src,\\n    address to,\\n    address asset,\\n    uint amount\\n  ) external;\\n}\\n\\ncontract RangoCometIntermediary is ReentrancyGuard, IRangoMessageReceiver {\\n  /* Type & Enum declarations */\\n  struct RangoCometMessageParams {\\n    address userAddress;\\n    address cometAddress;\\n  }\\n\\n  /* State variables */\\n  // address for use instead of Ether address\\n  address private constant ETHER_ADDRESS = address(0);\\n\\n  // WETH contract used by comet\\n  address private s_weth;\\n\\n  // owner (admin) of the contract\\n  address private s_owner;\\n\\n  // address of Rango Contract\\n  address[] private s_rango;\\n\\n  /* Events */\\n  event SuppliedTo(\\n    address onBehalfOf,\\n    address comet,\\n    address token,\\n    uint256 amount\\n  );\\n  event SupplyFailed(\\n    address onBehalfOf,\\n    address comet,\\n    address token,\\n    uint256 amount,\\n    string reason\\n  );\\n  event WithdrawAndSupplyTo(\\n    address onBehalfOf,\\n    address comet,\\n    address token,\\n    uint256 amount\\n  );\\n  event OwnerChanged(address prevOwner, address newOwner);\\n  event RangoAddressAdded(address rangoAddress);\\n  event RangoAddressRemoved(address rangoAddress);\\n\\n  /* Modifiers */\\n  /**\\n   * @notice A modifier which indicates that a function can be only called by owner\\n   */\\n  modifier onlyOwner() {\\n    if (msg.sender != s_owner) revert(\\\"RangoCometIntermediary__NotOwner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice A modifier which indicates that a function can be only called by Rango contract addresses\\n   */\\n  modifier onlyRango() {\\n    bool found = false;\\n    for (uint256 i = 0; i < s_rango.length; i++) {\\n      if (s_rango[i] == msg.sender) {\\n        found = true;\\n        break;\\n      }\\n    }\\n    if (!found) {\\n      revert(\\\"RangoCometIntermediary__NotRango\\\");\\n    }\\n    _;\\n  }\\n\\n  /* Constructor */\\n  constructor() {\\n    s_owner = msg.sender;\\n    s_weth = address(0);\\n  }\\n\\n  /* Owner functions */\\n  function setWeth(address wethAddress) external onlyOwner {\\n    s_weth = wethAddress;\\n  }\\n\\n  /**\\n   * @notice Owner must be able to add a contract to rango list\\n   * @param rangoContractAddress the contract address which should be added to rango contracts list\\n   */\\n  function addRangoContract(address rangoContractAddress) external onlyOwner {\\n    s_rango.push(rangoContractAddress);\\n    emit RangoAddressAdded(rangoContractAddress);\\n  }\\n\\n  function addRangoContracts(\\n    address[] memory rangoContractAddresses\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i < rangoContractAddresses.length; i++) {\\n      s_rango.push(rangoContractAddresses[i]);\\n      emit RangoAddressAdded(rangoContractAddresses[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Owner must be able to remove a contract from rango list\\n   * @param rangoContractAddress the contract address which should be removed from rango contracts list\\n   */\\n  function removeRangoContract(\\n    address rangoContractAddress\\n  ) external onlyOwner {\\n    uint256 index = s_rango.length + 1;\\n    for (uint256 i = 0; i < s_rango.length; i++) {\\n      if (s_rango[i] == rangoContractAddress) {\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index < s_rango.length) {\\n      s_rango[index] = s_rango[s_rango.length - 1];\\n      s_rango.pop();\\n      emit RangoAddressRemoved(rangoContractAddress);\\n    } else {\\n      revert(\\\"RangoCometIntermediary__RangoContractAddressNotFound\\\");\\n    }\\n  }\\n\\n  /**\\n   * @notice In case anything bad happens and token gets stuck in intermediary contract, owner should be able to refund it to user\\n   * @param token the token which should be refunded, address(0) for native token\\n   * @param amount the amount of token that needs to be refunded\\n   * @param user the user that must be receiving the refund\\n   */\\n  function refund(\\n    address token,\\n    uint256 amount,\\n    address user\\n  ) external onlyOwner {\\n    TransferHelper.safeTransfer(token, user, amount, true);\\n  }\\n\\n  /**\\n   * @notice Owner must be able to transfer ownership to another address, for example a multi-sig/contract for future governance\\n   * @param newOwner The new owner which should be able to manage intermediary contract\\n   */\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    address prevOwner = s_owner;\\n    s_owner = newOwner;\\n    emit OwnerChanged(prevOwner, newOwner);\\n  }\\n\\n  /* Rango functions */\\n  /**\\n   * @dev This function should not revert in any case, since it might result in tokens getting stuck in contract. In any case, we have a refund function to handle such scenarios.\\n   * @notice Rango supplies token into the Comet\\n   * @param token The token which is provided by Rango, for native Eth, token is equal to address(0)\\n   * @param amount The amount of token which is provided by Rango\\n   */\\n  function handleRangoMessage(\\n    address token,\\n    uint256 amount,\\n    ProcessStatus status,\\n    bytes memory message\\n  ) external onlyRango nonReentrant {\\n    RangoCometMessageParams memory decodedMessage = abi.decode(\\n      message,\\n      (RangoCometMessageParams)\\n    );\\n\\n    if (status != ProcessStatus.SUCCESS) {\\n      TransferHelper.safeTransfer(\\n        token,\\n        decodedMessage.userAddress,\\n        amount,\\n        false\\n      );\\n      return;\\n    }\\n\\n    // if token is native, change it to weth and consider weth as final token\\n    address finalToken = token;\\n    if (token == ETHER_ADDRESS) {\\n      if (s_weth == address(0)) {\\n        revert(\\\"RangoCometIntermediary__WethAddressNotFound\\\");\\n      }\\n      IWETH9 weth = IWETH9(s_weth);\\n      weth.deposit{value: amount}();\\n      finalToken = s_weth;\\n    }\\n    // approve comet on final token\\n    bool cometApproveSuccess = TransferHelper.safeApprove(\\n      finalToken,\\n      decodedMessage.cometAddress,\\n      amount,\\n      false\\n    );\\n    if (!cometApproveSuccess) {\\n      // if unable to approve comet on token, trnasfer token to user\\n      TransferHelper.safeTransfer(\\n        finalToken,\\n        decodedMessage.userAddress,\\n        amount,\\n        false\\n      );\\n      return;\\n    }\\n    // supply to comet\\n    IComet comet = IComet(decodedMessage.cometAddress);\\n    bool supplySuccess = true;\\n    string memory supplyError = \\\"\\\";\\n    try comet.supplyTo(decodedMessage.userAddress, finalToken, amount) {\\n      emit SuppliedTo(\\n        decodedMessage.userAddress,\\n        decodedMessage.cometAddress,\\n        token,\\n        amount\\n      );\\n    } catch Error(string memory reason) {\\n      // catch failing revert() and require()\\n      supplySuccess = false;\\n      supplyError = reason;\\n    } catch {\\n      // catch failing assert() or other\\n      supplySuccess = false;\\n    }\\n    if (supplySuccess == false) {\\n      // if unable to supply on comet, transfer funds to user\\n      TransferHelper.safeTransferToken(\\n        finalToken,\\n        decodedMessage.userAddress,\\n        amount,\\n        false\\n      );\\n      // then remove approval on token for comet\\n      TransferHelper.safeApprove(\\n        finalToken,\\n        decodedMessage.cometAddress,\\n        0,\\n        false\\n      );\\n      emit SupplyFailed(\\n        decodedMessage.userAddress,\\n        decodedMessage.cometAddress,\\n        token,\\n        amount,\\n        supplyError\\n      );\\n    }\\n  }\\n\\n  /* User/Public functions */\\n  /**\\n   * @notice Users must be able to withdraw funds from a Comet instance on 1 chain, then bridge and supply it to another comet instance on another chain\\n   * @param sourceComet The comet contract on source blockchain which the fund must be withdrawn from\\n   * @param sourceToken The token contract on source blockchain which is the underlying asset of comet, address(0) for native token\\n   * @param sourceRango The rango contract on source blockchain which should receive the funds withdrawn from comet, it should be the included in s_rango addresses list\\n   * @param amount The amount of token which should be withdrawn from comet and sent to rango as input\\n   * @param rangoData The calldata created by Rango for cross-chain transfer\\n   */\\n  function withdrawAndCrosschainSupply(\\n    address sourceComet,\\n    address sourceToken,\\n    address sourceRango,\\n    uint256 amount,\\n    bytes calldata rangoData\\n  ) external nonReentrant {\\n    IComet comet = IComet(sourceComet);\\n    if (sourceToken == ETHER_ADDRESS) {\\n      revert(\\\"RangoCometIntermediary__InvalidSourceToken\\\");\\n    }\\n    comet.withdrawFrom(msg.sender, address(this), sourceToken, amount);\\n\\n    bool foundRango = false;\\n    for (uint256 i = 0; i < s_rango.length; i++) {\\n      if (s_rango[i] == sourceRango) {\\n        foundRango = true;\\n        break;\\n      }\\n    }\\n    if (!foundRango) {\\n      revert(\\\"RangoCometIntermediary__InvalidRangoContract\\\");\\n    }\\n\\n    bool success = TransferHelper.safeApprove(\\n      sourceToken,\\n      sourceRango,\\n      amount,\\n      false\\n    );\\n    // call rango if approve was successful\\n    if (success == true) {\\n      (success, ) = sourceRango.call(rangoData);\\n    }\\n\\n    if (success == false) {\\n      // revert transaction if rango approve or rango call failed\\n      revert(\\\"RangoCometIntermediary__RangoCrosschainCallFailed\\\");\\n    }\\n\\n    emit WithdrawAndSupplyTo(msg.sender, sourceComet, sourceToken, amount);\\n  }\\n\\n  /** receive and fallback */\\n  receive() external payable {\\n    // no receive logic yet\\n  }\\n\\n  fallback() external payable {\\n    // no fallback logic yet\\n  }\\n\\n  /** Getter Functions */\\n  /**\\n   * @notice Returns the owner of blockchain\\n   */\\n  function getOwner() public view returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice Returns the address index in s_rango address list\\n   */\\n  function getRango(uint index) public view returns (address) {\\n    return s_rango[index];\\n  }\\n\\n  /**\\n   * @notice Returns the length of s_rango address list\\n   */\\n  function getRangoLength() public view returns (uint256) {\\n    return s_rango.length;\\n  }\\n\\n  /**\\n   * @notice Returns the weth token address on this chain\\n   */\\n  function getWeth() public view returns (address) {\\n    return s_weth;\\n  }\\n}\\n\\n// TransferHelper library from UniSwapV2\\nlibrary TransferHelper {\\n  function safeApprove(\\n    address token,\\n    address to,\\n    uint256 value,\\n    bool raiseError\\n  ) internal returns (bool) {\\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(\\n      abi.encodeWithSelector(0x095ea7b3, to, value)\\n    );\\n    bool hasError = !(success &&\\n      (data.length == 0 || abi.decode(data, (bool))));\\n    if (hasError && raiseError) {\\n      revert(\\\"TransferHelper__ApproveFailed\\\");\\n    }\\n    return !hasError;\\n  }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint256 value,\\n    bool raiseError\\n  ) internal returns (bool) {\\n    if (token == address(0)) {\\n      return TransferHelper.safeTransferETH(payable(to), value, raiseError);\\n    } else {\\n      return TransferHelper.safeTransferToken(token, to, value, raiseError);\\n    }\\n  }\\n\\n  function safeTransferToken(\\n    address token,\\n    address to,\\n    uint256 value,\\n    bool raiseError\\n  ) internal returns (bool) {\\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(\\n      abi.encodeWithSelector(0xa9059cbb, to, value)\\n    );\\n    bool hasError = !(success &&\\n      (data.length == 0 || abi.decode(data, (bool))));\\n    if (hasError && raiseError) {\\n      revert(\\\"TransferHelper__TransferFailed\\\");\\n    }\\n    return !hasError;\\n  }\\n\\n  function safeTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bool raiseError\\n  ) internal returns (bool) {\\n    // bytes4(keccak256(bytes(' (address,address,uint256)')));\\n    (bool success, bytes memory data) = token.call(\\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\\n    );\\n    bool hasError = !(success &&\\n      (data.length == 0 || abi.decode(data, (bool))));\\n    if (hasError && raiseError) {\\n      revert(\\\"TransferHelper__TransferFromFailed\\\");\\n    }\\n    return !hasError;\\n  }\\n\\n  function safeTransferETH(\\n    address to,\\n    uint256 value,\\n    bool raiseError\\n  ) internal returns (bool) {\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\n    if (!success && raiseError) {\\n      revert(\\\"TransferHelper__EthTransferFailed\\\");\\n    }\\n    return success;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rangoAddress\",\"type\":\"address\"}],\"name\":\"RangoAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rangoAddress\",\"type\":\"address\"}],\"name\":\"RangoAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SuppliedTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SupplyFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAndSupplyTo\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rangoContractAddress\",\"type\":\"address\"}],\"name\":\"addRangoContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rangoContractAddresses\",\"type\":\"address[]\"}],\"name\":\"addRangoContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRango\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRangoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum IRangoMessageReceiver.ProcessStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"handleRangoMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rangoContractAddress\",\"type\":\"address\"}],\"name\":\"removeRangoContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wethAddress\",\"type\":\"address\"}],\"name\":\"setWeth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sourceComet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sourceRango\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rangoData\",\"type\":\"bytes\"}],\"name\":\"withdrawAndCrosschainSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RangoCometIntermediary", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}