{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Database.sol\": {\r\n      \"content\": \"pragma solidity 0.8.14;\\n\\nimport \\\"./interface/IProofOfDeveloper.sol\\\";\\nimport \\\"./interface/IProofOfAuditor.sol\\\";\\nimport \\\"./interface/IDeveloperWallet.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\n\\n/// @title   Hyacinth Database\\n/// @notice  Contract that keeps track of pending and completed audits\\n/// @author  Hyacinth\\ncontract HyacinthDatabase {\\n    /// EVENTS ///\\n\\n    /// @notice          Emitted after audit has been created\\n    /// @param auditId   Audit id\\n    /// @param previous  Audit id of previous audit\\n    /// @param developer Address of developer\\n    /// @param contracts Address of conrtacts being audited (Off chain audit if empty)\\n    event AuditCreated(\\n        uint256 indexed auditId,\\n        uint256 indexed previous,\\n        address indexed developer,\\n        address[] contracts\\n    );\\n\\n    /// @notice           Emitted after pod has been minted\\n    /// @param developer  Address of developer\\n    /// @param id         Id of POD minted\\n    event PODMinted(address indexed developer, uint256 id);\\n\\n    /// @notice           Emitted after audit result has been submitted\\n    /// @param auditor    Address of auditor\\n    /// @param developer  Developer of contracts\\n    /// @param auditId    Id of audit\\n    /// @param result     Result of audit\\n    event ResultSubmitted(address indexed auditor, address indexed developer, uint256 indexed auditId, STATUS result);\\n\\n    /// @notice           Emitted after audit result has been submitted\\n    /// @param auditId    Id of audit\\n    /// @param auditor    Address of auditor\\n    /// @param developer  Developer of `auditId`\\n    /// @param positive   Bool if positive feedback\\n    event AuditFeedBackGiven(\\n        uint256 indexed auditId,\\n        address indexed auditor,\\n        address indexed developer,\\n        bool positive\\n    );\\n\\n    /// @notice           Emitted after bounty has been refunded\\n    /// @param developer  Address of developer being refunded\\n    /// @param auditId    Id of audit being refunded\\n    event BountyRefunded(address indexed developer, uint256 indexed auditId);\\n\\n    /// @notice         Emitted after auditor request has been sent\\n    /// @param auditor  Address of auditor requesting\\n    /// @param auditId  Audit id of audit request\\n    event AuditorRequest(address indexed auditor, uint256 indexed auditId);\\n\\n    /// @notice           Emitted after auditor has been accepted\\n    /// @param developer  Address of developer of audit\\n    /// @param auditor    Address of auditor accepted\\n    /// @param auditId    Audit id auditor has been accepted for\\n    event AuditorAccepted(address indexed developer, address indexed auditor, uint256 indexed auditId);\\n\\n    /// @notice                 Emitted after collaboration has been created\\n    /// @param auditId          Audit id collaborator is being added to\\n    /// @param collaborator     Address of collaborator\\n    /// @param percentOfBounty  Percent of bounty given to collaborator\\n    event CollaborationCreated(uint256 indexed auditId, address collaborator, uint256 percentOfBounty);\\n\\n    /// @notice        Emitted after max number of audits for auditor set\\n    /// @param oldMax  Old max audits for auditor\\n    /// @param newMax  New max audits for auditor\\n    event MaxAuditsSet(uint256 oldMax, uint256 newMax);\\n\\n    /// @notice           Emitted after time to roll over is updated\\n    /// @param oldPeriod  Old roll over period\\n    /// @param newPeriod  New roll over period\\n    event TimeToRollOverSet(uint256 oldPeriod, uint256 newPeriod);\\n\\n    /// @notice         Emitted after auditor has been added\\n    /// @param auditor  Address of auditor being added\\n    event AuditorAdded(address auditor);\\n\\n    /// @notice         Emitted after auditor has been removed\\n    /// @param auditor  Address of auditor being removed\\n    event AuditorRemoved(address auditor);\\n\\n    /// @notice               Emitted after ownership has been transfered\\n    /// @param previousOwner  Address of previous owner\\n    /// @param newOwner       Address of new owner\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// ERRORS ///\\n\\n    /// @notice Error for if invalid level\\n    error InvalidLevel();\\n    /// @notice Error for if auditor has already been assigned\\n    error AuditorAssigned();\\n    /// @notice Error for if audit has not been failed\\n    error AuditNotFailed();\\n    /// @notice Error for if audit has been rolled over\\n    error AuditRolledOver();\\n    /// @notice Error for if refund condition not met\\n    error CanNotRefund();\\n    /// @notice Error for if the address is not the owner\\n    error NotOwner();\\n    /// @notice Error for if not approved auditor\\n    error NotApprovedAuditor();\\n    /// @notice Error for if not requested auditor\\n    error NotRequestedAuditor();\\n    /// @notice Error for only auditor\\n    error OnlyAuditor();\\n    /// @notice Error for only developer\\n    error OnlyDeveloper();\\n    /// @notice Error for if contract is not being audited\\n    error NotBeingAudited();\\n    /// @notice Error for if audit has not been passed\\n    error NotPassed();\\n    /// @notice Error for if feedback has already been given\\n    error FeedbackGiven();\\n    /// @notice Error for if contract is already in system\\n    error AlreadyInSystem();\\n    /// @notice Error for invalid audit result\\n    error InvalidResult();\\n    /// @notice Error for if address is not a contact\\n    error NotAContract();\\n    /// @notice Error for if collaboration has already been created\\n    error CollaborationAlreadyCreated();\\n    /// @notice Error for if trying to give away more of bounty than available\\n    error MoreThanCanGiveAway();\\n    /// @notice Error for if address already owns POD NFT\\n    error AlreadyOwnPOD();\\n    /// @notice Error for if submitting audit and does not own POD NFT\\n    error DoesNotOwnPODNFT();\\n    /// @notice Error for if auditor has max amount of audits\\n    error MaxAuditsInProgress();\\n    /// @notice Error for if roll over period is still active\\n    error RollOverStillActive();\\n    /// @notice Error for if invalid previous\\n    error InvalidPrevious();\\n\\n    /// STRUCTS ///\\n\\n    enum STATUS {\\n        NOTAUDITED,\\n        PENDING,\\n        PASSED,\\n        FAILED,\\n        REFUNDED\\n    }\\n\\n    /// @notice           Details of contract\\n    /// @param contracts  Address of contract developer\\n    /// @param audited    Bool if has been add to audit\\n    /// @param auditId    Audit id\\n    struct Contract {\\n        address developer;\\n        bool audited;\\n        uint256 auditId;\\n    }\\n\\n    /// @notice                  Details of audited contracts\\n    /// @param contracts         Contracts being audited\\n    /// @param auditor           Address of auditor\\n    /// @param developer         Address of developer\\n    /// @param status            Status of audit\\n    /// @param auditDescription  Description of audit results\\n    /// @param deadline          Deadline auditor has to complete audit\\n    /// @param feedback          Bool if feedback has been given to auditor\\n    struct Audit {\\n        address[] contracts;\\n        address auditor;\\n        address developer;\\n        STATUS status;\\n        string auditDescription;\\n        uint256 deadline;\\n        bool feedback;\\n    }\\n\\n    /// @notice                  Details of auditor\\n    /// @param auditsInProgress  Number of audits in progress\\n    /// @param positiveFeedback  Number of positive feedback for auditor\\n    /// @param negativeFeedbac   Number of negative feedback for auditor\\n    /// @param mintedLevel       Minted level for auditor\\n    struct Auditor {\\n        uint256 auditsInProgress;\\n        uint256 positiveFeedback;\\n        uint256 negativeFeedback;\\n        uint256 mintedLevel;\\n    }\\n\\n    /// STATE VARIABLES ///\\n\\n    /// @notice Fee percent for Hyacinth\\n    uint256 public constant HYACINTH_FEE = 25;\\n    /// @notice Fee amount to mint POD NFT\\n    uint256 public constant POD_MINT_FEE = 100000000;\\n    /// @notice 30 days to complete audit or can refund\\n    uint256 public constant AUDIT_DEADLINE = 30 days;\\n    /// @notice Max number of audits an auditor can pick up at one time\\n    uint256 public maxAuditsForAuditor;\\n    /// @notice Amount of time dev has to roll over audit until auditor can claim bounty\\n    uint256 public timeToRollOver;\\n    /// @notice Amount of audits in system\\n    uint256 public auditId;\\n\\n    /// @notice Address of owner\\n    address public owner;\\n\\n    /// @notice Address of previous POD\\n    address public immutable previousPOD;\\n    /// @notice Address of hyacinth wallet\\n    address public immutable hyacinthWallet;\\n    /// @notice Address of USDC\\n    address public immutable USDC;\\n    /// @notice Address of proof of developer NFT\\n    IProofOfDeveloper public immutable proofOfDeveloper;\\n    /// @notice Address of proof of auditor NFT\\n    IProofOfAuditor public immutable proofOfAuditor;\\n\\n    /// @notice Amount of audits completed at each level for auditor\\n    mapping(address => uint256[4]) internal _levelsCompleted;\\n\\n    /// @notice Contract details for contract address\\n    mapping(address => Contract) public contracts;\\n    /// @notice Audit details of address\\n    mapping(uint256 => Audit) public audits;\\n    /// @notice Auditor details of auditor\\n    mapping(address => Auditor) public auditors;\\n    /// @notice Bool if address is an approved auditor\\n    mapping(address => bool) public approvedAuditor;\\n    /// @notice Percent of bounty given to collaborators\\n    mapping(uint256 => uint256) public percentGivenForCollab;\\n    /// @notice Time rollover of bounty is active till\\n    mapping(uint256 => uint256) public timeRollOverActive;\\n    /// @notice Developer wallet contract of developer\\n    mapping(address => address) public developerWalletContract;\\n    /// @notice Address failed audit rolled over to\\n    mapping(uint256 => uint256) public rolledOverAudit;\\n    /// @notice Array of collaborators for audit id\\n    mapping(uint256 => address[]) public collaborators;\\n    /// @notice Array of fees collaborators receive\\n    mapping(uint256 => uint256[]) public collaboratorsPercentOfBounty;\\n    /// @notice Bounty percent for collaberation of an audit id of a collaborator\\n    mapping(uint256 => mapping(address => uint256)) public collaborationPercent;\\n    /// @notice Bool if address requested to be auditor of audit id\\n    mapping(uint256 => mapping(address => bool)) public requestToBeAuditor;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// @param hyacinthWallet_  Address of hyacinth wallet\\n    /// @param owner_           Address of owner\\n    /// @param pod_             Address of proof of developer NFT\\n    /// @param poa_             Address of proof of auditor NFT\\n    /// @param usdc_            Address of USDC\\n    /// @param previousPOD_     Address of previous proof of developer\\n    constructor(\\n        address hyacinthWallet_,\\n        address owner_,\\n        address pod_,\\n        address poa_,\\n        address usdc_,\\n        address previousPOD_\\n    ) {\\n        hyacinthWallet = hyacinthWallet_;\\n        owner = owner_;\\n        proofOfDeveloper = IProofOfDeveloper(pod_);\\n        proofOfAuditor = IProofOfAuditor(poa_);\\n        USDC = usdc_;\\n        previousPOD = previousPOD_;\\n    }\\n\\n    /// AUDIT FUNCTION ///\\n\\n    /// @notice               Function that creates audit\\n    /// @param beingAudited_  Array of addresses to have be audited (If 0 - Off chain audit)\\n    /// @param previous_      Previous audit id if rolling over\\n    /// @param bountyAmount_  Starting bounty amount\\n    /// @return auditId_      Id of audit created\\n    function createAudit(\\n        address[] calldata beingAudited_,\\n        uint256 previous_,\\n        uint256 bountyAmount_\\n    ) external returns (uint256 auditId_) {\\n        if (proofOfDeveloper.balanceOf(msg.sender) == 0) revert DoesNotOwnPODNFT();\\n\\n        ++auditId;\\n        auditId_ = auditId;\\n\\n        if (beingAudited_.length > 0) {\\n            for (uint i; i < beingAudited_.length; ++i) {\\n                Contract memory contract_ = contracts[beingAudited_[i]];\\n                if (contract_.audited) revert AlreadyInSystem();\\n                if (contract_.developer != msg.sender) revert OnlyDeveloper();\\n                contracts[beingAudited_[i]].audited = true;\\n                contracts[beingAudited_[i]].auditId = auditId_;\\n            }\\n\\n            if (\\n                previous_ != 0 &&\\n                (timeRollOverActive[previous_] <= block.timestamp || audits[previous_].developer != msg.sender)\\n            ) revert InvalidPrevious();\\n\\n            if (previous_ != 0) {\\n                audits[auditId_].auditor = audits[previous_].auditor;\\n                audits[auditId_].deadline = block.timestamp + AUDIT_DEADLINE;\\n                collaborators[auditId_] = collaborators[previous_];\\n                collaboratorsPercentOfBounty[auditId_] = collaboratorsPercentOfBounty[previous_];\\n                percentGivenForCollab[auditId_] = percentGivenForCollab[previous_];\\n                rolledOverAudit[previous_] = auditId_;\\n                IDeveloperWallet(developerWalletContract[msg.sender]).rollOverBounty(previous_, auditId_);\\n            }\\n\\n            audits[auditId_].contracts = beingAudited_;\\n        }\\n\\n        audits[auditId_].developer = msg.sender;\\n        audits[auditId_].status = STATUS.PENDING;\\n\\n        if (bountyAmount_ > 0) {\\n            address devWallet_ = developerWalletContract[msg.sender];\\n            IERC20(USDC).transferFrom(msg.sender, devWallet_, bountyAmount_);\\n            IDeveloperWallet(devWallet_).addToBounty(auditId_, bountyAmount_, false, USDC);\\n        }\\n\\n        emit AuditCreated(auditId_, previous_, msg.sender, beingAudited_);\\n    }\\n\\n    /// @notice  Called upon contract being deployed to be audited\\n    function beingAudited() external {\\n        if (proofOfDeveloper.balanceOf(tx.origin) == 0) revert DoesNotOwnPODNFT();\\n        if (msg.sender == tx.origin) revert NotAContract();\\n        Contract memory contract_ = contracts[msg.sender];\\n        if (contract_.developer != address(0)) revert AlreadyInSystem();\\n        contracts[msg.sender].developer = tx.origin;\\n    }\\n\\n    /// DEVELOPER FUNCTION ///\\n\\n    /// @notice                   Function that allow address to mint POD NFT\\n    /// @return id_               POD id minted\\n    /// @return developerWallet_  Address of developer wallet contract\\n    function mintPOD() external returns (uint256 id_, address developerWallet_) {\\n        if (previousPOD == address(0) || IERC721(previousPOD).balanceOf(msg.sender) == 0)\\n            IERC20(USDC).transferFrom(msg.sender, hyacinthWallet, POD_MINT_FEE);\\n        if (proofOfDeveloper.balanceOf(msg.sender) > 0) revert AlreadyOwnPOD();\\n        else (id_, developerWallet_) = proofOfDeveloper.mint(msg.sender);\\n        developerWalletContract[msg.sender] = developerWallet_;\\n\\n        emit PODMinted(msg.sender, id_);\\n    }\\n\\n    /// @notice           Function that allows developer to give feedback to auditor\\n    /// @param auditId_   Audit id feedback given for\\n    /// @param positive_  Bool if positive or negative feedback\\n    function giveAuditorFeedback(uint256 auditId_, bool positive_) external {\\n        Audit memory audit_ = audits[auditId_];\\n\\n        if (audit_.status != STATUS.PASSED) revert NotPassed();\\n        if (audit_.developer != msg.sender) revert OnlyDeveloper();\\n        if (audit_.feedback) revert FeedbackGiven();\\n\\n        audits[auditId_].feedback = true;\\n\\n        if (positive_) ++auditors[audit_.auditor].positiveFeedback;\\n        else ++auditors[audit_.auditor].negativeFeedback;\\n\\n        emit AuditFeedBackGiven(auditId_, audit_.auditor, audit_.developer, positive_);\\n    }\\n\\n    /// @notice           Function that allows developer to get a refund for bounty if no auditor or past deadline\\n    /// @param auditId_   Audit id to get refund for\\n    function refundBounty(uint256 auditId_) external {\\n        Audit memory audit_ = audits[auditId_];\\n        if (audit_.developer != msg.sender) revert OnlyDeveloper();\\n        if ((audit_.auditor != address(0) && audit_.deadline > block.timestamp) || audit_.status != STATUS.PENDING)\\n            revert CanNotRefund();\\n\\n        audits[auditId_].status = STATUS.REFUNDED;\\n\\n        address devWallet_ = developerWalletContract[msg.sender];\\n        IDeveloperWallet(devWallet_).refundBounty(auditId_);\\n\\n        emit BountyRefunded(msg.sender, auditId_);\\n    }\\n\\n    /// @notice          Function that allows developer to accept propose auditor\\n    /// @param auditId_  Audit Id of audit developer is accepting `auditor_` for\\n    /// @param auditor_  Address being accepted as auditor for `auditId_`\\n    function acceptAuditor(uint256 auditId_, address auditor_) external {\\n        if (audits[auditId_].developer != msg.sender) revert OnlyDeveloper();\\n        if (audits[auditId_].auditor != address(0)) revert AuditorAssigned();\\n        if (maxAuditsForAuditor <= auditors[auditor_].auditsInProgress) revert MaxAuditsInProgress();\\n        if (!requestToBeAuditor[auditId_][auditor_]) revert NotRequestedAuditor();\\n\\n        ++auditors[auditor_].auditsInProgress;\\n        audits[auditId_].auditor = auditor_;\\n        audits[auditId_].deadline = block.timestamp + AUDIT_DEADLINE;\\n\\n        emit AuditorAccepted(msg.sender, auditor_, auditId_);\\n    }\\n\\n    /// AUDITOR FUNCTION ///\\n\\n    /// @notice          Function that allows approved auditor to request to audit\\n    /// @param auditId_  Audit id auditor is requesting to audit\\n    function requestToAudit(uint256 auditId_) external {\\n        if (audits[auditId_].status != STATUS.PENDING) revert NotBeingAudited();\\n        if (audits[auditId_].auditor != address(0)) revert AuditorAssigned();\\n        if (!approvedAuditor[msg.sender]) revert NotApprovedAuditor();\\n        if (maxAuditsForAuditor <= auditors[msg.sender].auditsInProgress) revert MaxAuditsInProgress();\\n\\n        requestToBeAuditor[auditId_][msg.sender] = true;\\n\\n        emit AuditorRequest(msg.sender, auditId_);\\n    }\\n\\n    /// @notice              Auditor submits the `result_` of `auditId_`\\n    /// @param auditId_      Audit Id of audit having `result_` submitted\\n    /// @param result_       Result of the audit\\n    /// @param description_  Desecription of the audit\\n    function submitResult(uint256 auditId_, STATUS result_, string memory description_) external {\\n        Audit memory audit_ = audits[auditId_];\\n        if (audit_.status != STATUS.PENDING) revert NotBeingAudited();\\n        if (audit_.auditor != msg.sender) revert OnlyAuditor();\\n        if (result_ != STATUS.PASSED && result_ != STATUS.FAILED) revert InvalidResult();\\n        audit_.status = result_;\\n        audit_.auditDescription = description_;\\n        audits[auditId_] = audit_;\\n\\n        if (result_ == STATUS.PASSED) {\\n            uint256 level_ = _payBounty(auditId_, developerWalletContract[audit_.developer]);\\n            ++_levelsCompleted[audit_.auditor][level_];\\n        } else {\\n            timeRollOverActive[auditId_] = block.timestamp + timeToRollOver;\\n        }\\n\\n        emit ResultSubmitted(audit_.auditor, audit_.developer, auditId_, result_);\\n    }\\n\\n    /// @notice          Function that pays out bounty if roll over has expired\\n    /// @param auditId_  Audit id to pay out bounty for\\n    function rollOverExpired(uint256 auditId_) external {\\n        Audit memory audit_ = audits[auditId_];\\n        if (audit_.status != STATUS.FAILED) revert AuditNotFailed();\\n        if (audit_.auditor != msg.sender) revert OnlyAuditor();\\n        if (timeRollOverActive[auditId_] > block.timestamp) revert RollOverStillActive();\\n        if (rolledOverAudit[auditId_] != 0) revert AuditRolledOver();\\n\\n        _payBounty(auditId_, developerWalletContract[audit_.developer]);\\n    }\\n\\n    /// @notice                  Function that allows an auditor to propose a collaboration\\n    /// @param auditId_          Audit id\\n    /// @param collaborator_     Address of collaborator\\n    /// @param percentOfBounty_  Percent of bounty `collaborator_` will receive\\n    function createCollaboration(uint256 auditId_, address collaborator_, uint256 percentOfBounty_) external {\\n        Audit memory audit_ = audits[auditId_];\\n        if (audit_.status != STATUS.PENDING) revert NotBeingAudited();\\n        if (audit_.auditor != msg.sender) revert OnlyAuditor();\\n        if (!approvedAuditor[collaborator_]) revert NotApprovedAuditor();\\n        if (percentGivenForCollab[auditId_] + percentOfBounty_ > 100) revert MoreThanCanGiveAway();\\n\\n        uint256 collaborationPercent_ = collaborationPercent[auditId_][collaborator_];\\n        if (collaborationPercent_ > 0) revert CollaborationAlreadyCreated();\\n\\n        collaborationPercent[auditId_][collaborator_] = percentOfBounty_;\\n\\n        percentGivenForCollab[auditId_] += percentOfBounty_;\\n        collaborators[auditId_].push(collaborator_);\\n        collaboratorsPercentOfBounty[auditId_].push(percentOfBounty_);\\n\\n        emit CollaborationCreated(auditId_, collaborator_, percentOfBounty_);\\n    }\\n\\n    /// OWNER FUNCTION ///\\n\\n    /// @notice           Transfer ownership of contract\\n    /// @param newOwner_  Address of the new owner\\n    function transferOwnership(address newOwner_) external {\\n        if (msg.sender != owner) revert NotOwner();\\n        address oldOwner_ = owner;\\n        owner = newOwner_;\\n\\n        emit OwnershipTransferred(oldOwner_, newOwner_);\\n    }\\n\\n    /// @notice                 Set roll over time for failed audit\\n    /// @param timeToRollOver_  New roll over time for failed audit\\n    function setTimeToRollOver(uint256 timeToRollOver_) external {\\n        if (msg.sender != owner) revert NotOwner();\\n        uint256 oldPeriod_ = timeToRollOver;\\n        timeToRollOver = timeToRollOver_;\\n\\n        emit TimeToRollOverSet(oldPeriod_, timeToRollOver_);\\n    }\\n\\n    /// @notice            Set max number of audits\\n    /// @param maxAudits_  New max number of audits for auditor\\n    function setMaxAuditsForAuditor(uint256 maxAudits_) external {\\n        if (msg.sender != owner) revert NotOwner();\\n        uint256 oldMax_ = maxAuditsForAuditor;\\n        maxAuditsForAuditor = maxAudits_;\\n\\n        emit MaxAuditsSet(oldMax_, maxAudits_);\\n    }\\n\\n    /// @notice           Add auditor\\n    /// @param auditor_   Address to add as auditor\\n    /// @param baseLevel_  Base level to give `auditor_`\\n    /// @return id_       Id of POA for `auditor_`\\n    function addAuditor(address auditor_, uint256 baseLevel_) external returns (uint256 id_) {\\n        if (msg.sender != owner) revert NotOwner();\\n        if (baseLevel_ > 3) revert InvalidLevel();\\n\\n        if (proofOfAuditor.balanceOf(auditor_) == 0) {\\n            id_ = proofOfAuditor.mint(auditor_);\\n        } else id_ = proofOfAuditor.idHeld(auditor_);\\n\\n        auditors[auditor_].mintedLevel = baseLevel_;\\n        approvedAuditor[auditor_] = true;\\n\\n        emit AuditorAdded(auditor_);\\n    }\\n\\n    /// @notice          Remove auditor\\n    /// @param auditor_  Address to remove as auditor\\n    function removeAuditor(address auditor_) external {\\n        if (msg.sender != owner) revert NotOwner();\\n        approvedAuditor[auditor_] = false;\\n\\n        emit AuditorRemoved(auditor_);\\n    }\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n    /// @notice                  Internal function that pays out bounty\\n    /// @param auditId_          Bounty Id to pay bounty out for\\n    /// @param developerWallet_  Developer wallet contract\\n    function _payBounty(uint256 auditId_, address developerWallet_) internal returns (uint256 level_) {\\n        address[] memory collaborators_ = collaborators[auditId_];\\n        uint256[] memory percentsOfBounty_ = collaboratorsPercentOfBounty[auditId_];\\n\\n        level_ = IDeveloperWallet(developerWallet_).payOutBounty(auditId_, collaborators_, percentsOfBounty_);\\n\\n        --auditors[msg.sender].auditsInProgress;\\n    }\\n\\n    /// EXTERNAL VIEW FUNCTIONS ///\\n\\n    /// @notice                   Returns amount of audits completed at each level for `auditorAdderss_`\\n    /// @param auditorAddress_    Address of auditor\\n    /// @return levelsCompleted_  Array of levels of audits completed for `auditorAddress_`\\n    function levelsCompleted(address auditorAddress_) external view returns (uint256[4] memory levelsCompleted_) {\\n        return (_levelsCompleted[auditorAddress_]);\\n    }\\n\\n    /// @notice                   Returns audit status for `contractAddress_`\\n    /// @param contractAddress_   Contract address to check audit status for\\n    /// @return status_           Audit status of `contractAddress_`\\n    function auditStatus(address contractAddress_) external view returns (STATUS status_) {\\n        Contract memory contract_ = contracts[contractAddress_];\\n        if (contract_.audited) status_ = audits[contract_.auditId].status;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDeveloperWallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IDeveloperWallet {\\n    function payOutBounty(\\n        uint256 auditId_,\\n        address[] calldata collaborators_,\\n        uint256[] calldata percentsOfBounty_\\n    ) external returns (uint256 level_);\\n\\n    function rollOverBounty(uint256 previous_, uint256 new_) external;\\n\\n    function refundBounty(uint256 auditId_) external;\\n\\n    function currentBountyLevel(uint256 auditId_) external view returns (uint256 level_, uint256 bounty_);\\n\\n    function addToBounty(uint256 auditId_, uint256 amount_, bool transfer_, address token_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IProofOfAuditor.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IProofOfAuditor is IERC721 {\\n    function mint(address auditor_) external returns (uint256 id_);\\n\\n    function idHeld(address auditor_) external view returns (uint256 id_);\\n\\n    function level(uint256 tokenId_) external view returns (uint256 level_);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IProofOfDeveloper.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IProofOfDeveloper is IERC721 {\\n    function mint(address developer_) external returns (uint256 id_, address developerWallet_);\\n\\n    function idHeld(address developer_) external view returns (uint256 id_);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hyacinthWallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pod_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poa_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdc_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"previousPOD_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInSystem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyOwnPOD\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuditNotFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuditRolledOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuditorAssigned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CanNotRefund\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollaborationAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DoesNotOwnPODNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeedbackGiven\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLevel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrevious\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidResult\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxAuditsInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MoreThanCanGiveAway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedAuditor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotBeingAudited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRequestedAuditor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuditor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDeveloper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollOverStillActive\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"AuditCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"positive\",\"type\":\"bool\"}],\"name\":\"AuditFeedBackGiven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"}],\"name\":\"AuditorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"AuditorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"AuditorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"}],\"name\":\"AuditorRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"}],\"name\":\"BountyRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collaborator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentOfBounty\",\"type\":\"uint256\"}],\"name\":\"CollaborationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"MaxAuditsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PODMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum HyacinthDatabase.STATUS\",\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"ResultSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"TimeToRollOverSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUDIT_DEADLINE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HYACINTH_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POD_MINT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"auditor_\",\"type\":\"address\"}],\"name\":\"acceptAuditor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auditor_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseLevel_\",\"type\":\"uint256\"}],\"name\":\"addAuditor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedAuditor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auditId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress_\",\"type\":\"address\"}],\"name\":\"auditStatus\",\"outputs\":[{\"internalType\":\"enum HyacinthDatabase.STATUS\",\"name\":\"status_\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"auditors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auditsInProgress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positiveFeedback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"negativeFeedback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedLevel\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"audits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"internalType\":\"enum HyacinthDatabase.STATUS\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"auditDescription\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"feedback\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beingAudited\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collaborationPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collaborators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collaboratorsPercentOfBounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"audited\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auditId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beingAudited_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"previous_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bountyAmount_\",\"type\":\"uint256\"}],\"name\":\"createAudit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collaborator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentOfBounty_\",\"type\":\"uint256\"}],\"name\":\"createCollaboration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"developerWalletContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"positive_\",\"type\":\"bool\"}],\"name\":\"giveAuditorFeedback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hyacinthWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auditorAddress_\",\"type\":\"address\"}],\"name\":\"levelsCompleted\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"levelsCompleted_\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAuditsForAuditor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"developerWallet_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percentGivenForCollab\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousPOD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofOfAuditor\",\"outputs\":[{\"internalType\":\"contract IProofOfAuditor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofOfDeveloper\",\"outputs\":[{\"internalType\":\"contract IProofOfDeveloper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"}],\"name\":\"refundBounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auditor_\",\"type\":\"address\"}],\"name\":\"removeAuditor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"}],\"name\":\"requestToAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requestToBeAuditor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"}],\"name\":\"rollOverExpired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rolledOverAudit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAudits_\",\"type\":\"uint256\"}],\"name\":\"setMaxAuditsForAuditor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeToRollOver_\",\"type\":\"uint256\"}],\"name\":\"setTimeToRollOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auditId_\",\"type\":\"uint256\"},{\"internalType\":\"enum HyacinthDatabase.STATUS\",\"name\":\"result_\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description_\",\"type\":\"string\"}],\"name\":\"submitResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeRollOverActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToRollOver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HyacinthDatabase", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007102908124a91cd34130d192ae716f2bd75046b5000000000000000000000000afd525295a3f08bd362c0cee491b7ecc6a69a4780000000000000000000000000a99c64795c3f80288122859a2af282906e3e5db0000000000000000000000008147174325a4697982f149008d1491e2965f062b000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000168d5cf47b1ad250f48af2fa8c98a6df07bc982b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}