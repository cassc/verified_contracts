// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol";

contract MonsterraItem is 
    Initializable, 
    ContextUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC20Upgradeable,
    PausableUpgradeable,
    UUPSUpgradeable 
{

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant SERVER_ROLE = keccak256("SERVER_ROLE");

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function initialize(
        string memory name,
        string memory symbol
    ) public initializer {
        __MonsterraItem_init(name, symbol);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function __MonsterraItem_init(
        string memory name,
        string memory symbol
    ) internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __AccessControl_init_unchained();
        __AccessControlEnumerable_init_unchained();
        __ERC20_init_unchained(name, symbol);
        __Pausable_init_unchained();
        __MonsterraItem_init_unchained();
        __UUPSUpgradeable_init();
    }

    function __MonsterraItem_init_unchained() internal initializer {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    modifier adminGuard() {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),
            "Monsterra: must have admin role"
        );
        _;
    }

    modifier minterGuard() {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "Monsterra: must have minter role"
        );
        _;
    }

    modifier pauserGuard() {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            "Monsterra: must have pauser role"
        );
        _;   
    }

    function decimals() public view virtual override returns (uint8) {
        return 0;
    }

    function addMinter(address _admin) public {
        super.grantRole(MINTER_ROLE, _admin);
    }

    function addServer(address _server) public adminGuard {
        super.grantRole(SERVER_ROLE, _server);
    }

    function removeServer(address _server) public adminGuard {
        super.revokeRole(SERVER_ROLE, _server);
    }

    function getUsedNonce(string calldata _nonce) public view returns (bool){
        return _usedNonces[_nonce];
    }

    function mint(address _to, uint256 _amount) public minterGuard {
        _mint(_to, _amount);
    }

    function mint(uint256 _amount, string calldata _nonce, uint256 _timestamp, bytes calldata _signature) external {
        _verify(_amount, _nonce, _timestamp, _signature);
        _mint(_msgSender(), _amount);
    }

    function burn(uint256 _amount) public virtual {
        _burn(msg.sender, _amount);
    }

     /**
     * @dev Pauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual pauserGuard {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual pauserGuard {
        _unpause();
    }

    function _verify(
        uint256 _amount,
        string calldata _nonce,
        uint256 _timestamp,
        bytes memory _signature
    ) private {
        require(
            _timestamp + 60 * 2 > block.timestamp,
            "MonsterraStaking: signature expired"
        );

        require(!_usedNonces[_nonce], "MonsterraStaking: nonce has been used");
        _usedNonces[_nonce] = true;

        bytes32 messageHash = keccak256(
            abi.encodePacked(
                _msgSender(),
                address(this),
                _amount,
                _nonce,
                _timestamp
            )
        );
        bytes32 ethSignMessageHash = ECDSAUpgradeable.toEthSignedMessageHash(
            messageHash
        );
        address signer = ECDSAUpgradeable.recover(
            ethSignMessageHash,
            _signature
        );
        require(
            hasRole(SERVER_ROLE, signer),
            "MonsterraStaking: must have server signature"
        );
    }


    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        require(!paused(), "Monsterra: token transfer while paused");
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        override
        adminGuard
    {
        // Do something here.
    }

    function transferOwner(address _address) public adminGuard {
        _setupRole(DEFAULT_ADMIN_ROLE, _address);
        _setupRole(PAUSER_ROLE, _address);
        super.revokeRole(MINTER_ROLE, _msgSender());
        super.revokeRole(PAUSER_ROLE, _msgSender());
        super.revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    uint256[50] private __gap;
    mapping(string => bool) private _usedNonces;

}