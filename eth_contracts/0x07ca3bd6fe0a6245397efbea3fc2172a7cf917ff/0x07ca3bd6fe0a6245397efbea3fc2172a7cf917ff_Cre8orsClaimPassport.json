{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/interfaces/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\"\r\n    },\r\n    \"src/interfaces/ICre8orsCollective.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\ninterface ICre8orsCollective {\\n    function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721Drop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IMetadataRenderer} from \\\"../interfaces/IMetadataRenderer.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n*/\\n/// @notice Interface for ZORA Drops contract\\ninterface IERC721Drop {\\n    // Access errors\\n\\n    /// @notice Only admin can access this function\\n    error Access_OnlyAdmin();\\n    /// @notice Missing the given role or admin access\\n    error Access_MissingRoleOrAdmin(bytes32 role);\\n    /// @notice Withdraw is not allowed by this user\\n    error Access_WithdrawNotAllowed();\\n    /// @notice Cannot withdraw funds due to ETH send failure.\\n    error Withdraw_FundsSendFailure();\\n    /// @notice Missing the owner role.\\n    error Access_OnlyOwner();\\n    /// @notice Missing the owner role or approved nft access.\\n    error Access_MissingOwnerOrApproved();\\n\\n    // CRE8ING errors\\n    /// @notice Cre8ing Closed\\n    error Cre8ing_Cre8ingClosed();\\n    /// @notice Cre8ing\\n    error Cre8ing_Cre8ing();\\n\\n    // Sale/Purchase errors\\n    /// @notice Sale is inactive\\n    error Sale_Inactive();\\n    /// @notice Presale is inactive\\n    error Presale_Inactive();\\n    /// @notice Presale merkle root is invalid\\n    error Presale_MerkleNotApproved();\\n    /// @notice Wrong price for purchase\\n    error Purchase_WrongPrice(uint256 correctPrice);\\n    /// @notice NFT sold out\\n    error Mint_SoldOut();\\n    /// @notice Too many purchase for address\\n    error Purchase_TooManyForAddress();\\n    /// @notice Too many presale for address\\n    error Presale_TooManyForAddress();\\n\\n    // Admin errors\\n    /// @notice Royalty percentage too high\\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\\n    /// @notice Invalid admin upgrade address\\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\\n    error Admin_UnableToFinalizeNotOpenEdition();\\n\\n    /// @notice Event emitted for each sale\\n    /// @param to address sale was made to\\n    /// @param quantity quantity of the minted nfts\\n    /// @param pricePerToken price for each token\\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\\n    event Sale(\\n        address indexed to,\\n        uint256 indexed quantity,\\n        uint256 indexed pricePerToken,\\n        uint256 firstPurchasedTokenId\\n    );\\n\\n    /// @notice Sales configuration has been changed\\n    /// @dev To access new sales configuration, use getter function.\\n    /// @param changedBy Changed by user\\n    event SalesConfigChanged(address indexed changedBy);\\n\\n    /// @notice Event emitted when the funds recipient is changed\\n    /// @param newAddress new address for the funds recipient\\n    /// @param changedBy address that the recipient is changed by\\n    event FundsRecipientChanged(\\n        address indexed newAddress,\\n        address indexed changedBy\\n    );\\n\\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\\n    /// @param withdrawnBy address that issued the withdraw\\n    /// @param withdrawnTo address that the funds were withdrawn to\\n    /// @param amount amount that was withdrawn\\n    event FundsWithdrawn(\\n        address indexed withdrawnBy,\\n        address indexed withdrawnTo,\\n        uint256 amount\\n    );\\n\\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\\n    /// @param sender address sending close mint\\n    /// @param numberOfMints number of mints the contract is finalized at\\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\\n\\n    /// @notice Event emitted when metadata renderer is updated.\\n    /// @param sender address of the updater\\n    /// @param renderer new metadata renderer address\\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\\n\\n    /// @notice General configuration for NFT Minting and bookkeeping\\n    struct Configuration {\\n        /// @dev Metadata renderer (uint160)\\n        IMetadataRenderer metadataRenderer;\\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\\n        uint64 editionSize;\\n        /// @dev Royalty amount in bps (uint224+16 = 240)\\n        uint16 royaltyBPS;\\n        /// @dev Funds recipient for sale (new slot, uint160)\\n        address payable fundsRecipient;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct SalesConfiguration {\\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\\n    struct BurnConfiguration {\\n        /// @dev Token to burn\\n        address burnToken;\\n        /// @dev Required number of tokens to burn\\n        uint256 burnQuantity;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct ERC20SalesConfiguration {\\n        /// @notice Public sale price\\n        /// @dev max ether value > 1000 ether with this value\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct SaleDetails {\\n        // Synthesized status variables for sale and presale\\n        bool publicSaleActive;\\n        bool presaleActive;\\n        // Price for public sale\\n        uint256 publicSalePrice;\\n        // Timed sale actions for public sale\\n        uint64 publicSaleStart;\\n        uint64 publicSaleEnd;\\n        // Timed sale actions for presale\\n        uint64 presaleStart;\\n        uint64 presaleEnd;\\n        // Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        // Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        // Information about the rest of the supply\\n        // Total that have been minted\\n        uint256 totalMinted;\\n        // The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct ERC20SaleDetails {\\n        /// @notice Synthesized status variables for sale\\n        bool publicSaleActive;\\n        /// @notice Synthesized status variables for presale\\n        bool presaleActive;\\n        /// @notice Price for public sale\\n        uint256 publicSalePrice;\\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\\n        address erc20PaymentToken;\\n        /// @notice public sale start\\n        uint64 publicSaleStart;\\n        /// @notice public sale end\\n        uint64 publicSaleEnd;\\n        /// @notice Timed sale actions for presale start\\n        uint64 presaleStart;\\n        /// @notice Timed sale actions for presale end\\n        uint64 presaleEnd;\\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        /// @notice Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        /// @notice Total that have been minted\\n        uint256 totalMinted;\\n        /// @notice The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return type of specific mint counts and details per address\\n    struct AddressMintDetails {\\n        /// Number of total mints from the given address\\n        uint256 totalMints;\\n        /// Number of presale mints from the given address\\n        uint256 presaleMints;\\n        /// Number of public mints from the given address\\n        uint256 publicMints;\\n    }\\n\\n    /// @notice External purchase function (payable in eth)\\n    /// @param quantity to purchase\\n    /// @return first minted token ID\\n    function purchase(uint256 quantity) external payable returns (uint256);\\n\\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\\n    /// @param quantity to purchase\\n    /// @param maxQuantity can purchase (verified by merkle root)\\n    /// @param pricePerToken price per token allowed (verified by merkle root)\\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\\n    /// @return first minted token ID\\n    function purchasePresale(\\n        uint256 quantity,\\n        uint256 maxQuantity,\\n        uint256 pricePerToken,\\n        bytes32[] memory merkleProof\\n    ) external payable returns (uint256);\\n\\n    /// @notice Function to return the global sales details for the given drop\\n    function saleDetails() external view returns (ERC20SaleDetails memory);\\n\\n    /// @notice Function to return the specific sales details for a given address\\n    /// @param minter address for minter to return mint information for\\n    function mintedPerAddress(\\n        address minter\\n    ) external view returns (AddressMintDetails memory);\\n\\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\\n    function owner() external view returns (address);\\n\\n    /// @notice Update the metadata renderer\\n    /// @param newRenderer new address for renderer\\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\\n    function setMetadataRenderer(\\n        IMetadataRenderer newRenderer,\\n        bytes memory setupRenderer\\n    ) external;\\n\\n    /// @notice This is an admin mint function to mint a quantity to a specific address\\n    /// @param to address to mint to\\n    /// @param quantity quantity to mint\\n    /// @return the id of the first minted NFT\\n    function adminMint(address to, uint256 quantity) external returns (uint256);\\n\\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\\n    /// @param to list of addresses to mint an NFT each to\\n    /// @return the id of the first minted NFT\\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\\n\\n    /// @dev Getter for admin role associated with the contract to handle metadata\\n    /// @return boolean if address is admin\\n    function isAdmin(address user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                     \\n */\\n\\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\\ninterface IMetadataRenderer {\\n    function tokenURI(uint256) external view returns (string memory);\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function initializeWithData(bytes memory initData) external;\\n}\\n\"\r\n    },\r\n    \"src/minter/Cre8orsClaimPassportMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\nimport {IERC721A} from \\\"lib/ERC721A/contracts/interfaces/IERC721A.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {ICre8orsCollective} from \\\"../interfaces/ICre8orsCollective.sol\\\";\\n\\ncontract Cre8orsClaimPassportMinter {\\n    address private cre8orsClaimContractAddress;\\n    address private cre8orsPassportContractAddress;\\n\\n    constructor(\\n        address _cre8orsClaimContractAddress,\\n        address _cre8orsPassportContractAddress\\n    ) {\\n        cre8orsClaimContractAddress = _cre8orsClaimContractAddress;\\n        cre8orsPassportContractAddress = _cre8orsPassportContractAddress;\\n    }\\n\\n    function claimPassport(uint256 _tokenId) external returns (uint256) {\\n        require(\\n            IERC721A(cre8orsClaimContractAddress).ownerOf(_tokenId) ==\\n                msg.sender,\\n            \\\"You do not own this token\\\"\\n        );\\n        ICre8orsCollective(cre8orsClaimContractAddress).burn(_tokenId);\\n        // Mint the token to the sender\\n        return\\n            IERC721Drop(cre8orsPassportContractAddress).adminMint(\\n                msg.sender,\\n                1\\n            );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [\r\n      \":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \":ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \":ERC721A/=lib/ERC721A/contracts/\",\r\n      \":ds-test/=lib/ds-test/src/\",\r\n      \":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \":forge-std/=lib/forge-std/src/\",\r\n      \":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \":openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cre8orsClaimContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cre8orsPassportContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimPassport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Cre8orsClaimPassportMinter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000502aa9a163fdec9ac40e5b7d9e469e78383226ca000000000000000000000000d9635b70724b9f618a7bb37c7be182117b1f0dc1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}