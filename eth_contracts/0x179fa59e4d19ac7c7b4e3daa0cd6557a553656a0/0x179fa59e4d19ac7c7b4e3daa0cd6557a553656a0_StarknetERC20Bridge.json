{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"starkware/solidity/libraries/AccessControl.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contract (access/AccessControl.sol)\\n// StarkWare modification (storage slot, change to library).\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"third_party/open_zeppelin/utils/Strings.sol\\\";\\n\\n/*\\n  Library module that allows using contracts to implement role-based access\\n  control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n  members except through off-chain means by accessing the contract event logs. Some\\n  applications may benefit from on-chain enumerability, for those cases see\\n  {AccessControlEnumerable}.\\n \\n  Roles are referred to by their `bytes32` identifier. These should be exposed\\n  in the external API and be unique. The best way to achieve this is by\\n  using `public constant` hash digests:\\n \\n  ```\\n  bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n  ```\\n \\n  Roles can be used to represent a set of permissions. To restrict access to a\\n  function call, use {hasRole}:\\n \\n  ```\\n  function foo() public {\\n      require(hasRole(MY_ROLE, msg.sender));\\n      ...\\n  }\\n  ```\\n \\n  Roles can be granted and revoked dynamically via the {grantRole} and\\n  {revokeRole} functions. Each role has an associated admin role, and only\\n  accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n \\n  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n  that only accounts with this role will be able to grant or revoke other\\n  roles. More complex role relationships can be created by using\\n  {_setRoleAdmin}.\\n \\n  WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n  grant and revoke this role. Extra precautions should be taken to secure\\n  accounts that have been granted it.\\n \\n  OpenZeppelin implementation changed as following:\\n  1. Converted to library.\\n  2. Storage valiable {_roles} moved outside of linear storage,\\n     to avoid potential storage conflicts or corruption.\\n  3. Removed ERC165 support.\\n*/\\nlibrary AccessControl {\\n    /*\\n      Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     \\n      `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n      {RoleAdminChanged} not being emitted signaling this.\\n     \\n      Available since v3.1.\\n    */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /*\\n      Emitted when `account` is granted `role`.\\n     \\n      `sender` is the account that originated the contract call, an admin role\\n      bearer except when using {AccessControl-_setupRole}.\\n    */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /*\\n      Emitted when `account` is revoked `role`.\\n     \\n      `sender` is the account that originated the contract call:\\n        - if using `revokeRole`, it is the admin role bearer\\n        - if using `renounceRole`, it is the role bearer (i.e. `account`).\\n    */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    // Context interface functions.\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal pure returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    // The storage variable `_roles` is located away from the contract linear area (low storage addresses)\\n    // to prevent potential collision/corruption in upgrade scenario.\\n    // Slot = Web3.keccak(text=\\\"AccesControl_Storage_Slot\\\").\\n    bytes32 constant rolesSlot = 0x53e43b954ba190a7e49386f1f78b01dcd9f628db23f432fa029a7dfd6d98e8fb;\\n\\n    function _roles() private pure returns (mapping(bytes32 => RoleData) storage roles) {\\n        assembly {\\n            roles.slot := rolesSlot\\n        }\\n    }\\n\\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /*\\n      Modifier that checks that an account has a specific role. Reverts\\n      with a standardized message including the required role.\\n      \\n      The format of the revert reason is given by the following regular expression:\\n      \\n      /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n      \\n      Available since v4.1.\\n    */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n      Returns `true` if `account` has been granted `role`.\\n    */\\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\\n        return _roles()[role].members[account];\\n    }\\n\\n    /*\\n      Revert with a standard message if `_msgSender()` is missing `role`.\\n      Overriding this function changes the behavior of the {onlyRole} modifier.\\n     \\n      Format of the revert message is described in {_checkRole}.\\n     \\n      Available since v4.6.\\n    */\\n    function _checkRole(bytes32 role) internal view {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /*\\n      Revert with a standard message if `account` is missing `role`.\\n     \\n      The format of the revert reason is given by the following regular expression:\\n     \\n       /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/.\\n    */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n      Returns the admin role that controls `role`. See {grantRole} and\\n      {revokeRole}.\\n     \\n      To change a role's admin, use {_setRoleAdmin}.\\n    */\\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n        return _roles()[role].adminRole;\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      If `account` had not been already granted `role`, emits a {RoleGranted}\\n      event.\\n     \\n      Requirements:\\n     \\n      - the caller must have ``role``'s admin role.\\n     \\n      May emit a {RoleGranted} event.\\n    */\\n    function grantRole(bytes32 role, address account) internal onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /*\\n      Revokes `role` from `account`.\\n     \\n      If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     \\n      Requirements:\\n     \\n      - the caller must have ``role``'s admin role.\\n     \\n      * May emit a {RoleRevoked} event.\\n    */\\n    function revokeRole(bytes32 role, address account) internal onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /*\\n      Revokes `role` from the calling account.\\n     \\n      Roles are often managed via {grantRole} and {revokeRole}: this function's\\n      purpose is to provide a mechanism for accounts to lose their privileges\\n      if they are compromised (such as when a trusted device is misplaced).\\n     \\n      If the calling account had been revoked `role`, emits a {RoleRevoked}\\n      event.\\n     \\n      Requirements:\\n     \\n      - the caller must be `account`.\\n     \\n      May emit a {RoleRevoked} event.\\n    */\\n    function renounceRole(bytes32 role, address account) internal {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      If `account` had not been already granted `role`, emits a {RoleGranted}\\n      event. Note that unlike {grantRole}, this function doesn't perform any\\n      checks on the calling account.\\n     \\n      May emit a {RoleGranted} event.\\n     \\n      [WARNING]virtual\\n      ====\\n      This function should only be called from the constructor when setting\\n      up the initial roles for the system.\\n     \\n      Using this function in any other way is effectively circumventing the admin\\n      system imposed by {AccessControl}.\\n      ====\\n     \\n      NOTE: This function is deprecated in favor of {_grantRole}.\\n    */\\n    function _setupRole(bytes32 role, address account) internal {\\n        _grantRole(role, account);\\n    }\\n\\n    /*\\n      Sets `adminRole` as ``role``'s admin role.\\n     \\n      Emits a {RoleAdminChanged} event.\\n    */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles()[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      Internal function without access restriction.\\n     \\n      May emit a {RoleGranted} event.\\n    */\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles()[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /*\\n      Revokes `role` from `account`.\\n     \\n      Internal function without access restriction.\\n     \\n      May emit a {RoleRevoked} event.\\n    */\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            _roles()[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/Addresses.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  Common Utility Libraries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    /*\\n      Note: isContract function has some known limitation.\\n      See https://github.com/OpenZeppelin/\\n      openzeppelin-contracts/blob/master/contracts/utils/Address.sol.\\n    */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        if (amount == 0) return;\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don't return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/BlockDirectCall.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  This contract provides means to block direct call of an external function.\\n  A derived contract (e.g. MainDispatcherBase) should decorate sensitive functions with the\\n  notCalledDirectly modifier, thereby preventing it from being called directly, and allowing only\\n  calling using delegate_call.\\n*/\\nabstract contract BlockDirectCall {\\n    address immutable this_;\\n\\n    constructor() {\\n        this_ = address(this);\\n    }\\n\\n    modifier notCalledDirectly() {\\n        require(this_ != address(this), \\\"DIRECT_CALL_DISALLOWED\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/cairo/eth/CairoConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nlibrary CairoConstants {\\n    uint256 public constant FIELD_PRIME =\\n        0x800000000000011000000000000000000000000000000000000000000000001;\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/ContractInitializer.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/**\\n  Interface for contract initialization.\\n  The functions it exposes are the app specific parts of the contract initialization,\\n  and are called by the ProxySupport contract that implement the generic part of behind-proxy\\n  initialization.\\n*/\\nabstract contract ContractInitializer {\\n    /*\\n      The number of sub-contracts that the proxied contract consists of.\\n    */\\n    function numOfSubContracts() internal pure virtual returns (uint256);\\n\\n    /*\\n      Indicates if the proxied contract has already been initialized.\\n      Used to prevent re-init.\\n    */\\n    function isInitialized() internal view virtual returns (bool);\\n\\n    /*\\n      Validates the init data that is passed into the proxied contract.\\n    */\\n    function validateInitData(bytes calldata data) internal view virtual;\\n\\n    /*\\n      For a proxied contract that consists of sub-contracts, this function processes\\n      the sub-contract addresses, e.g. validates them, stores them etc.\\n    */\\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal virtual;\\n\\n    /*\\n      This function applies the logic of initializing the proxied contract state,\\n      e.g. setting root values etc.\\n    */\\n    function initializeContractState(bytes calldata data) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/solidity/Fees.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n// Estimate cost for L1-L2 message handler.\\nuint256 constant DEPOSIT_FEE_GAS = 20000;\\nuint256 constant DEPLOYMENT_FEE_GAS = 100000;\\n\\n// We don't have a solid way to gauge block gas price\\n// (block.basefee cannot be used).\\nuint256 constant DEFAULT_WEI_PER_GAS = 5 * 10**9;\\n\\nabstract contract Fees {\\n    // Effectively no minimum fee on testnet.\\n    uint256 immutable MIN_FEE = (block.chainid == 1) ? 10**12 : 1;\\n    uint256 constant MAX_FEE = 10**16;\\n\\n    function estimateDepositFee() internal pure returns (uint256) {\\n        return DEPOSIT_FEE_GAS * DEFAULT_WEI_PER_GAS;\\n    }\\n\\n    function estimateEnrollmentFee() internal pure returns (uint256) {\\n        return DEPLOYMENT_FEE_GAS * DEFAULT_WEI_PER_GAS;\\n    }\\n\\n    function checkFee(uint256 feeWei) internal view {\\n        require(feeWei >= MIN_FEE, \\\"INSUFFICIENT_FEE_VALUE\\\");\\n        require(feeWei <= MAX_FEE, \\\"FEE_VALUE_TOO_HIGH\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/utils/Felt252.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/cairo/eth/CairoConstants.sol\\\";\\n\\n/**\\n * @dev String to felt functions.\\n *\\n * These functions convert string to felt (felt252) uint value.\\n * The felt value is the Starknet short string representation.\\n *\\n * As felt value is bound by the field prime, it limits the length of the represented string.\\n * For felt252 the limit is 31 characters.\\n *\\n * `safeToFelt()` converts to felt as many as 31 characters of the string.\\n * i.e. for a long string: safeToFelt(string) == toFelt(string[:31]).\\n *\\n * When `toFelt()` accepts a long string - it fails and the call revert.\\n */\\nlibrary Felt252 {\\n    uint256 constant MAX_SHORT_STRING_LENGTH = 31;\\n\\n    /**\\n      Convert a string to felt uint value.\\n      Reverts if the string is longer than 31 characters.\\n     */\\n    function toFelt(string memory shortString) internal pure returns (uint256) {\\n        uint256 length = strlen(shortString);\\n        return strToFelt(shortString, length);\\n    }\\n\\n    /**\\n      Safely convert a string to felt uint value.\\n      For a string up to 31 characters, behaves identically ot `toFelt`.\\n      For longer strings, it returns the felt representation of the first 31 characters.\\n     */\\n    function safeToFelt(string memory string_) internal pure returns (uint256) {\\n        uint256 len = min(MAX_SHORT_STRING_LENGTH, strlen(string_));\\n        return strToFelt(string_, len);\\n    }\\n\\n    function strToFelt(string memory string_, uint256 length) private pure returns (uint256) {\\n        require(length <= MAX_SHORT_STRING_LENGTH, \\\"STRING_TOO_LONG\\\");\\n        uint256 asUint;\\n\\n        // As we process only short strings (<=31 chars),\\n        // we can look no further than the first 32 bytes of the string.\\n        // We convert first 32 bytes of the string to a uint.\\n        assembly {\\n            asUint := mload(add(string_, 32))\\n        }\\n\\n        // We shift left the unused bits, so we don't get lsb zero padding.\\n        // The shift is 8 bits for every unused characters (of the looked at 32 bytes).\\n        uint256 felt252 = asUint >> (8 * (32 - length));\\n        return felt252;\\n    }\\n\\n    /**\\n      Returns string length.\\n     */\\n    function strlen(string memory string_) private pure returns (uint256) {\\n        bytes memory bytes_;\\n        assembly {\\n            bytes_ := string_\\n        }\\n        return bytes_.length;\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\nlibrary UintFelt252 {\\n    function isValidL2Address(uint256 l2Address) internal pure returns (bool) {\\n        return (l2Address != 0 && isFelt(l2Address));\\n    }\\n\\n    function isFelt(uint256 maybeFelt) internal pure returns (bool) {\\n        return (maybeFelt < CairoConstants.FIELD_PRIME);\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/tokens/ERC20/IERC20.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/**\\n  Interface of the ERC20 standard as defined in the EIP. Does not include\\n  the optional functions; to access them see {ERC20Detailed}.\\n*/\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/tokens/ERC20/IERC20Metadata.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n  Interface for the optional metadata functions from the ERC20 standard.\\n*/\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n      Returns the name of the token.\\n    */\\n    function name() external view returns (string memory);\\n\\n    /**\\n      Returns the symbol of the token.\\n    */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n      Returns the decimals places of the token.\\n    */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateBridge.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateBridge {\\n    /**\\n       Enrolls a token in the Starknet Token Bridge system.\\n    */\\n    function enrollToken(address token) external payable;\\n\\n    /**\\n      Deactivates token bridging.\\n      Deactivated token does not accept deposits.\\n     */\\n    function deactivate(address token) external;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateManager.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateManager {\\n    /**\\n      Returns the address of the Starkgate Registry contract.\\n    */\\n    function getRegistry() external view returns (address);\\n\\n    /**\\n      Adds an existing bridge to the Starkgate system for a specific token.\\n     */\\n    function addExistingBridge(address token, address bridge) external;\\n\\n    /**\\n      Deactivates bridging of a specific token.\\n      A deactivated token is blocked for deposits and cannot be re-deployed.     \\n      */\\n    function deactivateToken(address token) external;\\n\\n    /**\\n      Block a specific token from being used in the StarkGate.\\n      A blocked token cannot be deployed.\\n      */\\n    function blockToken(address token) external;\\n\\n    /**\\n      Enrolls a token bridge for a specific token.\\n     */\\n    function enrollTokenBridge(address token) external payable;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateRegistry.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateRegistry {\\n    /**\\n      Returns the bridge that handles the given token.\\n    */\\n    function getBridge(address token) external view returns (address);\\n\\n    /**\\n      Add a mapping between a token and the bridge handling it.\\n    */\\n    function enlistToken(address token, address bridge) external;\\n\\n    /**\\n      Block a specific token from being used in the StarkGate.\\n      A blocked token cannot be deployed.\\n      */\\n    function blockToken(address token) external;\\n\\n    /**\\n      Retrieves a list of bridge addresses that have facilitated withdrawals \\n      for the specified token.\\n     */\\n    function getWithdrawalBridges(address token) external view returns (address[] memory bridges);\\n\\n    /**\\n      Using this function a bridge removes enlisting of its token from the registry.\\n      The bridge must implement `isServicingToken(address token)` (see `IStarkgateService`).\\n     */\\n    function selfRemove(address token) external;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateService.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateService {\\n    /**\\n    Checks whether the calling contract is providing a service for the specified token.\\n    Returns True if the calling contract is providing a service for the token, otherwise false.\\n   */\\n    function isServicingToken(address token) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"starkware/starknet/solidity/IStarknetMessaging.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/starknet/solidity/IStarknetMessagingEvents.sol\\\";\\n\\ninterface IStarknetMessaging is IStarknetMessagingEvents {\\n    /**\\n      Returns the max fee (in Wei) that StarkNet will accept per single message.\\n    */\\n    function getMaxL1MsgFee() external pure returns (uint256);\\n\\n    /**\\n      Returns the msg_fee + 1 for the message with the given 'msgHash',\\n      or 0 if no message with such a hash is pending.\\n    */\\n    function l1ToL2Messages(bytes32 msgHash) external view returns (uint256);\\n\\n    /**\\n      Sends a message to an L2 contract.\\n      This function is payable, the payed amount is the message fee.\\n\\n      Returns the hash of the message and the nonce of the message.\\n    */\\n    function sendMessageToL2(\\n        uint256 toAddress,\\n        uint256 selector,\\n        uint256[] calldata payload\\n    ) external payable returns (bytes32, uint256);\\n\\n    /**\\n      Consumes a message that was sent from an L2 contract.\\n\\n      Returns the hash of the message.\\n    */\\n    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\\n        external\\n        returns (bytes32);\\n\\n    /**\\n      Starts the cancellation of an L1 to L2 message.\\n      A message can be canceled messageCancellationDelay() seconds after this function is called.\\n\\n      Note: This function may only be called for a message that is currently pending and the caller\\n      must be the sender of the that message.\\n    */\\n    function startL1ToL2MessageCancellation(\\n        uint256 toAddress,\\n        uint256 selector,\\n        uint256[] calldata payload,\\n        uint256 nonce\\n    ) external returns (bytes32);\\n\\n    /**\\n      Cancels an L1 to L2 message, this function should be called at least\\n      messageCancellationDelay() seconds after the call to startL1ToL2MessageCancellation().\\n      A message may only be cancelled by its sender.\\n      If the message is missing, the call will revert.\\n\\n      Note that the message fee is not refunded.\\n    */\\n    function cancelL1ToL2Message(\\n        uint256 toAddress,\\n        uint256 selector,\\n        uint256[] calldata payload,\\n        uint256 nonce\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"starkware/starknet/solidity/IStarknetMessagingEvents.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarknetMessagingEvents {\\n    // This event needs to be compatible with the one defined in Output.sol.\\n    event LogMessageToL1(uint256 indexed fromAddress, address indexed toAddress, uint256[] payload);\\n\\n    // An event that is raised when a message is sent from L1 to L2.\\n    event LogMessageToL2(\\n        address indexed fromAddress,\\n        uint256 indexed toAddress,\\n        uint256 indexed selector,\\n        uint256[] payload,\\n        uint256 nonce,\\n        uint256 fee\\n    );\\n\\n    // An event that is raised when a message from L2 to L1 is consumed.\\n    event ConsumedMessageToL1(\\n        uint256 indexed fromAddress,\\n        address indexed toAddress,\\n        uint256[] payload\\n    );\\n\\n    // An event that is raised when a message from L1 to L2 is consumed.\\n    event ConsumedMessageToL2(\\n        address indexed fromAddress,\\n        uint256 indexed toAddress,\\n        uint256 indexed selector,\\n        uint256[] payload,\\n        uint256 nonce\\n    );\\n\\n    // An event that is raised when a message from L1 to L2 Cancellation is started.\\n    event MessageToL2CancellationStarted(\\n        address indexed fromAddress,\\n        uint256 indexed toAddress,\\n        uint256 indexed selector,\\n        uint256[] payload,\\n        uint256 nonce\\n    );\\n\\n    // An event that is raised when a message from L1 to L2 is canceled.\\n    event MessageToL2Canceled(\\n        address indexed fromAddress,\\n        uint256 indexed toAddress,\\n        uint256 indexed selector,\\n        uint256[] payload,\\n        uint256 nonce\\n    );\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/Identity.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface Identity {\\n    /*\\n      Allows a caller to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/solidity/LegacyBridge.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"src/solidity/StarknetTokenBridge.sol\\\";\\nimport \\\"starkware/solidity/components/OverrideLegacyProxyGovernance.sol\\\";\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\n\\n/*\\n  Common implementation for the Upgraded legacy bridges, contains all the legacy relevant\\n  code except for the handling of Eth transfers (vs. ERC20).\\n*/\\nabstract contract LegacyBridge is StarknetTokenBridge, OverrideLegacyProxyGovernance {\\n    /* Legacy events */\\n    event LogDepositCancelRequest(\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce\\n    );\\n    event LogDepositReclaimed(\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce\\n    );\\n    event LogDeposit(\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce,\\n        uint256 fee\\n    );\\n\\n    function bridgedToken() internal view returns (address) {\\n        return NamedStorage.getAddressValue(BRIDGED_TOKEN_TAG);\\n    }\\n\\n    function depositors() internal pure returns (mapping(uint256 => address) storage) {\\n        return NamedStorage.uintToAddressMapping(DEPOSITOR_ADDRESSES_TAG);\\n    }\\n\\n    modifier onlyDepositor(uint256 nonce) {\\n        require(depositors()[nonce] == msg.sender, \\\"ONLY_DEPOSITOR\\\");\\n        _;\\n    }\\n\\n    /*\\n      Upgraded legacy bridge does not support token enrollment.\\n    */\\n    function enrollToken(\\n        address /*token*/\\n    ) external payable virtual override {\\n        revert(\\\"UNSUPPORTED\\\");\\n    }\\n\\n    /// Support Legacy ABI.\\n    /*\\n      Deposit, using the old version ABI.\\n      Note - The actual L1-L2 message sent to the l2-bridge is of the new format.\\n    */\\n    function deposit(uint256 amount, uint256 l2Recipient) external payable {\\n        uint256[] memory noMessage = new uint256[](0);\\n        address token = bridgedToken();\\n        uint256 fee = acceptDeposit(token, amount);\\n        uint256 nonce = sendDepositMessage(\\n            token,\\n            amount,\\n            l2Recipient,\\n            noMessage,\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            fee\\n        );\\n        emitDepositEvent(\\n            token,\\n            amount,\\n            l2Recipient,\\n            noMessage,\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            nonce,\\n            fee\\n        );\\n        // Emits a deposit event of the old ABI, emitted in addition to the new one.\\n        emit LogDeposit(msg.sender, amount, l2Recipient, nonce, fee);\\n    }\\n\\n    function maxTotalBalance() external view returns (uint256) {\\n        return getMaxTotalBalance(bridgedToken());\\n    }\\n\\n    function withdraw(uint256 amount, address recipient) external {\\n        withdraw(bridgedToken(), amount, recipient);\\n    }\\n\\n    function withdraw(uint256 amount) external {\\n        withdraw(bridgedToken(), amount, msg.sender);\\n    }\\n\\n    /*\\n      This comsume message override the base implementation from StarknetTokenBridge,\\n      and supports withdraw of both the new format and the legacy format.\\n    */\\n    function consumeMessage(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) internal virtual override {\\n        require(l2TokenBridge() != 0, \\\"L2_BRIDGE_NOT_SET\\\");\\n        uint256 u_recipient = uint256(uint160(recipient));\\n        uint256 amount_low = amount & (UINT256_PART_SIZE - 1);\\n        uint256 amount_high = amount >> UINT256_PART_SIZE_BITS;\\n\\n        // Compose the new format of L2-L1 consumption.\\n        uint256[] memory payload = new uint256[](5);\\n        payload[0] = TRANSFER_FROM_STARKNET;\\n        payload[1] = u_recipient;\\n        payload[2] = uint256(uint160(token));\\n        payload[3] = amount_low;\\n        payload[4] = amount_high;\\n        // Contain failure of comsumption (e.g. no message to consume).\\n        try messagingContract().consumeMessageFromL2(l2TokenBridge(), payload) {} catch Error(\\n            string memory\\n        ) {\\n            // Upon failure with the new format,\\n            // compose the old format,\\n            // in case the withdrawal was initiated on a bridge with an older version.\\n            payload = new uint256[](4);\\n            payload[0] = TRANSFER_FROM_STARKNET;\\n            payload[1] = u_recipient;\\n            payload[2] = amount_low;\\n            payload[3] = amount_high;\\n            messagingContract().consumeMessageFromL2(l2TokenBridge(), payload);\\n        }\\n    }\\n\\n    // The old version of depositCancelRequest (renamed to avoid confusion).\\n    // Supports cancellation of deposits that were made before the L1 bridge was upgraded.\\n    function legacyDepositCancelRequest(\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256 nonce\\n    ) external onlyDepositor(nonce) {\\n        messagingContract().startL1ToL2MessageCancellation(\\n            l2TokenBridge(),\\n            HANDLE_DEPOSIT_SELECTOR,\\n            legacyDepositMessagePayload(amount, l2Recipient),\\n            nonce\\n        );\\n        emit LogDepositCancelRequest(msg.sender, amount, l2Recipient, nonce);\\n    }\\n\\n    // The old version of depositReclaim (renamed to avoid confusion).\\n    // Supports reclaim of deposits that were made before the L1 bridge was upgraded.\\n    function legacyDepositReclaim(\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256 nonce\\n    ) external onlyDepositor(nonce) {\\n        messagingContract().cancelL1ToL2Message(\\n            l2TokenBridge(),\\n            HANDLE_DEPOSIT_SELECTOR,\\n            legacyDepositMessagePayload(amount, l2Recipient),\\n            nonce\\n        );\\n\\n        transferOutFunds(bridgedToken(), amount, msg.sender);\\n        emit LogDepositReclaimed(msg.sender, amount, l2Recipient, nonce);\\n    }\\n\\n    // Construct the deposit l1-l2 message payload of the older version.\\n    // (renamed to avoid confusion).\\n    function legacyDepositMessagePayload(uint256 amount, uint256 l2Recipient)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory payload = new uint256[](3);\\n        payload[0] = l2Recipient;\\n        payload[1] = amount & (UINT256_PART_SIZE - 1);\\n        payload[2] = amount >> UINT256_PART_SIZE_BITS;\\n        return payload;\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/NamedStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  Library to provide basic storage, in storage location out of the low linear address space.\\n\\n  New types of storage variables should be added here upon need.\\n*/\\nlibrary NamedStorage {\\n    function bytes32ToBoolMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => bool) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function bytes32ToUint256Mapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => uint256) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToUint256Mapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => uint256) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function bytes32ToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function uintToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(uint256 => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToAddressListMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => address[]) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToBoolMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => bool) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function getUintValue(string memory tag_) internal view returns (uint256 retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setUintValue(string memory tag_, uint256 value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setUintValueOnce(string memory tag_, uint256 value) internal {\\n        require(getUintValue(tag_) == 0, \\\"ALREADY_SET\\\");\\n        setUintValue(tag_, value);\\n    }\\n\\n    function getAddressValue(string memory tag_) internal view returns (address retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setAddressValue(string memory tag_, address value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setAddressValueOnce(string memory tag_, address value) internal {\\n        require(getAddressValue(tag_) == address(0x0), \\\"ALREADY_SET\\\");\\n        setAddressValue(tag_, value);\\n    }\\n\\n    function getBoolValue(string memory tag_) internal view returns (bool retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setBoolValue(string memory tag_, bool value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/components/OverrideLegacyProxyGovernance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/RolesLib.sol\\\";\\n\\nstruct GovernanceInfoStruct {\\n    mapping(address => bool) effectiveGovernors;\\n    address candidateGovernor;\\n    bool initialized;\\n}\\n\\n// PROXY_GOVERNANCE_TAG = \\\"StarkEx.Proxy.2019.GovernorsInformation\\\"\\n// LEGACY_PROXY_GOVERNOR_SLOT = Web3.solidityKeccak([\\\"string\\\", \\\"uint256\\\"], [PROXY_GOVERNANCE_TAG, 0]) .\\nbytes32 constant LEGACY_PROXY_GOVERNOR_SLOT = 0x45f38e273862f8834bd2fe7a449988f63de55a7a5b685dea46ccedeb69cf0e26;\\n\\n/**\\n  This contract allows the governance admin (which is the top of the `Roles` heirarchy),\\n  to override the proxy governance.\\n*/\\nabstract contract OverrideLegacyProxyGovernance {\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n\\n    modifier GovernanceAdminOnly() {\\n        require(\\n            AccessControl.hasRole(GOVERNANCE_ADMIN, AccessControl._msgSender()),\\n            \\\"GOVERNANCE_ADMIN_ONLY\\\"\\n        );\\n        _;\\n    }\\n\\n    function legacyProxyGovInfo() private pure returns (GovernanceInfoStruct storage gov) {\\n        bytes32 location = LEGACY_PROXY_GOVERNOR_SLOT;\\n        assembly {\\n            gov.slot := location\\n        }\\n    }\\n\\n    /*\\n      Assigns `account` as proxy governor and clears pending govneror candidate.\\n    */\\n    function assignLegacyProxyGovernor(address account) external GovernanceAdminOnly {\\n        GovernanceInfoStruct storage legacyProxyGov = legacyProxyGovInfo();\\n        legacyProxyGov.effectiveGovernors[account] = true;\\n        delete legacyProxyGov.candidateGovernor;\\n        emit LogNewGovernorAccepted(account);\\n    }\\n\\n    /*\\n      Removes `account` from proxy governor role and clears pending govneror candidate.\\n    */\\n    function removeLegacyProxyGovernor(address account) external GovernanceAdminOnly {\\n        GovernanceInfoStruct storage legacyProxyGov = legacyProxyGovInfo();\\n        legacyProxyGov.effectiveGovernors[account] = false;\\n        delete legacyProxyGov.candidateGovernor;\\n        emit LogRemovedGovernor(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/ProxySupport.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/components/Roles.sol\\\";\\nimport \\\"starkware/solidity/libraries/RolesLib.sol\\\";\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/interfaces/BlockDirectCall.sol\\\";\\nimport \\\"starkware/solidity/interfaces/ContractInitializer.sol\\\";\\n\\n/**\\n  This contract contains the code commonly needed for a contract to be deployed behind\\n  an upgradability proxy.\\n  It perform the required semantics of the proxy pattern,\\n  but in a generic manner.\\n*/\\nabstract contract ProxySupport is BlockDirectCall, ContractInitializer, Roles(true) {\\n    using Addresses for address;\\n\\n    // The two function below (isFrozen & initialize) needed to bind to the Proxy.\\n    function isFrozen() external view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /*\\n      The initialize() function serves as an alternative constructor for a proxied deployment.\\n\\n      Flow and notes:\\n      1. This function cannot be called directly on the deployed contract, but only via\\n         delegate call.\\n      2. If an EIC is provided - init is passed onto EIC and the standard init flow is skipped.\\n         This true for both first intialization or a later one.\\n      3. The data passed to this function is as follows:\\n         [sub_contracts addresses, eic address, initData].\\n\\n         When calling on an initialized contract (no EIC scenario), initData.length must be 0.\\n    */\\n    function initialize(bytes calldata data) external notCalledDirectly {\\n        uint256 eicOffset = 32 * numOfSubContracts();\\n        uint256 expectedBaseSize = eicOffset + 32;\\n        require(data.length >= expectedBaseSize, \\\"INIT_DATA_TOO_SMALL\\\");\\n        address eicAddress = abi.decode(data[eicOffset:expectedBaseSize], (address));\\n\\n        bytes calldata subContractAddresses = data[:eicOffset];\\n\\n        processSubContractAddresses(subContractAddresses);\\n\\n        bytes calldata initData = data[expectedBaseSize:];\\n\\n        // EIC Provided - Pass initData to EIC and the skip standard init flow.\\n        if (eicAddress != address(0x0)) {\\n            callExternalInitializer(eicAddress, initData);\\n            return;\\n        }\\n\\n        if (isInitialized()) {\\n            require(initData.length == 0, \\\"UNEXPECTED_INIT_DATA\\\");\\n        } else {\\n            // Contract was not initialized yet.\\n            validateInitData(initData);\\n            initializeContractState(initData);\\n            RolesLib.initialize();\\n        }\\n    }\\n\\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata eicData)\\n        private\\n    {\\n        require(externalInitializerAddr.isContract(), \\\"EIC_NOT_A_CONTRACT\\\");\\n\\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\\n            abi.encodeWithSelector(this.initialize.selector, eicData)\\n        );\\n        require(success, string(returndata));\\n        require(returndata.length == 0, string(returndata));\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/components/Roles.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/RolesLib.sol\\\";\\n\\nabstract contract Roles {\\n    // This flag dermine if the GOVERNANCE_ADMIN role can be renounced.\\n    bool immutable fullyRenouncable;\\n\\n    constructor(bool renounceable) {\\n        fullyRenouncable = renounceable;\\n        RolesLib.initialize();\\n    }\\n\\n    // MODIFIERS.\\n    modifier onlyAppGovernor() {\\n        require(isAppGovernor(AccessControl._msgSender()), \\\"ONLY_APP_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(isOperator(AccessControl._msgSender()), \\\"ONLY_OPERATOR\\\");\\n        _;\\n    }\\n\\n    modifier onlySecurityAdmin() {\\n        require(isSecurityAdmin(AccessControl._msgSender()), \\\"ONLY_SECURITY_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlySecurityAgent() {\\n        require(isSecurityAgent(AccessControl._msgSender()), \\\"ONLY_SECURITY_AGENT\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenAdmin() {\\n        require(isTokenAdmin(AccessControl._msgSender()), \\\"ONLY_TOKEN_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyUpgradeGovernor() {\\n        require(isUpgradeGovernor(AccessControl._msgSender()), \\\"ONLY_UPGRADE_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    modifier notSelf(address account) {\\n        require(account != AccessControl._msgSender(), \\\"CANNOT_PERFORM_ON_SELF\\\");\\n        _;\\n    }\\n\\n    // Is holding role.\\n    function isAppGovernor(address account) public view returns (bool) {\\n        return AccessControl.hasRole(APP_GOVERNOR, account);\\n    }\\n\\n    function isAppRoleAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function isGovernanceAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function isOperator(address account) public view returns (bool) {\\n        return AccessControl.hasRole(OPERATOR, account);\\n    }\\n\\n    function isSecurityAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function isSecurityAgent(address account) public view returns (bool) {\\n        return AccessControl.hasRole(SECURITY_AGENT, account);\\n    }\\n\\n    function isTokenAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function isUpgradeGovernor(address account) public view returns (bool) {\\n        return AccessControl.hasRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Register Role.\\n    function registerAppGovernor(address account) external {\\n        AccessControl.grantRole(APP_GOVERNOR, account);\\n    }\\n\\n    function registerAppRoleAdmin(address account) external {\\n        AccessControl.grantRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function registerGovernanceAdmin(address account) external {\\n        AccessControl.grantRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function registerOperator(address account) external {\\n        AccessControl.grantRole(OPERATOR, account);\\n    }\\n\\n    function registerSecurityAdmin(address account) external {\\n        AccessControl.grantRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function registerSecurityAgent(address account) external {\\n        AccessControl.grantRole(SECURITY_AGENT, account);\\n    }\\n\\n    function registerTokenAdmin(address account) external {\\n        AccessControl.grantRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function registerUpgradeGovernor(address account) external {\\n        AccessControl.grantRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Revoke Role.\\n    function revokeAppGovernor(address account) external {\\n        AccessControl.revokeRole(APP_GOVERNOR, account);\\n    }\\n\\n    function revokeAppRoleAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function revokeGovernanceAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function revokeOperator(address account) external {\\n        AccessControl.revokeRole(OPERATOR, account);\\n    }\\n\\n    function revokeSecurityAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function revokeSecurityAgent(address account) external {\\n        AccessControl.revokeRole(SECURITY_AGENT, account);\\n    }\\n\\n    function revokeTokenAdmin(address account) external {\\n        AccessControl.revokeRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function revokeUpgradeGovernor(address account) external {\\n        AccessControl.revokeRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Renounce Role.\\n    function renounceRole(bytes32 role, address account) external {\\n        if (role == GOVERNANCE_ADMIN && !fullyRenouncable) {\\n            revert(\\\"CANNOT_RENOUNCE_GOVERNANCE_ADMIN\\\");\\n        }\\n        AccessControl.renounceRole(role, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/RolesLib.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/AccessControl.sol\\\";\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_APP_GOVERNOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant APP_GOVERNOR = bytes32(\\n    uint256(0xd2ead78c620e94b02d0a996e99298c59ddccfa1d8a0149080ac3a20de06068)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_APP_ROLE_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant APP_ROLE_ADMIN = bytes32(\\n    uint256(0x03e615638e0b79444a70f8c695bf8f2a47033bf1cf95691ec3130f64939cee99)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_GOVERNANCE_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant GOVERNANCE_ADMIN = bytes32(\\n    uint256(0x03711c9d994faf6055172091cb841fd4831aa743e6f3315163b06a122c841846)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_OPERATOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant OPERATOR = bytes32(\\n    uint256(0x023edb77f7c8cc9e38e8afe78954f703aeeda7fffe014eeb6e56ea84e62f6da7)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_SECURITY_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant SECURITY_ADMIN = bytes32(\\n    uint256(0x026bd110619d11cfdfc28e281df893bc24828e89177318e9dbd860cdaedeb6b3)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_SECURITY_AGENT\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant SECURITY_AGENT = bytes32(\\n    uint256(0x037693ba312785932d430dccf0f56ffedd0aa7c0f8b6da2cc4530c2717689b96)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_TOKEN_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant TOKEN_ADMIN = bytes32(\\n    uint256(0x0128d63adbf6b09002c26caf55c47e2f26635807e3ef1b027218aa74c8d61a3e)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_UPGRADE_GOVERNOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant UPGRADE_GOVERNOR = bytes32(\\n    uint256(0x0251e864ca2a080f55bce5da2452e8cfcafdbc951a3e7fff5023d558452ec228)\\n);\\n\\n/*\\n  Role                |   Role Admin\\n  ----------------------------------------\\n  GOVERNANCE_ADMIN    |   GOVERNANCE_ADMIN\\n  UPGRADE_GOVERNOR    |   GOVERNANCE_ADMIN\\n  APP_ROLE_ADMIN      |   GOVERNANCE_ADMIN\\n  APP_GOVERNOR        |   APP_ROLE_ADMIN\\n  OPERATOR            |   APP_ROLE_ADMIN\\n  TOKEN_ADMIN         |   APP_ROLE_ADMIN\\n  SECURITY_ADMIN      |   SECURITY_ADMIN\\n  SECURITY_AGENT      |   SECURITY_ADMIN .\\n*/\\nlibrary RolesLib {\\n    // INITIALIZERS.\\n    function governanceRolesInitialized() internal view returns (bool) {\\n        return AccessControl.getRoleAdmin(GOVERNANCE_ADMIN) != bytes32(0x00);\\n    }\\n\\n    function securityRolesInitialized() internal view returns (bool) {\\n        return AccessControl.getRoleAdmin(SECURITY_ADMIN) != bytes32(0x00);\\n    }\\n\\n    function initialize() internal {\\n        address provisional = AccessControl._msgSender();\\n        initialize(provisional, provisional);\\n    }\\n\\n    function initialize(address provisionalGovernor, address provisionalSecAdmin) internal {\\n        if (governanceRolesInitialized()) {\\n            // Support Proxied contract initialization.\\n            // In case the Proxy already initialized the roles,\\n            // init will succeed IFF the provisionalGovernor is already `GovernanceAdmin`.\\n            require(\\n                AccessControl.hasRole(GOVERNANCE_ADMIN, provisionalGovernor),\\n                \\\"ROLES_ALREADY_INITIALIZED\\\"\\n            );\\n        } else {\\n            initGovernanceRoles(provisionalGovernor);\\n        }\\n\\n        if (securityRolesInitialized()) {\\n            // If SecurityAdmin initialized,\\n            // then provisionalSecAdmin must already be a `SecurityAdmin`.\\n            // If it's not initilized - initialize it.\\n            require(\\n                AccessControl.hasRole(SECURITY_ADMIN, provisionalSecAdmin),\\n                \\\"SECURITY_ROLES_ALREADY_INITIALIZED\\\"\\n            );\\n        } else {\\n            initSecurityRoles(provisionalSecAdmin);\\n        }\\n    }\\n\\n    function initSecurityRoles(address provisionalSecAdmin) private {\\n        AccessControl._setRoleAdmin(SECURITY_ADMIN, SECURITY_ADMIN);\\n        AccessControl._setRoleAdmin(SECURITY_AGENT, SECURITY_ADMIN);\\n        AccessControl._grantRole(SECURITY_ADMIN, provisionalSecAdmin);\\n    }\\n\\n    function initGovernanceRoles(address provisionalGovernor) private {\\n        AccessControl._grantRole(GOVERNANCE_ADMIN, provisionalGovernor);\\n        AccessControl._setRoleAdmin(APP_GOVERNOR, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(APP_ROLE_ADMIN, GOVERNANCE_ADMIN);\\n        AccessControl._setRoleAdmin(GOVERNANCE_ADMIN, GOVERNANCE_ADMIN);\\n        AccessControl._setRoleAdmin(OPERATOR, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(TOKEN_ADMIN, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(UPGRADE_GOVERNOR, GOVERNANCE_ADMIN);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/StarkgateConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\n// Starknet L1 handler selectors.\\nuint256 constant HANDLE_DEPOSIT_SELECTOR = 1285101517810983806491589552491143496277809242732141897358598292095611420389;\\nuint256 constant HANDLE_TOKEN_DEPOSIT_SELECTOR = 774397379524139446221206168840917193112228400237242521560346153613428128537;\\n\\nuint256 constant HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR = 247015267890530308727663503380700973440961674638638362173641612402089762826;\\n\\nuint256 constant HANDLE_TOKEN_DEPLOYMENT_SELECTOR = 1737780302748468118210503507461757847859991634169290761669750067796330642876;\\n\\nuint256 constant TRANSFER_FROM_STARKNET = 0;\\nuint256 constant UINT256_PART_SIZE_BITS = 128;\\nuint256 constant UINT256_PART_SIZE = 2**UINT256_PART_SIZE_BITS;\\nuint256 constant MAX_PENDING_DURATION = 5 days;\\naddress constant BLOCKED_TOKEN = address(0x1);\\n\\n// Cairo felt252 value (short string) of 'ETH'\\naddress constant ETH = address(0x455448);\\n\"\r\n    },\r\n    \"src/solidity/StarkgateManager.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"starkware/solidity/components/Roles.sol\\\";\\nimport \\\"starkware/solidity/interfaces/Identity.sol\\\";\\nimport \\\"starkware/solidity/interfaces/ProxySupport.sol\\\";\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\nimport \\\"src/solidity/IStarkgateBridge.sol\\\";\\nimport \\\"src/solidity/IStarkgateManager.sol\\\";\\nimport \\\"src/solidity/IStarkgateRegistry.sol\\\";\\nimport \\\"src/solidity/StarkgateConstants.sol\\\";\\n\\ncontract StarkgateManager is Identity, IStarkgateManager, ProxySupport {\\n    using Addresses for address;\\n    // Named storage slot tags.\\n    string internal constant REGISTRY_TAG = \\\"STARKGATE_MANAGER_REGISTRY_SLOT_TAG\\\";\\n    string internal constant BRIDGE_TAG = \\\"STARKGATE_MANAGER_BRIDGE_SLOT_TAG\\\";\\n    event TokenEnrolled(address indexed token, address indexed sender);\\n    event ExistingBridgeAdded(address indexed token, address indexed bridge);\\n    event TokenDeactivated(address indexed token, address indexed sender);\\n    event TokenBlocked(address indexed token, address indexed sender);\\n\\n    function getRegistry() external view returns (address) {\\n        return registry();\\n    }\\n\\n    // Storage Getters.\\n    // TODO : add doc.\\n    function registry() internal view returns (address) {\\n        return NamedStorage.getAddressValue(REGISTRY_TAG);\\n    }\\n\\n    function bridge() internal view returns (address) {\\n        return NamedStorage.getAddressValue(BRIDGE_TAG);\\n    }\\n\\n    // Storage Setters.\\n    function setRegistry(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(REGISTRY_TAG, contract_);\\n    }\\n\\n    function setBridge(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(BRIDGE_TAG, contract_);\\n    }\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_StarkgateManager_2.0_1\\\";\\n    }\\n\\n    /*\\n      Initializes the contract.\\n    */\\n    function initializeContractState(bytes calldata data) internal override {\\n        (address registry_, address bridge_) = abi.decode(data, (address, address));\\n        setRegistry(registry_);\\n        setBridge(bridge_);\\n    }\\n\\n    function isInitialized() internal view override returns (bool) {\\n        return registry() != address(0);\\n    }\\n\\n    function numOfSubContracts() internal pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /*\\n      No processing needed, as there are no sub-contracts to this contract.\\n    */\\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal override {}\\n\\n    function validateInitData(bytes calldata data) internal view virtual override {\\n        require(data.length == 64, \\\"ILLEGAL_DATA_SIZE\\\");\\n        (address registry_, address bridge_) = abi.decode(data, (address, address));\\n        require(registry_.isContract(), \\\"INVALID_REGISTRY_CONTRACT_ADDRESS\\\");\\n        require(bridge_.isContract(), \\\"INVALID_BRIDGE_CONTRACT_ADDRESS\\\");\\n    }\\n\\n    function addExistingBridge(address token, address bridge_) external onlyTokenAdmin {\\n        require(bridge() != bridge_, \\\"CANNOT_ADD_MAIN_MULTI_BRIDGE_AS_EXISTING\\\");\\n        IStarkgateRegistry(registry()).enlistToken(token, bridge_);\\n        emit ExistingBridgeAdded(token, bridge_);\\n    }\\n\\n    /**\\n      Deactivates bridging of a specific token.\\n      A deactivated token is blocked for deposits and cannot be re-deployed.\\n      Note: Only serviced tokens can be deactivated. In order to block an unserviced tokens\\n      see 'blockToken'.\\n    */\\n    function deactivateToken(address token) external onlyTokenAdmin {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        address current_bridge = registryContract.getBridge(token);\\n\\n        require(current_bridge != address(0), \\\"TOKEN_NOT_ENROLLED\\\");\\n        if (current_bridge == BLOCKED_TOKEN) {\\n            string memory revertMsg = registryContract.getWithdrawalBridges(token).length == 0\\n                ? \\\"TOKEN_ALREADY_BLOCKED\\\"\\n                : \\\"TOKEN_ALREADY_DEACTIVATED\\\";\\n            revert(revertMsg);\\n        }\\n        emit TokenDeactivated(token, msg.sender);\\n        registryContract.blockToken(token);\\n        if (current_bridge == bridge()) {\\n            IStarkgateBridge(bridge()).deactivate(token);\\n        }\\n    }\\n\\n    /**\\n      Block token from being bridged.\\n      A blocked token cannot be deployed.\\n      Note: Only an unserviced token can be blocked. In order to deactivate a serviced tokens\\n        see 'deactivateToken'.\\n    */\\n    function blockToken(address token) external onlyTokenAdmin {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        address current_bridge = registryContract.getBridge(token);\\n        if (current_bridge == address(0)) {\\n            emit TokenBlocked(token, msg.sender);\\n            registryContract.blockToken(token);\\n        } else if (current_bridge == BLOCKED_TOKEN) {\\n            string memory revertMsg = registryContract.getWithdrawalBridges(token).length == 0\\n                ? \\\"TOKEN_ALREADY_BLOCKED\\\"\\n                : \\\"CANNOT_BLOCK_DEACTIVATED_TOKEN\\\";\\n            revert(revertMsg);\\n        } else {\\n            revert(\\\"CANNOT_BLOCK_TOKEN_IN_SERVICE\\\");\\n        }\\n    }\\n\\n    function enrollTokenBridge(address token) external payable {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        require(registryContract.getBridge(token) != BLOCKED_TOKEN, \\\"CANNOT_DEPLOY_BRIDGE\\\");\\n        emit TokenEnrolled(token, msg.sender);\\n        registryContract.enlistToken(token, bridge());\\n        IStarkgateBridge(bridge()).enrollToken{value: msg.value}(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/StarknetERC20Bridge.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"src/solidity/LegacyBridge.sol\\\";\\n\\ncontract StarknetERC20Bridge is LegacyBridge {\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_StarknetERC20Bridge_2.0_4\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/StarknetTokenBridge.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"starkware/solidity/interfaces/Identity.sol\\\";\\nimport \\\"starkware/solidity/interfaces/ProxySupport.sol\\\";\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\nimport \\\"starkware/solidity/libraries/Transfers.sol\\\";\\nimport \\\"starkware/solidity/tokens/ERC20/IERC20.sol\\\";\\nimport \\\"starkware/solidity/tokens/ERC20/IERC20Metadata.sol\\\";\\nimport \\\"starkware/starknet/solidity/IStarknetMessaging.sol\\\";\\nimport \\\"src/solidity/Fees.sol\\\";\\nimport \\\"src/solidity/IStarkgateBridge.sol\\\";\\nimport \\\"src/solidity/IStarkgateManager.sol\\\";\\nimport \\\"src/solidity/IStarkgateRegistry.sol\\\";\\nimport \\\"src/solidity/IStarkgateService.sol\\\";\\nimport \\\"src/solidity/StarkgateConstants.sol\\\";\\nimport \\\"src/solidity/StarkgateManager.sol\\\";\\nimport \\\"src/solidity/StarknetTokenStorage.sol\\\";\\nimport \\\"src/solidity/WithdrawalLimit.sol\\\";\\nimport \\\"src/solidity/utils/Felt252.sol\\\";\\n\\ncontract StarknetTokenBridge is\\n    IStarkgateBridge,\\n    IStarkgateService,\\n    Identity,\\n    Fees,\\n    StarknetTokenStorage,\\n    ProxySupport\\n{\\n    using Addresses for address;\\n    using Felt252 for string;\\n    using UintFelt252 for uint256;\\n\\n    event TokenEnrollmentInitiated(address token, bytes32 deploymentMsgHash);\\n    event TokenDeactivated(address token);\\n\\n    event DepositWithMessage(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256[] message,\\n        uint256 nonce,\\n        uint256 fee\\n    );\\n    event DepositWithMessageCancelRequest(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256[] message,\\n        uint256 nonce\\n    );\\n    event DepositWithMessageReclaimed(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256[] message,\\n        uint256 nonce\\n    );\\n    event Withdrawal(address indexed recipient, address indexed token, uint256 amount);\\n    event SetL2TokenBridge(uint256 value);\\n    event SetMaxTotalBalance(address indexed token, uint256 value);\\n    event Deposit(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce,\\n        uint256 fee\\n    );\\n    event DepositCancelRequest(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce\\n    );\\n    event DepositReclaimed(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 indexed l2Recipient,\\n        uint256 nonce\\n    );\\n    event WithdrawalLimitEnabled(address indexed sender, address indexed token);\\n    event WithdrawalLimitDisabled(address indexed sender, address indexed token);\\n    uint256 constant N_DEPOSIT_PAYLOAD_ARGS = 5;\\n    uint256 constant DEPOSIT_MESSAGE_FIXED_SIZE = 1;\\n\\n    function identify() external pure virtual returns (string memory) {\\n        return \\\"StarkWare_StarknetTokenBridge_2.0_4\\\";\\n    }\\n\\n    function validateInitData(bytes calldata data) internal view virtual override {\\n        require(data.length == 64, \\\"ILLEGAL_DATA_SIZE\\\");\\n        (address manager_, address messagingContract_) = abi.decode(data, (address, address));\\n        require(messagingContract_.isContract(), \\\"INVALID_MESSAGING_CONTRACT_ADDRESS\\\");\\n        require(manager_.isContract(), \\\"INVALID_MANAGER_CONTRACT_ADDRESS\\\");\\n    }\\n\\n    /*\\n      Gets the addresses of bridgedToken & messagingContract from the ProxySupport initialize(),\\n      and sets the storage slot accordingly.\\n    */\\n    function initializeContractState(bytes calldata data) internal override {\\n        (address manager_, address messagingContract_) = abi.decode(data, (address, address));\\n        messagingContract(messagingContract_);\\n        setManager(manager_);\\n        WithdrawalLimit.setWithdrawLimitPct(WithdrawalLimit.DEFAULT_WITHDRAW_LIMIT_PCT);\\n    }\\n\\n    function isInitialized() internal view virtual override returns (bool) {\\n        return address(messagingContract()) != address(0);\\n    }\\n\\n    /*\\n      No processing needed, as there are no sub-contracts to this contract.\\n    */\\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal override {}\\n\\n    function numOfSubContracts() internal pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    modifier onlyManager() {\\n        require(manager() == msg.sender, \\\"ONLY_MANAGER\\\");\\n        _;\\n    }\\n\\n    modifier skipUnlessPending(address token) {\\n        if (tokenSettings()[token].tokenStatus != TokenStatus.Pending) return;\\n        _;\\n    }\\n\\n    modifier onlyServicingToken(address token) {\\n        require(isServicingToken(token), \\\"TOKEN_NOT_SERVICED\\\");\\n        _;\\n    }\\n\\n    function estimateDepositFeeWei() external pure returns (uint256) {\\n        return Fees.estimateDepositFee();\\n    }\\n\\n    function estimateEnrollmentFeeWei() external pure returns (uint256) {\\n        return Fees.estimateEnrollmentFee();\\n    }\\n\\n    // Virtual functions.\\n    function acceptDeposit(address token, uint256 amount) internal virtual returns (uint256) {\\n        Fees.checkFee(msg.value);\\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\\n        require(currentBalance + amount <= getMaxTotalBalance(token), \\\"MAX_BALANCE_EXCEEDED\\\");\\n        Transfers.transferIn(token, msg.sender, amount);\\n        return msg.value;\\n    }\\n\\n    function transferOutFunds(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) internal virtual {\\n        Transfers.transferOut(token, recipient, amount);\\n    }\\n\\n    /**\\n        Initiates the enrollment of a token into the system.\\n        This function is used to initiate the enrollment process of a token.\\n        The token is marked as 'Pending' because the success of the deployment is uncertain at this stage.\\n        The deployment message's existence is checked, indicating that deployment has been attempted.\\n        The success of the deployment is determined at a later stage during the application's lifecycle.\\n        Only the manager, who initiates the deployment, can call this function.\\n\\n        @param token The address of the token contract to be enrolled.\\n        No return value, but it updates the token's status to 'Pending' and records the deployment message and expiration time.\\n        Emits a `TokenEnrollmentInitiated` event when the enrollment is initiated.\\n        Throws an error if the sender is not the manager or if the deployment message does not exist.\\n     */\\n    function enrollToken(address token) external payable virtual onlyManager {\\n        require(\\n            tokenSettings()[token].tokenStatus == TokenStatus.Unknown,\\n            \\\"TOKEN_ALREADY_ENROLLED\\\"\\n        );\\n        // send message.\\n        bytes32 deploymentMsgHash = sendDeployMessage(token);\\n\\n        require(\\n            messagingContract().l1ToL2Messages(deploymentMsgHash) > 0,\\n            \\\"DEPLOYMENT_MESSAGE_NOT_EXIST\\\"\\n        );\\n        tokenSettings()[token].tokenStatus = TokenStatus.Pending;\\n        tokenSettings()[token].deploymentMsgHash = deploymentMsgHash;\\n        tokenSettings()[token].pendingDeploymentExpiration = block.timestamp + MAX_PENDING_DURATION;\\n        emit TokenEnrollmentInitiated(token, deploymentMsgHash);\\n    }\\n\\n    function getStatus(address token) external view returns (TokenStatus) {\\n        return tokenSettings()[token].tokenStatus;\\n    }\\n\\n    function isServicingToken(address token) public view returns (bool) {\\n        TokenStatus status = tokenSettings()[token].tokenStatus;\\n        return (status == TokenStatus.Pending || status == TokenStatus.Active);\\n    }\\n\\n    /**\\n        Returns the remaining amount of withdrawal allowed for this day.\\n        If the daily allowance was not yet set, it is calculated and returned.\\n        If the withdraw limit is not enabled for that token - the uint256.max is returned.\\n     */\\n    function getRemainingIntradayAllowance(address token) external view returns (uint256) {\\n        return\\n            tokenSettings()[token].withdrawalLimitApplied\\n                ? WithdrawalLimit.getRemainingIntradayAllowance(token)\\n                : type(uint256).max;\\n    }\\n\\n    /**\\n        Deactivates a token in the system.\\n        This function is used to deactivate a token that was previously enrolled.\\n        Only the manager, who initiated the enrollment, can call this function.\\n\\n        @param token The address of the token contract to be deactivated.\\n        No return value, but it updates the token's status to 'Deactivated'.\\n        Emits a `TokenDeactivated` event when the deactivation is successful.\\n        Throws an error if the token is not enrolled or if the sender is not the manager.\\n\\n     */\\n    function deactivate(address token) external virtual onlyManager {\\n        require(tokenSettings()[token].tokenStatus != TokenStatus.Unknown, \\\"UNKNOWN_TOKEN\\\");\\n        tokenSettings()[token].tokenStatus = TokenStatus.Deactivated;\\n        emit TokenDeactivated(token);\\n    }\\n\\n    /**\\n        Checks token deployment status.\\n        Relies on Starknet clearing L1-L2 message upon successful completion of deployment.\\n        Processing: Check the l1-l2 deployment message. Set status to `active` If consumed.\\n        If not consumed after the expected duration, it returns the status to unknown.\\n     */\\n    function checkDeploymentStatus(address token) public skipUnlessPending(token) {\\n        TokenSettings storage settings = tokenSettings()[token];\\n        bytes32 msgHash = settings.deploymentMsgHash;\\n\\n        if (messagingContract().l1ToL2Messages(msgHash) == 0) {\\n            settings.tokenStatus = TokenStatus.Active;\\n        } else if (block.timestamp > settings.pendingDeploymentExpiration) {\\n            delete tokenSettings()[token];\\n            address registry = IStarkgateManager(manager()).getRegistry();\\n            IStarkgateRegistry(registry).selfRemove(token);\\n        }\\n    }\\n\\n    function depositWithMessage(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256[] calldata message\\n    ) external payable onlyServicingToken(token) {\\n        uint256 fee = acceptDeposit(token, amount);\\n        uint256 nonce = sendDepositMessage(\\n            token,\\n            amount,\\n            l2Recipient,\\n            message,\\n            HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR,\\n            fee\\n        );\\n        emitDepositEvent(\\n            token,\\n            amount,\\n            l2Recipient,\\n            message,\\n            HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR,\\n            nonce,\\n            fee\\n        );\\n\\n        // Piggy-back the deposit tx to check and update the status of token bridge deployment.\\n        checkDeploymentStatus(token);\\n    }\\n\\n    function deposit(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient\\n    ) external payable onlyServicingToken(token) {\\n        uint256[] memory noMessage = new uint256[](0);\\n        uint256 fee = acceptDeposit(token, amount);\\n        uint256 nonce = sendDepositMessage(\\n            token,\\n            amount,\\n            l2Recipient,\\n            noMessage,\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            fee\\n        );\\n        emitDepositEvent(\\n            token,\\n            amount,\\n            l2Recipient,\\n            noMessage,\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            nonce,\\n            fee\\n        );\\n\\n        // Piggy-back the deposit tx to check and update the status of token bridge deployment.\\n        checkDeploymentStatus(token);\\n    }\\n\\n    function emitDepositEvent(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256[] memory message,\\n        uint256 selector,\\n        uint256 nonce,\\n        uint256 fee\\n    ) internal {\\n        if (selector == HANDLE_TOKEN_DEPOSIT_SELECTOR) {\\n            emit Deposit(msg.sender, token, amount, l2Recipient, nonce, fee);\\n        } else {\\n            require(selector == HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR, \\\"UNKNOWN_SELECTOR\\\");\\n            emit DepositWithMessage(msg.sender, token, amount, l2Recipient, message, nonce, fee);\\n        }\\n    }\\n\\n    function setL2TokenBridge(uint256 l2TokenBridge_) external onlyAppGovernor {\\n        require(isInitialized(), \\\"CONTRACT_NOT_INITIALIZED\\\");\\n        require(l2TokenBridge_.isValidL2Address(), \\\"L2_ADDRESS_OUT_OF_RANGE\\\");\\n        l2TokenBridge(l2TokenBridge_);\\n        emit SetL2TokenBridge(l2TokenBridge_);\\n    }\\n\\n    /**\\n        Set withdrawal limit for a token.\\n     */\\n    function enableWithdrawalLimit(address token) external onlySecurityAgent {\\n        tokenSettings()[token].withdrawalLimitApplied = true;\\n        emit WithdrawalLimitEnabled(msg.sender, token);\\n    }\\n\\n    /**\\n        Unset withdrawal limit for a token.\\n     */\\n    function disableWithdrawalLimit(address token) external onlySecurityAdmin {\\n        tokenSettings()[token].withdrawalLimitApplied = false;\\n        emit WithdrawalLimitDisabled(msg.sender, token);\\n    }\\n\\n    /**\\n       Set the maximum allowed balance of the bridge.\\n       Note: It is possible to set a lower value than the current total balance.\\n       In this case, deposits will not be possible, until enough withdrawls are done, such that the\\n       total balance is below the limit.\\n     */\\n    function setMaxTotalBalance(address token, uint256 maxTotalBalance_) external onlyAppGovernor {\\n        require(maxTotalBalance_ != 0, \\\"INVALID_MAX_TOTAL_BALANCE\\\");\\n        emit SetMaxTotalBalance(token, maxTotalBalance_);\\n        tokenSettings()[token].maxTotalBalance = maxTotalBalance_;\\n    }\\n\\n    // Returns the maximal allowed balance of the bridge\\n    // If the value is 0, it means that there is no limit.\\n    function getMaxTotalBalance(address token) public view returns (uint256) {\\n        uint256 maxTotalBalance = tokenSettings()[token].maxTotalBalance;\\n        return maxTotalBalance == 0 ? type(uint256).max : maxTotalBalance;\\n    }\\n\\n    // The max depsoit limitation is deprecated.\\n    // For Backward compatibility, we return maxUint256, which means no limitation.\\n    function maxDeposit() external pure returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function deployMessagePayload(address token) private view returns (uint256[] memory) {\\n        IERC20Metadata erc20 = IERC20Metadata(token);\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = uint256(uint160(token));\\n        payload[1] = erc20.name().safeToFelt();\\n        payload[2] = erc20.symbol().safeToFelt();\\n        payload[3] = uint256(erc20.decimals());\\n        return payload;\\n    }\\n\\n    function depositMessagePayload(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        bool withMessage,\\n        uint256[] memory message\\n    ) private view returns (uint256[] memory) {\\n        uint256 MESSAGE_OFFSET = withMessage\\n            ? N_DEPOSIT_PAYLOAD_ARGS + DEPOSIT_MESSAGE_FIXED_SIZE\\n            : N_DEPOSIT_PAYLOAD_ARGS;\\n        uint256[] memory payload = new uint256[](MESSAGE_OFFSET + message.length);\\n        payload[0] = uint256(uint160(token));\\n        payload[1] = uint256(uint160(msg.sender));\\n        payload[2] = l2Recipient;\\n        payload[3] = amount & (UINT256_PART_SIZE - 1);\\n        payload[4] = amount >> UINT256_PART_SIZE_BITS;\\n        if (withMessage) {\\n            payload[MESSAGE_OFFSET - 1] = message.length;\\n            for (uint256 i = 0; i < message.length; i++) {\\n                require(message[i].isFelt(), \\\"INVALID_MESSAGE_DATA\\\");\\n                payload[i + MESSAGE_OFFSET] = message[i];\\n            }\\n        }\\n        return payload;\\n    }\\n\\n    function depositMessagePayload(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient\\n    ) private view returns (uint256[] memory) {\\n        uint256[] memory noMessage = new uint256[](0);\\n        return\\n            depositMessagePayload(\\n                token,\\n                amount,\\n                l2Recipient,\\n                false, /*without message*/\\n                noMessage\\n            );\\n    }\\n\\n    function sendDeployMessage(address token) internal returns (bytes32) {\\n        require(l2TokenBridge() != 0, \\\"L2_BRIDGE_NOT_SET\\\");\\n        Fees.checkFee(msg.value);\\n\\n        (bytes32 deploymentMsgHash, ) = messagingContract().sendMessageToL2{value: msg.value}(\\n            l2TokenBridge(),\\n            HANDLE_TOKEN_DEPLOYMENT_SELECTOR,\\n            deployMessagePayload(token)\\n        );\\n        return deploymentMsgHash;\\n    }\\n\\n    function sendDepositMessage(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256[] memory message,\\n        uint256 selector,\\n        uint256 fee\\n    ) internal returns (uint256) {\\n        require(l2TokenBridge() != 0, \\\"L2_BRIDGE_NOT_SET\\\");\\n        require(amount > 0, \\\"ZERO_DEPOSIT\\\");\\n        require(l2Recipient.isValidL2Address(), \\\"L2_ADDRESS_OUT_OF_RANGE\\\");\\n\\n        bool isWithMsg = selector == HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR;\\n        (, uint256 nonce) = messagingContract().sendMessageToL2{value: fee}(\\n            l2TokenBridge(),\\n            selector,\\n            depositMessagePayload(token, amount, l2Recipient, isWithMsg, message)\\n        );\\n\\n        // The function exclusively supports two specific selectors, and any attempt to use an unknown\\n        // selector will result in a transaction failure.\\n        return nonce;\\n    }\\n\\n    function consumeMessage(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) internal virtual {\\n        require(l2TokenBridge() != 0, \\\"L2_BRIDGE_NOT_SET\\\");\\n        uint256[] memory payload = new uint256[](5);\\n        payload[0] = TRANSFER_FROM_STARKNET;\\n        payload[1] = uint256(uint160(recipient));\\n        payload[2] = uint256(uint160(token));\\n        payload[3] = amount & (UINT256_PART_SIZE - 1);\\n        payload[4] = amount >> UINT256_PART_SIZE_BITS;\\n        messagingContract().consumeMessageFromL2(l2TokenBridge(), payload);\\n    }\\n\\n    function withdraw(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) public {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n\\n        // The call to consumeMessage will succeed only if a matching L2->L1 message\\n        // exists and is ready for consumption.\\n        consumeMessage(token, amount, recipient);\\n        // Check if the withdrawal limit is enabled for that token.\\n        if (tokenSettings()[token].withdrawalLimitApplied) {\\n            // If the withdrawal limit is enabled, consume the quota.\\n            WithdrawalLimit.consumeWithdrawQuota(token, amount);\\n        }\\n        transferOutFunds(token, amount, recipient);\\n        emit Withdrawal(recipient, token, amount);\\n    }\\n\\n    function withdraw(address token, uint256 amount) external {\\n        withdraw(token, amount, msg.sender);\\n    }\\n\\n    /*\\n      A deposit cancellation requires two steps:\\n      1. The depositor should send a depositCancelRequest request with deposit details & nonce.\\n      2. After a predetermined time (cancellation delay), the depositor can claim back the funds by\\n         calling depositReclaim (using the same arguments).\\n\\n      Note: As long as the depositReclaim was not performed, the deposit may be processed, even if\\n            the cancellation delay time has already passed. Only the depositor is allowed to cancel\\n            a deposit, and only before depositReclaim was performed.\\n    */\\n    function depositCancelRequest(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256 nonce\\n    ) external {\\n        messagingContract().startL1ToL2MessageCancellation(\\n            l2TokenBridge(),\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            depositMessagePayload(token, amount, l2Recipient),\\n            nonce\\n        );\\n\\n        emit DepositCancelRequest(msg.sender, token, amount, l2Recipient, nonce);\\n    }\\n\\n    /*\\n        See: depositCancelRequest docstring.\\n    */\\n    function depositWithMessageCancelRequest(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256[] calldata message,\\n        uint256 nonce\\n    ) external {\\n        messagingContract().startL1ToL2MessageCancellation(\\n            l2TokenBridge(),\\n            HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR,\\n            depositMessagePayload(\\n                token,\\n                amount,\\n                l2Recipient,\\n                true, /*with message*/\\n                message\\n            ),\\n            nonce\\n        );\\n\\n        emit DepositWithMessageCancelRequest(\\n            msg.sender,\\n            token,\\n            amount,\\n            l2Recipient,\\n            message,\\n            nonce\\n        );\\n    }\\n\\n    function depositWithMessageReclaim(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256[] calldata message,\\n        uint256 nonce\\n    ) external {\\n        messagingContract().cancelL1ToL2Message(\\n            l2TokenBridge(),\\n            HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR,\\n            depositMessagePayload(\\n                token,\\n                amount,\\n                l2Recipient,\\n                true, /*with message*/\\n                message\\n            ),\\n            nonce\\n        );\\n\\n        transferOutFunds(token, amount, msg.sender);\\n        emit DepositWithMessageReclaimed(msg.sender, token, amount, l2Recipient, message, nonce);\\n    }\\n\\n    function depositReclaim(\\n        address token,\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256 nonce\\n    ) external {\\n        messagingContract().cancelL1ToL2Message(\\n            l2TokenBridge(),\\n            HANDLE_TOKEN_DEPOSIT_SELECTOR,\\n            depositMessagePayload(token, amount, l2Recipient),\\n            nonce\\n        );\\n\\n        transferOutFunds(token, amount, msg.sender);\\n        emit DepositReclaimed(msg.sender, token, amount, l2Recipient, nonce);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/StarknetTokenStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\nimport \\\"starkware/starknet/solidity/IStarknetMessaging.sol\\\";\\n\\nabstract contract StarknetTokenStorage {\\n    // Named storage slot tags.\\n    string internal constant BRIDGED_TOKEN_TAG = \\\"STARKNET_ERC20_TOKEN_BRIDGE_TOKEN_ADDRESS\\\";\\n    string internal constant L2_BRIDGE_TAG = \\\"STARKNET_TOKEN_BRIDGE_L2_TOKEN_CONTRACT\\\";\\n    string internal constant MANAGER_TAG = \\\"STARKNET_TOKEN_BRIDGE_MANAGER_SLOT_TAG\\\";\\n    string internal constant MESSAGING_CONTRACT_TAG = \\\"STARKNET_TOKEN_BRIDGE_MESSAGING_CONTRACT\\\";\\n    string internal constant DEPOSITOR_ADDRESSES_TAG = \\\"STARKNET_TOKEN_BRIDGE_DEPOSITOR_ADDRESSES\\\";\\n\\n    enum TokenStatus {\\n        Unknown,\\n        Pending,\\n        Active,\\n        Deactivated\\n    }\\n\\n    struct TokenSettings {\\n        TokenStatus tokenStatus;\\n        bytes32 deploymentMsgHash;\\n        uint256 pendingDeploymentExpiration;\\n        uint256 maxTotalBalance;\\n        bool withdrawalLimitApplied;\\n    }\\n\\n    // Slot = Web3.keccak(text=\\\"TokenSettings_Storage_Slot\\\").\\n    bytes32 constant tokenSettingsSlot =\\n        0xc59c20aaa96597268f595db30ec21108a505370e3266ed3a6515637f16b8b689;\\n\\n    function tokenSettings()\\n        internal\\n        pure\\n        returns (mapping(address => TokenSettings) storage _tokenSettings)\\n    {\\n        assembly {\\n            _tokenSettings.slot := tokenSettingsSlot\\n        }\\n    }\\n\\n    // Storage Getters.\\n    function manager() internal view returns (address) {\\n        return NamedStorage.getAddressValue(MANAGER_TAG);\\n    }\\n\\n    function l2TokenBridge() internal view returns (uint256) {\\n        return NamedStorage.getUintValue(L2_BRIDGE_TAG);\\n    }\\n\\n    function messagingContract() internal view returns (IStarknetMessaging) {\\n        return IStarknetMessaging(NamedStorage.getAddressValue(MESSAGING_CONTRACT_TAG));\\n    }\\n\\n    // Storage Setters.\\n    function setManager(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(MANAGER_TAG, contract_);\\n    }\\n\\n    function l2TokenBridge(uint256 value) internal {\\n        NamedStorage.setUintValueOnce(L2_BRIDGE_TAG, value);\\n    }\\n\\n    function messagingContract(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(MESSAGING_CONTRACT_TAG, contract_);\\n    }\\n}\\n\"\r\n    },\r\n    \"third_party/open_zeppelin/utils/Strings.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/Transfers.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/tokens/ERC20/IERC20.sol\\\";\\n\\nlibrary Transfers {\\n    using Addresses for address;\\n\\n    /*\\n      Transfers funds from sender to this contract.\\n    */\\n    function transferIn(\\n        address token,\\n        address sender,\\n        uint256 amount\\n    ) internal {\\n        if (amount == 0) return;\\n        IERC20 erc20Token = IERC20(token);\\n        uint256 balanceBefore = erc20Token.balanceOf(address(this));\\n        uint256 expectedAfter = balanceBefore + amount;\\n        require(expectedAfter >= balanceBefore, \\\"OVERFLOW\\\");\\n\\n        bytes memory callData = abi.encodeWithSelector(\\n            erc20Token.transferFrom.selector,\\n            sender,\\n            address(this),\\n            amount\\n        );\\n        token.safeTokenContractCall(callData);\\n\\n        uint256 balanceAfter = erc20Token.balanceOf(address(this));\\n        require(balanceAfter == expectedAfter, \\\"INCORRECT_AMOUNT_TRANSFERRED\\\");\\n    }\\n\\n    /*\\n      Transfers funds from this contract to recipient.\\n    */\\n    function transferOut(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        if (amount == 0) return;\\n        IERC20 erc20Token = IERC20(token);\\n        uint256 balanceBefore = erc20Token.balanceOf(address(this));\\n        uint256 expectedAfter = balanceBefore - amount;\\n        require(expectedAfter <= balanceBefore, \\\"UNDERFLOW\\\");\\n\\n        bytes memory callData = abi.encodeWithSelector(\\n            erc20Token.transfer.selector,\\n            recipient,\\n            amount\\n        );\\n        token.safeTokenContractCall(callData);\\n\\n        uint256 balanceAfter = erc20Token.balanceOf(address(this));\\n        require(balanceAfter == expectedAfter, \\\"INCORRECT_AMOUNT_TRANSFERRED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/WithdrawalLimit.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\nimport \\\"starkware/solidity/tokens/ERC20/IERC20.sol\\\";\\nimport \\\"src/solidity/StarkgateConstants.sol\\\";\\n\\n/**\\n    A library to provide withdrawal limit functionality.\\n */\\nlibrary WithdrawalLimit {\\n    uint256 constant DEFAULT_WITHDRAW_LIMIT_PCT = 5;\\n    string internal constant WITHDRAW_LIMIT_PCT_TAG = \\\"WITHDRAWL_LIMIT_WITHDRAW_LIMIT_PCT_SLOT_TAG\\\";\\n    string internal constant INTRADAY_QUOTA_TAG = \\\"WITHDRAWL_LIMIT_INTRADAY_QUOTA_SLOT_TAG\\\";\\n\\n    function getWithdrawLimitPct() internal view returns (uint256) {\\n        return NamedStorage.getUintValue(WITHDRAW_LIMIT_PCT_TAG);\\n    }\\n\\n    function setWithdrawLimitPct(uint256 value) internal {\\n        NamedStorage.setUintValue(WITHDRAW_LIMIT_PCT_TAG, value);\\n    }\\n\\n    // Returns the key for the intraday allowance mapping.\\n    function withdrawQuotaKey(address token) internal view returns (bytes32) {\\n        uint256 day = block.timestamp / 86400;\\n        return keccak256(abi.encode(token, day));\\n    }\\n\\n    /**\\n        Calculates the intraday allowance for a given token.\\n        The allowance is calculated as a percentage of the current balance.\\n     */\\n    function calculateIntradayAllowance(address token) internal view returns (uint256) {\\n        uint256 currentBalance;\\n        // If the token is Eth and not an ERC20 - calculate balance accordingly.\\n        if (token == ETH) {\\n            currentBalance = address(this).balance;\\n        } else {\\n            currentBalance = IERC20(token).balanceOf(address(this));\\n        }\\n        uint256 withdrawLimitPct = getWithdrawLimitPct();\\n        return (currentBalance * withdrawLimitPct) / 100;\\n    }\\n\\n    /**\\n        Returns the intraday quota mapping.\\n     */\\n    function intradayQuota() internal pure returns (mapping(bytes32 => uint256) storage) {\\n        return NamedStorage.bytes32ToUint256Mapping(INTRADAY_QUOTA_TAG);\\n    }\\n\\n    // The offset is used to distinguish between an unset value and a value of 0.\\n    uint256 constant OFFSET = 1;\\n\\n    function isWithdrawQuotaInitialized(address token) private view returns (bool) {\\n        return intradayQuota()[withdrawQuotaKey(token)] != 0;\\n    }\\n\\n    function getIntradayQuota(address token) internal view returns (uint256) {\\n        return intradayQuota()[withdrawQuotaKey(token)] - OFFSET;\\n    }\\n\\n    function setIntradayQuota(address token, uint256 value) private {\\n        intradayQuota()[withdrawQuotaKey(token)] = value + OFFSET;\\n    }\\n\\n    /**\\n        Returns the remaining amount of withdrawal allowed for this day.\\n        If the daily allowance was not yet set, it is calculated and returned.\\n     */\\n    function getRemainingIntradayAllowance(address token) internal view returns (uint256) {\\n        if (!isWithdrawQuotaInitialized(token)) {\\n            return calculateIntradayAllowance(token);\\n        }\\n        return getIntradayQuota(token);\\n    }\\n\\n    /**\\n        Consumes the intraday allowance for a given token.\\n        If the allowance was not yet calculated, it is calculated and consumed.\\n     */\\n    function consumeWithdrawQuota(address token, uint256 amount) internal {\\n        uint256 intradayAllowance = getRemainingIntradayAllowance(token);\\n        require(intradayAllowance >= amount, \\\"EXCEEDS_GLOBAL_WITHDRAW_LIMIT\\\");\\n        setIntradayQuota(token, intradayAllowance - amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"DepositCancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"DepositReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"DepositWithMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"DepositWithMessageCancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"DepositWithMessageReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogDepositCancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogDepositReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetL2TokenBridge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetMaxTotalBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"deploymentMsgHash\",\"type\":\"bytes32\"}],\"name\":\"TokenEnrollmentInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"WithdrawalLimitDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"WithdrawalLimitEnabled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"assignLegacyProxyGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkDeploymentStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"depositCancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"depositReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"}],\"name\":\"depositWithMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"depositWithMessageCancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"message\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"depositWithMessageReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"disableWithdrawalLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enableWithdrawalLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"enrollToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimateDepositFeeWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimateEnrollmentFeeWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMaxTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRemainingIntradayAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum StarknetTokenStorage.TokenStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAppGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAppRoleAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isGovernanceAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSecurityAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSecurityAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isServicingToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTokenAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isUpgradeGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"legacyDepositCancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Recipient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"legacyDepositReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerAppGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerAppRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerGovernanceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerSecurityAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerSecurityAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerUpgradeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeLegacyProxyGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAppGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAppRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeGovernanceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeSecurityAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeSecurityAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeUpgradeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"l2TokenBridge_\",\"type\":\"uint256\"}],\"name\":\"setL2TokenBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalBalance_\",\"type\":\"uint256\"}],\"name\":\"setMaxTotalBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StarknetERC20Bridge", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}