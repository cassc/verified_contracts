{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.8.20 ^0.8.17 ^0.8.4;\r\n\r\n// lib/solady/src/utils/LibString.sol\r\n\r\n/// @notice Library for converting numbers into strings and other string operations.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\r\nlibrary LibString {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The `length` of the output is too small to contain all the hex digits.\r\n    error HexLengthInsufficient();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The constant returned when the `search` is not found in the string.\r\n    uint256 internal constant NOT_FOUND = type(uint256).max;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     DECIMAL OPERATIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits.\r\n            str := add(mload(0x40), 0x80)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            let w := not(0) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 1)`.\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(int256 value) internal pure returns (string memory str) {\r\n        if (value >= 0) {\r\n            return toString(uint256(value));\r\n        }\r\n        unchecked {\r\n            str = toString(uint256(-value));\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We still have some spare memory space on the left,\r\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\r\n            let length := mload(str) // Load the string length.\r\n            mstore(str, 0x2d) // Store the '-' character.\r\n            str := sub(str, 1) // Move back the string pointer by a byte.\r\n            mstore(str, add(length, 1)) // Update the string length.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   HEXADECIMAL OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2 + 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value, length);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexStringNoPrefix(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory str)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\r\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\r\n            // We add 0x20 to the total and round down to a multiple of 0x20.\r\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\r\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let start := sub(str, add(length, length))\r\n            let w := not(1) // Tsk.\r\n            let temp := value\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for {} 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(xor(str, start)) { break }\r\n            }\r\n\r\n            if temp {\r\n                // Store the function selector of `HexLengthInsufficient()`.\r\n                mstore(0x00, 0x2194895a)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2 + 2` bytes.\r\n    function toHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2` bytes.\r\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\r\n            str := add(mload(0x40), 0x80)\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let w := not(1) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\r\n    /// and the alphabets are capitalized conditionally according to\r\n    /// https://eips.ethereum.org/EIPS/eip-55\r\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\r\n        str = toHexString(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\r\n            let o := add(str, 0x22)\r\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\r\n            let t := shl(240, 136) // `0b10001000 << 240`\r\n            for { let i := 0 } 1 {} {\r\n                mstore(add(i, i), mul(t, byte(i, hashed)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\r\n            o := add(o, 0x20)\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(address value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            str := mload(0x40)\r\n\r\n            // Allocate the memory.\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\r\n            mstore(0x40, add(str, 0x80))\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            str := add(str, 2)\r\n            mstore(str, 40)\r\n\r\n            let o := add(str, 0x20)\r\n            mstore(add(o, 40), 0)\r\n\r\n            value := shl(96, value)\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let i := 0 } 1 {} {\r\n                let p := add(o, add(i, i))\r\n                let temp := byte(i, value)\r\n                mstore8(add(p, 1), mload(and(temp, 15)))\r\n                mstore8(p, mload(shr(4, temp)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(raw);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(raw)\r\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\r\n            mstore(str, add(length, length)) // Store the length of the output.\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let o := add(str, 0x20)\r\n            let end := add(raw, length)\r\n\r\n            for {} iszero(eq(raw, end)) {} {\r\n                raw := add(raw, 1)\r\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\r\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\r\n                o := add(o, 2)\r\n            }\r\n            mstore(o, 0) // Zeroize the slot after the string.\r\n            mstore(0x40, and(add(o, 31), not(31))) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   RUNE STRING OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the number of UTF characters in the string.\r\n    function runeCount(string memory s) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mload(s) {\r\n                mstore(0x00, div(not(0), 255))\r\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\r\n                let o := add(s, 0x20)\r\n                let end := add(o, mload(s))\r\n                for { result := 1 } 1 { result := add(result, 1) } {\r\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   BYTE STRING OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // For performance and bytecode compactness, all indices of the following operations\r\n    // are byte (ASCII) offsets, not UTF character offsets.\r\n\r\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\r\n    function replace(string memory subject, string memory search, string memory replacement)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n            let replacementLength := mload(replacement)\r\n\r\n            subject := add(subject, 0x20)\r\n            search := add(search, 0x20)\r\n            replacement := add(replacement, 0x20)\r\n            result := add(mload(0x40), 0x20)\r\n\r\n            let subjectEnd := add(subject, subjectLength)\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                mstore(result, t)\r\n                                result := add(result, 1)\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Copy the `replacement` one word at a time.\r\n                        for { let o := 0 } 1 {} {\r\n                            mstore(add(result, o), mload(add(replacement, o)))\r\n                            o := add(o, 0x20)\r\n                            if iszero(lt(o, replacementLength)) { break }\r\n                        }\r\n                        result := add(result, replacementLength)\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    mstore(result, t)\r\n                    result := add(result, 1)\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n            }\r\n\r\n            let resultRemainder := result\r\n            result := add(mload(0x40), 0x20)\r\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\r\n            // Copy the rest of the string one word at a time.\r\n            for {} lt(subject, subjectEnd) {} {\r\n                mstore(resultRemainder, mload(subject))\r\n                resultRemainder := add(resultRemainder, 0x20)\r\n                subject := add(subject, 0x20)\r\n            }\r\n            result := sub(result, 0x20)\r\n            // Zeroize the slot after the string.\r\n            let last := add(add(result, 0x20), k)\r\n            mstore(last, 0)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), not(31)))\r\n            // Store the length of the result.\r\n            mstore(result, k)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for { let subjectLength := mload(subject) } 1 {} {\r\n                if iszero(mload(search)) {\r\n                    // `result = min(from, subjectLength)`.\r\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\r\n                    break\r\n                }\r\n                let searchLength := mload(search)\r\n                let subjectStart := add(subject, 0x20)\r\n\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                subject := add(subjectStart, from)\r\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\r\n\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(add(search, 0x20))\r\n\r\n                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n\r\n                if iszero(lt(searchLength, 32)) {\r\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                        if iszero(shr(m, xor(mload(subject), s))) {\r\n                            if eq(keccak256(subject, searchLength), h) {\r\n                                result := sub(subject, subjectStart)\r\n                                break\r\n                            }\r\n                        }\r\n                        subject := add(subject, 1)\r\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                    }\r\n                    break\r\n                }\r\n                for {} 1 {} {\r\n                    if iszero(shr(m, xor(mload(subject), s))) {\r\n                        result := sub(subject, subjectStart)\r\n                        break\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = indexOf(subject, search, 0);\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {} 1 {} {\r\n                let searchLength := mload(search)\r\n                let fromMax := sub(mload(subject), searchLength)\r\n                if iszero(gt(fromMax, from)) { from := fromMax }\r\n                if iszero(mload(search)) {\r\n                    result := from\r\n                    break\r\n                }\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\r\n\r\n                subject := add(add(subject, 0x20), from)\r\n                if iszero(gt(subject, subjectSearchEnd)) { break }\r\n                // As this function is not too often used,\r\n                // we shall simply use keccak256 for smaller bytecode size.\r\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                    if eq(keccak256(subject, searchLength), h) {\r\n                        result := sub(subject, add(subjectSearchEnd, 1))\r\n                        break\r\n                    }\r\n                    subject := sub(subject, 1)\r\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns whether `subject` starts with `search`.\r\n    function startsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                iszero(gt(searchLength, mload(subject))),\r\n                eq(\r\n                    keccak256(add(subject, 0x20), searchLength),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `subject` ends with `search`.\r\n    function endsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            let subjectLength := mload(subject)\r\n            // Whether `search` is not longer than `subject`.\r\n            let withinRange := iszero(gt(searchLength, subjectLength))\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                withinRange,\r\n                eq(\r\n                    keccak256(\r\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\r\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\r\n                        searchLength\r\n                    ),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `subject` repeated `times`.\r\n    function repeat(string memory subject, uint256 times)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(or(iszero(times), iszero(subjectLength))) {\r\n                subject := add(subject, 0x20)\r\n                result := mload(0x40)\r\n                let output := add(result, 0x20)\r\n                for {} 1 {} {\r\n                    // Copy the `subject` one word at a time.\r\n                    for { let o := 0 } 1 {} {\r\n                        mstore(add(output, o), mload(add(subject, o)))\r\n                        o := add(o, 0x20)\r\n                        if iszero(lt(o, subjectLength)) { break }\r\n                    }\r\n                    output := add(output, subjectLength)\r\n                    times := sub(times, 1)\r\n                    if iszero(times) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(output, 0)\r\n                // Store the length.\r\n                let resultLength := sub(output, add(result, 0x20))\r\n                mstore(result, resultLength)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\r\n    /// `start` and `end` are byte offsets.\r\n    function slice(string memory subject, uint256 start, uint256 end)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\r\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\r\n            if lt(start, end) {\r\n                result := mload(0x40)\r\n                let resultLength := sub(end, start)\r\n                mstore(result, resultLength)\r\n                subject := add(subject, start)\r\n                let w := not(31)\r\n                // Copy the `subject` one word at a time, backwards.\r\n                for { let o := and(add(resultLength, 31), w) } 1 {} {\r\n                    mstore(add(result, o), mload(add(subject, o)))\r\n                    o := add(o, w) // `sub(o, 0x20)`.\r\n                    if iszero(o) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(add(add(result, 0x20), resultLength), 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 63), w)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\r\n    /// `start` is a byte offset.\r\n    function slice(string memory subject, uint256 start)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = slice(subject, start, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns all the indices of `search` in `subject`.\r\n    /// The indices are byte offsets.\r\n    function indicesOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                subject := add(subject, 0x20)\r\n                search := add(search, 0x20)\r\n                result := add(mload(0x40), 0x20)\r\n\r\n                let subjectStart := subject\r\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Append to `result`.\r\n                        mstore(result, sub(subject, subjectStart))\r\n                        result := add(result, 0x20)\r\n                        // Advance `subject` by `searchLength`.\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                let resultEnd := result\r\n                // Assign `result` to the free memory pointer.\r\n                result := mload(0x40)\r\n                // Store the length of `result`.\r\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\r\n                // Allocate memory for result.\r\n                // We allocate one more word, so this array can be recycled for {split}.\r\n                mstore(0x40, add(resultEnd, 0x20))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\r\n    function split(string memory subject, string memory delimiter)\r\n        internal\r\n        pure\r\n        returns (string[] memory result)\r\n    {\r\n        uint256[] memory indices = indicesOf(subject, delimiter);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(31)\r\n            let indexPtr := add(indices, 0x20)\r\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\r\n            mstore(add(indicesEnd, w), mload(subject))\r\n            mstore(indices, add(mload(indices), 1))\r\n            let prevIndex := 0\r\n            for {} 1 {} {\r\n                let index := mload(indexPtr)\r\n                mstore(indexPtr, 0x60)\r\n                if iszero(eq(index, prevIndex)) {\r\n                    let element := mload(0x40)\r\n                    let elementLength := sub(index, prevIndex)\r\n                    mstore(element, elementLength)\r\n                    // Copy the `subject` one word at a time, backwards.\r\n                    for { let o := and(add(elementLength, 31), w) } 1 {} {\r\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\r\n                        o := add(o, w) // `sub(o, 0x20)`.\r\n                        if iszero(o) { break }\r\n                    }\r\n                    // Zeroize the slot after the string.\r\n                    mstore(add(add(element, 0x20), elementLength), 0)\r\n                    // Allocate memory for the length and the bytes,\r\n                    // rounded up to a multiple of 32.\r\n                    mstore(0x40, add(element, and(add(elementLength, 63), w)))\r\n                    // Store the `element` into the array.\r\n                    mstore(indexPtr, element)\r\n                }\r\n                prevIndex := add(index, mload(delimiter))\r\n                indexPtr := add(indexPtr, 0x20)\r\n                if iszero(lt(indexPtr, indicesEnd)) { break }\r\n            }\r\n            result := indices\r\n            if iszero(mload(delimiter)) {\r\n                result := add(indices, 0x20)\r\n                mstore(result, sub(mload(indices), 2))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a concatenated string of `a` and `b`.\r\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\r\n    function concat(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(31)\r\n            result := mload(0x40)\r\n            let aLength := mload(a)\r\n            // Copy `a` one word at a time, backwards.\r\n            for { let o := and(add(mload(a), 32), w) } 1 {} {\r\n                mstore(add(result, o), mload(add(a, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let bLength := mload(b)\r\n            let output := add(result, mload(a))\r\n            // Copy `b` one word at a time, backwards.\r\n            for { let o := and(add(bLength, 32), w) } 1 {} {\r\n                mstore(add(output, o), mload(add(b, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let totalLength := add(aLength, bLength)\r\n            let last := add(add(result, 0x20), totalLength)\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Stores the length.\r\n            mstore(result, totalLength)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), w))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\r\n    function toCase(string memory subject, bool toUpper)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(subject)\r\n            if length {\r\n                result := add(mload(0x40), 0x20)\r\n                subject := add(subject, 1)\r\n                let flags := shl(add(70, shl(5, toUpper)), 67108863)\r\n                let w := not(0)\r\n                for { let o := length } 1 {} {\r\n                    o := add(o, w)\r\n                    let b := and(0xff, mload(add(subject, o)))\r\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\r\n                    if iszero(o) { break }\r\n                }\r\n                // Restore the result.\r\n                result := mload(0x40)\r\n                // Stores the string length.\r\n                mstore(result, length)\r\n                // Zeroize the slot after the string.\r\n                let last := add(add(result, 0x20), length)\r\n                mstore(last, 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, and(add(last, 31), not(31)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a lowercased copy of the string.\r\n    function lower(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, false);\r\n    }\r\n\r\n    /// @dev Returns an UPPERCASED copy of the string.\r\n    function upper(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, true);\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within HTML tags.\r\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {\r\n                let end := add(s, mload(s))\r\n                result := add(mload(0x40), 0x20)\r\n                // Store the bytes of the packed offsets and strides into the scratch space.\r\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\r\n                mstore(0x1f, 0x900094)\r\n                mstore(0x08, 0xc0000000a6ab)\r\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\r\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\r\n            } iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\r\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\r\n                    mstore8(result, c)\r\n                    result := add(result, 1)\r\n                    continue\r\n                }\r\n                let t := shr(248, mload(c))\r\n                mstore(result, mload(and(t, 31)))\r\n                result := add(result, shr(5, t))\r\n            }\r\n            let last := result\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Restore the result to the start of the free memory.\r\n            result := mload(0x40)\r\n            // Store the length of the result.\r\n            mstore(result, sub(last, add(result, 0x20)))\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), not(31)))\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {\r\n                let end := add(s, mload(s))\r\n                result := add(mload(0x40), 0x20)\r\n                // Store \"\\\\u0000\" in scratch space.\r\n                // Store \"0123456789abcdef\" in scratch space.\r\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\r\n                // into the scratch space.\r\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\r\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\r\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\r\n            } iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                if iszero(lt(c, 0x20)) {\r\n                    if iszero(and(shl(c, 1), e)) {\r\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\r\n                        mstore8(result, c)\r\n                        result := add(result, 1)\r\n                        continue\r\n                    }\r\n                    mstore8(result, 0x5c) // \"\\\\\".\r\n                    mstore8(add(result, 1), c)\r\n                    result := add(result, 2)\r\n                    continue\r\n                }\r\n                if iszero(and(shl(c, 1), 0x3700)) {\r\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\r\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\r\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\r\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\r\n                    result := add(result, 6)\r\n                    continue\r\n                }\r\n                mstore8(result, 0x5c) // \"\\\\\".\r\n                mstore8(add(result, 1), mload(add(c, 8)))\r\n                result := add(result, 2)\r\n            }\r\n            let last := result\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Restore the result to the start of the free memory.\r\n            result := mload(0x40)\r\n            // Store the length of the result.\r\n            mstore(result, sub(last, add(result, 0x20)))\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), not(31)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`.\r\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\r\n        assembly {\r\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\r\n        }\r\n    }\r\n\r\n    /// @dev Packs a single string with its length into a single word.\r\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\r\n    function packOne(string memory a) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We don't need to zero right pad the string,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes.\r\n                    mload(add(a, 0x1f)),\r\n                    // `length != 0 && length < 32`. Abuses underflow.\r\n                    // Assumes that the length is valid and within the block gas limit.\r\n                    lt(sub(mload(a), 1), 0x1f)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks a string packed using {packOne}.\r\n    /// Returns the empty string if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\r\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            result := mload(0x40)\r\n            // Allocate 2 words (1 for the length, 1 for the bytes).\r\n            mstore(0x40, add(result, 0x40))\r\n            // Zeroize the length slot.\r\n            mstore(result, 0)\r\n            // Store the length and bytes.\r\n            mstore(add(result, 0x1f), packed)\r\n            // Right pad with zeroes.\r\n            mstore(add(add(result, 0x20), mload(result)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Packs two strings with their lengths into a single word.\r\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\r\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let aLength := mload(a)\r\n            // We don't need to zero right pad the strings,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes of `a` and `b`.\r\n                    or(\r\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\r\n                        mload(sub(add(b, 0x1e), aLength))\r\n                    ),\r\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\r\n                    // Assumes that the lengths are valid and within the block gas limit.\r\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks strings packed using {packTwo}.\r\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\r\n    function unpackTwo(bytes32 packed)\r\n        internal\r\n        pure\r\n        returns (string memory resultA, string memory resultB)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            resultA := mload(0x40)\r\n            resultB := add(resultA, 0x40)\r\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\r\n            mstore(0x40, add(resultB, 0x40))\r\n            // Zeroize the length slots.\r\n            mstore(resultA, 0)\r\n            mstore(resultB, 0)\r\n            // Store the lengths and bytes.\r\n            mstore(add(resultA, 0x1f), packed)\r\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\r\n            // Right pad with zeroes.\r\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\r\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Directly returns `a` without copying.\r\n    function directReturn(string memory a) internal pure {\r\n        assembly {\r\n            // Assumes that the string does not start from the scratch space.\r\n            let retStart := sub(a, 0x20)\r\n            let retSize := add(mload(a), 0x40)\r\n            // Right pad with zeroes. Just in case the string is produced\r\n            // by a method that doesn't zero right pad.\r\n            mstore(add(retStart, retSize), 0)\r\n            // Store the return offset.\r\n            mstore(retStart, 0x20)\r\n            // End the transaction, returning the string.\r\n            return(retStart, retSize)\r\n        }\r\n    }\r\n}\r\n\r\n// src/interfaces/IAxelarGasReceiverProxy.sol\r\n\r\ninterface IAxelarGasReceiverProxy {\r\n    function payNativeGasForContractCall(\r\n        address sender,\r\n        string memory destinationChain,\r\n        string memory destinationAddress,\r\n        bytes memory payload,\r\n        address refundAddress\r\n    ) external payable;\r\n}\r\n\r\n// src/interfaces/IAxelarGateway.sol\r\n\r\ninterface IAxelarGateway {\r\n    /**\r\n     * \\\r\n     * |* Errors *|\r\n     * \\*********\r\n     */\r\n    error NotSelf();\r\n    error NotProxy();\r\n    error InvalidCodeHash();\r\n    error SetupFailed();\r\n    error InvalidAuthModule();\r\n    error InvalidTokenDeployer();\r\n    error InvalidAmount();\r\n    error InvalidChainId();\r\n    error InvalidCommands();\r\n    error TokenDoesNotExist(string symbol);\r\n    error TokenAlreadyExists(string symbol);\r\n    error TokenDeployFailed(string symbol);\r\n    error TokenContractDoesNotExist(address token);\r\n    error BurnFailed(string symbol);\r\n    error MintFailed(string symbol);\r\n    error InvalidSetMintLimitsParams();\r\n    error ExceedMintLimit(string symbol);\r\n\r\n    /**\r\n     * \\\r\n     * |* Events *|\r\n     * \\*********\r\n     */\r\n    event TokenSent(\r\n        address indexed sender, string destinationChain, string destinationAddress, string symbol, uint256 amount\r\n    );\r\n\r\n    event ContractCall(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationContractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes payload\r\n    );\r\n\r\n    event ContractCallWithToken(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationContractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes payload,\r\n        string symbol,\r\n        uint256 amount\r\n    );\r\n\r\n    event Executed(bytes32 indexed commandId);\r\n\r\n    event TokenDeployed(string symbol, address tokenAddresses);\r\n\r\n    event ContractCallApproved(\r\n        bytes32 indexed commandId,\r\n        string sourceChain,\r\n        string sourceAddress,\r\n        address indexed contractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    );\r\n\r\n    event ContractCallApprovedWithMint(\r\n        bytes32 indexed commandId,\r\n        string sourceChain,\r\n        string sourceAddress,\r\n        address indexed contractAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    );\r\n\r\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\r\n\r\n    event OperatorshipTransferred(bytes newOperatorsData);\r\n\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * \\\r\n     * |* Public Functions *|\r\n     * \\*******************\r\n     */\r\n    function sendToken(\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function callContract(string calldata destinationChain, string calldata contractAddress, bytes calldata payload)\r\n        external;\r\n\r\n    function callContractWithToken(\r\n        string calldata destinationChain,\r\n        string calldata contractAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function isContractCallApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) external view returns (bool);\r\n\r\n    function isContractCallAndMintApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external view returns (bool);\r\n\r\n    function validateContractCall(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash\r\n    ) external returns (bool);\r\n\r\n    function validateContractCallAndMint(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * \\\r\n     * |* Getters *|\r\n     * \\**********\r\n     */\r\n    function authModule() external view returns (address);\r\n\r\n    function tokenDeployer() external view returns (address);\r\n\r\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\r\n\r\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\r\n\r\n    function allTokensFrozen() external view returns (bool);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function tokenAddresses(string memory symbol) external view returns (address);\r\n\r\n    function tokenFrozen(string memory symbol) external view returns (bool);\r\n\r\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\r\n\r\n    function adminEpoch() external view returns (uint256);\r\n\r\n    function adminThreshold(uint256 epoch) external view returns (uint256);\r\n\r\n    function admins(uint256 epoch) external view returns (address[] memory);\r\n\r\n    /**\r\n     * \\\r\n     * |* Admin Functions *|\r\n     * \\******************\r\n     */\r\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\r\n\r\n    function upgrade(address newImplementation, bytes32 newImplementationCodeHash, bytes calldata setupParams)\r\n        external;\r\n\r\n    /**\r\n     * \\\r\n     * |* External Functions *|\r\n     * \\*********************\r\n     */\r\n    function setup(bytes calldata params) external;\r\n\r\n    function execute(bytes calldata input) external;\r\n}\r\n\r\n// src/EthereumStateSender.sol\r\n\r\n/// @title EthereumStateSender\r\n/// @notice Sends weekly period block + block hash to a set of destination chains through Axelar\r\n/// @dev This contract uses Axelar network for cross-chain communication\r\ncontract EthereumStateSender {\r\n    using LibString for address;\r\n\r\n    address public governance;\r\n    address public constant AXELAR_GATEWAY = 0x4F4495243837681061C4743b74B3eEdf548D56A5;\r\n    address public constant AXELAR_GAS_RECEIVER = 0x2d5d7d31F671F86C782533cc367F14109a082712;\r\n\r\n    uint256 public sendBlockHashMinValue = 0.003 ether;\r\n    uint256 public setRecipientMinValue = 0.001 ether;\r\n\r\n    struct ChainContract {\r\n        string chain;\r\n        address[] contracts;\r\n    }\r\n\r\n    ChainContract[] public chains;\r\n    mapping(uint256 => uint256) public blockNumbers;\r\n    mapping(uint256 => bytes32) public blockHashes;\r\n\r\n    mapping(string => uint256) private chainIndex;\r\n    mapping(string => bool) private chainExists;\r\n\r\n    event ChainRemoved(string indexed chain);\r\n    event RecipientMinValueSet(uint256 newValue);\r\n    event SendBlockHashMinValueSet(uint256 newValue);\r\n    event GovernanceChanged(address indexed newGovernance);\r\n    event ChainAdded(string indexed chain, address[] indexed contracts);\r\n    event RecipientSet(address indexed sender, address indexed recipient, string indexed chain);\r\n\r\n    error ChainAlreadyExists();\r\n    error ChainNotFound();\r\n    error GovernanceOnly();\r\n    error InsufficientValue();\r\n    error AlreadySent();\r\n    error TooCloseToCurrentPeriod();\r\n\r\n    constructor(address _governance) payable {\r\n        governance = _governance;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        if (msg.sender != governance) revert GovernanceOnly();\r\n        _;\r\n    }\r\n\r\n    /// @notice Sends the block hash to all contracts on all chains\r\n    /// @dev Requires payment to cover gas fees and checks for timing to avoid too frequent updates\r\n    function sendBlockHash() external payable {\r\n        uint256 currentPeriod = getCurrentPeriod();\r\n        uint256 amountOfContracts = getEnabledContracts();\r\n\r\n        if (msg.value < sendBlockHashMinValue * amountOfContracts) revert InsufficientValue();\r\n        if (block.timestamp < currentPeriod + 5 minutes) revert TooCloseToCurrentPeriod();\r\n        if (blockNumbers[currentPeriod] != 0) revert AlreadySent();\r\n\r\n        ChainContract[] memory chainsToSend = chains;\r\n        uint256 chainsToSendLength = chainsToSend.length;\r\n\r\n        uint256 valuePerContract = msg.value / amountOfContracts;\r\n\r\n        blockNumbers[currentPeriod] = block.number - 1;\r\n        blockHashes[currentPeriod] = blockhash(block.number - 1);\r\n\r\n        for (uint256 i = 0; i < chainsToSendLength;) {\r\n            ChainContract memory chain = chainsToSend[i];\r\n            for (uint256 j = 0; j < chain.contracts.length;) {\r\n                address contractAddress = chain.contracts[j];\r\n                _sendBlockHash(contractAddress, chain.chain, valuePerContract, currentPeriod);\r\n                unchecked {\r\n                    j++;\r\n                }\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Sets the recipient for an address on oracle\r\n    /// @param chain Name of the chain\r\n    /// @param contracts List of contract addresses on the chain\r\n    /// @param recipient Address to set as the recipient\r\n    function setRecipient(string calldata chain, address[] calldata contracts, address recipient) external payable {\r\n        uint256 valuePerContract = msg.value / contracts.length;\r\n        if (!chainExists[chain]) revert ChainNotFound();\r\n        if (valuePerContract < setRecipientMinValue) revert InsufficientValue();\r\n\r\n        for (uint256 i = 0; i < contracts.length;) {\r\n            string memory _destinationContract = contracts[i].toHexStringChecksumed();\r\n            bytes memory payload = abi.encodeWithSignature(\"setRecipient(address,address)\", msg.sender, recipient);\r\n\r\n            IAxelarGasReceiverProxy(AXELAR_GAS_RECEIVER).payNativeGasForContractCall{value: valuePerContract}(\r\n                address(this), chain, _destinationContract, payload, msg.sender\r\n            );\r\n\r\n            IAxelarGateway(AXELAR_GATEWAY).callContract(chain, _destinationContract, payload);\r\n\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit RecipientSet(msg.sender, recipient, chain);\r\n    }\r\n\r\n    function _sendBlockHash(\r\n        address destinationContract,\r\n        string memory destinationChain,\r\n        uint256 value,\r\n        uint256 currentPeriod\r\n    ) internal {\r\n        string memory destinationContractHex = destinationContract.toHexStringChecksumed();\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"setEthBlockHash(uint256,bytes32)\", blockNumbers[currentPeriod], blockHashes[currentPeriod]\r\n        );\r\n\r\n        IAxelarGasReceiverProxy(AXELAR_GAS_RECEIVER).payNativeGasForContractCall{value: value}(\r\n            address(this), destinationChain, destinationContractHex, payload, msg.sender\r\n        );\r\n\r\n        IAxelarGateway(AXELAR_GATEWAY).callContract(destinationChain, destinationContractHex, payload);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    /// --- GOVERNANCE\r\n    ////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Adds a new chain and its associated contracts to the list\r\n    /// @dev Can only be called by the governance address\r\n    /// @param chain Name of the chain\r\n    /// @param contracts List of contract addresses on the new chain\r\n    function addChain(string calldata chain, address[] calldata contracts) external onlyGovernance {\r\n        if (chainExists[chain]) revert ChainAlreadyExists();\r\n        chains.push(ChainContract({chain: chain, contracts: contracts}));\r\n        chainIndex[chain] = chains.length - 1;\r\n        chainExists[chain] = true;\r\n        emit ChainAdded(chain, contracts);\r\n    }\r\n\r\n    /// @notice Removes a chain and its associated contracts from the list\r\n    /// @dev Can only be called by the governance address\r\n    /// @param chain Name of the chain\r\n    function removeChain(string calldata chain) external onlyGovernance {\r\n        if (!chainExists[chain]) revert ChainNotFound();\r\n        uint256 index = chainIndex[chain];\r\n        uint256 lastIndex = chains.length - 1;\r\n        if (index != lastIndex) {\r\n            chains[index] = chains[lastIndex];\r\n            chainIndex[chains[lastIndex].chain] = index;\r\n        }\r\n        chains.pop();\r\n        delete chainIndex[chain];\r\n        delete chainExists[chain];\r\n        emit ChainRemoved(chain);\r\n    }\r\n\r\n    /// @notice Sends the block hash to all contracts on a specific chain\r\n    /// @dev Can only be called by the governance address\r\n    /// @param chain Name of the chain\r\n    /// @param contracts List of contract addresses on the chain\r\n    /// @param blockNumber Block number to send\r\n    /// @param blockHash Block hash to send\r\n    /// @dev Do not care about already sent or too close, only for emergency purposes\r\n    function sendBlockHashEmergency(\r\n        string calldata chain,\r\n        address[] calldata contracts,\r\n        uint256 blockNumber,\r\n        bytes32 blockHash\r\n    ) external payable onlyGovernance {\r\n        if (msg.value < sendBlockHashMinValue * contracts.length) revert InsufficientValue();\r\n\r\n        uint256 valuePerContract = msg.value / contracts.length;\r\n\r\n        for (uint256 i = 0; i < contracts.length;) {\r\n            string memory destinationContractHex = contracts[i].toHexStringChecksumed();\r\n            bytes memory payload = abi.encodeWithSignature(\"setEthBlockHash(uint256,bytes32)\", blockNumber, blockHash);\r\n\r\n            IAxelarGasReceiverProxy(AXELAR_GAS_RECEIVER).payNativeGasForContractCall{value: valuePerContract}(\r\n                address(this), chain, destinationContractHex, payload, msg.sender\r\n            );\r\n\r\n            IAxelarGateway(AXELAR_GATEWAY).callContract(chain, destinationContractHex, payload);\r\n\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setMinValueForSetRecipient(uint256 newValue) external onlyGovernance {\r\n        setRecipientMinValue = newValue;\r\n        emit RecipientMinValueSet(newValue);\r\n    }\r\n\r\n    function setSendBlockHashMinValue(uint256 newValue) external onlyGovernance {\r\n        sendBlockHashMinValue = newValue;\r\n        emit SendBlockHashMinValueSet(newValue);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    /// --- VIEW FUNCTIONS\r\n    ////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Retrieves chain and contract information by index\r\n    /// @param index Index of the chain in the array\r\n    /// @return ChainContract The chain and its contracts\r\n    function getChain(uint256 index) public view returns (ChainContract memory) {\r\n        return chains[index];\r\n    }\r\n\r\n    /// @notice Calculates the current period based on weekly intervals\r\n    /// @return uint256 The start of the current weekly period\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return (block.timestamp / 1 weeks) * 1 weeks;\r\n    }\r\n\r\n    /// @notice Counts all enabled contracts across all chains\r\n    /// @return count Total number of enabled contracts\r\n    function getEnabledContracts() public view returns (uint256 count) {\r\n        uint256 chainsLength = chains.length;\r\n        for (uint256 i = 0; i < chainsLength;) {\r\n            count += chains[i].contracts.length;\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice   Generate proof parameters for a given user, gauge and time\r\n    /// @param    _user The user\r\n    /// @param    _gauge The gauge\r\n    /// @param    _time The time\r\n    function generateEthProofParams(address _user, address _gauge, uint256 _time)\r\n        external\r\n        view\r\n        returns (address, address, uint256, uint256[6] memory _positions, uint256)\r\n    {\r\n        uint256 lastUserVotePosition = uint256(keccak256(abi.encode(keccak256(abi.encode(11, _user)), _gauge)));\r\n        _positions[0] = lastUserVotePosition;\r\n        uint256 pointWeightsPosition =\r\n            uint256(keccak256(abi.encode(keccak256(abi.encode(keccak256(abi.encode(12, _gauge)), _time)))));\r\n        uint256 i;\r\n        for (i = 0; i < 2; i++) {\r\n            _positions[1 + i] = pointWeightsPosition + i;\r\n        }\r\n\r\n        uint256 voteUserSlopePosition =\r\n            uint256(keccak256(abi.encode(keccak256(abi.encode(keccak256(abi.encode(9, _user)), _gauge)))));\r\n        for (i = 0; i < 3; i++) {\r\n            _positions[3 + i] = voteUserSlopePosition + i;\r\n        }\r\n        return (_user, _gauge, _time, _positions, block.number);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadySent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChainAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChainNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernanceOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooCloseToCurrentPeriod\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"ChainAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"name\":\"ChainRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"RecipientMinValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"name\":\"RecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"SendBlockHashMinValueSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AXELAR_GAS_RECEIVER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AXELAR_GATEWAY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"addChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockNumbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chains\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"generateEthProofParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"_positions\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getChain\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"internalType\":\"struct EthereumStateSender.ChainContract\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEnabledContracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"name\":\"removeChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendBlockHash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"sendBlockHashEmergency\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendBlockHashMinValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinValueForSetRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setRecipient\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRecipientMinValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setSendBlockHashMinValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EthereumStateSender", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008898502ba35ab64b3562abc509befb7eb178d4df", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4ec4e35c91379af2469210fd30c7ede74c42068259bfc10506824444a70f3cea"}