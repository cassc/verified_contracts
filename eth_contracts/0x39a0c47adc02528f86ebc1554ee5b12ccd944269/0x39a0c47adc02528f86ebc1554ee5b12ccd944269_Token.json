{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {IERC20Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\\n    struct ERC20Storage {\\n        mapping(address account => uint256) _balances;\\n\\n        mapping(address account => mapping(address spender => uint256)) _allowances;\\n\\n        uint256 _totalSupply;\\n\\n        string _name;\\n        string _symbol;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ERC20\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\\n\\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\\n        assembly {\\n            $.slot := ERC20StorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        $._name = name_;\\n        $._symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            $._totalSupply += value;\\n        } else {\\n            uint256 fromBalance = $._balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                $._balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                $._totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                $._balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        $._allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDataStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.8.24;\\n\\ninterface IDataStoreResponse {\\n    struct DataStoreAddressResponse {\\n        address locker;\\n        address payable proofWallet;\\n        address payable proofStaking;\\n        address proofPassNFT;\\n        address router;\\n    }\\n\\n    struct DataStoreLimitsResponse {\\n        uint initMaxTx;\\n        uint swapTokensAtAmount;\\n        uint maxTxUpper;\\n        uint maxTxLower;\\n        uint maxWalletUpper;\\n        uint maxWalletLower;\\n        uint maxBuyFee;\\n        uint maxSellFee;\\n        uint denominator;\\n    }\\n}\\n\\ninterface IDataStore is IDataStoreResponse {\\n    function getAddresses(string[] memory addrKeys) external view returns (address[] memory);\\n    function getUints(string[] memory uintKeys) external view returns (uint256[] memory);\\n    function getPlatformAddresses() external view returns (DataStoreAddressResponse memory);\\n    function getLimits() external view returns (DataStoreLimitsResponse memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.8.24;\\n\\ninterface IERC721A {\\n    function totalSupply() external returns (uint256);\\n    function ownerOf(uint256) external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITeamFinanceLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.8.24;\\n\\ninterface ITeamFinanceLocker {\\n    function lockToken(\\n        address _tokenAddress,\\n        address _withdrawalAddress,\\n        uint256 _amount,\\n        uint256 _unlockTime,\\n        bool _mintNFT, \\n        address referrer\\n    ) external payable returns (uint256 _id);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"./IDataStore.sol\\\";\\n\\ninterface ITokenWhitelist is IDataStoreResponse {\\n    \\n    struct TokenInfo {\\n        string name;\\n        string symbol;\\n        address owner;\\n        address mainWallet;\\n        address secondaryWallet;\\n        uint256 totalSupply;\\n        uint256 percentToLP;\\n        uint256 lpLockDuration;\\n        uint256 initMaxWallet;\\n        FeeInfo buyFees;\\n        FeeInfo sellFees;\\n        address[] whitelist;\\n        uint256 whitelistDuration;\\n        address rewardToken;\\n    }\\n\\n    struct FeeInfo {\\n        uint256 main;\\n        uint256 secondary;\\n        uint256 liquidity;\\n        uint256 proof;\\n        uint256 total;\\n    }\\n\\n    error ExceedsMaxTxAmount();\\n    error ExceedsMaxWalletAmount();\\n    error InvalidConfiguration();\\n    error TradingNotEnabled();\\n    error NotWhitelisted();\\n\\n}\"\r\n    },\r\n    \"contracts/ProofStandardWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IERC721A.sol\\\";\\nimport \\\"./interfaces/ITeamFinanceLocker.sol\\\";\\nimport \\\"./interfaces/ITokenWhitelist.sol\\\";\\n\\n/// This token was incubated and launched by PROOF: https://proofplatform.io/projects. The smart contract is audited by SourceHat: https://sourcehat.com/\\n\\ncontract Token is ITokenWhitelist, Initializable, ERC20Upgradeable, OwnableUpgradeable {\\n    \\n    struct UserInfo {\\n        bool isFeeExempt;\\n        bool isTxLimitExempt;\\n        bool isWhitelisted;\\n    }\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public pair;\\n\\n    address payable public mainWallet;\\n    address payable public secondaryWallet;\\n\\n    IERC721A public proofPassNFT;\\n\\n    bool public isTradingEnabled;\\n\\n    bool public isWhitelistActive;\\n    uint256 public whitelistEndTime;\\n    uint256 public whitelistDuration;\\n    uint256 public launchedAt;\\n\\n    uint256 public maxTxAmount;\\n    uint256 public maxWallet;\\n    uint256 public initMaxWallet;\\n    bool public restrictWhales;\\n    bool public maxWalletChanged;\\n\\n    uint256 public swapping;\\n    bool public swapEnabled;\\n    uint256 public swapTokensAtAmount;\\n\\n    FeeInfo public feeTokens;\\n    FeeInfo public buyFees;\\n    FeeInfo public sellFees;\\n\\n    uint256 public restingBuyTotal;\\n    uint256 public restingSellTotal;\\n\\n    bool public buyTaxesSettled;\\n    bool public sellTaxesSettled;\\n\\n    bool public proofFeeReduced;\\n    bool public proofFeeRemoved;\\n\\n    uint256 public lockID;\\n    uint256 public lpLockDuration;\\n\\n    mapping (address => UserInfo) public userInfo;\\n\\n    IDataStore public immutable DATA_STORE;\\n    DataStoreAddressResponse public addresses;\\n    DataStoreLimitsResponse public limits;\\n\\n    event SwapAndLiquify(uint256 tokensAutoLiq, uint256 ethAutoLiq);\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n\\n    constructor(IDataStore dataStore) {\\n        DATA_STORE = dataStore;\\n        _disableInitializers();\\n    }\\n    \\n    function initialize(bytes calldata params) initializer public payable {\\n        TokenInfo memory token = abi.decode(params, (TokenInfo));\\n        __ERC20_init(token.name, token.symbol);\\n        __Ownable_init(token.owner);\\n\\n        DataStoreLimitsResponse memory _limits = DATA_STORE.getLimits();\\n        limits = _limits;\\n        \\n        (token.buyFees.proof, token.sellFees.proof) = (2,2);\\n        _validateFees(token.buyFees, token.sellFees);\\n        restingBuyTotal = token.buyFees.total;\\n        restingSellTotal = token.sellFees.total;\\n\\n        token.buyFees.main = 15 - token.buyFees.proof - token.buyFees.secondary - token.buyFees.liquidity;\\n        token.buyFees.total = 15;\\n        token.sellFees.main = 20 - token.sellFees.proof - token.sellFees.secondary - token.sellFees.liquidity;\\n        token.sellFees.total = 20;\\n\\n        buyFees = token.buyFees;\\n        sellFees = token.sellFees;\\n\\n        // set addresses\\n        mainWallet = payable(token.mainWallet);\\n        secondaryWallet = payable(token.secondaryWallet);\\n\\n        DataStoreAddressResponse memory _addresses = DATA_STORE.getPlatformAddresses();\\n        addresses = _addresses;\\n\\n        proofPassNFT = IERC721A(_addresses.proofPassNFT);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_addresses.router);\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        uint256 amountToPair = token.totalSupply * token.percentToLP / 100;\\n        super._update(address(0), address(this), amountToPair); // mint to contract for liquidity\\n\\n        // set basic data\\n\\n        lpLockDuration = token.lpLockDuration;\\n        swapTokensAtAmount = token.totalSupply * _limits.swapTokensAtAmount / _limits.denominator; // 125 / 100000\\n\\n        maxTxAmount = token.totalSupply * _limits.initMaxTx / _limits.denominator;\\n        initMaxWallet = token.initMaxWallet;\\n        maxWallet = token.totalSupply * token.initMaxWallet / 1000;\\n\\n        userInfo[address(this)] = UserInfo(true, true, true);\\n        userInfo[pair].isTxLimitExempt = true;\\n        userInfo[pair].isWhitelisted = true;\\n\\n        whitelistDuration = token.whitelistDuration;\\n        _setWhitelisted(token.whitelist);\\n\\n        super._update(address(0), owner(), token.totalSupply - amountToPair); // mint to owner\\n    }\\n\\n    function launch() external payable onlyOwner lockTheSwap {\\n        if (launchedAt != 0) {\\n            revert InvalidConfiguration();\\n        }\\n\\n        // enable trading\\n        restrictWhales = true;\\n        swapEnabled = true;\\n        whitelistEndTime = block.timestamp + whitelistDuration;\\n        isWhitelistActive = true;\\n        launchedAt = block.timestamp;\\n        isTradingEnabled = true;\\n\\n        // add NFT snapshot\\n        uint256 len = proofPassNFT.totalSupply() + 1;\\n        for (uint256 i = 1; i < len; ) {\\n            userInfo[proofPassNFT.ownerOf(i)].isWhitelisted = true;\\n            unchecked { ++i; }\\n        }\\n\\n        // add liquidity\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        addLiquidity(balanceOf(address(this)), address(this).balance - msg.value, address(this));\\n\\n        // lock liquidity\\n        uint256 lpBalance = IERC20(pair).balanceOf(address(this));\\n        IERC20(pair).approve(addresses.locker, lpBalance);\\n        \\n        lockID = ITeamFinanceLocker(addresses.locker).lockToken{value: msg.value}(pair, msg.sender, lpBalance, block.timestamp + lpLockDuration, false, address(0));\\n    }\\n\\n    function cancel() external onlyOwner {\\n        if (launchedAt != 0) {\\n            revert InvalidConfiguration();\\n        }\\n\\n        // send the tokens and eth back to the owner\\n        super._update(address(this), owner(), balanceOf(address(this)));\\n        address(owner()).call{value: address(this).balance}(\\\"\\\");\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        if (!isTradingEnabled) {\\n            revert TradingNotEnabled();\\n        }\\n\\n        if (swapping == 2 || from == owner() || to == owner() || amount == 0) {\\n            super._update(from, to, amount);\\n            return;\\n        }\\n\\n        UserInfo storage sender = userInfo[from];\\n        UserInfo storage recipient = userInfo[to];\\n\\n        if (isWhitelistActive) {\\n            if (block.timestamp < whitelistEndTime) {\\n                if (!sender.isWhitelisted || !recipient.isWhitelisted)\\n                {\\n                    revert NotWhitelisted();\\n                }\\n            } else {\\n                isWhitelistActive = false;\\n            }\\n        }\\n\\n        //start at anywhere from 0.1% to 0.5%, increase by 0.1%, every 10 blocks, until it reaches 1%\\n        if (!maxWalletChanged) {\\n            uint256 secondsPassed = block.timestamp - launchedAt;\\n            uint256 percentage = initMaxWallet + (secondsPassed / 120);\\n            if (percentage > 9) {\\n                percentage = 10;\\n                maxWalletChanged = true;\\n            }\\n            uint256 newMax = totalSupply() * percentage / 1000;\\n            if (newMax != maxWallet) {\\n                maxWallet = newMax;\\n            }\\n        }\\n\\n        if (restrictWhales) {\\n            if (to == pair && !sender.isTxLimitExempt && amount > maxTxAmount) {\\n                revert ExceedsMaxTxAmount();\\n            }\\n\\n            if (!recipient.isTxLimitExempt && amount + balanceOf(to) > maxWallet) {\\n                revert ExceedsMaxWalletAmount();\\n            }\\n        }\\n\\n        uint256 total = feeTokens.total;\\n        bool canSwap = total >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            swapEnabled &&\\n            from != pair\\n        ) {\\n            processFees(total, swapTokensAtAmount);\\n        }\\n        \\n        if (!sender.isFeeExempt && !recipient.isFeeExempt) {\\n\\n            FeeInfo storage _buyFees = buyFees;\\n            FeeInfo storage _sellFees = sellFees;\\n\\n            if (!proofFeeRemoved) {\\n                uint256 secondsPassed = block.timestamp - launchedAt;\\n                if (!proofFeeReduced && secondsPassed > 1 days) {\\n                    uint256 totalBuy = _buyFees.total - _buyFees.proof;\\n                    if (totalBuy == 0) {\\n                        _buyFees.total = 0;\\n                        _buyFees.proof = 0;\\n                    } else {\\n                        _buyFees.total = totalBuy + 1;\\n                        _buyFees.proof = 1;\\n                    }\\n                    uint256 totalSell = _sellFees.total - _sellFees.proof;\\n                    if (totalSell == 0) {\\n                        _sellFees.total = 0;\\n                        _sellFees.proof = 0;\\n                    } else {\\n                        _sellFees.total = totalSell + 1;\\n                        _sellFees.proof = 1;\\n                    }\\n                    proofFeeReduced = true;\\n                } else if (secondsPassed > 31 days) {\\n                    _buyFees.total -= _buyFees.proof;\\n                    _sellFees.total -= _sellFees.proof;\\n                    _buyFees.proof = 0;\\n                    _sellFees.proof = 0;\\n                    proofFeeRemoved = true;\\n                } else {\\n                    if (!buyTaxesSettled) {\\n                        uint256 restingTotal = restingBuyTotal;\\n                        uint256 feeTotal = restingTotal;\\n                        if (secondsPassed < 1801) {\\n                            feeTotal = 15 - (secondsPassed / 120);\\n                        }\\n                        if (feeTotal <= restingTotal) {\\n                            _buyFees.total = restingTotal;\\n                            _buyFees.main = restingTotal - _buyFees.liquidity - _buyFees.secondary - _buyFees.proof;\\n                            buyTaxesSettled = true;\\n                        } else if (feeTotal != _buyFees.total) {\\n                            _buyFees.total = feeTotal;\\n                            _buyFees.main = feeTotal - _buyFees.liquidity - _buyFees.secondary - _buyFees.proof;\\n                        }\\n                    }\\n                    if (!sellTaxesSettled) {\\n                        uint256 restingTotal = restingSellTotal;\\n                        uint256 feeTotal = restingTotal;\\n                        if (secondsPassed < 2401) {\\n                            feeTotal = 20 - (secondsPassed / 120);\\n                        }\\n                        if (feeTotal <= restingTotal) {\\n                            _sellFees.total = restingTotal;\\n                            _sellFees.main = restingTotal - _sellFees.liquidity - _sellFees.secondary - _sellFees.proof;\\n                            sellTaxesSettled = true;\\n                        } else if (feeTotal != _sellFees.total) {\\n                            _sellFees.total = feeTotal;\\n                            _sellFees.main = feeTotal - _sellFees.liquidity - _sellFees.secondary - _sellFees.proof;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            uint256 fees;\\n            if (to == pair) { //sell\\n                fees = _calculateFees(_sellFees, amount);\\n            } else if (from == pair) { //buy\\n                fees = _calculateFees(_buyFees, amount);\\n            }\\n            if (fees > 0) {\\n                amount -= fees;\\n                super._update(from, address(this), fees);\\n            }\\n        }\\n\\n        super._update(from, to, amount);\\n\\n    }\\n\\n    function _calculateFees(FeeInfo memory feeRate, uint256 amount) internal returns (uint256 fees) {\\n        if (feeRate.total != 0) {\\n            fees = amount * feeRate.total / 100;\\n            \\n            FeeInfo storage _feeTokens = feeTokens;\\n            _feeTokens.main += fees * feeRate.main / feeRate.total;\\n            _feeTokens.secondary += fees * feeRate.secondary / feeRate.total;\\n            _feeTokens.liquidity += fees * feeRate.liquidity / feeRate.total;\\n            _feeTokens.proof += fees * feeRate.proof / feeRate.total;\\n            _feeTokens.total += fees;\\n        }\\n    }\\n\\n    function processFees(uint256 total, uint256 amountToSwap) internal lockTheSwap {\\n        FeeInfo storage _feeTokens = feeTokens;\\n\\n        FeeInfo memory swapTokens;\\n        swapTokens.main = amountToSwap * _feeTokens.main / total;\\n        swapTokens.secondary = amountToSwap * _feeTokens.secondary / total;\\n        swapTokens.liquidity = amountToSwap * _feeTokens.liquidity / total;\\n        swapTokens.proof = amountToSwap * _feeTokens.proof / total;\\n\\n        uint256 amountToPair = swapTokens.liquidity / 2;\\n\\n        swapTokens.total = amountToSwap - amountToPair;\\n\\n        uint256 ethBalance = swapTokensForETH(swapTokens.total);\\n\\n        FeeInfo memory ethSplit;\\n\\n        ethSplit.main = ethBalance * swapTokens.main / swapTokens.total;\\n        if (ethSplit.main > 0) {\\n           address(mainWallet).call{value: ethSplit.main}(\\\"\\\");\\n        }\\n\\n        ethSplit.secondary = ethBalance * swapTokens.secondary / swapTokens.total;\\n        if (ethSplit.secondary > 0) {\\n            address(secondaryWallet).call{value: ethSplit.secondary}(\\\"\\\");\\n        }\\n\\n        ethSplit.proof = ethBalance * swapTokens.proof / swapTokens.total;\\n        if (ethSplit.proof > 0) {\\n            uint256 revenueSplit = ethSplit.proof / 2;\\n            address(addresses.proofStaking).call{value: revenueSplit}(\\\"\\\");\\n            address(addresses.proofWallet).call{value: ethSplit.proof - revenueSplit}(\\\"\\\");\\n        }\\n\\n        uint256 amountPaired;\\n        ethSplit.liquidity = address(this).balance;\\n        if (amountToPair > 0 && ethSplit.liquidity > 0) {\\n            amountPaired = addLiquidity(amountToPair, ethSplit.liquidity, address(0xdead));\\n            emit SwapAndLiquify(amountToPair, ethSplit.liquidity);\\n        }\\n\\n        uint256 liquidityAdjustment = swapTokens.liquidity - (amountToPair - amountPaired);\\n\\n        _feeTokens.main -= swapTokens.main;\\n        _feeTokens.secondary -= swapTokens.secondary;\\n        _feeTokens.liquidity -= liquidityAdjustment;\\n        _feeTokens.proof -= swapTokens.proof;\\n        _feeTokens.total -= swapTokens.main + swapTokens.secondary + swapTokens.proof + liquidityAdjustment;\\n    }\\n\\n    function swapTokensForETH(uint256 tokenAmount) internal returns (uint256 ethBalance) {\\n        uint256 ethBalBefore = address(this).balance;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        ethBalance = address(this).balance - ethBalBefore;\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount, address recipient) private returns (uint256) {\\n        (uint256 amountA,,) = uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            recipient,\\n            block.timestamp\\n        );\\n        return amountA;\\n    }\\n\\n    function changeFees(\\n        uint256 liquidityBuy,\\n        uint256 mainBuy,\\n        uint256 secondaryBuy,\\n        uint256 liquiditySell,\\n        uint256 mainSell,\\n        uint256 secondarySell\\n    ) external onlyOwner {\\n        if (!buyTaxesSettled || !sellTaxesSettled) {\\n            revert InvalidConfiguration();\\n        }\\n        FeeInfo memory _buyFees;\\n        _buyFees.liquidity = liquidityBuy;\\n        _buyFees.main = mainBuy;\\n        _buyFees.secondary = secondaryBuy;\\n\\n        FeeInfo memory _sellFees;\\n        _sellFees.liquidity = liquiditySell;\\n        _sellFees.main = mainSell;\\n        _sellFees.secondary = secondarySell;\\n\\n        (_buyFees.proof, _sellFees.proof) = launchedAt != 0 ? _calculateProofFee() : (2,2);\\n        _validateFees(_buyFees, _sellFees);\\n        buyFees = _buyFees;\\n        sellFees = _sellFees;\\n    }\\n\\n    function _calculateProofFee() internal returns (uint256, uint256) {\\n        uint256 secondsPassed = block.timestamp - launchedAt;\\n        if (secondsPassed > 31 days) {\\n            proofFeeRemoved = true;\\n            return (0,0);\\n        } else if (secondsPassed > 1 days) {\\n            proofFeeReduced = true;\\n            return (1,1);\\n        } else {\\n            return (2,2);\\n        }\\n    }\\n\\n    function _validateFees(FeeInfo memory _buyFees, FeeInfo memory _sellFees) internal view {\\n        _buyFees.total = _buyFees.liquidity + _buyFees.main + _buyFees.secondary;\\n        if (_buyFees.total == 0) {\\n            _buyFees.proof = 0;\\n        } else {\\n             _buyFees.total += _buyFees.proof;\\n        }\\n\\n        _sellFees.total = _sellFees.liquidity + _sellFees.main + _sellFees.secondary;\\n        if (_sellFees.total == 0) {\\n            _sellFees.proof = 0;\\n        } else {\\n            _sellFees.total += _sellFees.proof;\\n        }\\n\\n        if (_buyFees.total > limits.maxBuyFee || _sellFees.total > limits.maxSellFee) {\\n            revert InvalidConfiguration();\\n        }\\n\\n    }\\n\\n    function setMaxTxAmount(uint256 _maxTxAmt) external onlyOwner() {\\n        DataStoreLimitsResponse storage _limits = limits;\\n        if (launchedAt == 0 ||\\n            _maxTxAmt < (totalSupply() * _limits.maxTxLower) / _limits.denominator ||\\n            _maxTxAmt > (totalSupply() * _limits.maxTxUpper) / _limits.denominator\\n           ) {\\n            revert InvalidConfiguration();\\n        }\\n        maxTxAmount = _maxTxAmt;\\n    }\\n\\n    function setMaxWalletSize(uint256 _maxWalletSize) external onlyOwner() {\\n        DataStoreLimitsResponse storage _limits = limits;\\n        if (launchedAt == 0 ||\\n            _maxWalletSize < (totalSupply() * _limits.maxWalletLower) / _limits.denominator ||\\n            _maxWalletSize > (totalSupply() * _limits.maxWalletUpper) / _limits.denominator\\n           ) {\\n            revert InvalidConfiguration();\\n        }\\n        maxWallet = _maxWalletSize;\\n        maxWalletChanged = true;\\n    }\\n\\n    function setRestrictWhalesEnabled(bool _enabled) external onlyOwner{\\n        restrictWhales = _enabled;\\n    }\\n\\n    function setFeeExempt(address account, bool value) public onlyOwner {\\n        userInfo[account].isFeeExempt = value;\\n    }\\n\\n    function setFeeExempt(address[] memory accounts) public onlyOwner {\\n        uint256 len = accounts.length;\\n        for (uint256 i; i < len; i++) {\\n            userInfo[accounts[i]].isFeeExempt = true;\\n        }\\n    }\\n\\n    function setTxLimitExempt(address account, bool value) public onlyOwner {\\n        userInfo[account].isTxLimitExempt = value;\\n    }\\n\\n    function setTxLimitExempt(address[] memory accounts) public onlyOwner {\\n        uint256 len = accounts.length;\\n        for (uint256 i; i < len; i++) {\\n            userInfo[accounts[i]].isTxLimitExempt = true;\\n        }\\n    }\\n\\n    function setMainWallet(address newWallet) external onlyOwner {\\n        mainWallet = payable(newWallet);\\n    }\\n\\n    function setSecondaryWallet(address newWallet) external onlyOwner {\\n        secondaryWallet = payable(newWallet);\\n    }\\n\\n    function setSwapAndLiquifyEnabled(bool _enabled) external onlyOwner {\\n        swapEnabled = _enabled;\\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\\n    }\\n\\n    function setSwapAtAmount(uint256 amount) external onlyOwner {\\n        swapTokensAtAmount = amount;\\n    }\\n\\n    function setWhitelisted(address[] memory accounts) external onlyOwner {\\n        if (launchedAt != 0) {\\n            revert InvalidConfiguration();\\n        }\\n        _setWhitelisted(accounts);\\n    }\\n\\n    function _setWhitelisted(address[] memory accounts) internal {\\n        uint256 len = accounts.length;\\n        for (uint256 i; i < len; i++) {\\n            userInfo[accounts[i]].isWhitelisted = true;\\n        }\\n    }\\n\\n    function withdrawStuckTokens() external onlyOwner {\\n        super._update(address(this), _msgSender(), balanceOf(address(this)) - feeTokens.total);\\n    }\\n\\n    function getCirculatingSupply() external view returns (uint256) {\\n        return totalSupply() - balanceOf(address(0xdead));\\n    }\\n\\n    modifier lockTheSwap() {\\n        swapping = 2;\\n        _;\\n        swapping = 1;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function version() public pure returns (uint8) {\\n        return 1;\\n    }\\n\\n    receive() external payable {}\\n \\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IDataStore\",\"name\":\"dataStore\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxTxAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxWalletAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConfiguration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradingNotEnabled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAutoLiq\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAutoLiq\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATA_STORE\",\"outputs\":[{\"internalType\":\"contract IDataStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"proofWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"proofStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proofPassNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"main\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondary\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proof\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxesSettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondaryBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondarySell\",\"type\":\"uint256\"}],\"name\":\"changeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"main\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondary\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proof\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initMaxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelistActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initMaxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTokensAtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTxUpper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTxLower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletUpper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletLower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletChanged\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofFeeReduced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofFeeRemoved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofPassNFT\",\"outputs\":[{\"internalType\":\"contract IERC721A\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restingBuyTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restingSellTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictWhales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"main\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondary\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proof\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxesSettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setMainWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTxAmt\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWalletSize\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRestrictWhalesEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setSecondaryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"setTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isFeeExempt\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTxLimitExempt\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008a85eb1fff988a1b01136279174c969d681a0151", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}