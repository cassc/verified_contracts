{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/emeralds.sol\": {\r\n      \"content\": \"//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28e4\u28f6\u28fe\u28ff\u28f7\u28fe\u28ff\u28ff\u28ff\u28ff\u28f6\u28fe\u28ff\u28ff\u28f6\u28e6\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u281b\u2809\u2889\u287d\u288b\u28d9\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28e6\u28c0\u2800\u2880\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28db\u28db\u28d3\u28d2\u2836\u28a4\u28fe\u2800\u2800\u2838\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2833\u28ff\u28f7\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u2844\u2800\u2800\u28b3\u28e6\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2844\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u283f\u28ff\u2866\u2800\u2800\u283b\u283f\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28f7\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28bf\u284f\u2800\u281c\u2874\u2801\u2800\u2800\u2800\u2840\u2800\u2800\u2809\u2809\u2832\u28a6\u2840\u2800\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28f7\u287e\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2800\u2800\u28f8\u2800\u2800\u2800\u28a7\u2800\u2800\u2800\u2800\u2839\u2812\u28a4\u28c0\u2800\u2800\u2801\u2808\u28a2\u2800\\n//   \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28ff\u28df\u2800\u2800\u2808\u283b\u28ff\u280f\u28a8\u2814\u28a6\u2808\u28bb\u28ff\u287c\u280b\u2880\u28e4\u28f6\u28f6\u28ff\u28ff\u28ff\u28c4\u28a0\u28c0\u285c\u2806\u2800\u2880\u2860\u2834\u2812\u2802\u2808\u28bb\u28a6\u2840\u2800\u2808\u2847\\n//   \u2800\u2800\u2880\u28f6\u28ff\u28f7\u2800\u2800\u2818\u28ff\u2844\u2800\u2810\u28f6\u28ac\u28c7\u2809\u28a3\u2878\u2800\u28f0\u28ff\u28c1\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28bf\u28fd\u285b\u28e7\u2814\u2812\u284f\u28c0\u2800\u2800\u28c0\u28c0\u28fe\u2800\u2811\u2822\u2824\u2803\\n//   \u2800\u28f4\u285f\u28fe\u285f\u28ff\u2847\u28c0\u28fc\u28ff\u28ff\u28e6\u2840\u2800\u2819\u283b\u2846\u2800\u2807\u28b0\u281f\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28f7\u287f\u281f\u28c7\u2800\u2800\u2899\u28f0\u28fa\u28fd\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\\n//   \u28b8\u287f\u28b8\u287f\u28f0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2874\u2803\u2800\u2800\u28b8\u2840\u2800\u28b9\u28ff\u28ff\u28ff\u28ff\u28ff\u28b9\u28ff\u28ff\u28ef\u28c0\u28c0\u28c0\u28ed\u28cf\u2801\u2800\u2800\u2808\u283b\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\\n//   \u28ff\u2847\u28b8\u2857\u28b8\u281b\u28ff\u284d\u2809\u2819\u281b\u283b\u28ad\u28fb\u28ff\u28e7\u2800\u2800\u2880\u28f4\u2837\u28c4\u2840\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u287b\u2846\u2800\u2800\u2800\u2800\u2819\u2807\u2800\u2800\u2800\u2800\u2800\\n//   \u28ff\u2847\u28b8\u28f7\u28fd\u2836\u281b\u28b7\u2840\u28e0\u2824\u28a4\u28fe\u28ff\u28ff\u28fd\u28de\u28ff\u28ed\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2859\u28bf\u28ff\u2809\u281b\u28bf\u28ff\u28f7\u2847\u2800\u2880\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//   \u28ff\u28c7\u28fc\u28bf\u2801\u2800\u2800\u28a0\u2877\u2847\u28a0\u28f6\u287d\u28ff\u280b\u2809\u28bb\u283f\u281b\u280b\u2809\u2809\u28b9\u2809\u28bb\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2876\u288f\u2860\u283f\u28ff\u28f7\u285e\u281b\u2819\u28b3\u28e6\u2840\u2800\u2800\u2800\u2800\u2800\\n//   \u28ff\u284f\u28a0\u284b\u28c6\u2800\u2800\u285e\u2800\u2807\u2808\u28bf\u28ff\u28cf\u2800\u2800\u2838\u2840\u2800\u2800\u2800\u2880\u285e\u2800\u28b8\u28b8\u28ff\u284f\u281b\u281b\u281b\u2809\u28e0\u280b\u28e0\u2800\u2838\u2827\u28bb\u285d\u28b7\u2844\u28bf\u28f7\u2800\u2800\u2800\u2800\u2800\\n//   \u28b8\u28e7\u2838\u2879\u284c\u2886\u28f4\u28ff\u2840\u2800\u2800\u2808\u283b\u283f\u28c6\u2800\u2800\u2833\u28c4\u28f0\u28da\u2809\u2809\u2809\u283b\u28fe\u28ff\u287b\u28e6\u28c0\u28e0\u28f4\u2837\u281f\u28fb\u2800\u2800\u2800\u28b8\u2847\u28b8\u28e7\u28a8\u28ff\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u28bf\u28c7\u2813\u2803\u28fc\u28c7\u2848\u283b\u28c4\u2800\u2830\u28a6\u28c0\u2880\u28f7\u2844\u2800\u2800\u2800\u2808\u2809\u2813\u2864\u28c4\u2848\u287f\u28ff\u28f7\u28f6\u28f6\u28f6\u28fe\u28ff\u281f\u2880\u2806\u2800\u287e\u28b7\u28fe\u2847\u28fc\u285f\u2800\u2800\u2800\u2800\u2800\\n//   \u2800\u2808\u28bf\u28b7\u28de\u281b\u28ff\u28ff\u28e4\u284d\u2833\u28e4\u28e4\u28e4\u287f\u2817\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u2800\u2839\u2845\u2800\u2808\u2809\u2809\u2809\u283b\u28e4\u2814\u281a\u2812\u280a\u2800\u2800\u2808\u28ff\u287f\u2803\u2800\u2800\u2800\u2800\u2800\\n//  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2588   \u2588\u2588\u2877\u2800\u2800\u2800\u2880\u28f4\u281e\u2813\u2832\u2826\u28e4\u2840\u2800\u2800\u28e0\u287f\u2801\u2800\u2800                    \\n// \u2588\u2588          \u2588\u2588     \u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u28c3\u28e4\u2836\u281e\u28eb\u28e4\u28df\u28db\u28f7\u28f6\u28ff\u289f\u2866\u28fe\u281f\u2800\u2800\u2800                    \\n// \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588   \u2588\u2588   \u2588\u2588\u284f\u283e\u283f\u28f6\u28ff\u28ff\u28ff\u283f\u28db\u28fd\u28fe\u287f\u281a\u2801\u2800                    \\n//      \u2588\u2588 \u2588\u2588  \u2588\u2588   \u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2800\u28e0\u280f\u2809\u281b\u2833\u2836\u28b6\u28f6\u287f\u283f\u281f\u280a\u2809\u2800                    \\n// \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588        \u2588\u2588  \u2588\u2588\u2588\u2588\u2801\u2800\u2800\u2800\u2800\u2800\u28c0\u28c0\u28c0\u2840  \\n\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588    \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \\n// \u2588\u2588      \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588      \\n// \u2588\u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n// \u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588      \u2588\u2588 \\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// A public demonstration in single-contract dual-token implementations\\n// with zero-conflict events, and function overloading.\\n// https://github.com/SerecThunderson/SJ741\\n// https://t.me/partyhat\\n// SJ741 EMERALDS\\n\\n// WARNING - Fungible NFT specs are universally new, and inherently DANGEROUS\\n// no systems have been built with these usecases in mind, and there are a number of \\n// ways that experimental, complex contracts can lead to unforseen consequences.\\n// INTERACT WITH EXPERIMENTAL SMART CONTRACTS AT YOUR OWN RISK\\n\\n//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// libraries to separate ERC20 and ERC721 events, and certain signature-specific functions\\n// ERC20 events\\nlibrary libSJ20 {\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function emitTransfer(address _from, address _to, uint _amount) internal { emit Transfer(_from, _to, _amount); }\\n    function emitApproval(address _owner, address _spender, uint _value) internal { emit Approval(_owner, _spender, _value); }\\n}\\n\\n// ERC721 events\\nlibrary libSJ721 {\\n    event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId);\\n    event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId);\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n    function emitTransfer(address _from, address _to, uint _tokenId) internal { emit Transfer(_from, _to, _tokenId); }\\n    function emitApproval(address _owner, address _approve, uint _tokenId) internal { emit Approval(_owner, _approve, _tokenId); }\\n    function emitApprovalForAll(address _owner, address _operator, bool _approved) internal { emit ApprovalForAll(_owner, _operator, _approved); }\\n}\\n\\n// ERC165 https://eips.ethereum.org/EIPS/eip-721\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\n// ERC20 https://eips.ethereum.org/EIPS/eip-20\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\n// ERC721 https://eips.ethereum.org/EIPS/eip-721\\ninterface IERC721 is IERC165 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n    // payable removed for erc20 etherscan compatibility\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ninterface ISJ741 is IERC20, IERC721 {\\n    // library transfers can not be included in the interface\\n    // incorporate them directly with library\\n    // libSJ20.Transfer\\n    // libSJ20.Approval\\n    // libSJ721.Transfer\\n    // libSJ721.Approval\\n    // libSJ721.ApprovalForAll\\n    function balanceOf(address account) external override(IERC20, IERC721) view returns (uint256);\\n    function approve(address spender, uint256 value) external override(IERC20, IERC721) returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external override(IERC20, IERC721) returns (bool);\\n}\\n\\n// ERC721 Token Receiver https://eips.ethereum.org/EIPS/eip-721\\ninterface IERC721TokenReceiver {\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\\n}\\n\\ncontract SJ741 is ISJ741 {\\n\\n    string public baseURI = \\\"https://raw.githubusercontent.com/SerecThunderson/assets/main/emeralds/metadata/\\\";\\n    string internal constant _name = \\\"SJ741 Emeralds\\\";\\n    string internal constant _symbol = \\\"EMERALD\\\";\\n\\n    uint internal constant _decimals = 8;\\n    uint internal constant _totalIds = 7777;\\n    uint internal constant _totalSupply = _totalIds * 10**_decimals; \\n    uint internal constant ONE = 10**_decimals; // 1.0 token(s)\\n    uint internal constant MAXID = ONE + _totalIds;  // 1.00000001 : 1.00007777 is the range for NFT IDs\\n\\n    uint32 public minted; // number of unique ID mints\\n    uint32[] private broken; // broken NFTs stored in limbo list \\n\\n    address public dev;\\n    bool public supportsNFTinterface;\\n\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n    mapping(address => mapping(address => uint)) internal _allowance;\\n    mapping(uint256 tokenId => address) public ownerOf;\\n    mapping(uint256 => address) private _nftApprovals;\\n    mapping(address => uint) internal _balanceOf;\\n    mapping(address => uint32[]) public ownedNFTs;\\n    mapping(uint32 => uint256) private idToIndex; \\n\\n    error UnsupportedReceiver();\\n\\n    modifier onlyDev() {\\n        require(msg.sender == dev, \\\"Not the developer\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        //set minted at ONE to ensure correct operation within range of IDs\\n        minted = uint32(ONE);\\n\\n        //the message sender receives the entire supply, and is set as \\\"dev\\\"\\n        _balanceOf[msg.sender] = _totalSupply; \\n        dev = msg.sender;\\n    }\\n\\n    function name() public view virtual returns (string memory) { return _name; }\\n    function symbol() public view virtual returns (string memory) { return _symbol; }\\n    function decimals() public view virtual returns (uint) { return _decimals; }\\n    function totalSupply() public pure override returns (uint) { return _totalSupply; }\\n    function balanceOf( address account) public view override returns (uint) { return _balanceOf[account]; }\\n    function allowance(address owner, address spender) public view override returns (uint) { return _allowance[owner][spender]; }\\n    function setBaseURI(string memory newBaseURI) public onlyDev {baseURI = newBaseURI;}\\n    function changeDev(address newDev) public onlyDev {dev = newDev;}//simple function to change developer address, or revoke ownership (with address(0))\\n    // @DEV toggleNFTinterface is for the small possibility of frontend system changes leading the contract to favor enabling the disabled supportsNFTinterface flag\\n    // don't waste it, as frontends don't typically change classification of contracts\\n    // probably never to be used.\\n    function toggelNFTinterface() public onlyDev {supportsNFTinterface = !supportsNFTinterface;}\\n\\n\\n    function approve(address spender, uint amount) public override returns (bool) {\\n\\n        // if the amount is greater than one token, and within range of IDs for NFTs \\n        // then set NFT approval for the given ID\\n        if(amount > ONE && amount <= MAXID) {\\n            address owner = ownerOf[amount]; // getting the owner of token ID via the `amount` input\\n            if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert(\\\"SJ741: You are not approved\\\");\\n            _nftApprovals[amount] = spender; // calling nft approval for the token and spender\\n            libSJ721.emitApproval(owner, spender, amount);\\n            return true;\\n        }\\n        \\n        // else set the ERC20 allowance\\n        // the NFT ID range being set within a limited subset of ONE token(s)\\n        // allows for non-clashing interactions\\n        _allowance[msg.sender][spender] = amount;\\n        libSJ20.emitApproval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _transfer741(address from, address to, uint amount) internal virtual {\\n        \\n        require(_balanceOf[from] >= amount, \\\"SJ741: transfer amount exceeds balance\\\");\\n        \\n        // checking the decimal amount of tokens owned before transaction for both participants\\n        uint256 fromDecimalsPre = _balanceOf[from] % ONE;\\n        uint256 toDecimalsPre = _balanceOf[to] % ONE;\\n        \\n        // simple erc20 balance operations\\n        _transfer20(from, to, amount);\\n\\n        // checking the decimal amount of tokens after transaction for both partcipants\\n        uint256 fromDecimalsPost = _balanceOf[from] % ONE;\\n        uint256 toDecimalsPost = _balanceOf[to] % ONE;\\n\\n        // stores the NFT IDs owned by `from`, enabling NFT management for that address.\\n        uint32[] storage ownedNFTsArray = ownedNFTs[from];\\n\\n        // references NFTs marked as \\\"broken\\\", tracking these special state NFTs.\\n        uint32[] storage brokenIDsArray = broken;\\n\\n        // if sender has higher decimal count after transaction, then they \\\"roll under\\\" and break an NFT\\n        if (fromDecimalsPre < fromDecimalsPost) {\\n\\n            if(ownedNFTsArray.length > 0) { // if the sender has an nft to send\\n\\n                uint32 tokenId = ownedNFTsArray[0];//selects the user's first NFT from the list\\n\\n                brokenIDsArray.push(tokenId);//pushes the nft into the \\\"broken list\\\" for limbo NFTs\\n                _transfer721(from, address(0), tokenId);//transfers the NFT ID ownership to (0) address for stewardship\\n            }\\n        }\\n\\n        // if receiver has lower decimal count after transaction then they \\\"roll over\\\" and will \\\"remake\\\" an nft \\n        if (toDecimalsPre > toDecimalsPost) {\\n\\n            if(brokenIDsArray.length > 0) { // recover an id from broken list\\n\\n                _transfer721(address(0), to, brokenIDsArray[brokenIDsArray.length - 1]);\\n                brokenIDsArray.pop();\\n            }\\n            else { // mint new id\\n                _mint(to);\\n            }\\n            \\n        }\\n        \\n        // amount of tokens - amount of whole tokens being processed in int\\n        uint amountInTokens = amount / ONE;\\n\\n        // ignore minting nfts from dev when they call -- this allows for gas-efficient team operations\\n        // @DEV if dev gathers NFTs, use the ERC721 transferFrom method to extract\\n        // @DEV be careful, don't let the wallet fall to some convoluted transferFrom scam to do something unexpected\\n        if(from == dev) return;\\n\\n\\n        if(amountInTokens > 0) {\\n\\n            uint len = ownedNFTsArray.length; //len is the length, or number of NFTs in the addresses's owned array\\n            len = amountInTokens < len ? amountInTokens : len;\\n            // transfers owned NFTs from `from` to `to` until either all are transferred or the desired amount is reached\\n            // Subtracts transferred NFT count from `amountInTokens` to update remaining transfers\\n            for (uint i = 0; i < len; i++) {\\n                _transfer721(from, to, ownedNFTsArray[0]); \\n            }\\n            amountInTokens -= len;\\n            len = brokenIDsArray.length;\\n            len = amountInTokens < len ? amountInTokens : len;\\n            \\n            // recovers NFTs from the broken state to `to`, or mints new ones if not enough broken NFTs are available\\n            // if any tokens remain to be allocated, it mints new NFTs to `to` for the remaining balance\\n            for (uint i = 0; i < len; i++) {        \\n                _transfer721(address(0), to, brokenIDsArray[brokenIDsArray.length - 1]);\\n                brokenIDsArray.pop();\\n            }\\n\\n            _mintBatch(to, amountInTokens - len);\\n\\n        }\\n    }\\n\\n    function _mintBatch(address to, uint256 amount) internal {\\n        if(amount == 0) return; // Exit if no NFTs to mint\\n\\n        if(amount == 1) { // Optimize single mint process\\n            _mint(to);\\n            return;\\n        }\\n        uint32 id = minted; // Start ID from last minted value\\n        uint256 ownedLen = ownedNFTs[to].length; // Current number of NFTs owned by 'to'\\n        for(uint i = 0; i < amount;) {\\n            unchecked {\\n                id++; // Increment ID for each new NFT\\n            }\\n            ownerOf[id] = to; // Assign new NFT to owner.\\n            idToIndex[id] = ownedLen; // Map NFT ID to its index in owner's array\\n            ownedNFTs[to].push(id); // Add new NFT ID to owner's list\\n\\n            libSJ721.emitTransfer(address(0), to, id); // Emit NFT transfer event\\n\\n            unchecked {\\n                ownedLen++; // Increment count of owned NFTs\\n                i++; // Move to next NFT\\n            }\\n        }\\n        unchecked {\\n            minted += uint32(amount); // Update total minted count\\n        }\\n    }\\n\\n\\n    function _mint(address to) internal returns(uint32 tokenId){\\n        unchecked {\\n            minted++; // Increment the total number of minted tokens\\n        }\\n        tokenId = minted; // Assign the newly minted token ID\\n\\n        ownerOf[tokenId] = to; // Set ownership of the new token to 'to'\\n        idToIndex[tokenId] = ownedNFTs[to].length; // Map the new token ID to its index in the owner's list\\n        ownedNFTs[to].push(tokenId); // Add the new token ID to the owner's list of owned tokens\\n        \\n        libSJ721.emitTransfer(address(0), to, tokenId); // Emit an event for the token transfer\\n    }\\n\\n\\n    // Updates the mappings and arrays managing ownership and index of NFTs after a transfer\\n    function _updateOwnedNFTs(address from, address to, uint32 tokenId) internal { \\n        uint256 index = idToIndex[tokenId]; // Get current index of the token in the owner's list\\n        uint32[] storage nftArray = ownedNFTs[from]; // Reference to the list of NFTs owned by 'from'\\n        uint256 len = nftArray.length; // Current number of NFTs owned by 'from'\\n        uint32 lastTokenId = nftArray[len - 1]; // Last token in the 'from' array to swap with transferred token\\n        \\n        nftArray[index] = lastTokenId; // Replace the transferred token with the last token in the array\\n        nftArray.pop(); // Remove the last element, effectively deleting the transferred token from 'from'\\n        \\n        if(len - 1 != 0){ \\n            idToIndex[lastTokenId] = index; // Update the index of the swapped token\\n        } \\n    \\n        ownedNFTs[to].push(tokenId); // Add the transferred token to the 'to' array\\n        idToIndex[tokenId] = ownedNFTs[to].length - 1; // Update the index mapping for the transferred token\\n    }\\n\\n    // Executes a simple ERC20 token transfer.\\n    function _transfer20(address from, address to, uint256 amount) internal {\\n        _balanceOf[from] -= amount; // Deduct the amount from the sender's balance\\n        unchecked {\\n            _balanceOf[to] += amount; // Add the amount to the recipient's balance\\n        }\\n        libSJ20.emitTransfer(from, to, amount); // Emit an ERC20 transfer event\\n    }\\n\\n    // Handles the transfer of an ERC721 token, ensuring proper ownership and event emission\\n    function _transfer721(address from, address to, uint32 tokenId) internal virtual {\\n        require(from == ownerOf[tokenId], \\\"SJ741: Incorrect owner\\\"); // Ensure 'from' is the current owner\\n        \\n        delete _nftApprovals[tokenId]; // Clear any approvals for this token\\n        ownerOf[tokenId] = to; // Transfer ownership of the token to 'to'\\n        _updateOwnedNFTs(from, to, tokenId); // Update ownership tracking structures\\n        libSJ721.emitTransfer(from, to, tokenId); // Emit an ERC721 transfer event\\n    }\\n\\n\\n    // only erc20 calls this\\n    // if amount is a token id owned my the caller send as an NFT\\n    // else transfer741\\n    function transfer(address to, uint amount) public override returns (bool) {\\n        if(ownerOf[amount] == msg.sender) {\\n            _transfer721(msg.sender, to, uint32(amount));\\n            _transfer20(msg.sender, to, ONE);\\n            return true;\\n        }\\n        _transfer741(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    // erc20 and erc721 call this\\n    function transferFrom(address from, address to, uint amount) public override returns (bool) {\\n\\n        //if amount is within the NFT id range, then a simple NFT transfer + token amount (ONE)\\n        if(amount > ONE && amount <= MAXID) {\\n            require(\\n                //require from is the msg caller, or that caller is approved for that specific NFT, or all NFTs \\n                msg.sender == from || msg.sender == getApproved(amount) || isApprovedForAll(from, msg.sender),\\n                \\\"SJ741: You don't have the right\\\"\\n                );\\n\\n            _transfer721(from, to, uint32(amount));\\n            _transfer20(from, to, ONE);\\n            return true;\\n        }\\n\\n        _spendAllowance(from, msg.sender, amount);\\n        _transfer741(from, to, amount);\\n        return true;\\n\\n    }\\n\\n    // erc721\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override {\\n        require(\\n                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),\\n                \\\"SJ741: You don't have the right\\\"\\n            );\\n        _transfer721(from, to, uint32(tokenId)); \\n        _transfer20(from, to, ONE);\\n\\n        if (\\n            to.code.length != 0 &&\\n            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, \\\"\\\") !=\\n            IERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsupportedReceiver();\\n        }\\n    }\\n\\n    // erc721\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable override {\\n        require(\\n                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),\\n                \\\"SJ741: You don't have the right\\\"\\n            );\\n        _transfer721(from, to, uint32(tokenId)); \\n        _transfer20(from, to, ONE);\\n\\n        if (\\n            to.code.length != 0 &&\\n            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) !=\\n            IERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsupportedReceiver();\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint amount) internal virtual {\\n        require(_allowance[owner][spender] >= amount, \\\"SJ741: insufficient allowance\\\");\\n        _allowance[owner][spender] -= amount;\\n    }\\n\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (ownerOf[tokenId] == address(0)) revert();\\n        return _nftApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public override {\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        libSJ721.emitApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        require(tokenId <= MAXID, \\\"SJ741: invalid id\\\");\\n        if (bytes(baseURI).length == 0) {return \\\"\\\";}\\n        return string(abi.encodePacked(baseURI, toString(tokenId - ONE), \\\".json\\\"));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {return \\\"0\\\";} uint256 temp = value; uint256 digits;\\n        while (temp != 0) {digits++; temp /= 10;} bytes memory buffer = new bytes(digits);\\n        while (value != 0) {digits -= 1; buffer[digits] = bytes1(uint8(value % 10) + 48); value /= 10;}\\n        return string(buffer);\\n    }\\n\\n    function withdraw() external onlyDev {\\n        payable(dev).transfer(address(this).balance);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return\\n            // Even though we support ERC721 and should return true, etherscan wants to treat us as ERC721 instead of ERC20\\n            // @DEV ERC165 for ERC721 can be toggled on for reasons of frontend/dapp/script implementations, but is very specific\\n            (supportsNFTinterface && interfaceId == 0x80ac58cd) || // ERC165 interface ID for ERC721\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165\\n            interfaceId == 0x36372b07;   // ERC165 interface ID for ERC20\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"UnsupportedReceiver\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedNFTs\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsNFTinterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggelNFTinterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SJ741", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4aee2a28c37c680b65f83917246894b8c27600584178872e11334127ee4dfd1d"}