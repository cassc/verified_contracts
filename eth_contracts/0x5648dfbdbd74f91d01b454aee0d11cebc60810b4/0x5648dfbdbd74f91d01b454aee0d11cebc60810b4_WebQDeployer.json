{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice A struct defining public drop data.\r\n *         Designed to fit efficiently in one storage slot.\r\n * \r\n * @param mintPrice                The mint price per token. (Up to 1.2m\r\n *                                 of native token, e.g. ETH, MATIC)\r\n * @param startTime                The start time, ensure this is not zero.\r\n * @param endTIme                  The end time, ensure this is not zero.\r\n * @param maxTotalMintableByWallet Maximum total number of mints a user is\r\n *                                 allowed. (The limit for this field is\r\n *                                 2^16 - 1)\r\n * @param feeBps                   Fee out of 10_000 basis points to be\r\n *                                 collected.\r\n * @param restrictFeeRecipients    If false, allow any fee recipient;\r\n *                                 if true, check fee recipient is allowed.\r\n */\r\nstruct PublicDrop {\r\n    uint80 mintPrice; // 80/256 bits\r\n    uint48 startTime; // 128/256 bits\r\n    uint48 endTime; // 176/256 bits\r\n    uint16 maxTotalMintableByWallet; // 224/256 bits\r\n    uint16 feeBps; // 240/256 bits\r\n    bool restrictFeeRecipients; // 248/256 bits\r\n}\r\n\r\n/**\r\n * @notice A struct defining token gated drop stage data.\r\n *         Designed to fit efficiently in one storage slot.\r\n * \r\n * @param mintPrice                The mint price per token. (Up to 1.2m \r\n *                                 of native token, e.g.: ETH, MATIC)\r\n * @param maxTotalMintableByWallet Maximum total number of mints a user is\r\n *                                 allowed. (The limit for this field is\r\n *                                 2^16 - 1)\r\n * @param startTime                The start time, ensure this is not zero.\r\n * @param endTime                  The end time, ensure this is not zero.\r\n * @param dropStageIndex           The drop stage index to emit with the event\r\n *                                 for analytical purposes. This should be \r\n *                                 non-zero since the public mint emits\r\n *                                 with index zero.\r\n * @param maxTokenSupplyForStage   The limit of token supply this stage can\r\n *                                 mint within. (The limit for this field is\r\n *                                 2^16 - 1)\r\n * @param feeBps                   Fee out of 10_000 basis points to be\r\n *                                 collected.\r\n * @param restrictFeeRecipients    If false, allow any fee recipient;\r\n *                                 if true, check fee recipient is allowed.\r\n */\r\nstruct TokenGatedDropStage {\r\n    uint80 mintPrice; // 80/256 bits\r\n    uint16 maxTotalMintableByWallet; // 96/256 bits\r\n    uint48 startTime; // 144/256 bits\r\n    uint48 endTime; // 192/256 bits\r\n    uint8 dropStageIndex; // non-zero. 200/256 bits\r\n    uint32 maxTokenSupplyForStage; // 232/256 bits\r\n    uint16 feeBps; // 248/256 bits\r\n    bool restrictFeeRecipients; // 256/256 bits\r\n}\r\n\r\n/**\r\n * @notice A struct defining mint params for an allow list.\r\n *         An allow list leaf will be composed of `msg.sender` and\r\n *         the following params.\r\n * \r\n *         Note: Since feeBps is encoded in the leaf, backend should ensure\r\n *         that feeBps is acceptable before generating a proof.\r\n * \r\n * @param mintPrice                The mint price per token.\r\n * @param maxTotalMintableByWallet Maximum total number of mints a user is\r\n *                                 allowed.\r\n * @param startTime                The start time, ensure this is not zero.\r\n * @param endTime                  The end time, ensure this is not zero.\r\n * @param dropStageIndex           The drop stage index to emit with the event\r\n *                                 for analytical purposes. This should be\r\n *                                 non-zero since the public mint emits with\r\n *                                 index zero.\r\n * @param maxTokenSupplyForStage   The limit of token supply this stage can\r\n *                                 mint within.\r\n * @param feeBps                   Fee out of 10_000 basis points to be\r\n *                                 collected.\r\n * @param restrictFeeRecipients    If false, allow any fee recipient;\r\n *                                 if true, check fee recipient is allowed.\r\n */\r\nstruct MintParams {\r\n    uint256 mintPrice; \r\n    uint256 maxTotalMintableByWallet;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 dropStageIndex; // non-zero\r\n    uint256 maxTokenSupplyForStage;\r\n    uint256 feeBps;\r\n    bool restrictFeeRecipients;\r\n}\r\n\r\n/**\r\n * @notice A struct defining token gated mint params.\r\n * \r\n * @param allowedNftToken    The allowed nft token contract address.\r\n * @param allowedNftTokenIds The token ids to redeem.\r\n */\r\nstruct TokenGatedMintParams {\r\n    address allowedNftToken;\r\n    uint256[] allowedNftTokenIds;\r\n}\r\n\r\n/**\r\n * @notice A struct defining allow list data (for minting an allow list).\r\n * \r\n * @param merkleRoot    The merkle root for the allow list.\r\n * @param publicKeyURIs If the allowListURI is encrypted, a list of URIs\r\n *                      pointing to the public keys. Empty if unencrypted.\r\n * @param allowListURI  The URI for the allow list.\r\n */\r\nstruct AllowListData {\r\n    bytes32 merkleRoot;\r\n    string[] publicKeyURIs;\r\n    string allowListURI;\r\n}\r\n\r\n/**\r\n * @notice A struct defining minimum and maximum parameters to validate for \r\n *         signed mints, to minimize negative effects of a compromised signer.\r\n *\r\n * @param minMintPrice                The minimum mint price allowed.\r\n * @param maxMaxTotalMintableByWallet The maximum total number of mints allowed\r\n *                                    by a wallet.\r\n * @param minStartTime                The minimum start time allowed.\r\n * @param maxEndTime                  The maximum end time allowed.\r\n * @param maxMaxTokenSupplyForStage   The maximum token supply allowed.\r\n * @param minFeeBps                   The minimum fee allowed.\r\n * @param maxFeeBps                   The maximum fee allowed.\r\n */\r\nstruct SignedMintValidationParams {\r\n    uint80 minMintPrice; // 80/256 bits\r\n    uint24 maxMaxTotalMintableByWallet; // 104/256 bits\r\n    uint40 minStartTime; // 144/256 bits\r\n    uint40 maxEndTime; // 184/256 bits\r\n    uint40 maxMaxTokenSupplyForStage; // 224/256 bits\r\n    uint16 minFeeBps; // 240/256 bits\r\n    uint16 maxFeeBps; // 256/256 bits\r\n}\r\n\r\ninterface ERC721SeaDropStructsErrorsAndEvents {\r\n  /**\r\n   * @notice Revert with an error if mint exceeds the max supply.\r\n   */\r\n  error MintQuantityExceedsMaxSupply(uint256 total, uint256 maxSupply);\r\n\r\n  /**\r\n   * @notice Revert with an error if the number of token gated \r\n   *         allowedNftTokens doesn't match the length of supplied\r\n   *         drop stages.\r\n   */\r\n  error TokenGatedMismatch();\r\n\r\n  /**\r\n   *  @notice Revert with an error if the number of signers doesn't match\r\n   *          the length of supplied signedMintValidationParams\r\n   */\r\n  error SignersMismatch();\r\n\r\n  /**\r\n   * @notice An event to signify that a SeaDrop token contract was deployed.\r\n   */\r\n  event SeaDropTokenDeployed();\r\n\r\n  /**\r\n   * @notice A struct to configure multiple contract options at a time.\r\n   */\r\n  struct MultiConfigureStruct {\r\n    uint256 maxSupply;\r\n    string baseURI;\r\n    string contractURI;\r\n    address seaDropImpl;\r\n    PublicDrop publicDrop;\r\n    string dropURI;\r\n    AllowListData allowListData;\r\n    address creatorPayoutAddress;\r\n    bytes32 provenanceHash;\r\n\r\n    address[] allowedFeeRecipients;\r\n    address[] disallowedFeeRecipients;\r\n\r\n    address[] allowedPayers;\r\n    address[] disallowedPayers;\r\n\r\n    // Token-gated\r\n    address[] tokenGatedAllowedNftTokens;\r\n    TokenGatedDropStage[] tokenGatedDropStages;\r\n    address[] disallowedTokenGatedAllowedNftTokens;\r\n\r\n    // Server-signed\r\n    address[] signers;\r\n    SignedMintValidationParams[] signedMintValidationParams;\r\n    address[] disallowedSigners;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create2(0, 0x09, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(add(ptr, 0x38), deployer)\r\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\r\n            mstore(add(ptr, 0x14), implementation)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\r\n            mstore(add(ptr, 0x58), salt)\r\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\r\n            predicted := keccak256(add(ptr, 0x43), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt\r\n    ) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the QRC Protocol.\r\n */\r\ninterface IQRC {\r\n    /**\r\n     * @dev Emitted when receciving QRC Transaction.\r\n     *\r\n     * Note that `Q_signature` must be checked off-line.\r\n     */\r\n    event EntryQRC(uint256 indexed index, bytes32 indexed Q_address, bytes32 Q_message_hash, bytes Q_signature);\r\n\r\n\r\n    /**\r\n     * @dev invoke an QRC transaction from `Q_address`, with message `Q_message` and signature `Q_signature`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {EntryQRC} event.\r\n     */\r\n    function entryQRC(bytes32 Q_address, bytes memory Q_message, bytes calldata Q_signature) payable external returns (bool);\r\n}\r\n\r\ninterface IQRC20 is IQRC {\r\n    /**\r\n     * @dev calculate QRC minting amount.\r\n     *\r\n     * @param totalSupply current total supply of QRC20, given by calcultion from previous QRC txs.\r\n     * @param Q_address bytes32 Q_address that sends the QRC tx.\r\n     * @param nonce uint256 current nonce for the Q_address. (nonce for QRC tx instead of wrapped tx.)\r\n     * @param value uint256 carried value of the corresponding wrapped tx. \r\n     *\r\n     * @return amount uint256 value indicating the amount of minted token.\r\n     *\r\n     * THIS FUNCTION SHALL BE STATIC.\r\n     */\r\n    function mintQRC(uint256 totalSupply, bytes32 Q_address, uint256 nonce, uint256 value) view external returns (uint256 amount);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title WebQ - Web Q contract with gnosis {safe} account as fund receiver.\r\n * @author 0xTroll\r\n */\r\ncontract WebQ is IQRC20 {\r\n\r\n    // Foundation address is safe account.\r\n    address payable public safe;\r\n\r\n    /**\r\n     * @notice Constructor function sets address of fund receiver contract.\r\n     * @param _safe safe account address.\r\n     */\r\n    constructor(address payable _safe) {\r\n\r\n        require(_safe != address(0));\r\n\r\n        safe = _safe;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Total donation donated to Web-Q.fundation.\r\n     */\r\n    uint256 public totalDonation;\r\n\r\n\r\n    /**\r\n     * @notice Current index for QRC transactions.\r\n     */\r\n    uint256 public qrcIndex;\r\n\r\n\r\n    /**\r\n     * @dev Current mintable specical NFT supply.\r\n     */\r\n    uint256 public mintableSupply;\r\n\r\n\r\n    /**\r\n     * @dev Allowner minter for given mintId.\r\n     */\r\n    mapping (uint256=>address) internal allowedMinterForMintId;\r\n\r\n    /**\r\n     * @dev Total donation donated to Web-Q.fundation.\r\n     */\r\n    event Donation(address donor, uint256 amount, uint256 totalDonation);\r\n\r\n    /**\r\n     * @dev Grant spNFT for donors who make considerable contribution.\r\n     */\r\n    event GrantSpNFT(address donor, uint256 mintId);\r\n\r\n\r\n    /**\r\n     * @dev Calculate how much donation required to mint {deltaAmount} spNFT when current supply is {supplyAmount} .\r\n     */\r\n    function donationForSpNfts(uint256 deltaAmount, uint256 supplyAmount) internal pure returns (uint256 donationRequired){\r\n\r\n        uint256 nextAmount = deltaAmount + supplyAmount;\r\n\r\n        \r\n        donationRequired = ((nextAmount**2 - supplyAmount **2) * 25  + (nextAmount - supplyAmount) * 975) * 1e15;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate how much donation required to mint {deltaAmount} spNFT .\r\n     */\r\n    function donationForSpNfts(uint256 deltaAmount) external view returns (uint256 donationRequired){\r\n        donationRequired = donationForSpNfts(deltaAmount, mintableSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Special NFT badges will be rewarded to initial donors to Web-Q.Foundation,\r\n     * @dev {ownerOf} function is for compatiblity with tokenGated ERC721 SeaDrop contract,\r\n     * @dev in order to remeber donors eligible to receive special NFT badges.\r\n     * @dev Only allowedMinter can mint the corresponding NFT.\r\n     * @dev Note that the snapshot of total donation is used as unique marker.\r\n     * @dev Note that the acutal NFT id is decided by the sequence of SeaDrop mingting. \r\n     */\r\n    function ownerOf(uint256 mintId) external view returns (address allowedMinter){\r\n\r\n        allowedMinter = allowedMinterForMintId[mintId];\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Grant {to} with pending special NFT, which can be accessed by ownerOf function with {uniqueMarker} as minting id.\r\n     */\r\n    function _grantSpecialNFT(address to, uint256 mintId) internal {\r\n\r\n        require( to != address(0) );\r\n        \r\n        allowedMinterForMintId[mintId] = to;\r\n\r\n        emit GrantSpNFT(to, mintId);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Handle donation, trying to grant special NFTs.\r\n     * @dev visit https://web-q.foundation for more information.\r\n     */\r\n    function donate(address donor) payable public returns (uint256 donation, uint256 mintable){\r\n        \r\n        //storage -> memory\r\n        mintable = mintableSupply;\r\n\r\n        uint256 _value = msg.value;\r\n        uint256 _threshold;\r\n\r\n        if (_value > 0) {\r\n            emit Donation(donor, _value, totalDonation);\r\n        }\r\n\r\n        while (mintable < 108) {\r\n            _threshold = donationForSpNfts(1, mintable);\r\n            if (_value >= _threshold){\r\n                _value -= _threshold;\r\n                mintable += 1;\r\n                _grantSpecialNFT(donor, mintable);\r\n            } else{\r\n                break;\r\n            }\r\n        }\r\n        \r\n        totalDonation += msg.value;\r\n\r\n        donation = totalDonation;\r\n\r\n        //memory -> storage \r\n        mintableSupply = mintable;\r\n\r\n        (bool success, ) = safe.call{value: msg.value}(\"\");\r\n        \r\n        require(success);\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of  QRC entry interface.\r\n     * @dev visit https://web-q.foundation for more information.\r\n     * Note that donation is triggered to handle donation.\r\n     */\r\n\r\n    function entryQRC(bytes32 Q_address, bytes memory Q_message, bytes calldata Q_signature) payable external returns (bool){\r\n\r\n        donate(msg.sender);\r\n        \r\n        emit EntryQRC(qrcIndex, Q_address, keccak256(Q_message), Q_signature);\r\n\r\n        qrcIndex += 1;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Implementation of mintQRC, according to QRC-20 protocol.\r\n     * @dev visit https://web-q.foundation for more information.\r\n     */\r\n\r\n    function mintQRC(uint256 totalSupply, bytes32 Q_address, uint256 nonce, uint256 value) pure external override returns (uint256 amount){\r\n        Q_address;\r\n        value;\r\n        nonce;\r\n\r\n        uint256 MaxSupply   = 21000000 ether;\r\n        uint256 MintAmount  = 1000 ether; \r\n        uint256 HalveTimes  = 0;\r\n\r\n        if (totalSupply >= MaxSupply){\r\n            return 0;\r\n        }\r\n        while (totalSupply >= (MaxSupply - MaxSupply/(2**HalveTimes))){\r\n            amount = MintAmount/(2**HalveTimes);\r\n            HalveTimes += 1;\r\n        }\r\n        if (totalSupply + amount >= MaxSupply){\r\n            amount = MaxSupply - totalSupply;\r\n        }\r\n    }\r\n\r\n     /**\r\n     * @dev Fund received will be transfered to {safe} account by default.\r\n     */\r\n\r\n    receive() external payable {\r\n        safe.transfer(msg.value);\r\n    }\r\n\r\n}\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n\r\n\r\ninterface ISeaDrop {\r\n    function mintSigned(\r\n        address nftContract,\r\n        address feeRecipient,\r\n        address minterIfNotPayer,\r\n        uint256 quantity,\r\n        MintParams calldata mintParams,\r\n        uint256 salt,\r\n        bytes calldata signature\r\n    ) external payable;\r\n    function mintAllowedTokenHolder(\r\n        address nftContract,\r\n        address feeRecipient,\r\n        address minterIfNotPayer,\r\n        TokenGatedMintParams calldata mintParams\r\n    ) external payable;\r\n    function getAllowedNftTokenIdIsRedeemed(\r\n        address nftContract,\r\n        address allowedNftToken,\r\n        uint256 allowedNftTokenId\r\n    ) external view returns (bool);\r\n}\r\n\r\ninterface IERC721SeaDropClonable is ERC721SeaDropStructsErrorsAndEvents{\r\n    function setBaseURI(string calldata tokenURI) external;\r\n    function setContractURI(string calldata newContractURI) external;\r\n    function setMaxSupply(uint256 newMaxSupply) external;\r\n    function updateSignedMintValidationParams(\r\n        address seaDropImpl,\r\n        address signer,\r\n        SignedMintValidationParams memory signedMintValidationParams\r\n    ) external;\r\n    function updatePayer(address seaDropImpl, address payer, bool allowed) external;\r\n    function updateAllowedFeeRecipient(address seaDropImpl, address feeRecipient, bool allowed) external;\r\n    function updateTokenGatedDrop(address seaDropImpl, address allowedNftToken, TokenGatedDropStage calldata dropStage) external;\r\n    function getMintStats(address minter)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 minterNumMinted,\r\n            uint256 currentTotalSupply,\r\n            uint256 maxSupply\r\n        );\r\n    function transferOwnership(address newPotentialOwner) external;\r\n    function multiConfigure(MultiConfigureStruct calldata config) external;\r\n    function initialize(\r\n        string calldata __name,\r\n        string calldata __symbol,\r\n        address[] calldata allowedSeaDrop,\r\n        address initialOwner\r\n    ) external;\r\n}\r\n\r\ninterface Safe {\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n}\r\n\r\n\r\ncontract WebQDeployer is Ownable, ERC721SeaDropStructsErrorsAndEvents {\r\n\r\n    IERC721SeaDropClonable public NFT;\r\n\r\n    IERC721SeaDropClonable public spNFT;\r\n\r\n    ISeaDrop public seaDrop;\r\n\r\n    address payable public webQBase;\r\n\r\n    event WebQDeployed(address webQ, address fundReceiver, address NFT, address spNFT);\r\n\r\n    constructor(address seaDropImplementation, \r\n                address payable fundReceiver,\r\n                address nftSigner,\r\n                address seaDropCloneableImplementation,\r\n                string memory contractURIforNFT,\r\n                string memory baseURIforNFT,\r\n                string memory contractURIforspNFT,\r\n                string memory baseURIforspNFT\r\n                ){\r\n\r\n        address[] memory allowedSeaDrop = new address [] (1);\r\n\r\n        seaDrop = ISeaDrop(seaDropImplementation);\r\n\r\n        webQBase= payable(new WebQ(fundReceiver));\r\n\r\n        allowedSeaDrop[0] = seaDropImplementation;\r\n\r\n        NFT = IERC721SeaDropClonable(Clones.clone(seaDropCloneableImplementation));\r\n\r\n        NFT.initialize(\r\n                'Web-Q NFT Badger',\r\n                'Web-Q NFT',\r\n                allowedSeaDrop,\r\n                address(this)\r\n            );\r\n\r\n        SignedMintValidationParams memory signValidationSetup = SignedMintValidationParams(\r\n            0    ,//uint80 minMintPrice; \r\n            10000    ,//uint24 maxMaxTotalMintableByWallet; \r\n            0    ,//uint40 minStartTime; \r\n            uint40(type(uint40).max)    ,//uint40 maxEndTime; \r\n            10000    ,//uint40 maxMaxTokenSupplyForStage; \r\n            0    ,//uint16 minFeeBps; \r\n            0     //uint16 maxFeeBps; \r\n        );\r\n\r\n        NFT.setContractURI(contractURIforNFT);\r\n\r\n        NFT.setBaseURI(baseURIforNFT);\r\n\r\n        NFT.setMaxSupply(10000);\r\n\r\n        NFT.updateSignedMintValidationParams(\r\n            seaDropImplementation,\r\n            nftSigner,\r\n            signValidationSetup\r\n        );\r\n\r\n        NFT.updatePayer(seaDropImplementation, address(this), true);\r\n       \r\n        NFT.updateAllowedFeeRecipient(seaDropImplementation, webQBase, true);\r\n\r\n        spNFT = IERC721SeaDropClonable(Clones.clone(seaDropCloneableImplementation));\r\n\r\n        spNFT.initialize(\r\n            'Web-Q Special NFT Badger',\r\n            'Web-Q spNFT',\r\n            allowedSeaDrop,\r\n            address(this)\r\n        );\r\n\r\n        TokenGatedDropStage memory tokenGatedSetup = TokenGatedDropStage(\r\n            0    ,//uint80 mintPrice; \r\n            108    ,//uint16 maxTotalMintableByWallet; \r\n            0   ,//uint48 startTime; \r\n            uint48(type(uint48).max),//uint48 endTime; \r\n            1    ,//uint8 dropStageIndex; // non-zero. \r\n            108    ,//uint32 maxTokenSupplyForStage; \r\n            0    ,//uint16 feeBps; \r\n            false    //bool restrictFeeRecipients\r\n        );\r\n\r\n        spNFT.setMaxSupply(108);\r\n\r\n        spNFT.updateTokenGatedDrop(\r\n            seaDropImplementation,\r\n            webQBase, \r\n            tokenGatedSetup\r\n        );\r\n\r\n        spNFT.setContractURI(contractURIforspNFT);\r\n\r\n        spNFT.setBaseURI(baseURIforspNFT);\r\n\r\n        spNFT.updatePayer(seaDropImplementation, address(this), true);\r\n\r\n        spNFT.updateAllowedFeeRecipient(seaDropImplementation, webQBase, true);\r\n\r\n        emit WebQDeployed(address(webQBase), address(fundReceiver), address(NFT), address(spNFT));\r\n\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Check if salt is used for NFT minting.\r\n     */\r\n    mapping (uint256 => bool) public saltUsed;\r\n\r\n\r\n    /**\r\n     * @dev Record routed minting history.\r\n     */\r\n    event MintNFT(address from, address nftContract, uint256 spGrant);\r\n\r\n\r\n    /**\r\n     * @dev Mint NFTs and special NFTs in one function.\r\n     *\r\n     * @param grantedNFT last index of NFT to be minted.\r\n     * @param signature server-side signature to mint NFT.\r\n     * @param grantedSpNFTs ids of spNFT to be minted (not the final NFT id). Should be checked using claimableSpNFT.\r\n     */\r\n    function mintNFT(uint256 grantedNFT, bytes calldata signature, uint256[] calldata grantedSpNFTs) external {\r\n        \r\n        (uint256 _mintedNFT,,) = NFT.getMintStats(msg.sender); \r\n\r\n        if (grantedNFT > _mintedNFT){\r\n            MintParams memory _mintParams = MintParams(\r\n                0,grantedNFT,0,4070880000,1,10000,0,true\r\n            );\r\n            seaDrop.mintSigned(\r\n                address(NFT), //nftContract\r\n                webQBase, //feeRecipient\r\n                msg.sender, //minter\r\n                grantedNFT - _mintedNFT, //quantity\r\n                _mintParams, //mintParams\r\n                uint256(uint160(msg.sender)) + grantedNFT,  //salt\r\n                signature\r\n                );\r\n        }\r\n\r\n        if  (grantedSpNFTs.length > 0){\r\n            seaDrop.mintAllowedTokenHolder(address(spNFT), webQBase, msg.sender, TokenGatedMintParams(webQBase, grantedSpNFTs));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Donate to web-q.foundation and mint special NFTs within one transcation.\r\n     *\r\n     */\r\n    function donationAndMint() external payable {\r\n        uint256 oldMintable    = WebQ(webQBase).mintableSupply();\r\n        \r\n        (,uint256 newMintable) = WebQ(webQBase).donate{value: msg.value}(msg.sender);\r\n        \r\n        if (newMintable > oldMintable){\r\n            uint256 [] memory grantedSpNFTs = new uint256[](newMintable - oldMintable);\r\n            for (uint i = oldMintable; i < newMintable; i++){\r\n                grantedSpNFTs[i-oldMintable] = i + 1;\r\n            }\r\n\r\n            seaDrop.mintAllowedTokenHolder(address(spNFT), webQBase, msg.sender, TokenGatedMintParams(webQBase, grantedSpNFTs));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check how many NFTs that have been minted by minter.\r\n     *\r\n     * @param minter whoever wants to mint spNFT.\r\n     *\r\n     * @return minted quantity of NFTs minted by minter.\r\n     */\r\n    function mintedNFT(address minter) external view returns(uint256 minted){\r\n        (minted,,) = NFT.getMintStats(minter); \r\n    }\r\n\r\n    /**\r\n     * @dev Mint NFTs and special NFTs in one function.\r\n     *\r\n     * @param minter whoever wants to mint spNFT.\r\n     * @param grantedSpNFTs ids of spNFT to be checked.\r\n     *\r\n     * @return mintableSpNFTs ids of spNFT can be minted (not the final NFT id).\r\n     */\r\n    function claimableSpNFT(address minter, uint256[] calldata grantedSpNFTs) external view returns(uint256[] memory mintableSpNFTs){\r\n        uint256[] memory mintableSpNFTsPadded = new uint256[](grantedSpNFTs.length);\r\n        uint256 mintableSpNFTsLength = 0;\r\n        for (uint i=0; i<grantedSpNFTs.length; i++) {\r\n            if (WebQ(webQBase).ownerOf(grantedSpNFTs[i]) == minter && \r\n                !seaDrop.getAllowedNftTokenIdIsRedeemed(\r\n                    address(spNFT), webQBase, grantedSpNFTs[i]\r\n                    )){\r\n                        mintableSpNFTsPadded[mintableSpNFTsLength] = grantedSpNFTs[i];\r\n                        mintableSpNFTsLength += 1;\r\n                    }\r\n        }\r\n        mintableSpNFTs = new uint256[](mintableSpNFTsLength);\r\n        for (uint i=0; i<mintableSpNFTsLength; i++){\r\n            mintableSpNFTs[i] = mintableSpNFTsPadded[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ownership of NFT contract in case of crtitial bugs.\r\n     *\r\n     * @param to to whom transfer ownership\r\n     */\r\n    function transferNftOwnership(address to)\r\n        external\r\n        onlyOwner{\r\n            spNFT.transferOwnership(to);\r\n            NFT.transferOwnership(to);\r\n        }\r\n\r\n    /**\r\n     * @dev Configure multiple properties at a time.\r\n     *\r\n     * @param isSpNFT true: config spNFT, false: config NFT.\r\n     * @param config The configuration struct.\r\n     */\r\n    function multiConfigure(bool isSpNFT,MultiConfigureStruct calldata config)\r\n        external\r\n        onlyOwner{\r\n            if (isSpNFT){\r\n                spNFT.multiConfigure(config);\r\n            } else {\r\n                NFT.multiConfigure(config);\r\n            }\r\n        }\r\n    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seaDropImplementation\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftSigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seaDropCloneableImplementation\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractURIforNFT\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURIforNFT\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURIforspNFT\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURIforspNFT\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"MintQuantityExceedsMaxSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignersMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenGatedMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spGrant\",\"type\":\"uint256\"}],\"name\":\"MintNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SeaDropTokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"webQ\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spNFT\",\"type\":\"address\"}],\"name\":\"WebQDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"contract IERC721SeaDropClonable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"grantedSpNFTs\",\"type\":\"uint256[]\"}],\"name\":\"claimableSpNFT\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"mintableSpNFTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationAndMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"grantedNFT\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"grantedSpNFTs\",\"type\":\"uint256[]\"}],\"name\":\"mintNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mintedNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isSpNFT\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"seaDropImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint80\",\"name\":\"mintPrice\",\"type\":\"uint80\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"endTime\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"maxTotalMintableByWallet\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"restrictFeeRecipients\",\"type\":\"bool\"}],\"internalType\":\"struct PublicDrop\",\"name\":\"publicDrop\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"dropURI\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string[]\",\"name\":\"publicKeyURIs\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"allowListURI\",\"type\":\"string\"}],\"internalType\":\"struct AllowListData\",\"name\":\"allowListData\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creatorPayoutAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"provenanceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"allowedFeeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"disallowedFeeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"allowedPayers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"disallowedPayers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenGatedAllowedNftTokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint80\",\"name\":\"mintPrice\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"maxTotalMintableByWallet\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"endTime\",\"type\":\"uint48\"},{\"internalType\":\"uint8\",\"name\":\"dropStageIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"maxTokenSupplyForStage\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"restrictFeeRecipients\",\"type\":\"bool\"}],\"internalType\":\"struct TokenGatedDropStage[]\",\"name\":\"tokenGatedDropStages\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"disallowedTokenGatedAllowedNftTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint80\",\"name\":\"minMintPrice\",\"type\":\"uint80\"},{\"internalType\":\"uint24\",\"name\":\"maxMaxTotalMintableByWallet\",\"type\":\"uint24\"},{\"internalType\":\"uint40\",\"name\":\"minStartTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maxEndTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maxMaxTokenSupplyForStage\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"minFeeBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxFeeBps\",\"type\":\"uint16\"}],\"internalType\":\"struct SignedMintValidationParams[]\",\"name\":\"signedMintValidationParams\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"disallowedSigners\",\"type\":\"address[]\"}],\"internalType\":\"struct ERC721SeaDropStructsErrorsAndEvents.MultiConfigureStruct\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"multiConfigure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saltUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seaDrop\",\"outputs\":[{\"internalType\":\"contract ISeaDrop\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spNFT\",\"outputs\":[{\"internalType\":\"contract IERC721SeaDropClonable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferNftOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"webQBase\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WebQDeployer", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000005ea00ac477b1030ce78506496e8c2de24bf5000000000000000000000000d0a507a12721a2f5332991a0d280b2149c108ee80000000000000000000000000bbe130961d1bc3c73520ce5d9583e936eb9eb41000000000000000000000000391a04311e0bfc913ef6fa784773307c826104f00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000002568747470733a2f2f6d657461646174612e7765622d712e666f756e646174696f6e2f6e6674000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002668747470733a2f2f6d657461646174612e7765622d712e666f756e646174696f6e2f6e66742f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002868747470733a2f2f6d657461646174612e7765622d712e666f756e646174696f6e2f73705f6e6674000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002968747470733a2f2f6d657461646174612e7765622d712e666f756e646174696f6e2f73705f6e66742f0000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a000491f73f307af52025c9cf4cb4f9c3a78f273f560f2a4f93cfbf1549905e9"}