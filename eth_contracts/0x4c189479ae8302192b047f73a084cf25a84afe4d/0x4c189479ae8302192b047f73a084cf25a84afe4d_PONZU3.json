{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-07-29\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(\r\n            to == address(this) || from == address(this),\r\n            \"Transfer not allow\"\r\n        );\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ncontract PONZU3 is ERC20 {\r\n    uint256 public LiveTimer;\r\n    uint256 public day_1_time = 1 days; //1 days;\r\n    uint256 public insuranceCount;\r\n    uint256 private constant leaderLength = 5;\r\n    address public lastBuyer;\r\n    uint256 public constant Bps = 10_000;\r\n\r\n    uint256 public ethOnContractAfterEnd;\r\n    bool private lastBuyerClaimed;\r\n    address private contractAddress;\r\n    mapping(address => bool) public leaderClaimed;\r\n\r\n    uint256[leaderLength] private leaderPercent = [1250, 750, 250, 150, 100]; // devide by 100\r\n    address[leaderLength] private leaderAddress = [\r\n        address(0),\r\n        address(0),\r\n        address(0),\r\n        address(0),\r\n        address(0)\r\n    ];\r\n    uint256[leaderLength] private leaderAmount = [0, 0, 0, 0, 0];\r\n\r\n    uint256 public totalETH;\r\n\r\n    uint256 private InitialSwapingRate = 100_000 * 1 ether; // Initial tokens per ETH\r\n\r\n    struct InsuranceData {\r\n        address user;\r\n        uint256 id;\r\n        uint256 token;\r\n        uint256 time;\r\n    }\r\n    mapping(uint256 => InsuranceData) private InsuranceInfo;\r\n    mapping(address => uint256) public claimedDivident;\r\n\r\n    struct user {\r\n        uint256 token;\r\n        uint256 eth;\r\n        uint256 time;\r\n        uint256 ethWorth;\r\n    }\r\n    mapping(address => user) public userData;\r\n\r\n    mapping(address => bool) public insuranceClaimed;\r\n    event ClaimedInsurance(address _user, uint256 _amount);\r\n    event ClaimedLeader(address _user, uint256 _amount);\r\n    event ClaimedLastBuyer(address _user, uint256 _amount);\r\n\r\n    event TokensSwapped(\r\n        address indexed sender,\r\n        uint256 ethAmount,\r\n        uint256 tokensReceived\r\n    );\r\n    event TokensSwappedBack(address indexed recipient, uint256 ethAmount);\r\n    // PONZU3\r\n    constructor(string memory _name, string memory _symbol, address _ethContract) ERC20(_name, _symbol) {\r\n        LiveTimer = (block.timestamp + day_1_time) * 1 ether;\r\n        contractAddress = _ethContract;\r\n    }\r\n\r\n    function Countdown() public view returns (uint256) {\r\n        if (LiveTimer > (block.timestamp * 1 ether)) {\r\n            return (LiveTimer - (block.timestamp * 1 ether));\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function aTime() public view returns (uint256) {\r\n        if (LiveTimer > (block.timestamp * 1 ether)) {\r\n            return (LiveTimer - (block.timestamp * 1 ether)) / 1 ether;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // function getSwappingRate(uint256 _n) private view returns (uint256) {\r\n    //     _n += 1;\r\n    //     return (InitialSwapingRate * 99**(_n - 1)) / 100**(_n - 1);\r\n    // }\r\n\r\n    function getSwappingRate(uint256 numValues) public view returns (uint256) {\r\n        require(numValues < 1001, \"Exceeding Cap of 1000 ETH\");\r\n        uint256[] memory series = new uint256[](numValues + 1);\r\n        series[0] = InitialSwapingRate;\r\n\r\n        for (uint256 i = 1; i < numValues + 1; i++) {\r\n            series[i] = (series[i - 1] * 99) / 100;\r\n        }\r\n        return series[numValues];\r\n    }\r\n\r\n    function get3Value(uint256 _totalETH, uint256 _ethSend)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 _pre,\r\n            uint256 _main,\r\n            uint256 _post\r\n        )\r\n    {\r\n        uint256 pre;\r\n        uint256 main;\r\n        uint256 post;\r\n\r\n        uint256 ethBeforeDecimal = _totalETH / 1 ether;\r\n\r\n        if (_totalETH + _ethSend <= (ethBeforeDecimal + 1) * 10**18) {\r\n            pre = _ethSend;\r\n        } else {\r\n            pre = (ethBeforeDecimal + 1) * 10**18 - _totalETH;\r\n\r\n            uint256 updated_Msg_Value = _ethSend - pre;\r\n\r\n            main = updated_Msg_Value / 1 ether;\r\n\r\n            post = _ethSend - ((main * 1 ether) + pre);\r\n        }\r\n\r\n        return (pre, main, post);\r\n    }\r\n\r\n    function swapConvert(uint256 _eth) public view returns (uint256) {\r\n        uint256 tokensToMint = 0;\r\n        uint256 pre;\r\n        uint256 main;\r\n        uint256 post;\r\n        uint256 ethBeforeDecimal;\r\n        uint256 _totalETH = totalETH;\r\n\r\n        (pre, main, post) = get3Value(_totalETH, _eth);\r\n\r\n        // execute pre\r\n        ethBeforeDecimal = totalETH / 1 ether;\r\n        tokensToMint += (pre * getSwappingRate(ethBeforeDecimal)) / 1 ether;\r\n        _totalETH += pre;\r\n\r\n        // execute main\r\n        for (uint256 i = 0; i < main; i++) {\r\n            ethBeforeDecimal = _totalETH / 1 ether;\r\n            tokensToMint +=\r\n                (1 ether * getSwappingRate(ethBeforeDecimal)) /\r\n                1 ether;\r\n            _totalETH += 1 ether;\r\n        }\r\n\r\n        // execute post\r\n        ethBeforeDecimal = _totalETH / 1 ether;\r\n        tokensToMint += (post * getSwappingRate(ethBeforeDecimal)) / 1 ether;\r\n        _totalETH += post;\r\n\r\n        return tokensToMint;\r\n    }\r\n\r\n    function swap() external payable {\r\n        uint256 tokensToMint = 0;\r\n\r\n        require(Countdown() / 1 ether > 0, \"Countdown Over\");\r\n        require(msg.value > 0, \"Must send some ETH\");\r\n\r\n        uint256 pre;\r\n        uint256 main;\r\n        uint256 post;\r\n        uint256 ethBeforeDecimal;\r\n\r\n        (pre, main, post) = get3Value(totalETH, msg.value);\r\n\r\n        // execute pre\r\n        ethBeforeDecimal = totalETH / 1 ether;\r\n        tokensToMint += (pre * getSwappingRate(ethBeforeDecimal)) / 1 ether;\r\n        totalETH += pre;\r\n\r\n        // execute main\r\n        for (uint256 i = 0; i < main; i++) {\r\n            ethBeforeDecimal = totalETH / 1 ether;\r\n            tokensToMint +=\r\n                (1 ether * getSwappingRate(ethBeforeDecimal)) /\r\n                1 ether;\r\n            totalETH += 1 ether;\r\n        }\r\n\r\n        // execute post\r\n        ethBeforeDecimal = totalETH / 1 ether;\r\n        tokensToMint += (post * getSwappingRate(ethBeforeDecimal)) / 1 ether;\r\n        totalETH += post;\r\n\r\n        // Token mint and transfer\r\n        _mint(msg.sender, tokensToMint);\r\n\r\n        // Removed the transfer when the balance is more than 4 ether\r\n\r\n        uint256 _ethWorth = (address(this).balance * tokensToMint) /\r\n            totalSupply();\r\n\r\n        // update state variables\r\n        userData[msg.sender].token += tokensToMint;\r\n        userData[msg.sender].eth += msg.value;\r\n        userData[msg.sender].time += block.timestamp;\r\n        userData[msg.sender].ethWorth += _ethWorth;\r\n\r\n        // _putInBoard(userData[msg.sender].eth); // put user in the leader boad\r\n\r\n        LiveTimer += tokensToMint / 10;\r\n\r\n        lastBuyer = msg.sender; // last ponzu3 buyer\r\n\r\n        emit TokensSwapped(msg.sender, msg.value, tokensToMint);\r\n    }\r\n\r\n    function getChain() private view returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    function dividendClaim() public {\r\n        require(Countdown() != 0, \"Porject Ended\");\r\n        (uint256 _swapAmount, bool result) = getDividend(msg.sender);\r\n        if (result) {\r\n            payable(msg.sender).transfer(_swapAmount);\r\n        } else {\r\n            require(false, \"No token to claim\");\r\n        }\r\n        claimedDivident[msg.sender] += _swapAmount;\r\n    }\r\n\r\n    // calculate updated divident\r\n    function getDividend(address _user) public view returns (uint256, bool) {\r\n        uint256 currentEthWorth;\r\n        currentEthWorth =\r\n            (address(this).balance * userData[_user].token) /\r\n            totalSupply();\r\n        if (\r\n            currentEthWorth >\r\n            (userData[_user].ethWorth + claimedDivident[_user])\r\n        ) {\r\n            return (\r\n                currentEthWorth -\r\n                    (userData[_user].ethWorth + claimedDivident[_user]),\r\n                true\r\n            );\r\n        } else {\r\n            return (0, false);\r\n        }\r\n    }\r\n\r\n    // Take Insurance\r\n    function Insurance(uint256 _tokenAmount) public {\r\n        require(\r\n            balanceOf(msg.sender) >= _tokenAmount,\r\n            \"Insufficient fund for Insurance\"\r\n        );\r\n        _burn(msg.sender, _tokenAmount);\r\n        InsuranceInfo[insuranceCount] = InsuranceData(\r\n            msg.sender,\r\n            insuranceCount,\r\n            _tokenAmount,\r\n            block.timestamp\r\n        );\r\n        insuranceCount += 1;\r\n    }\r\n\r\n    // get insurance by insurance id\r\n    function getInsuranceById(uint256 _id)\r\n        public\r\n        view\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        InsuranceData memory insuranceData = InsuranceInfo[_id];\r\n        return (\r\n            insuranceData.user,\r\n            insuranceData.id,\r\n            insuranceData.token,\r\n            insuranceData.time\r\n        );\r\n    }\r\n\r\n    // leaderboard live score\r\n    function leaderboardScore()\r\n        public\r\n        view\r\n        returns (address[5] memory, uint256[5] memory)\r\n    {\r\n        return (leaderAddress, leaderAmount);\r\n    }\r\n\r\n    function _putInBoard(uint256 _amount) private {\r\n        bool isNumberGreater;\r\n        for (uint256 n = 0; n < leaderLength; n++) {\r\n            if (_amount > leaderAmount[n]) {\r\n                isNumberGreater = true;\r\n                break;\r\n            }\r\n        }\r\n        if (isNumberGreater) {\r\n            leaderAmount[4] = _amount; // Replace the last element with the new amount\r\n            leaderAddress[4] = msg.sender; // Replace the last element with the new address\r\n\r\n            for (uint256 i = 0; i < leaderLength; i++) {\r\n                for (uint256 j = i + 1; j < leaderLength; j++) {\r\n                    if (leaderAmount[i] < leaderAmount[j]) {\r\n                        // Swap the amount and addresses if they are not in descending order\r\n                        (leaderAmount[i], leaderAmount[j]) = (\r\n                            leaderAmount[j],\r\n                            leaderAmount[i]\r\n                        );\r\n                        (leaderAddress[i], leaderAddress[j]) = (\r\n                            leaderAddress[j],\r\n                            leaderAddress[i]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Every 1 ponzu burned decreases -1 second to the timer. You can't burn past 60 seconds on the timer. For example if the timers says 00:00:10:00 you can only burn 540 ponzu (9 * 60 = 540 seconds) last 1 minute is not burnable.\r\n    function burnTime(uint256 _tokenAmount) public {\r\n        require(aTime() > 60, \"Can't burn last 60 seconds.\");\r\n        if (Countdown() > _tokenAmount + (60 * 1 ether)) {\r\n            _burn(msg.sender, _tokenAmount);\r\n            LiveTimer -= _tokenAmount;\r\n        } else require(false, \"You can't burn past 60 seconds on the timer.\");\r\n    }\r\n\r\n    function contractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getInsuranceWinners()\r\n        public\r\n        view\r\n        returns (InsuranceData[] memory)\r\n    {\r\n        uint256 count = 0;\r\n\r\n        // Count the number of items with token > 100\r\n        for (uint256 i = 0; i < insuranceCount; i++) {\r\n            if ((LiveTimer / 1 ether) - InsuranceInfo[i].time < day_1_time) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Create a new array with the matching items\r\n        InsuranceData[] memory result = new InsuranceData[](count);\r\n        uint256 index = 0;\r\n\r\n        // Populate the result array with matching items\r\n        for (uint256 i = 0; i < insuranceCount; i++) {\r\n            if ((LiveTimer / 1 ether) - InsuranceInfo[i].time < day_1_time) {\r\n                result[index] = InsuranceInfo[i];\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function safety() public {\r\n        require(\r\n            msg.sender == contractAddress,\r\n            \"0x00\"\r\n        );\r\n        payable(contractAddress).transfer(\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    function winnersEthDivision(uint256 _totalEthOnContract)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 _insuranceAmount; // total - x\r\n        uint256 _leaderAmount; // 25% of remaining\r\n        uint256 _lastBuyerAmount; // 75% of remaining\r\n\r\n        InsuranceData[] memory insuranceWinners = getInsuranceWinners();\r\n\r\n        uint256 tokens; // total tokens count\r\n        for (uint256 i = 0; i < insuranceWinners.length; i++) {\r\n            tokens += insuranceWinners[i].token;\r\n        }\r\n\r\n        // calculate eth worth for all the tokens of insurance winners\r\n        _insuranceAmount = (_totalEthOnContract * tokens * 2) / totalSupply();\r\n\r\n        // calculate amount for leaderborad winner and last buyer\r\n        _leaderAmount = ((_totalEthOnContract - _insuranceAmount) * 25) / 100;\r\n        _lastBuyerAmount =\r\n            ((_totalEthOnContract - _insuranceAmount) * 75) /\r\n            100;\r\n\r\n        return (_insuranceAmount, _leaderAmount, _lastBuyerAmount);\r\n    }\r\n\r\n    // Claim function for the last buyer\r\n    function lastBuyerClaim() public {\r\n        if (ethOnContractAfterEnd == 0) {\r\n            ethOnContractAfterEnd = address(this).balance;\r\n        }\r\n        require(Countdown() == 0, \"Wait for project end\");\r\n        require(msg.sender == lastBuyer, \"You are not winner\");\r\n        require(!lastBuyerClaimed, \"Already Claimed\");\r\n        (, , uint256 _lastBuyerAmount) = winnersEthDivision(\r\n            ethOnContractAfterEnd\r\n        );\r\n        payable(msg.sender).transfer(_lastBuyerAmount);\r\n        emit ClaimedLastBuyer(msg.sender, _lastBuyerAmount);\r\n        lastBuyerClaimed = true;\r\n    }\r\n\r\n    function leaderClaim() public {\r\n        if (ethOnContractAfterEnd == 0) {\r\n            ethOnContractAfterEnd = address(this).balance;\r\n        }\r\n        require(!leaderClaimed[msg.sender], \"You have already Claimed\");\r\n        require(Countdown() == 0, \"Wait for project end\");\r\n        require(msg.sender != address(0), \"Not allowed\");\r\n\r\n        address[5] memory _leaderAddress;\r\n\r\n        (_leaderAddress, ) = leaderboardScore();\r\n\r\n        uint256 _percent;\r\n        for (uint256 i = 0; i < leaderLength; i++) {\r\n            if (_leaderAddress[i] == msg.sender) {\r\n                _percent = leaderPercent[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        (, uint256 _leaderAmountPer, ) = winnersEthDivision(\r\n            ethOnContractAfterEnd\r\n        );\r\n        uint256 _swapAmount = (_leaderAmountPer * _percent) / Bps;\r\n\r\n        payable(msg.sender).transfer((_leaderAmountPer * _percent) / Bps);\r\n\r\n        emit ClaimedLeader(msg.sender, _swapAmount);\r\n\r\n        leaderClaimed[msg.sender] = true;\r\n    }\r\n\r\n    // 2.5%\r\n\r\n    function insuranceClaim() public {\r\n        require(Countdown() == 0, \"Wait for project end\");\r\n        require(!insuranceClaimed[msg.sender], \"You have already Claimed\");\r\n        if (ethOnContractAfterEnd == 0) {\r\n            ethOnContractAfterEnd = address(this).balance;\r\n        }\r\n        InsuranceData[] memory winners = getInsuranceWinners();\r\n        uint256 amount;\r\n\r\n        for (uint256 i = 0; i < winners.length; i++) {\r\n            if (winners[i].user == msg.sender) {\r\n                amount += winners[i].token;\r\n            }\r\n        }\r\n        require(amount != 0, \"You are not winner\");\r\n        uint256 _swapAmount = swapBackConvert(\r\n            amount * 2,\r\n            ethOnContractAfterEnd\r\n        );\r\n        emit ClaimedInsurance(msg.sender, _swapAmount);\r\n\r\n        payable(msg.sender).transfer(_swapAmount);\r\n\r\n        insuranceClaimed[msg.sender] = true;\r\n    }\r\n\r\n    function swapBackConvert(uint256 _tokens, uint256 _contractBalance)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (_contractBalance * _tokens) / totalSupply();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_ethContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedInsurance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedLastBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedLeader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"name\":\"TokensSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"TokensSwappedBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Bps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Countdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Insurance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiveTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"burnTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedDivident\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"day_1_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethOnContractAfterEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getInsuranceById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInsuranceWinners\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct PONZU3.InsuranceData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numValues\",\"type\":\"uint256\"}],\"name\":\"getSwappingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"insuranceClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyerClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"leaderClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderboardScore\",\"outputs\":[{\"internalType\":\"address[5]\",\"name\":\"\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safety\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contractBalance\",\"type\":\"uint256\"}],\"name\":\"swapBackConvert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"swapConvert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethWorth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalEthOnContract\",\"type\":\"uint256\"}],\"name\":\"winnersEthDivision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PONZU3", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000058a48e0833da82b36ea8557a8cecf9c439230c670000000000000000000000000000000000000000000000000000000000000006504f4e5a553300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006504f4e5a55330000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34dbe405f77119d53840eddd91357a37d697cef704a88a54497ad4647dedfdcc"}