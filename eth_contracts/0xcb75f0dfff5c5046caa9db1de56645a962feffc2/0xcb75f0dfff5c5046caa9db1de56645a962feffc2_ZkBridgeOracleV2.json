{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/oracle/ZkBridgeOracleV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../interface/IBlockUpdater.sol\\\";\\nimport \\\"../interface/IZKMptValidator.sol\\\";\\nimport \\\"../interface/IMptValidator.sol\\\";\\nimport \\\"../libraries/RLPReader.sol\\\";\\nimport \\\"contracts/libraries/LzV2PacketCodec.sol\\\";\\nimport {ILayerZeroEndpointV2} from \\\"../interface/layerzeroV2/ILayerZeroEndpointV2.sol\\\";\\nimport {ILayerZeroDVN} from \\\"../interface/layerzeroV2/ILayerZeroDVN.sol\\\";\\nimport {IReceiveUlnE2, Verification, UlnConfig} from \\\"../interface/layerzeroV2/IReceiveUlnE2.sol\\\";\\nimport {IReceiveUlnView, VerificationState} from \\\"../interface/layerzeroV2/IReceiveUlnView.sol\\\";\\nimport {ISendLib, MessageLibType} from \\\"../interface/layerzeroV2/ISendLib.sol\\\";\\nimport {ILayerZeroEndpoint} from  \\\"../interface/ILayerZeroEndpoint.sol\\\";\\n\\ncontract ZkBridgeOracleV2 is ILayerZeroDVN, Initializable, OwnableUpgradeable {\\n    using LzV2PacketCodec for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for bytes;\\n\\n    struct MessageLibInfo {\\n        bool enabled;\\n        MessageLibType libType;\\n        address lib;\\n    }\\n\\n    bytes32 public constant MESSAGE_TOPIC_V1 = 0x3dc6f2ede34d1db05729bbb76e5efd17ec1bc83f98f665e7fba0596dca438b96;\\n    bytes32 public constant MESSAGE_TOPIC_V2 = 0x1ab700d4ced0c005b164c0f789fd09fcbb0156d4c2041b8a3bfbcd961cd1567f;\\n\\n    ILayerZeroEndpointV2 public immutable layerZeroEndpointV2;\\n    ILayerZeroEndpoint  public immutable  layerZeroEndpointV1;\\n    uint32 public immutable localEid;\\n\\n    // eid=>fee\\n    mapping(uint32 => uint256) public chainFeeLookup;\\n    // eid=>bool\\n    mapping(uint32 => bool) public supportedDstChain;\\n    // eid=>blockUpdater\\n    mapping(uint32 => IBlockUpdater) public blockUpdaters;\\n\\n    IZKMptValidator public zkMptValidator;\\n\\n    IMptValidator public mptValidator;\\n\\n    address[] internal lzMessageLibs;\\n\\n    mapping(address => MessageLibInfo) internal messageLibLookup;\\n\\n    mapping(address => bool) public feeManager;\\n\\n    mapping(address => address) public receiveLibToView;\\n\\n    mapping(uint32 => address) public trustedRemoteLookup;\\n\\n    event OracleNotified(uint32 dstEid, uint64 blockConfirmations, address userApplication, uint256 fee);\\n    event WithdrawFee(address messageLib, address receiver, uint256 amount);\\n    event SetFee(uint32 dstEid, uint256 fee);\\n    event NewBlockUpdater(uint32 srcEid, address oldBlockUpdater, address newBlockUpdater);\\n    event NewZKMptValidator(address oldValidator, address newValidator);\\n    event NewMptValidator(address oldValidator, address newValidator);\\n    event DstChainStatusChanged(uint32 dstEid, bool enabled);\\n    event SetFeeManager(address feeManager, bool enabled);\\n\\n    error ZeroAddress();\\n    error ZkMptValidatorUnavailable();\\n    error MptValidatorUnavailable();\\n    error NotTrustedSource();\\n    error UnsupportedUpdater(uint32 srcEid);\\n    error UnsupportedChain(uint32 dstEid);\\n    error UnsupportedSendLib();\\n    error BlockNotSet();\\n    error OnlySendLib();\\n    error InsufficientFee();\\n    error MessageLibAlreadyAdded();\\n    error MessageLibAlreadyDeleted();\\n    error AlreadySet();\\n    error Unauthorized();\\n    error InvalidZkMptProof();\\n    error InvalidParameters();\\n    error ReceiveLibViewNotSet();\\n    error PacketNotVerified();\\n\\n    modifier onlyFeeManager() {\\n        if (!feeManager[msg.sender]) revert Unauthorized();\\n        _;\\n    }\\n\\n    constructor(address _layerZeroEndpointV2, address _layerZeroEndpointV1) {\\n        if (_layerZeroEndpointV2 == address(0)) revert ZeroAddress();\\n        if (_layerZeroEndpointV1 == address(0)) revert ZeroAddress();\\n        layerZeroEndpointV2 = ILayerZeroEndpointV2(_layerZeroEndpointV2);\\n        layerZeroEndpointV1 = ILayerZeroEndpoint(_layerZeroEndpointV1);\\n        localEid = layerZeroEndpointV2.eid();\\n        _disableInitializers();\\n    }\\n\\n    function initialize() public initializer {\\n        feeManager[msg.sender] = true;\\n        __Ownable_init();\\n    }\\n\\n    function batchVerify(\\n        bytes32[] calldata _blockHashs,\\n        bytes[] calldata _encodedPayloads,\\n        bytes[] calldata _zkMptProof\\n    ) external {\\n        if (address(zkMptValidator) == address(0)) revert ZkMptValidatorUnavailable();\\n        if (_blockHashs.length != _encodedPayloads.length || _blockHashs.length != _zkMptProof.length) {\\n            revert InvalidParameters();\\n        }\\n\\n        IZKMptValidator.Receipt memory receipt;\\n        for (uint256 i = 0; i < _blockHashs.length; i++) {\\n            receipt = zkMptValidator.validateMPT(_zkMptProof[i]);\\n            if (keccak256(_encodedPayloads[i]) != receipt.logsHash) revert InvalidZkMptProof();\\n            _verify(\\n                _blockHashs[i],\\n                receipt.receiptHash,\\n                _encodedPayloads[i].srcEid(),\\n                _encodedPayloads[i].receiver(),\\n                _encodedPayloads[i].header(),\\n                _encodedPayloads[i].payloadHash()\\n            );\\n        }\\n    }\\n\\n    function batchVerifyByMpt(\\n        bytes32[] calldata _blockHashs,\\n        uint256[] calldata _logIndex,\\n        bytes[] calldata _mptProof\\n    ) external {\\n        if (address(mptValidator) == address(0)) revert ZkMptValidatorUnavailable();\\n        if (_blockHashs.length != _logIndex.length || _blockHashs.length != _mptProof.length) {\\n            revert InvalidParameters();\\n        }\\n\\n        IMptValidator.Receipt memory receipt;\\n        address logContract;\\n        bytes memory encodedPayload;\\n        uint32 srcEid;\\n        for (uint256 i = 0; i < _blockHashs.length; i++) {\\n            receipt = mptValidator.validateMPT(_mptProof[i]);\\n            (logContract, encodedPayload) = _parseLog(receipt.logs, _logIndex[i]);\\n            if (logContract == address(0)) revert NotTrustedSource();\\n\\n            srcEid = encodedPayload.srcEid2();\\n            if (_isV2(srcEid)) {\\n                if (logContract != address(layerZeroEndpointV2)) revert NotTrustedSource();\\n            } else {\\n                if (logContract != trustedRemoteLookup[srcEid]) revert NotTrustedSource();\\n            }\\n\\n            _verify(\\n                _blockHashs[i],\\n                receipt.receiptHash,\\n                srcEid,\\n                encodedPayload.receiver2(),\\n                encodedPayload.header2(),\\n                encodedPayload.payloadHash2()\\n            );\\n        }\\n    }\\n\\n    function verify(bytes32 _blockHash, bytes calldata _encodedPayload, bytes calldata _zkMptProof) external {\\n        if (address(zkMptValidator) == address(0)) revert ZkMptValidatorUnavailable();\\n        IZKMptValidator.Receipt memory receipt = zkMptValidator.validateMPT(_zkMptProof);\\n        if (keccak256(_encodedPayload) != receipt.logsHash) revert InvalidZkMptProof();\\n\\n        _verify(\\n            _blockHash,\\n            receipt.receiptHash,\\n            _encodedPayload.srcEid(),\\n            _encodedPayload.receiver(),\\n            _encodedPayload.header(),\\n            _encodedPayload.payloadHash()\\n        );\\n    }\\n\\n    function verifyByMpt(bytes32 _blockHash, uint256 _logIndex, bytes calldata _mptProof) external {\\n        if (address(mptValidator) == address(0)) revert MptValidatorUnavailable();\\n        IMptValidator.Receipt memory receipt = mptValidator.validateMPT(_mptProof);\\n        (address logContract, bytes memory encodedPayload) = _parseLog(receipt.logs, _logIndex);\\n        if (logContract == address(0)) revert NotTrustedSource();\\n\\n        uint32 srcEid = encodedPayload.srcEid2();\\n        if (_isV2(srcEid)) {\\n            if (logContract != address(layerZeroEndpointV2)) revert NotTrustedSource();\\n        } else {\\n            if (logContract != trustedRemoteLookup[srcEid]) revert NotTrustedSource();\\n        }\\n\\n        _verify(\\n            _blockHash,\\n            receipt.receiptHash,\\n            srcEid,\\n            encodedPayload.receiver2(),\\n            encodedPayload.header2(),\\n            encodedPayload.payloadHash2()\\n        );\\n    }\\n\\n    function _parseLog(bytes memory _logsByte, uint256 _logIndex) internal pure returns (address logContract, bytes memory encodedPayload) {\\n        RLPReader.RLPItem[] memory logs = _logsByte.toRlpItem().listIndex(_logIndex).toList();\\n        RLPReader.RLPItem[] memory topicItem = logs[1].toList();\\n        bytes32 topic = bytes32(topicItem[0].toUint());\\n        if (topic == MESSAGE_TOPIC_V1) {\\n            logContract = logs[0].toAddress();\\n            (encodedPayload,,,) = abi.decode(logs[2].toBytes(), (bytes, bytes, uint256, uint256));\\n        } else if (topic == MESSAGE_TOPIC_V2) {\\n            logContract = logs[0].toAddress();\\n            (encodedPayload,,) = abi.decode(logs[2].toBytes(), (bytes, bytes, address));\\n        }\\n    }\\n\\n    /// @dev for dvn to verify the payload\\n    function _verify(\\n        bytes32 _blockHash,\\n        bytes32 _receiptHash,\\n        uint32 _srcEid,\\n        address _receiver,\\n        bytes memory _packetHeader,\\n        bytes32 _payloadHash\\n    ) internal {\\n        IBlockUpdater blockUpdater = blockUpdaters[_srcEid];\\n        if (address(blockUpdater) == address(0)) revert UnsupportedUpdater(_srcEid);\\n        (bool exist, uint256 blockConfirmation) = blockUpdater.checkBlockConfirmation(_blockHash, _receiptHash);\\n        if (!exist) revert BlockNotSet();\\n        address receiverLib;\\n        if (_isV2(_srcEid)) {\\n            (receiverLib,) = layerZeroEndpointV2.getReceiveLibrary(_receiver, _srcEid);\\n        } else {\\n            receiverLib = layerZeroEndpointV1.getReceiveLibraryAddress(_receiver);\\n        }\\n        UlnConfig memory ulnConfig = IReceiveUlnE2(receiverLib).getUlnConfig(_receiver, _srcEid);\\n        if (blockConfirmation < ulnConfig.confirmations) revert PacketNotVerified();\\n        IReceiveUlnE2(receiverLib).verify(_packetHeader, _payloadHash, uint64(blockConfirmation));\\n    }\\n\\n    function _isV2(uint32 _eid) internal pure returns (bool) {\\n        if (_eid > 30000) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _isLocal(uint32 _dstEid) internal view returns (bool) {\\n        if (localEid == _dstEid || localEid == _dstEid + 30000) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @inheritdoc ILayerZeroDVN\\n    function assignJob(AssignJobParam calldata _param, bytes calldata /*_options*/)\\n    external\\n    payable\\n    returns (uint256 fee)\\n    {\\n        if (!supportedDstChain[_param.dstEid]) revert UnsupportedChain(_param.dstEid);\\n        if (!isSupportedMessageLib(msg.sender)) revert UnsupportedSendLib();\\n        fee = chainFeeLookup[_param.dstEid];\\n        emit OracleNotified(_param.dstEid, _param.confirmations, _param.sender, fee);\\n\\n        if (_param.dstEid == localEid) {\\n            (address receiverLib,) = layerZeroEndpointV2.getReceiveLibrary(_param.packetHeader.receiver(), localEid);\\n            IReceiveUlnE2(receiverLib).verify(_param.packetHeader, _param.payloadHash, _param.confirmations);\\n        } else if (_param.dstEid + 30000 == localEid) {\\n            address receiverLib = layerZeroEndpointV1.getReceiveLibraryAddress(_param.packetHeader.receiver());\\n            IReceiveUlnE2(receiverLib).verify(_param.packetHeader, _param.payloadHash, _param.confirmations);\\n        }\\n    }\\n\\n    /// @inheritdoc ILayerZeroDVN\\n    function getFee(uint32 _dstEid, uint64, /*_confirmations*/ address, /*_sender*/ bytes calldata /*_options*/)\\n    external\\n    view\\n    returns (uint256 fee)\\n    {\\n        fee = chainFeeLookup[_dstEid];\\n    }\\n\\n    function hashLookup(bytes calldata _encodedPayload) external view returns (bool) {\\n        address receiverLib;\\n        if (_isV2(_encodedPayload.srcEid())) {\\n            (receiverLib,) = layerZeroEndpointV2.getReceiveLibrary(_encodedPayload.receiver(), _encodedPayload.srcEid());\\n        } else {\\n            receiverLib = layerZeroEndpointV1.getReceiveLibraryAddress(_encodedPayload.receiver());\\n        }\\n\\n        address receiveLibView = receiveLibToView[receiverLib];\\n        if (receiveLibView == address(0x0)) revert ReceiveLibViewNotSet();\\n        VerificationState state =\\n        IReceiveUlnView(receiveLibView).verifiable(_encodedPayload.header(), _encodedPayload.payloadHash());\\n        if (state == VerificationState.Verifiable || state == VerificationState.Verified) {\\n            return true;\\n        }\\n\\n        Verification memory verification = IReceiveUlnE2(receiverLib).hashLookup(\\n            keccak256(_encodedPayload.header()), _encodedPayload.payloadHash(), address(this)\\n        );\\n        return verification.submitted;\\n    }\\n\\n    function feeBalance() public view returns (uint256 balance) {\\n        for (uint256 i = 0; i < getLzMessageLibLength(); i++) {\\n            address _messageLib = lzMessageLibs[i];\\n            if (messageLibLookup[_messageLib].enabled) {\\n                balance += ISendLib(_messageLib).fees(address(this));\\n            }\\n        }\\n    }\\n\\n    function isSupportedMessageLib(address _messageLib) public view returns (bool) {\\n        return messageLibLookup[_messageLib].enabled;\\n    }\\n\\n    function getLzMessageLibLength() public view returns (uint256) {\\n        return lzMessageLibs.length;\\n    }\\n\\n    function getLzMessageLib(address _msgLib) public view returns (MessageLibInfo memory) {\\n        return messageLibLookup[_msgLib];\\n    }\\n\\n    //----------------------------------------------------------------------------------\\n    // onlyFeeManager\\n    function setFees(uint32[] calldata _dstEid, uint256[] calldata _price) external onlyFeeManager {\\n        if (_dstEid.length != _price.length) revert InvalidParameters();\\n        for (uint256 i = 0; i < _dstEid.length; i++) {\\n            chainFeeLookup[_dstEid[i]] = _price[i];\\n            emit SetFee(_dstEid[i], _price[i]);\\n        }\\n    }\\n\\n    function setFee(uint32 _dstEid, uint256 _price) external onlyFeeManager {\\n        chainFeeLookup[_dstEid] = _price;\\n        emit SetFee(_dstEid, _price);\\n    }\\n\\n    //----------------------------------------------------------------------------------\\n    // onlyOwner\\n    function setDstChain(uint32 _dstEid, bool enabled) external onlyOwner {\\n        if (supportedDstChain[_dstEid] == enabled) revert AlreadySet();\\n\\n        supportedDstChain[_dstEid] = enabled;\\n        emit DstChainStatusChanged(_dstEid, enabled);\\n    }\\n\\n    function addLzMessageLib(address _messageLib) external onlyOwner {\\n        messageLibLookup[_messageLib] = MessageLibInfo(true, MessageLibType.Send, _messageLib);\\n        lzMessageLibs.push(_messageLib);\\n    }\\n\\n    function removeLzMessageLib(address _messageLib) external onlyOwner {\\n        if (!messageLibLookup[_messageLib].enabled) revert MessageLibAlreadyDeleted();\\n\\n        messageLibLookup[_messageLib].enabled = false;\\n        uint256 fee = ISendLib(_messageLib).fees(address(this));\\n        if (fee > 0) {\\n            ISendLib(_messageLib).withdrawFee(payable(owner()), fee);\\n            emit WithdrawFee(_messageLib, owner(), fee);\\n        }\\n    }\\n\\n    function withdrawFeeAll(address payable _to) external onlyOwner {\\n        uint256 _amount = 0;\\n        for (uint256 i = 0; i < getLzMessageLibLength(); i++) {\\n            address _messageLib = lzMessageLibs[i];\\n            if (!isSupportedMessageLib(_messageLib)) {\\n                continue;\\n            }\\n            uint256 ulnBalance = ISendLib(_messageLib).fees(address(this));\\n            if (ulnBalance > 0) {\\n                ISendLib(_messageLib).withdrawFee(_to, ulnBalance);\\n                emit WithdrawFee(_messageLib, _to, ulnBalance);\\n                _amount += ulnBalance;\\n            }\\n        }\\n        if (_amount == 0) {\\n            revert InsufficientFee();\\n        }\\n    }\\n\\n    function withdrawFee(address _messageLib, address payable _to) external onlyOwner {\\n        uint256 _fee = ISendLib(_messageLib).fees(address(this));\\n        if (_fee == 0) {\\n            revert InsufficientFee();\\n        }\\n        ISendLib(_messageLib).withdrawFee(_to, _fee);\\n\\n        emit WithdrawFee(_messageLib, _to, _fee);\\n    }\\n\\n    function setBlockUpdater(uint32 _srcEid, address _newBlockUpdater) external onlyOwner {\\n        if (_newBlockUpdater == address(0)) revert ZeroAddress();\\n        if (address(blockUpdaters[_srcEid]) == _newBlockUpdater) revert AlreadySet();\\n\\n        emit NewBlockUpdater(_srcEid, address(blockUpdaters[_srcEid]), _newBlockUpdater);\\n        blockUpdaters[_srcEid] = IBlockUpdater(_newBlockUpdater);\\n    }\\n\\n    function setZKMptValidator(address _newZkMptValidator) external onlyOwner {\\n        if (_newZkMptValidator == address(0)) revert ZeroAddress();\\n        if (address(zkMptValidator) == _newZkMptValidator) revert AlreadySet();\\n\\n        emit NewZKMptValidator(address(zkMptValidator), _newZkMptValidator);\\n\\n        zkMptValidator = IZKMptValidator(_newZkMptValidator);\\n    }\\n\\n    function setMptValidator(address _newMptValidator) external onlyOwner {\\n        if (_newMptValidator == address(0)) revert ZeroAddress();\\n        if (address(mptValidator) == _newMptValidator) revert AlreadySet();\\n\\n        emit NewMptValidator(address(mptValidator), _newMptValidator);\\n\\n        mptValidator = IMptValidator(_newMptValidator);\\n    }\\n\\n    function setFeeManager(address feeManager_, bool enabled_) external onlyOwner {\\n        if (feeManager_ == address(0)) revert ZeroAddress();\\n        if (feeManager[feeManager_] == enabled_) revert AlreadySet();\\n\\n        feeManager[feeManager_] = enabled_;\\n        emit SetFeeManager(feeManager_, enabled_);\\n    }\\n\\n    function setReceiveView(address receiveLib_, address receiveLibView_) external onlyOwner {\\n        receiveLibToView[receiveLib_] = receiveLibView_;\\n    }\\n\\n    function setTrustedRemoteLookup(uint32 eid, address trustedRemoteAddress) external onlyOwner {\\n        trustedRemoteLookup[eid] = trustedRemoteAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IBlockUpdater.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBlockUpdater {\\n    event ImportBlock(uint256 identifier, bytes32 blockHash, bytes32 receiptHash);\\n\\n    function importBlock(bytes calldata _proof) external;\\n\\n    function checkBlock(bytes32 _blockHash, bytes32 _receiptsRoot) external view returns (bool);\\n\\n    function checkBlockConfirmation(bytes32 _blockHash, bytes32 _receiptsRoot) external view returns (bool, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IZKMptValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IZKMptValidator {\\n    struct Receipt {\\n        bytes32 receiptHash;\\n        bytes32 logsHash;\\n    }\\n\\n    function validateMPT(bytes calldata _proof) external view returns (Receipt memory receipt);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMptValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMptValidator {\\n    struct Receipt {\\n        bytes32 receiptHash;\\n        bytes logs;\\n    }\\n\\n    function validateMPT(bytes memory proof) external view returns (Receipt memory receipt);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint len;\\n        uint memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint ptr = self.nextPtr;\\n        uint itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n        uint len = item.length;\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    function toRlpItemWithTxType(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n        uint len = item.length;\\n\\n        uint8 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n        if (len > 0 && byte0 < LIST_SHORT_START) {\\n            assembly {\\n                memPtr := add(memPtr, 0x01)\\n            }\\n            len -= 1;\\n        }\\n\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint memPtr;\\n        uint len;\\n        unchecked {\\n            memPtr = item.memPtr + offset;\\n            len = item.len - offset; // data length\\n        }\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\\n        (, uint len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        RLPItem[] memory result;\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        uint count = 0;\\n        uint freeMemPtr;\\n        assembly {\\n            freeMemPtr := mload(0x40)\\n        }\\n        unchecked {\\n            while (memPtr < endPtr) {\\n                uint dataLen = _itemLength(memPtr);\\n                assembly {\\n                    let offset := add(freeMemPtr, mul(count, 0x40))\\n                    mstore(offset, dataLen)\\n                    mstore(add(offset, 0x20), memPtr)\\n                }\\n                memPtr = memPtr + dataLen;\\n                count++;\\n            }\\n        }\\n        assembly {\\n            result := add(freeMemPtr, mul(count, 0x40))\\n            mstore(result, count)\\n            let j := add(result, 0x20)\\n            for {\\n                let i := freeMemPtr\\n            } lt(i, result) {\\n                i := add(i, 0x40)\\n                j := add(j, 0x20)\\n            } {\\n                mstore(j, i)\\n            }\\n            mstore(0x40, j)\\n        }\\n\\n        return result;\\n    }\\n\\n    function listIndex(RLPItem memory item, uint256 index) internal pure returns (RLPItem memory) {\\n        require(isList(item));\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        uint count = 0;\\n        unchecked {\\n            while (memPtr < endPtr) {\\n                uint dataLen = _itemLength(memPtr);\\n                if (count == index) return RLPItem(dataLen, memPtr);\\n                memPtr = memPtr + dataLen;\\n                count++;\\n            }\\n        }\\n        revert();\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint memPtr, uint len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint result;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint memPtr, uint len) = payloadLocation(item);\\n\\n        uint result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := shr(shl(3, sub(32, len)), result)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint result;\\n        uint memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint memPtr, uint len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint memPtr) private pure returns (uint) {\\n        uint itemLen;\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 < STRING_LONG_START) {\\n            unchecked {\\n                itemLen = byte0 - STRING_SHORT_START + 1;\\n            }\\n        }\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := shr(shl(3, sub(32, byteLen)), mload(memPtr)) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            unchecked {\\n                itemLen = byte0 - LIST_SHORT_START + 1;\\n            }\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := shr(shl(3, sub(32, byteLen)), mload(memPtr)) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\\n        else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            unchecked {\\n                return byte0 - (STRING_LONG_START - 1) + 1;\\n            }\\n        } else {\\n            unchecked {\\n                return byte0 - (LIST_LONG_START - 1) + 1;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint src, uint dest, uint len) private pure {\\n        if (len <= 32) {\\n            assembly {\\n                let mask := shr(shl(3, len), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n            return;\\n        }\\n\\n        function (uint, uint, uint) view impureCopy = __copy;\\n        function (uint, uint, uint) pure pureCopy;\\n\\n        assembly {\\n            pureCopy := impureCopy\\n        }\\n\\n        pureCopy(src, dest, len);\\n    }\\n\\n    function __copy(uint src, uint dest, uint len) private view {\\n        assembly {\\n            if iszero(staticcall(gas(), 0x04, src, len, dest, len)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function toBytes32(RLPItem memory self) internal pure returns (bytes32 data) {\\n        return bytes32(toUint(self));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LzV2PacketCodec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BytesLib.sol\\\";\\n\\nlibrary LzV2PacketCodec {\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant PACKET_VERSION = 1;\\n\\n    // header (version + nonce + path)\\n    // version\\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\\n    //    nonce\\n    uint256 private constant NONCE_OFFSET = 1;\\n    //    path\\n    uint256 private constant SRC_EID_OFFSET = 9;\\n    uint256 private constant SENDER_OFFSET = 13;\\n    uint256 private constant SENDER_OFFSET2 = 25;\\n    uint256 private constant DST_EID_OFFSET = 45;\\n    uint256 private constant RECEIVER_OFFSET = 49;\\n    uint256 private constant RECEIVER_OFFSET2 = 61;\\n    // payload (guid + message)\\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\\n    uint256 private constant MESSAGE_OFFSET = 113;\\n\\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return _packet[0 : GUID_OFFSET];\\n    }\\n\\n    function header2(bytes memory _packet) internal pure returns (bytes memory) {\\n        return _packet.slice(0,GUID_OFFSET);\\n    }\\n\\n    function version(bytes calldata _packet) internal pure returns (uint8) {\\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET : NONCE_OFFSET]));\\n    }\\n\\n    function version2(bytes memory _packet) internal pure returns (uint8) {\\n        return _packet.toUint8(PACKET_VERSION_OFFSET);\\n    }\\n\\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\\n        return uint64(bytes8(_packet[NONCE_OFFSET : SRC_EID_OFFSET]));\\n    }\\n\\n    function nonce2(bytes memory _packet) internal pure returns (uint64) {\\n        return _packet.toUint64(NONCE_OFFSET);\\n    }\\n\\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\\n        return uint32(bytes4(_packet[SRC_EID_OFFSET : SENDER_OFFSET]));\\n    }\\n\\n    function srcEid2(bytes memory _packet) internal pure returns (uint32) {\\n        return _packet.toUint32(SRC_EID_OFFSET);\\n    }\\n\\n    function sender(bytes calldata _packet) internal pure returns (address) {\\n        return address(uint160(uint256(bytes32(_packet[SENDER_OFFSET : DST_EID_OFFSET]))));\\n    }\\n\\n    function sender2(bytes memory _packet) internal pure returns (address) {\\n        return _packet.toAddress(SENDER_OFFSET2);\\n    }\\n\\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\\n        return uint32(bytes4(_packet[DST_EID_OFFSET : RECEIVER_OFFSET]));\\n    }\\n\\n    function dstEid2(bytes memory _packet) internal pure returns (uint32) {\\n        return _packet.toUint32(DST_EID_OFFSET);\\n    }\\n\\n    function receiver(bytes calldata _packet) internal pure returns (address) {\\n        return address(uint160(uint256(bytes32(_packet[RECEIVER_OFFSET : GUID_OFFSET]))));\\n    }\\n\\n    function receiver2(bytes memory _packet) internal pure returns (address) {\\n        return _packet.toAddress(RECEIVER_OFFSET2);\\n    }\\n\\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\\n        return bytes32(_packet[GUID_OFFSET : MESSAGE_OFFSET]);\\n    }\\n\\n    function guid2(bytes memory _packet) internal pure returns (bytes32) {\\n        return _packet.toBytes32(GUID_OFFSET);\\n    }\\n\\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return bytes(_packet[MESSAGE_OFFSET :]);\\n    }\\n\\n    function message2(bytes memory _packet) internal pure returns (bytes memory) {\\n        return _packet.slice(MESSAGE_OFFSET, _packet.length - MESSAGE_OFFSET);\\n    }\\n\\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return bytes(_packet[GUID_OFFSET :]);\\n    }\\n\\n    function payload2(bytes memory _packet) internal pure returns (bytes memory) {\\n        return _packet.slice(GUID_OFFSET, _packet.length - GUID_OFFSET);\\n    }\\n\\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\\n        return keccak256(payload(_packet));\\n    }\\n\\n    function payloadHash2(bytes memory _packet) internal pure returns (bytes32) {\\n        return keccak256(payload2(_packet));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/ILayerZeroEndpointV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IMessageLibManager } from \\\"./IMessageLibManager.sol\\\";\\nimport { IMessagingComposer } from \\\"./IMessagingComposer.sol\\\";\\nimport { IMessagingChannel } from \\\"./IMessagingChannel.sol\\\";\\nimport { IMessagingContext } from \\\"./IMessagingContext.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n    bool payInLzToken;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint256 nativeFee;\\n    uint256 lzTokenFee;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\\nenum ExecutionState {\\n    NotExecutable,\\n    Executable,\\n    Executed\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketDelivered(Origin origin, address receiver);\\n\\n    event LzReceiveAlert(\\n        address indexed receiver,\\n        address indexed executor,\\n        Origin origin,\\n        bytes32 guid,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    event LzTokenSet(address token);\\n\\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function verifiable(\\n        Origin calldata _origin,\\n        address _receiver,\\n        address _receiveLib,\\n        bytes32 _payloadHash\\n    ) external view returns (bool);\\n\\n    function executable(Origin calldata _origin, address _receiver) external view returns (ExecutionState);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLzToken(address _lzToken) external;\\n\\n    function lzToken() external view returns (address);\\n\\n    function nativeToken() external view returns (address);\\n\\n    function setDelegate(address _delegate) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/ILayerZeroDVN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroDVN {\\n    struct AssignJobParam {\\n        uint32 dstEid;\\n        bytes packetHeader;\\n        bytes32 payloadHash;\\n        uint64 confirmations;\\n        address sender;\\n    }\\n\\n    // @notice query price and assign jobs at the same time\\n    // @param _dstEid - the destination endpoint identifier\\n    // @param _packetHeader - version + nonce + path\\n    // @param _payloadHash - hash of guid + message\\n    // @param _confirmations - block confirmation delay before relaying blocks\\n    // @param _sender - the source sending contract address\\n    // @param _options - options\\n    function assignJob(AssignJobParam calldata _param, bytes calldata _options) external payable returns (uint256 fee);\\n\\n    // @notice query the dvn fee for relaying block information to the destination chain\\n    // @param _dstEid the destination endpoint identifier\\n    // @param _confirmations - block confirmation delay before relaying blocks\\n    // @param _sender - the source sending contract address\\n    // @param _options - options\\n    function getFee(\\n        uint32 _dstEid,\\n        uint64 _confirmations,\\n        address _sender,\\n        bytes calldata _options\\n    ) external view returns (uint256 fee);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IReceiveUlnE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nstruct Verification {\\n    bool submitted;\\n    uint64 confirmations;\\n}\\n\\nstruct UlnConfig {\\n    uint64 confirmations;\\n    uint8 requiredDVNCount;\\n    uint8 optionalDVNCount;\\n    uint8 optionalDVNThreshold;\\n    address[] requiredDVNs;\\n    address[] optionalDVNs;\\n\\n}\\n/// @dev should be implemented by the ReceiveUln302 contract and future ReceiveUln contracts on EndpointV2\\ninterface IReceiveUlnE2 {\\n    /// @notice for each dvn to verify the payload\\n    /// @dev this function signature 0x0223536e\\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;\\n\\n    /// @notice verify the payload at endpoint, will check if all DVNs verified\\n    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external;\\n\\n    function hashLookup(bytes32 _headerHash, bytes32 _payloadHash, address _dnv)\\n        external\\n        view\\n        returns (Verification memory);\\n\\n    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IReceiveUlnView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nenum VerificationState {\\n    Verifying,\\n    Verifiable,\\n    Verified,\\n    NotInitializable\\n}\\n\\ninterface IReceiveUlnView {\\n    /// @dev a ULN verifiable requires it to be endpoint verifiable and committable\\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/ISendLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport {MessagingFee} from \\\"./ILayerZeroEndpointV2.sol\\\";\\nimport {IMessageLib, MessageLibType} from \\\"./IMessageLib.sol\\\";\\n\\nstruct Packet {\\n    uint64 nonce;\\n    uint32 srcEid;\\n    address sender;\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes32 guid;\\n    bytes message;\\n}\\n\\ninterface ISendLib is IMessageLib {\\n    function send(Packet calldata _packet, bytes calldata _options, bool _payInLzToken)\\n        external\\n        returns (MessagingFee memory, bytes memory encodedPacket);\\n\\n    function quote(Packet calldata _packet, bytes calldata _options, bool _payInLzToken)\\n        external\\n        view\\n        returns (MessagingFee memory);\\n\\n    function setTreasury(address _treasury) external;\\n\\n    function withdrawFee(address _to, uint256 _amount) external;\\n\\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\\n\\n    function fees(address worker) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILayerZeroEndpoint {\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(\\n        address _userApplication\\n    ) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(\\n        address _userApplication\\n    ) external view returns (address);\\n\\n    function defaultSendLibrary() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IMessageLibManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 eid;\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint256 expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address oldLib, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address oldLib, address newLib);\\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IMessagingComposer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\\n    event LzComposeAlert(\\n        address indexed from,\\n        address indexed to,\\n        address indexed executor,\\n        bytes32 guid,\\n        uint16 index,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    function composeQueue(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index\\n    ) external view returns (bytes32 messageHash);\\n\\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IMessagingChannel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message cannot be verified for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IMessagingContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32 dstEid, address sender);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzeroV2/IMessageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {SetConfigParam} from \\\"./IMessageLibManager.sol\\\";\\n\\nenum MessageLibType {\\n    Send,\\n    Receive,\\n    SendAndReceive\\n}\\n\\ninterface IMessageLib is IERC165 {\\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\\n\\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    // message libs of same major version are compatible\\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\\n\\n    function messageLibType() external view returns (MessageLibType);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"solidity-bytes-utils/=node_modules/solidity-bytes-utils/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_layerZeroEndpointV2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_layerZeroEndpointV1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BlockNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZkMptProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MessageLibAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MessageLibAlreadyDeleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MptValidatorUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySendLib\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PacketNotVerified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiveLibViewNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"}],\"name\":\"UnsupportedChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedSendLib\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"}],\"name\":\"UnsupportedUpdater\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZkMptValidatorUnavailable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"DstChainStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldBlockUpdater\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBlockUpdater\",\"type\":\"address\"}],\"name\":\"NewBlockUpdater\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"NewMptValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"NewZKMptValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"blockConfirmations\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userApplication\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"OracleNotified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetFeeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"messageLib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MESSAGE_TOPIC_V1\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MESSAGE_TOPIC_V2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageLib\",\"type\":\"address\"}],\"name\":\"addLzMessageLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"packetHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"internalType\":\"struct ILayerZeroDVN.AssignJobParam\",\"name\":\"_param\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"assignJob\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_blockHashs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_encodedPayloads\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_zkMptProof\",\"type\":\"bytes[]\"}],\"name\":\"batchVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_blockHashs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_logIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_mptProof\",\"type\":\"bytes[]\"}],\"name\":\"batchVerifyByMpt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"blockUpdaters\",\"outputs\":[{\"internalType\":\"contract IBlockUpdater\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"chainFeeLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msgLib\",\"type\":\"address\"}],\"name\":\"getLzMessageLib\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"enum MessageLibType\",\"name\":\"libType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"lib\",\"type\":\"address\"}],\"internalType\":\"struct ZkBridgeOracleV2.MessageLibInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLzMessageLibLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_encodedPayload\",\"type\":\"bytes\"}],\"name\":\"hashLookup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageLib\",\"type\":\"address\"}],\"name\":\"isSupportedMessageLib\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerZeroEndpointV1\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerZeroEndpointV2\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpointV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localEid\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mptValidator\",\"outputs\":[{\"internalType\":\"contract IMptValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"receiveLibToView\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageLib\",\"type\":\"address\"}],\"name\":\"removeLzMessageLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_srcEid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_newBlockUpdater\",\"type\":\"address\"}],\"name\":\"setBlockUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDstChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeManager_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled_\",\"type\":\"bool\"}],\"name\":\"setFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_dstEid\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_price\",\"type\":\"uint256[]\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMptValidator\",\"type\":\"address\"}],\"name\":\"setMptValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiveLib_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiveLibView_\",\"type\":\"address\"}],\"name\":\"setReceiveView\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"trustedRemoteAddress\",\"type\":\"address\"}],\"name\":\"setTrustedRemoteLookup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newZkMptValidator\",\"type\":\"address\"}],\"name\":\"setZKMptValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"supportedDstChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"trustedRemoteLookup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_encodedPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_zkMptProof\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_logIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_mptProof\",\"type\":\"bytes\"}],\"name\":\"verifyByMpt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageLib\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFeeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkMptValidator\",\"outputs\":[{\"internalType\":\"contract IZKMptValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZkBridgeOracleV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001a44076050125825900e736c501f859c50fe728c00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd675", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}