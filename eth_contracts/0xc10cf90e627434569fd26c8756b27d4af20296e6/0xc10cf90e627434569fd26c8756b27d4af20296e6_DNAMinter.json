{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ERC6551/src/interfaces/IERC6551Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC6551Registry {\\n    event AccountCreated(\\n        address account,\\n        address implementation,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId,\\n        uint256 salt\\n    );\\n\\n    function createAccount(\\n        address implementation,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId,\\n        uint256 seed,\\n        bytes calldata initData\\n    ) external returns (address);\\n\\n    function account(\\n        address implementation,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId,\\n        uint256 salt\\n    ) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICre8ing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {ILockup} from \\\"./ILockup.sol\\\";\\n\\ninterface ICre8ing {\\n    /// @notice Getter for Lockup interface\\n    function lockUp(address) external view returns (ILockup);\\n\\n    /// @dev Emitted when a CRE8OR begins cre8ing.\\n    event Cre8ed(address, uint256 indexed tokenId);\\n\\n    /// @dev Emitted when a CRE8OR stops cre8ing; either through standard means or\\n    ///     by expulsion.\\n    event Uncre8ed(address, uint256 indexed tokenId);\\n\\n    /// @dev Emitted when a CRE8OR is expelled from the Warehouse.\\n    event Expelled(address, uint256 indexed tokenId);\\n\\n    /// @notice Missing cre8ing status\\n    error CRE8ING_NotCre8ing(address, uint256 tokenId);\\n\\n    /// @notice Cre8ing Closed\\n    error Cre8ing_Cre8ingClosed();\\n\\n    /// @notice Cre8ing\\n    error Cre8ing_Cre8ing();\\n\\n    /// @notice Missing Lockup\\n    error Cre8ing_MissingLockup();\\n\\n    /// @notice Cre8ing period\\n    function cre8ingPeriod(\\n        address,\\n        uint256\\n    ) external view returns (bool cre8ing, uint256 current, uint256 total);\\n\\n    /// @notice open / close staking\\n    function setCre8ingOpen(address, bool) external;\\n\\n    /// @notice force removal from staking\\n    function expelFromWarehouse(address, uint256) external;\\n\\n    /// @notice function getCre8ingStarted(\\n    function getCre8ingStarted(\\n        address _target,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    /// @notice array of staked tokenIDs\\n    /// @dev used in cre8ors ui to quickly get list of staked NFTs.\\n    function cre8ingTokens(\\n        address _target\\n    ) external view returns (uint256[] memory stakedTokens);\\n\\n    /// @notice initialize both staking and lockups\\n    function inializeStakingAndLockup(\\n        address _target,\\n        uint256[] memory,\\n        bytes memory\\n    ) external;\\n\\n    /// @notice Set a new lockup for the target.\\n    /// @param _target The target address.\\n    /// @param newLockup The new lockup contract address.\\n    function setLockup(address _target, ILockup newLockup) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICre8ors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Drop} from \\\"./IERC721Drop.sol\\\";\\nimport {ILockup} from \\\"./ILockup.sol\\\";\\nimport {IERC721A} from \\\"erc721a/contracts/IERC721A.sol\\\";\\nimport {ICre8ing} from \\\"./ICre8ing.sol\\\";\\nimport {ISubscription} from \\\"../subscription/interfaces/ISubscription.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n*/\\n/// @notice Interface for Cre8ors Drops contract\\ninterface ICre8ors is IERC721Drop, IERC721A {\\n    function cre8ing() external view returns (ICre8ing);\\n\\n    /// @notice Getter for last minted token ID (gets next token id and subtracts 1)\\n    function _lastMintedTokenId() external view returns (uint256);\\n\\n    /// @dev Returns `true` if `account` has been granted `role`.\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    function subscription() external view returns (address);\\n\\n    function setSubscription(address newSubscription) external;\\n\\n    function setCre8ing(ICre8ing _cre8ing) external;\\n\\n    function MINTER_ROLE() external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721Drop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IMetadataRenderer} from \\\"../interfaces/IMetadataRenderer.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n*/\\n/// @notice Interface for Cre8ors Drop contract\\ninterface IERC721Drop {\\n    // Access errors\\n\\n    /// @notice Only admin can access this function\\n    error Access_OnlyAdmin();\\n    /// @notice Missing the given role or admin access\\n    error Access_MissingRoleOrAdmin(bytes32 role);\\n    /// @notice Withdraw is not allowed by this user\\n    error Access_WithdrawNotAllowed();\\n    /// @notice Cannot withdraw funds due to ETH send failure.\\n    error Withdraw_FundsSendFailure();\\n    /// @notice Missing the owner role.\\n    error Access_OnlyOwner();\\n    /// @notice Missing the owner role or approved nft access.\\n    error Access_MissingOwnerOrApproved();\\n\\n    // Sale/Purchase errors\\n    /// @notice Sale is inactive\\n    error Sale_Inactive();\\n    /// @notice Presale is inactive\\n    error Presale_Inactive();\\n    /// @notice Presale merkle root is invalid\\n    error Presale_MerkleNotApproved();\\n    /// @notice Wrong price for purchase\\n    error Purchase_WrongPrice(uint256 correctPrice);\\n    /// @notice NFT sold out\\n    error Mint_SoldOut();\\n    /// @notice Too many purchase for address\\n    error Purchase_TooManyForAddress();\\n    /// @notice Too many presale for address\\n    error Presale_TooManyForAddress();\\n\\n    // Admin errors\\n    /// @notice Royalty percentage too high\\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\\n    /// @notice Invalid admin upgrade address\\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\\n    error Admin_UnableToFinalizeNotOpenEdition();\\n\\n    /// @notice Event emitted for each sale\\n    /// @param to address sale was made to\\n    /// @param quantity quantity of the minted nfts\\n    /// @param pricePerToken price for each token\\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\\n    event Sale(\\n        address indexed to,\\n        uint256 indexed quantity,\\n        uint256 indexed pricePerToken,\\n        uint256 firstPurchasedTokenId\\n    );\\n\\n    /// @notice Sales configuration has been changed\\n    /// @dev To access new sales configuration, use getter function.\\n    /// @param changedBy Changed by user\\n    event SalesConfigChanged(address indexed changedBy);\\n\\n    /// @notice Event emitted when the funds recipient is changed\\n    /// @param newAddress new address for the funds recipient\\n    /// @param changedBy address that the recipient is changed by\\n    event FundsRecipientChanged(\\n        address indexed newAddress,\\n        address indexed changedBy\\n    );\\n\\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\\n    /// @param withdrawnBy address that issued the withdraw\\n    /// @param withdrawnTo address that the funds were withdrawn to\\n    /// @param amount amount that was withdrawn\\n    event FundsWithdrawn(\\n        address indexed withdrawnBy,\\n        address indexed withdrawnTo,\\n        uint256 amount\\n    );\\n\\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\\n    /// @param sender address sending close mint\\n    /// @param numberOfMints number of mints the contract is finalized at\\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\\n\\n    /// @notice Event emitted when metadata renderer is updated.\\n    /// @param sender address of the updater\\n    /// @param renderer new metadata renderer address\\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\\n\\n    /// @notice General configuration for NFT Minting and bookkeeping\\n    struct Configuration {\\n        /// @dev Metadata renderer (uint160)\\n        IMetadataRenderer metadataRenderer;\\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\\n        uint64 editionSize;\\n        /// @dev Royalty amount in bps (uint224+16 = 240)\\n        uint16 royaltyBPS;\\n        /// @dev Funds recipient for sale (new slot, uint160)\\n        address payable fundsRecipient;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct SalesConfiguration {\\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\\n    struct BurnConfiguration {\\n        /// @dev Token to burn\\n        address burnToken;\\n        /// @dev Required number of tokens to burn\\n        uint256 burnQuantity;\\n    }\\n\\n    /// @notice Sales states and configuration\\n    /// @dev Uses 3 storage slots\\n    struct ERC20SalesConfiguration {\\n        /// @notice Public sale price\\n        /// @dev max ether value > 1000 ether with this value\\n        uint104 publicSalePrice;\\n        /// @dev ERC20 Token\\n        address erc20PaymentToken;\\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\\n        /// @dev Max purchase number per txn (90+32 = 122)\\n        uint32 maxSalePurchasePerAddress;\\n        /// @dev uint64 type allows for dates into 292 billion years\\n        /// @notice Public sale start timestamp (136+64 = 186)\\n        uint64 publicSaleStart;\\n        /// @notice Public sale end timestamp (186+64 = 250)\\n        uint64 publicSaleEnd;\\n        /// @notice Presale start timestamp\\n        /// @dev new storage slot\\n        uint64 presaleStart;\\n        /// @notice Presale end timestamp\\n        uint64 presaleEnd;\\n        /// @notice Presale merkle root\\n        bytes32 presaleMerkleRoot;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct SaleDetails {\\n        // Synthesized status variables for sale and presale\\n        bool publicSaleActive;\\n        bool presaleActive;\\n        // Price for public sale\\n        uint256 publicSalePrice;\\n        // Timed sale actions for public sale\\n        uint64 publicSaleStart;\\n        uint64 publicSaleEnd;\\n        // Timed sale actions for presale\\n        uint64 presaleStart;\\n        uint64 presaleEnd;\\n        // Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        // Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        // Information about the rest of the supply\\n        // Total that have been minted\\n        uint256 totalMinted;\\n        // The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return value for sales details to use with front-ends\\n    struct ERC20SaleDetails {\\n        /// @notice Synthesized status variables for sale\\n        bool publicSaleActive;\\n        /// @notice Synthesized status variables for presale\\n        bool presaleActive;\\n        /// @notice Price for public sale\\n        uint256 publicSalePrice;\\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\\n        address erc20PaymentToken;\\n        /// @notice public sale start\\n        uint64 publicSaleStart;\\n        /// @notice public sale end\\n        uint64 publicSaleEnd;\\n        /// @notice Timed sale actions for presale start\\n        uint64 presaleStart;\\n        /// @notice Timed sale actions for presale end\\n        uint64 presaleEnd;\\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\\n        bytes32 presaleMerkleRoot;\\n        /// @notice Limit public sale to a specific number of mints per wallet\\n        uint256 maxSalePurchasePerAddress;\\n        /// @notice Total that have been minted\\n        uint256 totalMinted;\\n        /// @notice The total supply available\\n        uint256 maxSupply;\\n    }\\n\\n    /// @notice Return type of specific mint counts and details per address\\n    struct AddressMintDetails {\\n        /// Number of total mints from the given address\\n        uint256 totalMints;\\n        /// Number of presale mints from the given address\\n        uint256 presaleMints;\\n        /// Number of public mints from the given address\\n        uint256 publicMints;\\n    }\\n\\n    /// @notice External purchase function (payable in eth)\\n    /// @param quantity to purchase\\n    /// @return first minted token ID\\n    function purchase(uint256 quantity) external payable returns (uint256);\\n\\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\\n    /// @param quantity to purchase\\n    /// @param maxQuantity can purchase (verified by merkle root)\\n    /// @param pricePerToken price per token allowed (verified by merkle root)\\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\\n    /// @return first minted token ID\\n    function purchasePresale(\\n        uint256 quantity,\\n        uint256 maxQuantity,\\n        uint256 pricePerToken,\\n        bytes32[] memory merkleProof\\n    ) external payable returns (uint256);\\n\\n    /// @notice Function to return the global sales details for the given drop\\n    function saleDetails() external view returns (ERC20SaleDetails memory);\\n\\n    /// @notice Function to return the specific sales details for a given address\\n    /// @param minter address for minter to return mint information for\\n    function mintedPerAddress(\\n        address minter\\n    ) external view returns (AddressMintDetails memory);\\n\\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\\n    function owner() external view returns (address);\\n\\n    /// @notice Update the metadata renderer\\n    /// @param newRenderer new address for renderer\\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\\n    function setMetadataRenderer(\\n        IMetadataRenderer newRenderer,\\n        bytes memory setupRenderer\\n    ) external;\\n\\n    /// @notice This is an admin mint function to mint a quantity to a specific address\\n    /// @param to address to mint to\\n    /// @param quantity quantity to mint\\n    /// @return the id of the first minted NFT\\n    function adminMint(address to, uint256 quantity) external returns (uint256);\\n\\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\\n    /// @param to list of addresses to mint an NFT each to\\n    /// @return the id of the first minted NFT\\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\\n\\n    /// @dev Getter for admin role associated with the contract to handle metadata\\n    /// @return boolean if address is admin\\n    function isAdmin(address user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILockup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                     \\n */\\ninterface ILockup {\\n    /// @notice Storage for token edition information\\n    struct TokenLockupInfo {\\n        uint64 unlockDate;\\n        uint256 priceToUnlock;\\n    }\\n\\n    /// @notice Locked\\n    error Lockup_Locked();\\n\\n    /// @notice Wrong price for unlock\\n    error Unlock_WrongPrice(uint256 correctPrice);\\n\\n    /// @notice Event for updated Lockup\\n    event TokenLockupUpdated(\\n        address indexed target,\\n        uint256 tokenId,\\n        uint64 unlockDate,\\n        uint256 priceToUnlock\\n    );\\n\\n    /// @notice retrieves locked state for token\\n    function isLocked(address, uint256) external view returns (bool);\\n\\n    /// @notice retieves unlock date for token\\n    function unlockInfo(\\n        address,\\n        uint256\\n    ) external view returns (TokenLockupInfo memory);\\n\\n    /// @notice sets unlock tier for token\\n    function setUnlockInfo(address, uint256, bytes memory) external;\\n\\n    /// @notice pay to unlock a locked token\\n    function payToUnlock(address payable, uint256) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                     \\n */\\n\\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\\ninterface IMetadataRenderer {\\n    function tokenURI(uint256) external view returns (string memory);\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function initializeWithData(bytes memory initData) external;\\n}\\n\"\r\n    },\r\n    \"src/minter/DNAMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {Cre8orsERC6551} from \\\"../utils/Cre8orsERC6551.sol\\\";\\nimport {ICre8ors} from \\\"../interfaces/ICre8ors.sol\\\";\\nimport {ICre8ing} from \\\"../interfaces/ICre8ing.sol\\\";\\nimport {IERC721Drop} from \\\"../interfaces/IERC721Drop.sol\\\";\\nimport {ISubscription} from \\\"../subscription/interfaces/ISubscription.sol\\\";\\nimport {Admin} from \\\"../subscription/abstracts/Admin.sol\\\";\\nimport {IERC6551Registry} from \\\"lib/ERC6551/src/interfaces/IERC6551Registry.sol\\\";\\n\\ncontract DNAMinter is Cre8orsERC6551, Admin {\\n    /// @notice Error event for attempting to mint a DNA Card that has already been minted.\\n    error DNAMinter_AlreadyMinted();\\n\\n    /// @notice The address of the collection contract for Cre8ors.\\n    address public cre8orsNft;\\n\\n    /// @notice The address of the collection contract for Cre8ors DNA cards.\\n    address public dnaNft;\\n\\n    /// @notice Initializes the contract with the address of the Cre8orsNFT contract.\\n    /// @param _cre8orsNft The address of the Cre8ors contract to be used.\\n    /// @param _dnaNft The address of the Cre8ors DNA contract to be used.\\n    /// @param _registry The address of the ERC6551 registry contract to be used.\\n    /// @param _implementation The address of the ERC6551 implementation contract to be used.\\n    constructor(\\n        address _cre8orsNft,\\n        address _dnaNft,\\n        address _registry,\\n        address _implementation\\n    ) Cre8orsERC6551(_registry, _implementation) {\\n        cre8orsNft = _cre8orsNft;\\n        dnaNft = _dnaNft;\\n    }\\n\\n    /// @notice Creates a Token Bound Account (TBA) and mints a DNA NFT.\\n    /// @param _cre8orsTokenId Token ID of the Cre8ors NFT for which DNA will be minted.\\n    /// @return _mintedDnaTokenId ID of the minted DNA token.\\n    function createTokenBoundAccountAndMintDNA(\\n        uint256 _cre8orsTokenId\\n    )\\n        public\\n        onlyFirstMint(_cre8orsTokenId)\\n        returns (uint256 _mintedDnaTokenId)\\n    {\\n        address[] memory airdropList = createTokenBoundAccounts(\\n            cre8orsNft,\\n            _cre8orsTokenId,\\n            1\\n        );\\n        _mintedDnaTokenId = ICre8ors(dnaNft).adminMint(airdropList[0], 1);\\n    }\\n\\n    /// @notice Modifier to allow minting only if it is the first mint for the given Cre8ors token ID.\\n    /// @param _cre8orsTokenId Token ID to check for first minting.\\n    modifier onlyFirstMint(uint256 _cre8orsTokenId) {\\n        address tba = IERC6551Registry(erc6551Registry).account(\\n            erc6551AccountImplementation,\\n            block.chainid,\\n            cre8orsNft,\\n            _cre8orsTokenId,\\n            0\\n        );\\n        if (ICre8ors(dnaNft).mintedPerAddress(tba).totalMints > 0) {\\n            revert DNAMinter_AlreadyMinted();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Set the Cre8orsNFT contract address.\\n    /// @dev This function can only be called by an admin, identified by the\\n    ///     \\\"cre8orsNFT\\\" contract address.\\n    /// @param _dnaNft The new address of the DNA contract to be set.\\n    function setDnaNFT(address _dnaNft) public onlyAdmin(dnaNft) {\\n        dnaNft = _dnaNft;\\n    }\\n\\n    /// @notice Set the ERC6551 registry address.\\n    /// @dev This function can only be called by an admin.\\n    /// @param _registry Address of the ERC6551 registry to be set.\\n    function setErc6551Registry(address _registry) public onlyAdmin(dnaNft) {\\n        erc6551Registry = _registry;\\n    }\\n\\n    /// @notice Set the ERC6551 account implementation address.\\n    /// @dev This function can only be called by an admin.\\n    /// @param _implementation Address of the ERC6551 account implementation to be set.\\n    function setErc6551Implementation(\\n        address _implementation\\n    ) public onlyAdmin(dnaNft) {\\n        erc6551AccountImplementation = _implementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/subscription/abstracts/Admin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Drop} from \\\"../../interfaces/IERC721Drop.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {Base} from \\\"./Base.sol\\\";\\n\\n/// @title Admin\\n/// @notice An abstract contract with access control functionality.\\nabstract contract Admin is Base {\\n    /// @notice Access control roles\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER\\\");\\n\\n    /// @notice Modifier to allow only users with admin access\\n    /// @param target The address of the contract implementing the access control\\n    modifier onlyAdmin(address target) {\\n        if (!isAdmin(target, msg.sender)) {\\n            revert IERC721Drop.Access_OnlyAdmin();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Modifier to allow only a given role or admin access\\n    /// @param target The address of the contract implementing the access control\\n    /// @param role The role to check for alongside the admin role\\n    modifier onlyRoleOrAdmin(address target, bytes32 role) {\\n        if (!isAdmin(target, msg.sender) && !IAccessControl(target).hasRole(role, msg.sender)) {\\n            revert IERC721Drop.Access_MissingRoleOrAdmin(role);\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Getter for admin role associated with the contract to handle minting\\n    /// @param target The address of the contract implementing the access control\\n    /// @param user The address to check for admin access\\n    /// @return Whether the address has admin access or not\\n    function isAdmin(address target, address user) public view returns (bool) {\\n        return IERC721Drop(target).isAdmin(user);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/subscription/abstracts/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title Base\\n/// @notice A base abstract contract implementing common functionality for other contracts.\\nabstract contract Base {\\n    /// @notice given address is invalid.\\n    error AddressCannotBeZero();\\n\\n    /// @dev Modifier to check if the provided address is not the zero address.\\n    /// @param addr The address to be checked.\\n    modifier notZeroAddress(address addr) {\\n        if (addr == address(0)) {\\n            revert AddressCannotBeZero();\\n        }\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/subscription/interfaces/ISubscription.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title ISubscription\\n/// @dev Interface for managing subscriptions to NFTs.\\ninterface ISubscription {\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The subscription associated with the provided token ID is invalid or has expired.\\n    error InvalidSubscription();\\n\\n    /// @notice Attempting to set a subscription contract address with a zero address value.\\n    error SubscriptionCannotBeZeroAddress();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Emitted when the renewability status of subscriptions is updated.\\n    event RenewableUpdate(bool renewable);\\n\\n    /// @dev Emitted when the minimum duration for subscription renewal is updated.\\n    event MinRenewalDurationUpdate(uint64 duration);\\n\\n    /// @dev Emitted when the maximum duration for subscription renewal is updated.\\n    event MaxRenewalDurationUpdate(uint64 duration);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks the subscription for the given `tokenId`.\\n    /// Throws if `tokenId` subscription has expired.\\n    /// @param tokenId The unique identifier of the NFT token.\\n    function checkSubscription(uint256 tokenId) external view;\\n\\n    /// @notice Returns whether the subscription for the given `tokenId` is valid.\\n    /// @param tokenId The unique identifier of the NFT token.\\n    /// @return A boolean indicating if the subscription is valid.\\n    function isSubscriptionValid(uint256 tokenId) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /*//////////   updateSubscriptionForFree variants   //////////*/\\n\\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration` for free.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\\n    function updateSubscriptionForFree(address target, uint64 duration, uint256 tokenId) external;\\n\\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration` for free.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\\n    function updateSubscriptionForFree(address target, uint64 duration, uint256[] calldata tokenIds) external;\\n\\n    /*//////////////   updateSubscription variants   /////////////*/\\n\\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration`, using native currency as\\n    /// payment.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\\n    function updateSubscription(address target, uint64 duration, uint256 tokenId) external payable;\\n\\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration`, using native currency as\\n    /// payment.\\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\\n    /// @param target The address of the contract implementing the access control\\n    /// @param duration The duration (in seconds) to extend the subscription for.\\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\\n    function updateSubscription(address target, uint64 duration, uint256[] calldata tokenIds) external payable;\\n}\\n\"\r\n    },\r\n    \"src/utils/Cre8orsERC6551.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC6551Registry} from \\\"lib/ERC6551/src/interfaces/IERC6551Registry.sol\\\";\\n\\n/**\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                                       \\n */\\n/// @title Cre8orsERC6551 contract for handling ERC6551 token-bound accounts.\\n/// @dev inspiration: https://github.com/ourzora/zora-drops-contracts\\ncontract Cre8orsERC6551 {\\n    /// @notice The address of ERC6551 Registry contract.\\n    address public erc6551Registry;\\n\\n    /// @notice The address of ERC6551 Account Implementation contract.\\n    address public erc6551AccountImplementation;\\n\\n    /// @notice Initializes the Cre8orsERC6551 contract with ERC6551 Registry and Implementation addresses.\\n    /// @param _registry The address of the ERC6551 registry contract.\\n    /// @param _implementation The address of the ERC6551 account implementation contract.\\n    constructor(address _registry, address _implementation) {\\n        erc6551Registry = _registry;\\n        erc6551AccountImplementation = _implementation;\\n    }\\n\\n    /// @dev Initial data for ERC6551 createAccount function.\\n    bytes public constant INIT_DATA = \\\"0x8129fc1c\\\";\\n\\n    /// @notice Creates Token Bound Accounts (TBA) with ERC6551.\\n    /// @dev Internal function used to create TBAs for a given ERC721 contract.\\n    /// @param _target Target ERC721 contract address.\\n    /// @param startTokenId Token ID to start from.\\n    /// @param quantity Number of token-bound accounts to create.\\n    /// @return airdropList An array containing the addresses of the created TBAs.\\n    function createTokenBoundAccounts(\\n        address _target,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal returns (address[] memory airdropList) {\\n        IERC6551Registry registry = IERC6551Registry(erc6551Registry);\\n        airdropList = new address[](quantity);\\n        for (uint256 i = 0; i < quantity; i++) {\\n            address smartWallet = registry.createAccount(\\n                erc6551AccountImplementation,\\n                block.chainid,\\n                _target,\\n                startTokenId + i,\\n                0,\\n                INIT_DATA\\n            );\\n            airdropList[i] = smartWallet;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC6551/=lib/ERC6551/src/\",\r\n      \"ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ERC721C/=lib/creator-token-contracts/contracts/\",\r\n      \"ERC721H/=lib/ERC721H/src/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"creator-token-contracts/=lib/creator-token-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc6551/=lib/tokenbound/lib/reference/src/\",\r\n      \"erc721a/=lib/ERC721A/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=lib/creator-token-contracts/node_modules/hardhat/\",\r\n      \"murky/=lib/creator-token-contracts/lib/murky/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"reference/=lib/tokenbound/lib/reference/src/\",\r\n      \"sstore2/=lib/ERC6551/lib/sstore2/contracts/\",\r\n      \"tokenbound/=lib/tokenbound/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cre8orsNft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dnaNft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Access_OnlyAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAMinter_AlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INIT_DATA\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cre8orsNft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cre8orsTokenId\",\"type\":\"uint256\"}],\"name\":\"createTokenBoundAccountAndMintDNA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintedDnaTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dnaNft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc6551AccountImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc6551Registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dnaNft\",\"type\":\"address\"}],\"name\":\"setDnaNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setErc6551Implementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setErc6551Registry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DNAMinter", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ddef0396d4b61fcbb0e4a821dfac52c011f79da00000000000000000000000082ac0f629fd89b08951694d1b896772fd57439ed00000000000000000000000002101dfb77fde026414827fdc604ddaf224f09210000000000000000000000002d25602551487c3f3354dd80d76d54383a243358", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}