{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/StanceRKLCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IMinterController} from \\\"./interfaces/IMinterController.sol\\\";\\nimport {IStanceRKLCollection} from \\\"./interfaces/IStanceRKLCollection.sol\\\";\\n\\nimport {Ownable} from \\\"./common/Ownable.sol\\\";\\nimport {Constants} from \\\"./common/Constants.sol\\\";\\n\\nimport {ERC1155} from \\\"solady/src/tokens/ERC1155.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\n\\ncontract StanceRKLCollection is ERC1155, IStanceRKLCollection, Ownable, Constants {\\n    using LibString for uint256;\\n    IMinterController public immutable minterController;\\n    string private baseUri = \\\"ipfs://QmQJN194brEQ5EV3QoCVt9SgNkPzcVs2foVUP6LRDpsZjF/\\\";\\n    string public name = \\\"RKL x Stance HyperSocks\\\";\\n    string public symbol = \\\"RKLSH\\\";\\n\\n    constructor(address _minterController) {\\n        admin = msg.sender;\\n        minterController = IMinterController(_minterController);\\n    }\\n\\n    function uri(uint256 id) public view override returns (string memory) {\\n        return string(abi.encodePacked(baseUri, id.toString()));\\n    }\\n\\n    function mint(address to, uint256[] memory tokenIds, uint256[] memory amounts) external {\\n        if (to == ZERO_ADDRESS) {\\n            revert MintToZeroAddr();\\n        }\\n        if (tokenIds.length == 0) {\\n            revert NothingToMint();\\n        }\\n        if (tokenIds.length != amounts.length) {\\n            revert ArgLengthMismatch();\\n        }\\n        minterController.checkMinterAllowedForTokenIds(msg.sender, tokenIds);\\n        if (tokenIds.length == 1) {\\n            super._mint(to, tokenIds[0], amounts[0], \\\"\\\");\\n        } else {\\n            super._batchMint(to, tokenIds, amounts, \\\"\\\");\\n        }\\n    }\\n\\n    // =====================================================================//\\n    //                              Admin                                   //\\n    // =====================================================================//\\n\\n    function setBaseUri(string calldata newBaseUri) external onlyOwner {\\n        baseUri = newBaseUri;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinterController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @dev responsible for registering minters with StanceRKLCollection\\n///      responsible for checking if particular Minter is allowed to mint token ids\\n///      responsible for managing token ids for StanceRKLCollection\\ninterface IMinterController {\\n    error MinterZeroAddressNotAllowed();\\n    error MinterNotRegistered();\\n    error MinterNotAllowedForTokenId(uint256 requestedTokenId, uint256 allowedLowerBound, uint256 allowedUpperBound);\\n    error MinterAlreadyRegistered();\\n    error InvalidBounds(uint128 lowerBound, uint128 upperBound);\\n\\n    /// @dev if only one token id is allowed, then lowerBound == upperBound\\n    ///      note that the bounds are inclusive, so lowerBound := 2 and\\n    ///      upperBound := 4 would mean that minter is allowed to mint token\\n    ///      ids 2, 3 and 4.\\n    struct MinterAllowedTokenIds {\\n        uint128 lowerBound;\\n        uint128 upperBound;\\n    }\\n\\n    /// @dev minter is the address of the contract that implementes IMinter\\n    ///      throws MinterNotAllowedForTokenId\\n    function checkMinterAllowedForTokenIds(address minter, uint256[] memory tokenIds) external;\\n\\n    /// @dev registers a new minter with StanceRKLCollection\\n    function registerMinter(address minter, MinterAllowedTokenIds calldata) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStanceRKLCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IStanceRKLCollection {\\n    error NothingToMint();\\n    error ArgLengthMismatch();\\n    error MintToZeroAddr();\\n\\n    function mint(address to, uint256[] memory tokenIds, uint256[] memory amounts) external;\\n}\\n\"\r\n    },\r\n    \"src/common/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nabstract contract Ownable {\\n    error NotAdmin();\\n\\n    address public admin;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != admin) {\\n            revert NotAdmin();\\n        }\\n        _;\\n    }\\n\\n    function changeAdmin(address newAdmin) external onlyOwner {\\n        admin = newAdmin;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/common/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nabstract contract Constants {\\n    address internal constant ZERO_ADDRESS = address(0);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC1155 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)\\n/// Note:\\n/// The ERC1155 standard allows for self-approvals.\\n/// For performance, this implementation WILL NOT revert for such actions.\\n/// Please add any checks with overrides if desired.\\nabstract contract ERC1155 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The lengths of the input arrays are not the same.\\n    error ArrayLengthsMismatch();\\n\\n    /// @dev Cannot mint or transfer to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev The recipient's balance has overflowed.\\n    error AccountBalanceOverflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Only the token owner or an approved account can manage the tokens.\\n    error NotOwnerNorApproved();\\n\\n    /// @dev Cannot safely transfer to a contract that does not implement\\n    /// the ERC1155Receiver interface.\\n    error TransferToNonERC1155ReceiverImplementer();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` of token `id` is transferred\\n    /// from `from` to `to` by `operator`.\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    /// @dev Emitted when `amounts` of token `ids` are transferred\\n    /// from `from` to `to` by `operator`.\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`\\n    /// is updated to `value`. This event is not used in the base contract.\\n    /// You may need to emit this event depending on your URI logic.\\n    ///\\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\\n    event URI(string value, uint256 indexed id);\\n\\n    /// @dev `keccak256(bytes(\\\"TransferSingle(address,address,address,uint256,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\\n\\n    /// @dev `keccak256(bytes(\\\"TransferBatch(address,address,address,uint256[],uint256[])\\\"))`.\\n    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\\n    /// ```\\n    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))\\n    /// ```\\n    ///\\n    /// The balance slot of `owner` is given by.\\n    /// ```\\n    ///     mstore(0x20, ownerSlotSeed)\\n    ///     mstore(0x00, id)\\n    ///     let balanceSlot := keccak256(0x00, 0x40)\\n    /// ```\\n    ///\\n    /// The operator approval slot of `owner` is given by.\\n    /// ```\\n    ///     mstore(0x20, ownerSlotSeed)\\n    ///     mstore(0x00, operator)\\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC1155 METADATA                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the URI for token `id`.\\n    ///\\n    /// You can either return the same templated URI for all token IDs,\\n    /// (e.g. \\\"https://example.com/api/{id}.json\\\"),\\n    /// or return a unique URI for each `id`.\\n    ///\\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ERC1155                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of `id` owned by `owner`.\\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\\n            mstore(0x14, owner)\\n            mstore(0x00, id)\\n            result := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\\n            mstore(0x14, owner)\\n            mstore(0x00, operator)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\\n    ///\\n    /// Emits a {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Convert to 0 or 1.\\n            isApproved := iszero(iszero(isApproved))\\n            // Update the `isApproved` for (`msg.sender`, `operator`).\\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\\n            mstore(0x14, caller())\\n            mstore(0x00, operator)\\n            sstore(keccak256(0x0c, 0x34), isApproved)\\n            // Emit the {ApprovalForAll} event.\\n            mstore(0x00, isApproved)\\n            // forgefmt: disable-next-line\\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\\n        }\\n    }\\n\\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - `from` must have at least `amount` of `id`.\\n    /// - If the caller is not `from`,\\n    ///   it must be approved to manage the tokens of `from`.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\\n            mstore(0x20, fromSlotSeed)\\n            // Clear the upper 96 bits.\\n            from := shr(96, fromSlotSeed)\\n            to := shr(96, toSlotSeed)\\n            // Revert if `to` is the zero address.\\n            if iszero(to) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // If the caller is not `from`, do the authorization check.\\n            if iszero(eq(caller(), from)) {\\n                mstore(0x00, caller())\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Subtract and store the updated balance of `from`.\\n            {\\n                mstore(0x00, id)\\n                let fromBalanceSlot := keccak256(0x00, 0x40)\\n                let fromBalance := sload(fromBalanceSlot)\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            }\\n            // Increase and store the updated balance of `to`.\\n            {\\n                mstore(0x20, toSlotSeed)\\n                let toBalanceSlot := keccak256(0x00, 0x40)\\n                let toBalanceBefore := sload(toBalanceSlot)\\n                let toBalanceAfter := add(toBalanceBefore, amount)\\n                if lt(toBalanceAfter, toBalanceBefore) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(toBalanceSlot, toBalanceAfter)\\n            }\\n            // Emit a {TransferSingle} event.\\n            mstore(0x20, amount)\\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Do the {onERC1155Received} check if `to` is a smart contract.\\n            if extcodesize(to) {\\n                // Prepare the calldata.\\n                let m := mload(0x40)\\n                let onERC1155ReceivedSelector := 0xf23a6e61\\n                mstore(m, onERC1155ReceivedSelector)\\n                mstore(add(m, 0x20), caller())\\n                mstore(add(m, 0x40), from)\\n                mstore(add(m, 0x60), id)\\n                mstore(add(m, 0x80), amount)\\n                mstore(add(m, 0xa0), 0xa0)\\n                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))\\n                // Revert if the call reverts.\\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\\n                    if returndatasize() {\\n                        // Bubble up the revert if the call reverts.\\n                        returndatacopy(0x00, 0x00, returndatasize())\\n                        revert(0x00, returndatasize())\\n                    }\\n                    mstore(m, 0)\\n                }\\n                // Load the returndata and compare it.\\n                if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {\\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - `from` must have at least `amount` of `id`.\\n    /// - `ids` and `amounts` must have the same length.\\n    /// - If the caller is not `from`,\\n    ///   it must be approved to manage the tokens of `from`.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {TransferBatch} event.\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, to, ids, amounts, data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(ids.length, amounts.length)) {\\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\\n            mstore(0x20, fromSlotSeed)\\n            // Clear the upper 96 bits.\\n            from := shr(96, fromSlotSeed)\\n            to := shr(96, toSlotSeed)\\n            // Revert if `to` is the zero address.\\n            if iszero(to) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // If the caller is not `from`, do the authorization check.\\n            if iszero(eq(caller(), from)) {\\n                mstore(0x00, caller())\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Loop through all the `ids` and update the balances.\\n            {\\n                let end := shl(5, ids.length)\\n                for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {\\n                    let amount := calldataload(add(amounts.offset, i))\\n                    // Subtract and store the updated balance of `from`.\\n                    {\\n                        mstore(0x20, fromSlotSeed)\\n                        mstore(0x00, calldataload(add(ids.offset, i)))\\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\\n                        let fromBalance := sload(fromBalanceSlot)\\n                        if gt(amount, fromBalance) {\\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                    }\\n                    // Increase and store the updated balance of `to`.\\n                    {\\n                        mstore(0x20, toSlotSeed)\\n                        let toBalanceSlot := keccak256(0x00, 0x40)\\n                        let toBalanceBefore := sload(toBalanceSlot)\\n                        let toBalanceAfter := add(toBalanceBefore, amount)\\n                        if lt(toBalanceAfter, toBalanceBefore) {\\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(toBalanceSlot, toBalanceAfter)\\n                    }\\n                }\\n            }\\n            // Emit a {TransferBatch} event.\\n            {\\n                let m := mload(0x40)\\n                // Copy the `ids`.\\n                mstore(m, 0x40)\\n                let n := add(0x20, shl(5, ids.length))\\n                let o := add(m, 0x40)\\n                calldatacopy(o, sub(ids.offset, 0x20), n)\\n                // Copy the `amounts`.\\n                mstore(add(m, 0x20), add(0x40, n))\\n                o := add(o, n)\\n                n := add(0x20, shl(5, amounts.length))\\n                calldatacopy(o, sub(amounts.offset, 0x20), n)\\n                n := sub(add(o, n), m)\\n                // Do the emit.\\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\\n            }\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\\n            if extcodesize(to) {\\n                let m := mload(0x40)\\n                // Prepare the calldata.\\n                let onERC1155BatchReceivedSelector := 0xbc197c81\\n                mstore(m, onERC1155BatchReceivedSelector)\\n                mstore(add(m, 0x20), caller())\\n                mstore(add(m, 0x40), from)\\n                // Copy the `ids`.\\n                mstore(add(m, 0x60), 0xa0)\\n                let n := add(0x20, shl(5, ids.length))\\n                let o := add(m, 0xc0)\\n                calldatacopy(o, sub(ids.offset, 0x20), n)\\n                // Copy the `amounts`.\\n                let s := add(0xa0, n)\\n                mstore(add(m, 0x80), s)\\n                o := add(o, n)\\n                n := add(0x20, shl(5, amounts.length))\\n                calldatacopy(o, sub(amounts.offset, 0x20), n)\\n                // Copy the `data`.\\n                mstore(add(m, 0xa0), add(s, n))\\n                o := add(o, n)\\n                n := add(0x20, data.length)\\n                calldatacopy(o, sub(data.offset, 0x20), n)\\n                n := sub(add(o, n), add(m, 0x1c))\\n                // Revert if the call reverts.\\n                if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\\n                    if returndatasize() {\\n                        // Bubble up the revert if the call reverts.\\n                        returndatacopy(0x00, 0x00, returndatasize())\\n                        revert(0x00, returndatasize())\\n                    }\\n                    mstore(m, 0)\\n                }\\n                // Load the returndata and compare it.\\n                if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {\\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the amounts of `ids` for `owners.\\n    ///\\n    /// Requirements:\\n    /// - `owners` and `ids` must have the same length.\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(ids.length, owners.length)) {\\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\\n                revert(0x1c, 0x04)\\n            }\\n            balances := mload(0x40)\\n            mstore(balances, ids.length)\\n            let o := add(balances, 0x20)\\n            let end := shl(5, ids.length)\\n            mstore(0x40, add(end, o))\\n            // Loop through all the `ids` and load the balances.\\n            for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {\\n                let owner := calldataload(add(owners.offset, i))\\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\\n                mstore(0x00, calldataload(add(ids.offset, i)))\\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` of `id` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let to_ := shl(96, to)\\n            // Revert if `to` is the zero address.\\n            if iszero(to_) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increase and store the updated balance of `to`.\\n            {\\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\\n                mstore(0x14, to)\\n                mstore(0x00, id)\\n                let toBalanceSlot := keccak256(0x00, 0x40)\\n                let toBalanceBefore := sload(toBalanceSlot)\\n                let toBalanceAfter := add(toBalanceBefore, amount)\\n                if lt(toBalanceAfter, toBalanceBefore) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(toBalanceSlot, toBalanceAfter)\\n            }\\n            // Emit a {TransferSingle} event.\\n            mstore(0x00, id)\\n            mstore(0x20, amount)\\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\\n        }\\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\\n    }\\n\\n    /// @dev Mints `amounts` of `ids` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - `ids` and `amounts` must have the same length.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {TransferBatch} event.\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(mload(ids), mload(amounts))) {\\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let to_ := shl(96, to)\\n            // Revert if `to` is the zero address.\\n            if iszero(to_) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Loop through all the `ids` and update the balances.\\n            {\\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\\n                let end := shl(5, mload(ids))\\n                for { let i := 0 } iszero(eq(i, end)) {} {\\n                    i := add(i, 0x20)\\n                    let amount := mload(add(amounts, i))\\n                    // Increase and store the updated balance of `to`.\\n                    {\\n                        mstore(0x00, mload(add(ids, i)))\\n                        let toBalanceSlot := keccak256(0x00, 0x40)\\n                        let toBalanceBefore := sload(toBalanceSlot)\\n                        let toBalanceAfter := add(toBalanceBefore, amount)\\n                        if lt(toBalanceAfter, toBalanceBefore) {\\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(toBalanceSlot, toBalanceAfter)\\n                    }\\n                }\\n            }\\n            // Emit a {TransferBatch} event.\\n            {\\n                let m := mload(0x40)\\n                // Copy the `ids`.\\n                mstore(m, 0x40)\\n                let n := add(0x20, shl(5, mload(ids)))\\n                let o := add(m, 0x40)\\n                pop(staticcall(gas(), 4, ids, n, o, n))\\n                // Copy the `amounts`.\\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\\n                o := add(o, returndatasize())\\n                n := add(0x20, shl(5, mload(amounts)))\\n                pop(staticcall(gas(), 4, amounts, n, o, n))\\n                n := sub(add(o, returndatasize()), m)\\n                // Do the emit.\\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\\n            }\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\\n        }\\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        _burn(address(0), from, id, amount);\\n    }\\n\\n    /// @dev Destroys `amount` of `id` from `from`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must have at least `amount` of `id`.\\n    /// - If `by` is not the zero address, it must be either `from`,\\n    ///   or approved to manage the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \\\"\\\");\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\\n            // If `by` is not the zero address, and not equal to `from`,\\n            // check if it is approved to manage all the tokens of `from`.\\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\\n                mstore(0x00, by)\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Decrease and store the updated balance of `from`.\\n            {\\n                mstore(0x00, id)\\n                let fromBalanceSlot := keccak256(0x00, 0x40)\\n                let fromBalance := sload(fromBalanceSlot)\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            }\\n            // Emit a {TransferSingle} event.\\n            mstore(0x00, id)\\n            mstore(0x20, amount)\\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \\\"\\\");\\n        }\\n    }\\n\\n    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.\\n    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\\n        internal\\n        virtual\\n    {\\n        _batchBurn(address(0), from, ids, amounts);\\n    }\\n\\n    /// @dev Destroys `amounts` of `ids` from `from`.\\n    ///\\n    /// Requirements:\\n    /// - `ids` and `amounts` must have the same length.\\n    /// - `from` must have at least `amounts` of `ids`.\\n    /// - If `by` is not the zero address, it must be either `from`,\\n    ///   or approved to manage the tokens of `from`.\\n    ///\\n    /// Emits a {TransferBatch} event.\\n    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\\n        internal\\n        virtual\\n    {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, address(0), ids, amounts, \\\"\\\");\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(mload(ids), mload(amounts))) {\\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let from_ := shl(96, from)\\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\\n            // If `by` is not the zero address, and not equal to `from`,\\n            // check if it is approved to manage all the tokens of `from`.\\n            let by_ := shl(96, by)\\n            if iszero(or(iszero(by_), eq(by_, from_))) {\\n                mstore(0x00, by)\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Loop through all the `ids` and update the balances.\\n            {\\n                let end := shl(5, mload(ids))\\n                for { let i := 0 } iszero(eq(i, end)) {} {\\n                    i := add(i, 0x20)\\n                    let amount := mload(add(amounts, i))\\n                    // Decrease and store the updated balance of `to`.\\n                    {\\n                        mstore(0x00, mload(add(ids, i)))\\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\\n                        let fromBalance := sload(fromBalanceSlot)\\n                        if gt(amount, fromBalance) {\\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                    }\\n                }\\n            }\\n            // Emit a {TransferBatch} event.\\n            {\\n                let m := mload(0x40)\\n                // Copy the `ids`.\\n                mstore(m, 0x40)\\n                let n := add(0x20, shl(5, mload(ids)))\\n                let o := add(m, 0x40)\\n                pop(staticcall(gas(), 4, ids, n, o, n))\\n                // Copy the `amounts`.\\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\\n                o := add(o, returndatasize())\\n                n := add(0x20, shl(5, mload(amounts)))\\n                pop(staticcall(gas(), 4, amounts, n, o, n))\\n                n := sub(add(o, returndatasize()), m)\\n                // Do the emit.\\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\\n            }\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, address(0), ids, amounts, \\\"\\\");\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Approve or remove the `operator` as an operator for `by`,\\n    /// without authorization checks.\\n    ///\\n    /// Emits a {ApprovalForAll} event.\\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Convert to 0 or 1.\\n            isApproved := iszero(iszero(isApproved))\\n            // Update the `isApproved` for (`by`, `operator`).\\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\\n            mstore(0x14, by)\\n            mstore(0x00, operator)\\n            sstore(keccak256(0x0c, 0x34), isApproved)\\n            // Emit the {ApprovalForAll} event.\\n            mstore(0x00, isApproved)\\n            let m := shr(96, not(0))\\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.\\n    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\\n        internal\\n        virtual\\n    {\\n        _safeTransfer(address(0), from, to, id, amount, data);\\n    }\\n\\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - `from` must have at least `amount` of `id`.\\n    /// - If `by` is not the zero address, it must be either `from`,\\n    ///   or approved to manage the tokens of `from`.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _safeTransfer(\\n        address by,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            let to_ := shl(96, to)\\n            // Revert if `to` is the zero address.\\n            if iszero(to_) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\\n            // If `by` is not the zero address, and not equal to `from`,\\n            // check if it is approved to manage all the tokens of `from`.\\n            let by_ := shl(96, by)\\n            if iszero(or(iszero(by_), eq(by_, from_))) {\\n                mstore(0x00, by)\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Subtract and store the updated balance of `from`.\\n            {\\n                mstore(0x00, id)\\n                let fromBalanceSlot := keccak256(0x00, 0x40)\\n                let fromBalance := sload(fromBalanceSlot)\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            }\\n            // Increase and store the updated balance of `to`.\\n            {\\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\\n                let toBalanceSlot := keccak256(0x00, 0x40)\\n                let toBalanceBefore := sload(toBalanceSlot)\\n                let toBalanceAfter := add(toBalanceBefore, amount)\\n                if lt(toBalanceAfter, toBalanceBefore) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(toBalanceSlot, toBalanceAfter)\\n            }\\n            // Emit a {TransferSingle} event.\\n            mstore(0x20, amount)\\n            // forgefmt: disable-next-line\\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\\n        }\\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\\n    }\\n\\n    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.\\n    function _safeBatchTransfer(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\\n    }\\n\\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `to` cannot be the zero address.\\n    /// - `ids` and `amounts` must have the same length.\\n    /// - `from` must have at least `amounts` of `ids`.\\n    /// - If `by` is not the zero address, it must be either `from`,\\n    ///   or approved to manage the tokens of `from`.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\\n    ///\\n    /// Emits a {TransferBatch} event.\\n    function _safeBatchTransfer(\\n        address by,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if (_useBeforeTokenTransfer()) {\\n            _beforeTokenTransfer(from, to, ids, amounts, data);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(mload(ids), mload(amounts))) {\\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let from_ := shl(96, from)\\n            let to_ := shl(96, to)\\n            // Revert if `to` is the zero address.\\n            if iszero(to_) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\\n            mstore(0x20, fromSlotSeed)\\n            // If `by` is not the zero address, and not equal to `from`,\\n            // check if it is approved to manage all the tokens of `from`.\\n            let by_ := shl(96, by)\\n            if iszero(or(iszero(by_), eq(by_, from_))) {\\n                mstore(0x00, by)\\n                if iszero(sload(keccak256(0x0c, 0x34))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Loop through all the `ids` and update the balances.\\n            {\\n                let end := shl(5, mload(ids))\\n                for { let i := 0 } iszero(eq(i, end)) {} {\\n                    i := add(i, 0x20)\\n                    let amount := mload(add(amounts, i))\\n                    // Subtract and store the updated balance of `from`.\\n                    {\\n                        mstore(0x20, fromSlotSeed)\\n                        mstore(0x00, mload(add(ids, i)))\\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\\n                        let fromBalance := sload(fromBalanceSlot)\\n                        if gt(amount, fromBalance) {\\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                    }\\n                    // Increase and store the updated balance of `to`.\\n                    {\\n                        mstore(0x20, toSlotSeed)\\n                        let toBalanceSlot := keccak256(0x00, 0x40)\\n                        let toBalanceBefore := sload(toBalanceSlot)\\n                        let toBalanceAfter := add(toBalanceBefore, amount)\\n                        if lt(toBalanceAfter, toBalanceBefore) {\\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        sstore(toBalanceSlot, toBalanceAfter)\\n                    }\\n                }\\n            }\\n            // Emit a {TransferBatch} event.\\n            {\\n                let m := mload(0x40)\\n                // Copy the `ids`.\\n                mstore(m, 0x40)\\n                let n := add(0x20, shl(5, mload(ids)))\\n                let o := add(m, 0x40)\\n                pop(staticcall(gas(), 4, ids, n, o, n))\\n                // Copy the `amounts`.\\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\\n                o := add(o, returndatasize())\\n                n := add(0x20, shl(5, mload(amounts)))\\n                pop(staticcall(gas(), 4, amounts, n, o, n))\\n                n := sub(add(o, returndatasize()), m)\\n                // Do the emit.\\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\\n            }\\n        }\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, to, ids, amounts, data);\\n        }\\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    HOOKS FOR OVERRIDING                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.\\n    /// The is to help the compiler avoid producing dead bytecode.\\n    function _useBeforeTokenTransfer() internal view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /// @dev Hook that is called before any token transfer.\\n    /// This includes minting and burning, as well as batched variants.\\n    ///\\n    /// The same hook is called on both single and batched variants.\\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /// @dev Override this function to return true if `_afterTokenTransfer` is used.\\n    /// The is to help the compiler avoid producing dead bytecode.\\n    function _useAfterTokenTransfer() internal view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /// @dev Hook that is called after any token transfer.\\n    /// This includes minting and burning, as well as batched variants.\\n    ///\\n    /// The same hook is called on both single and batched variants.\\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Helper for calling the `_afterTokenTransfer` hook.\\n    /// The is to help the compiler avoid producing dead bytecode.\\n    function _afterTokenTransferCalldata(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) private {\\n        if (_useAfterTokenTransfer()) {\\n            _afterTokenTransfer(from, to, ids, amounts, data);\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC1155Received(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC1155ReceivedSelector := 0xf23a6e61\\n            mstore(m, onERC1155ReceivedSelector)\\n            mstore(add(m, 0x20), caller())\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), amount)\\n            mstore(add(m, 0xa0), 0xa0)\\n            let n := mload(data)\\n            mstore(add(m, 0xc0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                mstore(m, 0)\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {\\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC1155BatchReceived(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC1155BatchReceivedSelector := 0xbc197c81\\n            mstore(m, onERC1155BatchReceivedSelector)\\n            mstore(add(m, 0x20), caller())\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            // Copy the `ids`.\\n            mstore(add(m, 0x60), 0xa0)\\n            let n := add(0x20, shl(5, mload(ids)))\\n            let o := add(m, 0xc0)\\n            pop(staticcall(gas(), 4, ids, n, o, n))\\n            // Copy the `amounts`.\\n            let s := add(0xa0, returndatasize())\\n            mstore(add(m, 0x80), s)\\n            o := add(o, returndatasize())\\n            n := add(0x20, shl(5, mload(amounts)))\\n            pop(staticcall(gas(), 4, amounts, n, o, n))\\n            // Copy the `data`.\\n            mstore(add(m, 0xa0), add(s, returndatasize()))\\n            o := add(o, returndatasize())\\n            n := add(0x20, mload(data))\\n            pop(staticcall(gas(), 4, data, n, o, n))\\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                mstore(m, 0)\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {\\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `x` in an array with a single element.\\n    function _single(uint256 x) private pure returns (uint256[] memory result) {\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x40, add(result, 0x40))\\n            mstore(result, 1)\\n            mstore(add(result, 0x20), x)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(mload(a), 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store the bytes of the packed offsets and strides into the scratch space.\\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n                mstore(0x1f, 0x900094)\\n                mstore(0x08, 0xc0000000a6ab)\\n                // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n                // Store \\\"0123456789abcdef\\\" in scratch space.\\n                // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n                // into the scratch space.\\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n                // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minterController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountBalanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArgLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArrayLengthsMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddr\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterController\",\"outputs\":[{\"internalType\":\"contract IMinterController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseUri\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StanceRKLCollection", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000767fe2e8e1f53d5ff4059192499afe07da050ba6", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}